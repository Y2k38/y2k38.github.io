<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"y2k38.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="golang的内存分配机制最初是基于TCMalloc，演化至今已经有了很大差异。其原理是：slab + tiling algorithm + 层级内存分配。本文仅介绍如何通过mallocgc分配内存，不涉及栈内存分配管理、手动内存管理等内容。当前go版本：1.24 前言slab + tiling内存分配基本单位-mspan（即slab），内部再划分更小的块（即tiling） 小对象（&lt;&amp;#x">
<meta property="og:type" content="article">
<meta property="og:title" content="golang系列之-内存分配">
<meta property="og:url" content="https://y2k38.github.io/golang-series-memory-allocation/index.html">
<meta property="og:site_name" content="noname">
<meta property="og:description" content="golang的内存分配机制最初是基于TCMalloc，演化至今已经有了很大差异。其原理是：slab + tiling algorithm + 层级内存分配。本文仅介绍如何通过mallocgc分配内存，不涉及栈内存分配管理、手动内存管理等内容。当前go版本：1.24 前言slab + tiling内存分配基本单位-mspan（即slab），内部再划分更小的块（即tiling） 小对象（&lt;&amp;#x">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-04-02T01:35:00.000Z">
<meta property="article:modified_time" content="2025-04-02T12:18:03.740Z">
<meta property="article:author" content="y2k38">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://y2k38.github.io/golang-series-memory-allocation/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://y2k38.github.io/golang-series-memory-allocation/","path":"golang-series-memory-allocation/","title":"golang系列之-内存分配"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>golang系列之-内存分配 | noname</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">noname</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#slab-tiling"><span class="nav-number">1.1.</span> <span class="nav-text">slab + tiling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E7%BA%A7%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.2.</span> <span class="nav-text">层级内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%8A%B6%E6%80%81"><span class="nav-number">1.3.</span> <span class="nav-text">系统内存状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E5%8A%A9%E6%94%BB"><span class="nav-number">1.4.</span> <span class="nav-text">GC助攻</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mspan"><span class="nav-number">2.1.</span> <span class="nav-text">mspan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mcache"><span class="nav-number">2.2.</span> <span class="nav-text">mcache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mcentral"><span class="nav-number">2.3.</span> <span class="nav-text">mcentral</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mheap"><span class="nav-number">2.4.</span> <span class="nav-text">mheap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">2.5.</span> <span class="nav-text">分配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fixalloc"><span class="nav-number">2.5.1.</span> <span class="nav-text">fixalloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pageAlloc"><span class="nav-number">2.5.2.</span> <span class="nav-text">pageAlloc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mallocgc"><span class="nav-number">3.</span> <span class="nav-text">mallocgc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mallocgcTiny"><span class="nav-number">3.1.</span> <span class="nav-text">mallocgcTiny</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mallocgcSmallNoscan"><span class="nav-number">3.2.</span> <span class="nav-text">mallocgcSmallNoscan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mallocgcSmallScanNoHeader"><span class="nav-number">3.3.</span> <span class="nav-text">mallocgcSmallScanNoHeader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mallocgcSmallScanHeader"><span class="nav-number">3.4.</span> <span class="nav-text">mallocgcSmallScanHeader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mallocgcLarge"><span class="nav-number">3.5.</span> <span class="nav-text">mallocgcLarge</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">相关依赖函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc"><span class="nav-number">4.1.</span> <span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mheap-1"><span class="nav-number">4.2.</span> <span class="nav-text">mheap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mcentral-1"><span class="nav-number">4.3.</span> <span class="nav-text">mcentral</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mcache-1"><span class="nav-number">4.4.</span> <span class="nav-text">mcache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mspan-1"><span class="nav-number">4.5.</span> <span class="nav-text">mspan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pageCache"><span class="nav-number">4.6.</span> <span class="nav-text">pageCache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pageAlloc-1"><span class="nav-number">4.7.</span> <span class="nav-text">pageAlloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pallocBits"><span class="nav-number">4.8.</span> <span class="nav-text">pallocBits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E5%8A%A9%E6%94%BB-1"><span class="nav-number">4.9.</span> <span class="nav-text">GC助攻</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">4.10.</span> <span class="nav-text">写屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OS%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="nav-number">4.11.</span> <span class="nav-text">OS内存申请</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#profile%E7%9B%B8%E5%85%B3"><span class="nav-number">4.12.</span> <span class="nav-text">profile相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">4.13.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">5.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">y2k38</p>
  <div class="site-description" itemprop="description">个人笔记</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-memory-allocation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="golang系列之-内存分配 | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          golang系列之-内存分配
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-04-02 09:35:00 / 修改时间：20:18:03" itemprop="dateCreated datePublished" datetime="2025-04-02T09:35:00+08:00">2025-04-02</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>27k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:38</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>golang的内存分配机制最初是基于TCMalloc，演化至今已经有了很大差异。其原理是：slab + tiling algorithm + 层级内存分配。本文仅介绍如何通过mallocgc分配内存，不涉及栈内存分配管理、手动内存管理等内容。当前go版本：1.24</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="slab-tiling"><a href="#slab-tiling" class="headerlink" title="slab + tiling"></a>slab + tiling</h3><p>内存分配基本单位-mspan（即slab），内部再划分更小的块（即tiling）</p>
<p>小对象（&lt;&#x3D;32KB）按预定义的sizeclass分成不同的mspan，每个mspan最低有8KB，切割成指定大小的块。而大对象（&gt;32KB）的sizeclass&#x3D;0，不限制大小，mspan不分块。如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mspann -&gt; sizeclass=0  -&gt; nKB  -&gt; | &lt;-----   nKB   -----&gt; |</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// mspanx -&gt; sizeclass=1  -&gt; 8KB  -&gt; | 8B  | 8B  | ... | 8B  |</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// mspany -&gt; sizeclass=5  -&gt; 8KB  -&gt; | 48B | 48B | ... | 48B |</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// mspanz -&gt; sizeclass=65 -&gt; 80KB</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>如<code>make([]int, 5)</code>，创建一块40B大小的内存区域，经过计算这个内存块会从sizeclass&#x3D;5的mspan分配（该mspan的每个元素大小为48B）</p>
<h3 id="层级内存分配"><a href="#层级内存分配" class="headerlink" title="层级内存分配"></a>层级内存分配</h3><p>参考TCMalloc，内存分配时主要分为3级：mcache、mcentral、mheap</p>
<ol>
<li>mcache为线程缓存，每个p都有一个，所有的内存分配&#x2F;回收都是先通过mcache，访问不需要加锁</li>
<li>mcentral负责向mheap申请分配内存、管理mspan，按spanclass分组，嵌入到mheap结构体，全局唯一</li>
<li>mheap负责从系统申请内存进行分配管理，一般情况下访问都要加锁，全局唯一</li>
</ol>
<p>执行mallocgc分配内存时，mheap、mcentral、mcache的关系如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  mallocgc</span></span><br><span class="line"><span class="comment">//     |</span></span><br><span class="line"><span class="comment">//     |    (&lt;=32KB)</span></span><br><span class="line"><span class="comment">//     |--&gt; p.mcache.alloc[spanclass] --&gt; mheap.central[spanclass] --&gt; mheap</span></span><br><span class="line"><span class="comment">//     |</span></span><br><span class="line"><span class="comment">//     |    (&gt;32KB)</span></span><br><span class="line"><span class="comment">//     |--&gt; mheap</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果对象&lt;&#x3D;32KB<ul>
<li>从p的mcache找一个空闲的mspan分配一段内存&#x2F;地址空间</li>
<li>如果mspan没有空闲空间，从mcentral申请一个新的&#x2F;重用一个已清扫的mspan</li>
<li>如果mcentral也没有可用mspan，通过mheap跟OS申请一段内存，初始化一个mspan返回</li>
</ul>
</li>
<li>如果对象&gt;32KB<ul>
<li>通过mheap跟OS申请一段内存，初始化一个mspan返回</li>
</ul>
</li>
</ul>
<h3 id="系统内存状态"><a href="#系统内存状态" class="headerlink" title="系统内存状态"></a>系统内存状态</h3><p>这里需要了解系统内存的几个状态，以及go内部是如何从系统分配、释放内存的</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>None</strong></td>
<td>默认状态，未映射，地址空间未被保留或使用</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>已保留，但未提交，即地址空间已经被申请，但尚未向操作系统请求实际物理内存</td>
</tr>
<tr>
<td><strong>Prepared</strong></td>
<td>已提交但未使用，已经向操作系统申请了物理内存，但可能未完全初始化</td>
</tr>
<tr>
<td><strong>Ready</strong></td>
<td>可用状态，内存已初始化，可用于分配</td>
</tr>
</tbody></table>
<p>状态转换函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">主要作用</th>
<th align="left">是否分配物理内存</th>
<th align="left">是否映射虚拟内存</th>
<th align="left">内存状态转换</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>sysAlloc</code></td>
<td align="left"><strong>直接申请内存</strong></td>
<td align="left">✅ 是</td>
<td align="left">✅ 是</td>
<td align="left">None -&gt; Ready</td>
<td align="left">可能会触发 <code>mmap</code></td>
</tr>
<tr>
<td align="left"><code>sysReserve</code></td>
<td align="left"><strong>保留虚拟地址空间，但不映射</strong></td>
<td align="left">❌ 否</td>
<td align="left">✅ 是</td>
<td align="left">None -&gt; Reserved</td>
<td align="left">预留地址，后续 <code>sysMap</code></td>
</tr>
<tr>
<td align="left"><code>sysMap</code></td>
<td align="left"><strong>将预留的虚拟地址映射为实际物理内存</strong></td>
<td align="left">✅ 是</td>
<td align="left">✅ 是</td>
<td align="left">Reserved -&gt; Prepared</td>
<td align="left">只有 <code>sysReserve</code> 过的地址能 <code>sysMap</code></td>
</tr>
<tr>
<td align="left"><code>sysUsed</code></td>
<td align="left"><strong>标记某段地址正在使用</strong></td>
<td align="left">✅ 是</td>
<td align="left">✅ 是</td>
<td align="left">Prepared -&gt; Ready</td>
<td align="left">可能会触发 <code>madvise</code> 让物理页生效</td>
</tr>
<tr>
<td align="left"><code>sysUnused</code></td>
<td align="left"><strong>标记某段地址未使用</strong>，可以回收物理内存</td>
<td align="left">⚠️ 可能</td>
<td align="left">❌ 否</td>
<td align="left">Ready -&gt; Prepared</td>
<td align="left"><code>MADV_DONTNEED</code>，内存仍属于进程</td>
</tr>
<tr>
<td align="left"><code>sysFault</code></td>
<td align="left"><strong>让一段地址变成不可访问</strong></td>
<td align="left">❌ 否</td>
<td align="left">✅ 是</td>
<td align="left">Ready -&gt; Reserved</td>
<td align="left"><code>mprotect(PROT_NONE)</code>，用于调试</td>
</tr>
<tr>
<td align="left"><code>sysFree</code></td>
<td align="left"><strong>释放虚拟内存，归还给 OS</strong></td>
<td align="left">✅ 是</td>
<td align="left">✅ 是</td>
<td align="left">-&gt; None</td>
<td align="left"><code>munmap</code>，这段内存不能再用</td>
</tr>
</tbody></table>
<p><strong>我对Go内存分配的理解</strong></p>
<ol>
<li>内存管理的本质是地址空间的组织和维护</li>
<li>Go的内存策略：尽量保留虚拟地址，按需释放物理页</li>
<li>Go会一次性申请64MB内存（Reserved-虚拟地址空间），但并不是立即分配物理页，而是在需要分配时使用sysMap + sysUsed使一小部份内存可用（Reserved-&gt;Prepared-&gt;Ready）</li>
</ol>
<h3 id="GC助攻"><a href="#GC助攻" class="headerlink" title="GC助攻"></a>GC助攻</h3><p>为了防止内存分配速度过快，导致GC跟不上，分配时会判断是否需要协助GC标记&#x2F;清扫。每次都要判断是否需要协助标记，而清扫只发生在获取新的mspan和大对象分配场景下</p>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h3><p>mspan负责纪录一片连续内存区域的起始&#x2F;终止地址、组织信息等，实际可用内存地址需要通过页分配器获得。一个mspan最少可管理8KB的内存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    _                     sys.NotInHeap</span><br><span class="line">    next                  *mspan        <span class="comment">// 链表用</span></span><br><span class="line">    prev                  *mspan        <span class="comment">// 链表用</span></span><br><span class="line">    list                  *mSpanList    <span class="comment">// debug，忽略</span></span><br><span class="line"></span><br><span class="line">    startAddr             <span class="type">uintptr</span>       <span class="comment">// 连续内存区域起始地址，同base</span></span><br><span class="line">    npages                <span class="type">uintptr</span>       <span class="comment">// 页数量，每个页8KB，每个mspan最少有1个页</span></span><br><span class="line"></span><br><span class="line">    manualFreeList        gclinkptr     <span class="comment">// 空闲对象链表，状态为mSpanManual时用</span></span><br><span class="line"></span><br><span class="line">    freeindex             <span class="type">uint16</span>        <span class="comment">// 下一个可用对象索引，范围[0,nelems)，GC后重置为0</span></span><br><span class="line">    nelems                <span class="type">uint16</span>        <span class="comment">// 可存储对象总量，=n*8192/elemsize</span></span><br><span class="line">    freeIndexForScan      <span class="type">uint16</span>        <span class="comment">// 同freeindex，用于GC</span></span><br><span class="line"></span><br><span class="line">    allocCache            <span class="type">uint64</span>        <span class="comment">// 64位bitmap，用于快速分配，从allocBits获取填充</span></span><br><span class="line"></span><br><span class="line">    allocBits             *gcBits       <span class="comment">// bitmap，用于标记mspan内哪些对象已被使用</span></span><br><span class="line">    gcmarkBits            *gcBits       <span class="comment">// bitmap，用于GC时将对象置为黑色</span></span><br><span class="line">    pinnerBits            *gcBits       <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果sweepgen == h-&gt;sweepgen - 2，mspan需要被清扫</span></span><br><span class="line">    <span class="comment">// 如果sweepgen == h-&gt;sweepgen - 1，mspan正在被清扫</span></span><br><span class="line">    <span class="comment">// 如果sweepgen == h-&gt;sweepgen，mspan已被清扫，可以随时被使用</span></span><br><span class="line">    <span class="comment">// 如果sweepgen == h-&gt;sweepgen + 1，mspan在sweep启动前被mcache使用，当然仍被使用，需要清扫</span></span><br><span class="line">    <span class="comment">// 如果sweepgen == h-&gt;sweepgen + 3，mspan已被清扫并被mcache使用</span></span><br><span class="line">    sweepgen              <span class="type">uint32</span>        <span class="comment">// 版本计数器，使用时/GC时同步mheap.sweepgen</span></span><br><span class="line">    divMul                <span class="type">uint32</span>        <span class="comment">// 用于优化除法运算</span></span><br><span class="line">    allocCount            <span class="type">uint16</span>        <span class="comment">// 已分配对象数，范围[0,nelems]</span></span><br><span class="line">    spanclass             spanClass     <span class="comment">// 类别，由7位sizeclass和1位noscan组成</span></span><br><span class="line">    state                 mSpanStateBox <span class="comment">// 状态，0-默认 1-使用中(heap) 2-使用中(手动)</span></span><br><span class="line">    needzero              <span class="type">uint8</span>         <span class="comment">// 分配前是否需要清0</span></span><br><span class="line">    isUserArenaChunk      <span class="type">bool</span>          <span class="comment">// 归属于arena包，用户手动管理</span></span><br><span class="line">    allocCountBeforeCache <span class="type">uint16</span>        <span class="comment">// allocCount快照，统计用</span></span><br><span class="line">    elemsize              <span class="type">uintptr</span>       <span class="comment">// 对象大小</span></span><br><span class="line">    limit                 <span class="type">uintptr</span>       <span class="comment">// 终止地址，与startAddr搭配使用</span></span><br><span class="line">    speciallock           mutex         <span class="comment">//</span></span><br><span class="line">    specials              *special      <span class="comment">//</span></span><br><span class="line">    userArenaChunkFree    addrRange     <span class="comment">//</span></span><br><span class="line">    largeType             *_type        <span class="comment">// 数据类型，大对象（&gt;32KB）分配时纪录，为nil表示noscan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>scan&#x2F;noscan</strong></p>
<p>noscan：如果对象是nil或者对象不包含指针（scalar）<br>scan：对象包含指针，如一个结构体有字段类型是指针类型</p>
<p><strong>状态</strong></p>
<p>mspan状态列表如下</p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mSpanDead</td>
<td align="left">0</td>
<td align="left">默认状态，未使用&#x2F;回收</td>
</tr>
<tr>
<td align="left">mSpanInUse</td>
<td align="left">1</td>
<td align="left">使用中，由go自己管理</td>
</tr>
<tr>
<td align="left">mSpanManual</td>
<td align="left">2</td>
<td align="left">使用中，手动管理，一般用于栈分配</td>
</tr>
</tbody></table>
<p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">spanAllocHeap</td>
<td align="left">0</td>
<td align="left">默认，heap类型，其他均为手动分配</td>
</tr>
<tr>
<td align="left">spanAllocStack</td>
<td align="left">1</td>
<td align="left">stack类型</td>
</tr>
<tr>
<td align="left">spanAllocPtrScalarBits</td>
<td align="left">2</td>
<td align="left">GC bitmap</td>
</tr>
<tr>
<td align="left">spanAllocWorkBuf</td>
<td align="left">3</td>
<td align="left">写屏障缓冲</td>
</tr>
</tbody></table>
<p><strong>小对象mspan示例</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有1个page的小对象（&lt;=32KB）mspan示例如下</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// noscan: startAddr</span></span><br><span class="line"><span class="comment">//            |</span></span><br><span class="line"><span class="comment">//            v</span></span><br><span class="line"><span class="comment">//            | &lt;---------- 8192 bytes ----------&gt;  |</span></span><br><span class="line"><span class="comment">//            | free                                |</span></span><br><span class="line"><span class="comment">//            | 8192 bytes                          |</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// scan &amp;&amp; size&lt;=512B</span></span><br><span class="line"><span class="comment">//            |</span></span><br><span class="line"><span class="comment">//            v</span></span><br><span class="line"><span class="comment">//            | &lt;---------- 8192 bytes ----------&gt;  |</span></span><br><span class="line"><span class="comment">//            | free                    | heapBits  |</span></span><br><span class="line"><span class="comment">//            | 8064 bytes              | 128 bytes | -&gt; 用于标记对象的可达性</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// scan类型时，elem大小超过512B需要存储类型，如下</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         &lt;= 512B =&gt; elem no header   =&gt; |    elemsize | ... |     elemsize |</span></span><br><span class="line"><span class="comment">//          &gt; 512B =&gt; elem with header =&gt; |8 + elemsize | ... | 8 + elemsize |</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 大对象的类型存储在mspan的largeType字段</span></span><br></pre></td></tr></table></figure>

<h3 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h3><p>每个p都有一个mcache，负责当前线程的内存分配，超小对象（scalar）通过tiny分配器分配（优化，本质还是访问的是mspan），小对象则通过找到alloc数组里相应的mspan进行分配，不负责大对象的分配</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    _           sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面三个每次malloc都会访问</span></span><br><span class="line">    nextSample  <span class="type">int64</span>                          <span class="comment">// 分配nextSample字节内存后触发采样</span></span><br><span class="line">    memProfRate <span class="type">int</span>                            <span class="comment">// 内存采样频率（缓存）</span></span><br><span class="line">    scanAlloc   <span class="type">uintptr</span>                        <span class="comment">// 需要被GC扫描的字节数（跟分配的内存大小也差不了多少）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// tiny分配器（spanclass=5 =&gt; sizeclass=2 + noscan）</span></span><br><span class="line">    tiny        <span class="type">uintptr</span>                        <span class="comment">// 16字节内存区域</span></span><br><span class="line">    tinyoffset  <span class="type">uintptr</span>                        <span class="comment">// 偏移量/下一个可分配地址</span></span><br><span class="line">    tinyAllocs  <span class="type">uintptr</span>                        <span class="comment">// 通过tiny区域分配的对象数量</span></span><br><span class="line"></span><br><span class="line">    alloc       [numSpanClasses]*mspan         <span class="comment">// 分配&lt;=32KB时使用，共136个mspan指针</span></span><br><span class="line">    stackcache  [_NumStackOrders]stackfreelist <span class="comment">// 栈分配使用，linux下共4个栈缓存链表</span></span><br><span class="line">    <span class="comment">// 只有当flushGen==sweepgen-2时清扫mcache</span></span><br><span class="line">    flushGen    atomic.Uint32                  <span class="comment">// sweepgen快照，创建mcache以及gcStart时同步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>alloc是一个固定长度的数组，包含136个mspan指针。如果其中的mspan空间分配完&#x2F;不足以容纳新对象，则向mcentral申请一个新的&#x2F;清扫过的mspan替换原mspan后重试</p>
<h3 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h3><p>新的mspan会立即替换mcache的纪录，而mcentral负责纪录空间已满&#x2F;不足的mspan、清扫重用mspan&#x2F;向mheap申请分配新的mspan。按spanclass进行分组，每个组都是一个二维数组，嵌入到mheap结构体，全局唯一</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    _         sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    spanclass spanClass     <span class="comment">// 类别，由7位的sizeclass和1位的noscan组成</span></span><br><span class="line"></span><br><span class="line">    partial   [<span class="number">2</span>]spanSet    <span class="comment">// mspan空间还有剩余（但不足以申请新的对象）</span></span><br><span class="line">    full      [<span class="number">2</span>]spanSet    <span class="comment">// mspan空间完全用完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组第一维</span></span><br><span class="line"><span class="keyword">type</span> spanSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    spineLock mutex                     <span class="comment">// 锁</span></span><br><span class="line">    spine     atomicSpanSetSpinePointer <span class="comment">// spanSetBlock切片指针，指向*[N]atomic.Pointer[spanSetBlock]，最少有256个指针</span></span><br><span class="line">    spineLen  atomic.Uintptr            <span class="comment">// spine数组长度</span></span><br><span class="line">    spineCap  <span class="type">uintptr</span>                   <span class="comment">// spine数组容量，访问需要加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个mspan的内存最小为1个页即8KB，2^32个索引最少能代表32TB</span></span><br><span class="line">    index     atomicHeadTailIndex       <span class="comment">// 索引，分为高32位-head，低32位-tail</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组第二维</span></span><br><span class="line"><span class="keyword">type</span> spanSetBlock <span class="keyword">struct</span> &#123;</span><br><span class="line">    lfnode                                         <span class="comment">// 无锁栈</span></span><br><span class="line">    popped atomic.Uint32                           <span class="comment">// 计数器，计算pop次数</span></span><br><span class="line">    spans  [spanSetBlockEntries]atomicMSpanPointer <span class="comment">// mspan指针数组，共512个指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无锁栈</span></span><br><span class="line"><span class="keyword">type</span> lfnode <span class="keyword">struct</span> &#123;</span><br><span class="line">    next    <span class="type">uint64</span>  <span class="comment">// 元素指针</span></span><br><span class="line">    pushcnt <span class="type">uintptr</span> <span class="comment">// 总量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mcentral示例</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mcentral[0].spanclass = 0</span></span><br><span class="line"><span class="comment">//            .partial[0] -&gt; *spanSet.spine[0]   -&gt; *spanSetBlock.spans[0]</span></span><br><span class="line"><span class="comment">//                                   ...            ...</span></span><br><span class="line"><span class="comment">//                                   ...            *spanSetBlock.spans[511]     </span></span><br><span class="line"><span class="comment">//                                   .spine[255]</span></span><br><span class="line"><span class="comment">//                                   ...</span></span><br><span class="line"><span class="comment">//                                   .spine[N]</span></span><br><span class="line"><span class="comment">//            .partial[1]</span></span><br><span class="line"><span class="comment">//            .full[0]</span></span><br><span class="line"><span class="comment">//            .full[1]</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// mcentral[67]</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// mcentral[135]</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>由于<code>spanclass = sizeclass &lt;&lt; 1 + noscan</code>，所以，奇数索引纪录scalar类型，偶数纪录索引类型</p>
<h3 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h3><p>负责向操作系统申请内存进行分配&#x2F;管理、纪录内存分配信息等。全局唯一，访问需要加锁或者STW。其中</p>
<ol>
<li>页通过pages-页分配器分配、管理</li>
<li>mspan通过spanalloc分配器创建&#x2F;回收，关联页后纪录到allspans，mspan空间用完&#x2F;不足会放到mcentral管理</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    _                  sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    lock               mutex          <span class="comment">// 锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页分配器，用于查找连续n页的起始地址</span></span><br><span class="line">    pages              pageAlloc</span><br><span class="line"></span><br><span class="line">    sweepgen           <span class="type">uint32</span>         <span class="comment">// 版本计数器</span></span><br><span class="line"></span><br><span class="line">    allspans           []*mspan       <span class="comment">// 通过spanalloc分配的mspan都纪录到这里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC清扫时使用</span></span><br><span class="line">    pagesInUse         atomic.Uintptr <span class="comment">// heap内存页使用量（mSpanInUse）</span></span><br><span class="line">    pagesSwept         atomic.Uint64  <span class="comment">// 已完成清扫的页数量</span></span><br><span class="line">    pagesSweptBasis    atomic.Uint64  <span class="comment">// pagesSwept快照</span></span><br><span class="line">    sweepHeapLiveBasis <span class="type">uint64</span>         <span class="comment">// heapLive快照（标记终止阶段纪录用于清扫阶段）</span></span><br><span class="line">    <span class="comment">// =剩余待清扫页数量/距离GC触发的剩余堆大小</span></span><br><span class="line">    <span class="comment">// 如果sweepPagesPerByte=0.01，那么每分配100字节，就需要清扫1个页</span></span><br><span class="line">    <span class="comment">// 分配对象时同步清扫，以确保GC触发前清扫任务能完成</span></span><br><span class="line">    sweepPagesPerByte  <span class="type">float64</span>        <span class="comment">// GC触发前，每分配1字节需要清扫的页数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存回收时用。先扣额度，额度用完则扫描heapArena</span></span><br><span class="line">    <span class="comment">// 额度用完时使用，索引从0开始，扫描完所有heapArena设置为1 &lt;&lt; 63</span></span><br><span class="line">    reclaimIndex       atomic.Uint64  <span class="comment">// heapArena索引</span></span><br><span class="line">    <span class="comment">// 释放完整的mspan或释放过多页时才会累计，避免scavenger过度回收</span></span><br><span class="line">    reclaimCredit      atomic.Uintptr <span class="comment">// 回收额度/回收积分</span></span><br><span class="line"></span><br><span class="line">    _                  cpu.CacheLinePad</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bitmap，二维数组，linux下结构为[1]*[4194304]*heapArena，其中</span></span><br><span class="line">    <span class="comment">// 1维只有一个元素，二维有4M个指针，每个heapArena负责管理64MB内存，共管理256TB内存</span></span><br><span class="line">    <span class="comment">// 因为基地址是0xffff800000000000，实际管理内存为128TB</span></span><br><span class="line">    arenas             [<span class="number">1</span> &lt;&lt; arenaL1Bits]*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class="line"></span><br><span class="line">    arenasHugePages    <span class="type">bool</span>           <span class="comment">// 是否启用huge page，linux下可用</span></span><br><span class="line">    heapArenaAlloc     linearAlloc    <span class="comment">// 线性分配器，32位平台用</span></span><br><span class="line">    arenaHints         *arenaHint     <span class="comment">// 链表，每个hint纪录一段heapArena占用的地址</span></span><br><span class="line">    arena              linearAlloc    <span class="comment">// 线性分配器，32位平台用</span></span><br><span class="line">    allArenas          []arenaIdx     <span class="comment">// 纪录arenaIdx</span></span><br><span class="line">    sweepArenas        []arenaIdx     <span class="comment">// allArenas快照，GC清扫时用</span></span><br><span class="line">    markArenas         []arenaIdx     <span class="comment">// allArenas快照，GC标记时用</span></span><br><span class="line">    curArena           <span class="keyword">struct</span> &#123;       <span class="comment">// 当前heapArena的基地址和下一个可分配的内存地址</span></span><br><span class="line">        base, end <span class="type">uintptr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配&lt;32KB内存时会先尝试清扫重用mcentral的mspan</span></span><br><span class="line">    central [numSpanClasses]<span class="keyword">struct</span> &#123;  <span class="comment">// 共136个mcentral</span></span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad      [(cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize) % cpu.CacheLinePadSize]<span class="type">byte</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面都是fixalloc类型的内存分配器，用于创建各类header，固定16KB，用完后重新从系统申请</span></span><br><span class="line">    spanalloc              fixalloc   <span class="comment">// span*</span></span><br><span class="line">    cachealloc             fixalloc   <span class="comment">// mcache*</span></span><br><span class="line">    specialfinalizeralloc  fixalloc   <span class="comment">// specialfinalizer*</span></span><br><span class="line">    specialCleanupAlloc    fixalloc   <span class="comment">// specialcleanup*</span></span><br><span class="line">    specialprofilealloc    fixalloc   <span class="comment">// specialprofile*</span></span><br><span class="line">    specialReachableAlloc  fixalloc   <span class="comment">// specialReachable</span></span><br><span class="line">    specialPinCounterAlloc fixalloc   <span class="comment">// specialPinCounter</span></span><br><span class="line">    specialWeakHandleAlloc fixalloc   <span class="comment">// specialWeakHandle</span></span><br><span class="line">    speciallock            mutex      <span class="comment">//</span></span><br><span class="line">    arenaHintAlloc         fixalloc   <span class="comment">// arenaHints</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// arena包用，用于手动分配内存</span></span><br><span class="line">    userArena              <span class="keyword">struct</span> &#123;</span><br><span class="line">        arenaHints     *arenaHint     <span class="comment">// 链表，初始化时创建128个arenaHint</span></span><br><span class="line">        quarantineList mSpanList      <span class="comment">//</span></span><br><span class="line">        readyList      mSpanList      <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cleanupID <span class="type">uint64</span>                  <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">    unused    *specialfinalizer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预规划地址，目的是尽量让地址连续</span></span><br><span class="line"><span class="keyword">type</span> arenaHint <span class="keyword">struct</span> &#123;</span><br><span class="line">    _    sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的addr是预设的，跟系统申请内存时尝试用sysMap直接映射，失败则回退到sysAlloc申请</span></span><br><span class="line">    addr <span class="type">uintptr</span>                      <span class="comment">// arena的开始虚拟地址</span></span><br><span class="line">    down <span class="type">bool</span>                         <span class="comment">// 分配内存时地址增长的方向，一般为false，即向上扩展</span></span><br><span class="line">    next *arenaHint                   <span class="comment">// 指针，指向下一个arenaHint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap，管理8K个页，每个页8192B，共64MB内存</span></span><br><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line">    _            sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 精确纪录</span></span><br><span class="line">    <span class="comment">// bitmap，共8192个mspan指针，每一个元素表示该页被哪个mspan使用，如</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// | 0       | 1       | ... | 8191     | -&gt; 通过地址addr找到页的索引idx</span></span><br><span class="line">    <span class="comment">// | page7   | page8   | ... | page8198 |</span></span><br><span class="line">    <span class="comment">// | *mspan3 | *mspan3 | ... | *mspan9  | -&gt; 页7、页8被mspan3使用</span></span><br><span class="line">    spans        [pagesPerArena]*mspan</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 粗略纪录，pageInUse纪录的颗粒度比较大，如果有n个页，只会纪录起始页</span></span><br><span class="line">    pageInUse    [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span> <span class="comment">// 用于标记mSpanInUse状态的mspan，共1KB</span></span><br><span class="line">    pageMarks    [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span> <span class="comment">// 同上，GC用</span></span><br><span class="line">    pageSpecials [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span> <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    checkmarks   *checkmarksMap           <span class="comment">// debug.gccheckmark不为0时使用（一般用不到）</span></span><br><span class="line">    zeroedBase   <span class="type">uintptr</span>                  <span class="comment">// 类似base，指向已经清0的区域，如果内存重用，分配的地址会比zeroedBase小，表示需要清0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>hint作用</strong></p>
<p>hint-预规划地址，它的作用是通过sysMap直接向操作系统申请在指定地址处映射内存，因为使用sysAlloc让操作系统选择地址空间会导致地址不连续、碎片化等。如果失败最后会回退到sysAlloc</p>
<p><strong>mheap示例</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mheap.arenas[0] -&gt; *heapArena[0](64MB)</span></span><br><span class="line"><span class="comment">//                    ...</span></span><br><span class="line"><span class="comment">//                    *heapArena[4194303]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      .central   -&gt; mcentral[0]</span></span><br><span class="line"><span class="comment">//                    ...</span></span><br><span class="line"><span class="comment">//                    mcentral[135]</span></span><br></pre></td></tr></table></figure>

<p><strong>可用内存空间</strong></p>
<ol>
<li>从arenas结构看，在linux系统下，mheap可以管理1<em>4194304</em>64MB&#x3D;256TB内存，但实际上，go选择内存地址的中间-<code>0xffff800000000000</code>作为基地址，计算最大地址<code>0x007ffffffff000</code>减去基地址，得出实际可管理内存为128TB</li>
<li>arena包用于手动管理内存，从预分配地址看，实际可管理内存也为128TB，当然，它选择的是另一个地址空间，不跟heap共用</li>
</ol>
<h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><h4 id="fixalloc"><a href="#fixalloc" class="headerlink" title="fixalloc"></a>fixalloc</h4><p>mheap大多数分配器是fixalloc类型，比如mspan就使用了fixalloc，每次用完就从系统申请16KB内存。分配内存优先从空闲对象链表list获取，没有才从chunk分配内存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> fixalloc <span class="keyword">struct</span> &#123;</span><br><span class="line">    size   <span class="type">uintptr</span>                     <span class="comment">// 元素大小，如mspan数据类型的大小为160B</span></span><br><span class="line">    first  <span class="function"><span class="keyword">func</span><span class="params">(arg, p unsafe.Pointer)</span></span> <span class="comment">// 一般为nil，除了mspan需要纪录每个页对应的mspan</span></span><br><span class="line">    arg    unsafe.Pointer              <span class="comment">// 函数参数，比如mspan指针</span></span><br><span class="line">    list   *mlink                      <span class="comment">// 空闲对象列表，比如mspan释放时会放到这里，后续重用</span></span><br><span class="line">    chunk  <span class="type">uintptr</span>                     <span class="comment">// 内存指针，指向未使用的内存的起始位置，也可以认为是offset</span></span><br><span class="line">    nchunk <span class="type">uint32</span>                      <span class="comment">// 剩余字节数，初始值为nalloc</span></span><br><span class="line">    nalloc <span class="type">uint32</span>                      <span class="comment">// 一般是16KB，但会优化移除尾部不用的部份，按8的倍数对齐</span></span><br><span class="line">    inuse  <span class="type">uintptr</span>                     <span class="comment">// 已使用字节数</span></span><br><span class="line">    stat   *sysMemStat                 <span class="comment">// 内存统计用</span></span><br><span class="line">    zero   <span class="type">bool</span>                        <span class="comment">// 默认都需要清0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pageAlloc"><a href="#pageAlloc" class="headerlink" title="pageAlloc"></a>pageAlloc</h4><p>页分配器，本身属于bitmap，用于快速查找连续n页的起始地址。实现比较复杂，是非常重要的数据结构。其中</p>
<ol>
<li>chunks为二维数组，总数据量与arena相同，一次性可管理512个页，即4MB内存</li>
<li>summary是chunks的索引，分5层，最后一层数量与chunks总数相同，每上一层数量缩减8倍，管理的页数增长8倍，可快速寻找连续n页内存的起始地址</li>
</ol>
<p><strong>注意</strong></p>
<p>pageAlloc对bitmap的处理与其他分配器正相反，1为已使用，0为未使用，刚开始看代码很容易混淆</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pageAlloc <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// summary =&gt; [0][2^14]pallocSum =&gt; 第1层每8个sum汇总成1个sum =&gt; 每个sum管理  2M个页共4GB内存</span></span><br><span class="line">    <span class="comment">//            [1][2^17]pallocSum =&gt; 第2层每8个sum汇总成1个sum =&gt; 每个sum管理256K个页共2GB内存</span></span><br><span class="line">    <span class="comment">//            [2][2^20]pallocSum =&gt; 第3层每8个sum汇总成1个sum =&gt; 每个sum管理 32K个页共256MB内存</span></span><br><span class="line">    <span class="comment">//            [3][2^23]pallocSum =&gt; 第4层每8个sum汇总成1个sum =&gt; 每个sum管理  4K个页共32MB内存</span></span><br><span class="line">    <span class="comment">//            [4][2^26]pallocSum =&gt; 代表8192*8192个chunk    =&gt; 每个sum管理 512个页共4MB内存</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// pallocSum =&gt; | 1bit   | 21bit | 21bit | 21bit |</span></span><br><span class="line">    <span class="comment">//              | allmax | end   | max   | start |</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    summary    [summaryLevels][]pallocSum</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chunks -&gt; [0]</span></span><br><span class="line">    <span class="comment">//           ...</span></span><br><span class="line">    <span class="comment">//           [8191] -&gt; [0]    -&gt; pallocBits(512 bit) + scavenged(512 bit)</span></span><br><span class="line">    <span class="comment">//            |        ...</span></span><br><span class="line">    <span class="comment">//            v        [8191] -&gt; 一个单元代表512*8KB=4MB内存</span></span><br><span class="line">    <span class="comment">//           一个单元代表8192*4MB=32GB</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// scavenged初始化时设置为全1，pallocBits初始化时设置为全0的bitmap</span></span><br><span class="line">    <span class="comment">// 可标记n=8192*8192*64*8个page指针，共n*8192=256TB内存，与mheap管理的arena的内存管理量相同</span></span><br><span class="line">    chunks     [<span class="number">1</span> &lt;&lt; pallocChunksL1Bits]*[<span class="number">1</span> &lt;&lt; pallocChunksL2Bits]pallocData</span><br><span class="line"></span><br><span class="line">    searchAddr offAddr               <span class="comment">// 搜索地址，避免每次从基地址开始搜索</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的索引计算刚开始看会很困惑，因为它是把2维数组当1维数组用了，索引范围是[0,8192*8192-1]</span></span><br><span class="line">    <span class="comment">// start会纪录全局最小的索引，而end则纪录全局最大的索引</span></span><br><span class="line">    start, end chunkIdx              <span class="comment">// 起始、终止索引</span></span><br><span class="line"></span><br><span class="line">    inUse      addrRanges            <span class="comment">// 扩容时纪录内存使用情况</span></span><br><span class="line"></span><br><span class="line">    scav       <span class="keyword">struct</span> &#123;              <span class="comment">//</span></span><br><span class="line">        index         scavengeIndex  <span class="comment">//</span></span><br><span class="line">        releasedBg    atomic.Uintptr <span class="comment">//</span></span><br><span class="line">        releasedEager atomic.Uintptr <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mheapLock          *mutex        <span class="comment">// mheap.lock字段</span></span><br><span class="line">    sysStat            *sysMemStat   <span class="comment">//</span></span><br><span class="line">    summaryMappedReady <span class="type">uintptr</span>       <span class="comment">// 已映射且可用的内存量，测试用</span></span><br><span class="line">    chunkHugePages     <span class="type">bool</span>          <span class="comment">// 开启huge page时，设置为true</span></span><br><span class="line"></span><br><span class="line">    test               <span class="type">bool</span>          <span class="comment">// 测试，忽略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> addrRanges <span class="keyword">struct</span> &#123;</span><br><span class="line">    ranges     []addrRange           <span class="comment">// 已分配的地址段，每个元素纪录base、limit，插入时会进行合并</span></span><br><span class="line">    totalBytes <span class="type">uintptr</span>               <span class="comment">// 总分配字节数</span></span><br><span class="line">    sysStat    *sysMemStat           <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// | 1bit   | 21bit | 21bit | 21bit |</span></span><br><span class="line"><span class="comment">// | allmax | end   | max   | start |</span></span><br><span class="line"><span class="keyword">type</span> pallocSum <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap，负责管理64*8=512个页 =&gt; 4MB内存</span></span><br><span class="line"><span class="keyword">type</span> pallocData <span class="keyword">struct</span> &#123;</span><br><span class="line">    pallocBits         <span class="comment">// 分配标记，64字节</span></span><br><span class="line">    scavenged pageBits <span class="comment">// 回收标记，64字节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pageBits [pallocChunkPages / <span class="number">64</span>]<span class="type">uint64</span> <span class="comment">// 512字节，共8个uint64</span></span><br></pre></td></tr></table></figure>

<h2 id="mallocgc"><a href="#mallocgc" class="headerlink" title="mallocgc"></a>mallocgc</h2><p>slice、map、string申请内存时是通过mallocgc来分配的，其他如newobject、newarray、reflect.unsafe_New底层实际也是在调用mallocgc</p>
<p>mallocg内部对申请的内存大小size、对象的类型type判断，分别调用不同的内存分配器分配内存，具体如下</p>
<table>
<thead>
<tr>
<th align="left">条件1</th>
<th align="left">条件2</th>
<th align="left">条件3</th>
<th align="left">内存分配器</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt;&#x3D;32760B</td>
<td align="left">nil或对象不包含指针</td>
<td align="left">&lt;16B</td>
<td align="left">mallocgcTiny</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">&gt;&#x3D;16B</td>
<td align="left">mallocgcSmallNoscan</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">对象包含指针</td>
<td align="left">&lt;&#x3D;512B</td>
<td align="left">mallocgcSmallScanNoHeader</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">&gt;512B</td>
<td align="left">mallocgcSmallScanHeader</td>
</tr>
<tr>
<td align="left">&gt;32760B</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">mallocgcLarge</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据请求的内存大小分配内存、返回地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// size为0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 一个全局变量的指针</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数，忽略（staticlockranking默认为false）</span></span><br><span class="line">    lockRankMayQueueFinalizer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动（gcStart时为true）</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 降低g的Assist额度，如果额度用光了，则g需要协助GC标记（g会被挂起）</span></span><br><span class="line">        deductAssistCredit(size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新申请的内存区域起始地址</span></span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    <span class="comment">// 对象大小，以mspan的为准</span></span><br><span class="line">    <span class="keyword">var</span> elemsize <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总申请字节数 &lt;= 32KB（32768-8）</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize-mallocHeaderSize &#123;</span><br><span class="line">        <span class="comment">// 没有类型信息 or 对象不包含指针（由scalar组成）</span></span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> || !typ.Pointers() &#123;</span><br><span class="line">            <span class="keyword">if</span> size &lt; maxTinySize &#123;</span><br><span class="line">                <span class="comment">// &lt; 16B</span></span><br><span class="line">                <span class="comment">// 从mcache.tiny分配</span></span><br><span class="line">                x, elemsize = mallocgcTiny(size, typ, needzero)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// &gt;= 16B</span></span><br><span class="line">                <span class="comment">// 计算spanclass获取span，分配size大小的内存返回</span></span><br><span class="line">                x, elemsize = mallocgcSmallNoscan(size, typ, needzero)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面的是有类型信息 and 包含指针的情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> heapBitsInSpan(size) &#123; </span><br><span class="line">            <span class="comment">// &lt;=512B</span></span><br><span class="line">            <span class="comment">// 直接存储对象、设置heapBits</span></span><br><span class="line">            x, elemsize = mallocgcSmallScanNoHeader(size, typ, needzero)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &gt;512B，&lt;=32KB</span></span><br><span class="line">            <span class="comment">// 对象大小增加8字节用于存储数据类型、设置heapBits</span></span><br><span class="line">            x, elemsize = mallocgcSmallScanHeader(size, typ, needzero)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// &gt; 32KB</span></span><br><span class="line">        <span class="comment">// 一个对象占用一个mspan</span></span><br><span class="line">        x, elemsize = mallocgcLarge(size, typ, needzero)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动（gcStart时为true） and elemsize不为0</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; elemsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 重复，避免当前g是调度的g0</span></span><br><span class="line">        <span class="keyword">if</span> assistG := getg().m.curg; assistG != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 额度-=剩余量</span></span><br><span class="line">            <span class="comment">// 先前只是按传入的size减少额度，到这里，size已elemsize为准，需要把多余的量也减去</span></span><br><span class="line">            assistG.gcAssistBytes -= <span class="type">int64</span>(elemsize - size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mallocgcTiny"><a href="#mallocgcTiny" class="headerlink" title="mallocgcTiny"></a>mallocgcTiny</h3><p>前提条件：size&lt;&#x3D;32KB，对象为nil或对象不包含指针，size&lt;16B。tiny区域只有16字节，用于合并多个微小对象的内存分配，大概逻辑如下</p>
<ol>
<li>访问mcache<ul>
<li>有p则获取p.mcache，没有p则获取mcache0</li>
</ul>
</li>
<li>tiny区域调整、计算<ul>
<li>tiny区域的offset偏移量跟内存分配量size对齐</li>
</ul>
</li>
<li>空间足够（offset+size&lt;&#x3D;61）<ul>
<li>更新偏移量、计数器，返回内存区域起始地址</li>
</ul>
</li>
<li>空间不足<ul>
<li>申请新的mspan<ul>
<li>从mcache.alloc[tinySpanClass]获取mspan</li>
</ul>
</li>
<li>快速分配<ul>
<li>通过64位的allocCache快速判断并分配对象</li>
</ul>
</li>
<li>慢速分配<ul>
<li>从allocBits获取64位数据，重新填充allocCache并重新判断分配对象</li>
<li>如果mspan已满&#x2F;空间不足，则从mcentral获取新的mspan替换原mspan后重试</li>
</ul>
</li>
</ul>
</li>
<li>收尾<ul>
<li>分配的16字节内存区域清0</li>
<li>如果size比offse小或tiny区域未初始化，替换tiny区域、更新信息</li>
<li>如果size比offset大，如offset&#x3D;8，size&#x3D;12，直接返回整个16字节内存块，不更新tiny区域</li>
<li>写屏障、profiling、GC处理</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从tiny区域分配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcTiny</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 防止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止被GC抢占</span></span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偏移量（指向下一个可用区域）</span></span><br><span class="line">    off := c.tinyoffset</span><br><span class="line">    <span class="comment">// 调整偏移量，按指定倍数向上取整</span></span><br><span class="line">    <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;        <span class="comment">// 低3位为0</span></span><br><span class="line">        <span class="comment">// 按8的倍数向上取整</span></span><br><span class="line">        off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> goarch.PtrSize == <span class="number">4</span> &amp;&amp; size == <span class="number">12</span> &#123; <span class="comment">// 32位系统 and 12B</span></span><br><span class="line">        <span class="comment">// 按8的倍数向上取整</span></span><br><span class="line">        off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123; <span class="comment">// 低2位为0</span></span><br><span class="line">        <span class="comment">// 按4的倍数向上取整</span></span><br><span class="line">        off = alignUp(off, <span class="number">4</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123; <span class="comment">// 低1位为0</span></span><br><span class="line">        <span class="comment">// 按2的倍数向上取整</span></span><br><span class="line">        off = alignUp(off, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有足够的空间容纳元素 and tiny区域已初始化</span></span><br><span class="line">    <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取内存地址</span></span><br><span class="line">        x := unsafe.Pointer(c.tiny + off)</span><br><span class="line">        <span class="comment">// 更新偏移量</span></span><br><span class="line">        c.tinyoffset = off + size</span><br><span class="line">        <span class="comment">// 计数器tinyAllocs+=1</span></span><br><span class="line">        c.tinyAllocs++</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        mp.mallocing = <span class="number">0</span></span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span> x, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空间不足（最大16字节） or tiny区域未初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要触发GC清扫（分配了新的mspan）</span></span><br><span class="line">    checkGCTrigger := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// mspan，索引tinySpanClass=5（sizeclass=2，noscan=true）</span></span><br><span class="line">    span := c.alloc[tinySpanClass]</span><br><span class="line">    <span class="comment">// 通过64位的allocCache快速判断并分配对象</span></span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="comment">// 64个对象已经被分配完了，进入slow path</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// mspan获取一个可用对象，如果mspan已满，则从mcentral获取新的mspan替换原mspan后重试</span></span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(tinySpanClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line">    <span class="comment">// 内存区域清0（共16个字节）</span></span><br><span class="line">    (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// raceenabled默认为false，因此固定为true and (size比已offset小 or tiny未初始化)</span></span><br><span class="line">    <span class="keyword">if</span> !raceenabled &amp;&amp; (size &lt; c.tinyoffset || c.tiny == <span class="number">0</span>) &#123;</span><br><span class="line">        c.tiny = <span class="type">uintptr</span>(x)</span><br><span class="line">        c.tinyoffset = size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果size比offset大，如offset=8，size=12，直接返回整个x内存块，不更新tiny区域</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步freeindex</span></span><br><span class="line">    span.freeIndexForScan = span.freeindex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障已开启</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        <span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextSample初始值为随机数：[0,MemProfileRate)</span></span><br><span class="line">    c.nextSample -= <span class="type">int64</span>(span.elemsize)</span><br><span class="line">    <span class="comment">// 负数立即采样 or MemProfileRate有改动</span></span><br><span class="line">    <span class="keyword">if</span> c.nextSample &lt; <span class="number">0</span> || MemProfileRate != c.memProfRate &#123;</span><br><span class="line">        <span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">        profilealloc(mp, x, span.elemsize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    mp.mallocing = <span class="number">0</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要触发GC清扫</span></span><br><span class="line">    <span class="keyword">if</span> checkGCTrigger &#123;</span><br><span class="line">        <span class="comment">// 内存达到阈值，执行GC</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">            gcStart(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x, span.elemsize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mallocgcSmallNoscan"><a href="#mallocgcSmallNoscan" class="headerlink" title="mallocgcSmallNoscan"></a>mallocgcSmallNoscan</h3><p>前提条件：size&lt;&#x3D;32KB，对象为nil或对象不包含指针，size&gt;&#x3D;16B。大概逻辑如下</p>
<ol>
<li>访问mcache<ul>
<li>有p则获取p.mcache，没有p则获取mcache0</li>
</ul>
</li>
<li>获取mspan<ul>
<li>通过组合sizeclass和noscan变量计算出spanclass<ul>
<li>如果size&lt;&#x3D;1016（1KB-8），sizeclass范围是[0,32]</li>
<li>如果size&gt;1016，sizeclass范围是[32,67]<br> 从mcache.alloc[sizeclass]获取mspan</li>
</ul>
</li>
</ul>
</li>
<li>分配内存<ul>
<li>快速分配<ul>
<li>通过64位的allocCache快速判断并分配对象</li>
</ul>
</li>
<li>慢速分配<ul>
<li>从allocBits获取64位数据，重新填充allocCache并重新判断分配对象</li>
<li>如果mspan已满&#x2F;空间不足，则从mcentral获取新的mspan替换原mspan后重试</li>
</ul>
</li>
</ul>
</li>
<li>收尾<ul>
<li>内存区域清0</li>
<li>写屏障、profiling、GC处理</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算spanclass获取span，分配size大小的内存返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcSmallNoscan</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止被GC抢占</span></span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要触发GC清扫（分配了新的mspan）</span></span><br><span class="line">    checkGCTrigger := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;=1016</span></span><br><span class="line">        <span class="comment">// =size_to_class8[ceil(size/8)]（sizeclass范围是[0,32]，闭区间）</span></span><br><span class="line">        sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// &gt;1016</span></span><br><span class="line">        <span class="comment">// =size_to_class128[ceil((size-1024)/128)]（sizeclass范围是[32,67]，闭区间）</span></span><br><span class="line">        sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上取整，如原size=20，经过计算sizeclass=3，新size=24</span></span><br><span class="line">    size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">    <span class="comment">// 组合sizeclass和noscan成spanclass</span></span><br><span class="line">    spc := makeSpanClass(sizeclass, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 找到mspan</span></span><br><span class="line">    span := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过64位的allocCache快速判断并分配对象</span></span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="comment">// 64个对象已经被分配完了，进入slow path</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// mspan获取一个可用对象，如果mspan已满，则从mcentral获取新的mspan替换原mspan后重试</span></span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(spc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要清0 and span分配前需要清0</span></span><br><span class="line">    <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 内存区域清0</span></span><br><span class="line">        memclrNoHeapPointers(x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步freeindex</span></span><br><span class="line">    span.freeIndexForScan = span.freeindex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障已开启</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        <span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextSample初始值为随机数：[0,MemProfileRate)</span></span><br><span class="line">    c.nextSample -= <span class="type">int64</span>(size)</span><br><span class="line">    <span class="comment">// 负数立即采样 or MemProfileRate有改动</span></span><br><span class="line">    <span class="keyword">if</span> c.nextSample &lt; <span class="number">0</span> || MemProfileRate != c.memProfRate &#123;</span><br><span class="line">        <span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">        profilealloc(mp, x, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    mp.mallocing = <span class="number">0</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要触发GC清扫</span></span><br><span class="line">    <span class="keyword">if</span> checkGCTrigger &#123;</span><br><span class="line">        <span class="comment">// 内存达到阈值，执行GC</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">            gcStart(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mallocgcSmallScanNoHeader"><a href="#mallocgcSmallScanNoHeader" class="headerlink" title="mallocgcSmallScanNoHeader"></a>mallocgcSmallScanNoHeader</h3><p>前提条件：size&lt;&#x3D;32KB，对象包含指针，size&lt;&#x3D;512B。大概逻辑如下</p>
<ol>
<li>访问mcache<ul>
<li>有p则获取p.mcache，没有p则获取mcache0</li>
</ul>
</li>
<li>获取mspan<ul>
<li>通过组合sizeclass和noscan变量计算出spanclass，最终sizeclass范围是[0,32]</li>
<li>从mcache.alloc[sizeclass]获取mspan</li>
</ul>
</li>
<li>分配内存<ul>
<li>快速分配<ul>
<li>通过64位的allocCache快速判断并分配对象</li>
</ul>
</li>
<li>慢速分配<ul>
<li>从allocBits获取64位数据，重新填充allocCache并重新判断分配对象</li>
<li>如果mspan已满&#x2F;空间不足，则从mcentral获取新的mspan替换原mspan后重试</li>
</ul>
</li>
</ul>
</li>
<li>收尾<ul>
<li>根据sizeclass调整scanAlloc、size</li>
<li>写屏障、profiling、GC处理</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcSmallScanNoHeader</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止被GC抢占</span></span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要触发GC清扫（分配了新的mspan）</span></span><br><span class="line">    checkGCTrigger := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =size_to_class8[ceil(size/8)]（sizeclass范围是[0,32]，闭区间）</span></span><br><span class="line">    sizeclass := size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">    <span class="comment">// 组合sizeclass和noscan成spanclass</span></span><br><span class="line">    spc := makeSpanClass(sizeclass, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// 找到mspan</span></span><br><span class="line">    span := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过64位的allocCache快速判断并分配对象</span></span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="comment">// 64个对象已经被分配完了，进入slow path</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// mspan获取一个可用对象，如果mspan已满，则从mcentral获取新的mspan替换原mspan后重试</span></span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(spc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要清0 and span分配前需要清0</span></span><br><span class="line">    <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 内存区域清0</span></span><br><span class="line">        memclrNoHeapPointers(x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64位操作系统 and sizeclass为1（&gt;8B)</span></span><br><span class="line">    <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &amp;&amp; sizeclass == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// mcentral在grow时已调用initHeapBits设置</span></span><br><span class="line">        c.scanAlloc += <span class="number">8</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 32位系统 or sizeclass不为1（&gt;8B)</span></span><br><span class="line">        <span class="comment">// bitmap纪录指针位置，返回需要扫描的字节数</span></span><br><span class="line">        c.scanAlloc += heapSetTypeNoHeader(<span class="type">uintptr</span>(x), size, typ, span)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上取整，如原size=20，经过计算sizeclass=3，新size=24</span></span><br><span class="line">    size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步freeindex</span></span><br><span class="line">    span.freeIndexForScan = span.freeindex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障已开启</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        <span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextSample初始值为随机数：[0,MemProfileRate)</span></span><br><span class="line">    c.nextSample -= <span class="type">int64</span>(size)</span><br><span class="line">    <span class="comment">// 负数立即采样 or MemProfileRate有改动</span></span><br><span class="line">    <span class="keyword">if</span> c.nextSample &lt; <span class="number">0</span> || MemProfileRate != c.memProfRate &#123;</span><br><span class="line">        <span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">        profilealloc(mp, x, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    mp.mallocing = <span class="number">0</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要触发GC清扫</span></span><br><span class="line">    <span class="keyword">if</span> checkGCTrigger &#123;</span><br><span class="line">        <span class="comment">// 内存达到阈值，执行GC</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">            gcStart(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mallocgcSmallScanHeader"><a href="#mallocgcSmallScanHeader" class="headerlink" title="mallocgcSmallScanHeader"></a>mallocgcSmallScanHeader</h3><p>前提条件：size&lt;&#x3D;32KB，对象包含指针，size&gt;512B。大概逻辑如下</p>
<ol>
<li>访问mcache<ul>
<li>有p则获取p.mcache，没有p则获取mcache0</li>
</ul>
</li>
<li>获取mspan<ul>
<li>size+&#x3D;8（多分配8字节存储type）</li>
<li>通过组合sizeclass和noscan变量计算出spanclass<ul>
<li>如果size&lt;&#x3D;1016（1KB-8），sizeclass范围是[0,32]</li>
<li>如果size&gt;1016，sizeclass范围是[32,67]</li>
</ul>
</li>
<li>从mcache.alloc[sizeclass]获取mspan</li>
</ul>
</li>
<li>分配内存<ul>
<li>快速分配<ul>
<li>通过64位的allocCache快速判断并分配对象</li>
</ul>
</li>
<li>慢速分配<ul>
<li>从allocBits获取64位数据，重新填充allocCache并重新判断分配对象</li>
<li>如果mspan已满&#x2F;空间不足，则从mcentral获取新的mspan替换原mspan后重试</li>
</ul>
</li>
</ul>
</li>
<li>收尾<ul>
<li>内存区域清0</li>
<li>存储type到内存区域头8个字节，调整内存区域指针、scanAlloc、size</li>
<li>写屏障、profiling、GC处理</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcSmallScanHeader</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止被GC抢占</span></span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要触发GC清扫（分配了新的mspan）</span></span><br><span class="line">    checkGCTrigger := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多申请8B用作header</span></span><br><span class="line">    size += mallocHeaderSize</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;=1016</span></span><br><span class="line">        <span class="comment">// =size_to_class8[ceil(size/8)]（sizeclass范围是[0,32]，闭区间）</span></span><br><span class="line">        sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// &gt;1016</span></span><br><span class="line">        <span class="comment">// =size_to_class128[ceil((size-1024)/128)]（sizeclass范围是[32,67]，闭区间）</span></span><br><span class="line">        sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上取整，如原size=20，经过计算sizeclass=3，新size=24</span></span><br><span class="line">    size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">    <span class="comment">// 组合sizeclass和noscan成spanclass</span></span><br><span class="line">    spc := makeSpanClass(sizeclass, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// 找到mspan</span></span><br><span class="line">    span := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过64位的allocCache快速判断并分配对象</span></span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="comment">// 64个对象已经被分配完了，进入slow path</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// mspan获取一个可用对象，如果mspan已满，则从mcentral获取新的mspan替换原mspan后重试</span></span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(spc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要清0 and span分配前需要清0</span></span><br><span class="line">    <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 内存区域清0</span></span><br><span class="line">        memclrNoHeapPointers(x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始的8B用作header</span></span><br><span class="line">    header := (**_type)(x)</span><br><span class="line">    <span class="comment">// 往后移动8B才是实际存储</span></span><br><span class="line">    x = add(x, mallocHeaderSize)</span><br><span class="line">    <span class="comment">// 把typ存储到header，返回span.elemsize</span></span><br><span class="line">    c.scanAlloc += heapSetTypeSmallHeader(<span class="type">uintptr</span>(x), size-mallocHeaderSize, typ, header, span)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步freeindex</span></span><br><span class="line">    span.freeIndexForScan = span.freeindex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障已开启</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        <span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextSample初始值为随机数：[0,MemProfileRate)</span></span><br><span class="line">    c.nextSample -= <span class="type">int64</span>(size)</span><br><span class="line">    <span class="comment">// 负数立即采样 or MemProfileRate有改动</span></span><br><span class="line">    <span class="keyword">if</span> c.nextSample &lt; <span class="number">0</span> || MemProfileRate != c.memProfRate &#123;</span><br><span class="line">        <span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">        profilealloc(mp, x, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    mp.mallocing = <span class="number">0</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要触发GC清扫</span></span><br><span class="line">    <span class="keyword">if</span> checkGCTrigger &#123;</span><br><span class="line">        <span class="comment">// 内存达到阈值，执行GC</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">            gcStart(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mallocgcLarge"><a href="#mallocgcLarge" class="headerlink" title="mallocgcLarge"></a>mallocgcLarge</h3><p>前提条件：size&gt;32KB。大概逻辑如下</p>
<ol>
<li>访问mcache<ul>
<li>有p则获取p.mcache，没有p则获取mcache0</li>
</ul>
</li>
<li>创建mspan<ul>
<li>通过mheap分配size大小的mspan（size会按一定的倍数向上取整），更新mspan信息</li>
<li>需要协助GC清扫</li>
</ul>
</li>
<li>收尾<ul>
<li>内存区域清0，如果是scan则纪录对象类型到largeType</li>
<li>写屏障、profiling、GC处理</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcLarge</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止被GC抢占</span></span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (c *mcache) allocLarge(size uintptr, noscan bool) *mspan</span></span><br><span class="line">    <span class="comment">// 协助sweeper清扫，从mheap分配内存、更新索引/gc等信息，mspan放到fullSwept</span></span><br><span class="line">    span := c.allocLarge(size, typ == <span class="literal">nil</span> || !typ.Pointers())</span><br><span class="line">    <span class="comment">// 下一个可用对象索引</span></span><br><span class="line">    span.freeindex = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 已分配对象数</span></span><br><span class="line">    span.allocCount = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 先设置为nil，避免GC扫描，特别是noscan类型</span></span><br><span class="line">    span.largeType = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 调整为mspan的对象大小，对齐后</span></span><br><span class="line">    size = span.elemsize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan的起始地址</span></span><br><span class="line">    x := unsafe.Pointer(span.base())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步freeindex</span></span><br><span class="line">    span.freeIndexForScan = span.freeindex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障已开启</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        <span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextSample初始值为随机数：[0,MemProfileRate)</span></span><br><span class="line">    c.nextSample -= <span class="type">int64</span>(size)</span><br><span class="line">    <span class="comment">// 负数立即采样 or MemProfileRate有改动</span></span><br><span class="line">    <span class="keyword">if</span> c.nextSample &lt; <span class="number">0</span> || MemProfileRate != c.memProfRate &#123;</span><br><span class="line">        <span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">        profilealloc(mp, x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    mp.mallocing = <span class="number">0</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存达到阈值，执行GC</span></span><br><span class="line">    <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">        gcStart(t)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是scan类型 or （需要清0 and span分配前需要清0）</span></span><br><span class="line">    <span class="keyword">if</span> noscan := typ == <span class="literal">nil</span> || !typ.Pointers(); !noscan || (needzero &amp;&amp; span.needzero != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 内存区域批量清0，发生抢占则挂起</span></span><br><span class="line">        memclrNoHeapPointersChunked(size, x)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止被GC抢占</span></span><br><span class="line">        mp := acquirem()</span><br><span class="line">        <span class="comment">// 如果是scan类型</span></span><br><span class="line">        <span class="keyword">if</span> !noscan &#123;</span><br><span class="line">            <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">            <span class="comment">// 把typ存储到span.largeType，返回span.elemsize</span></span><br><span class="line">            getMCache(mp).scanAlloc += heapSetTypeLarge(<span class="type">uintptr</span>(x), size, typ, span)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">        publicationBarrier()</span><br><span class="line">        releasem(mp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关依赖函数"><a href="#相关依赖函数" class="headerlink" title="相关依赖函数"></a>相关依赖函数</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc初始化，schedinit-调度器初始化时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. guard，各种检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// class_to_size[2] != 16</span></span><br><span class="line">    <span class="keyword">if</span> class_to_size[_TinySizeClass] != _TinySize &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad TinySizeClass&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heapArenaBitmapWords非2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> heapArenaBitmapWords&amp;(heapArenaBitmapWords<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;heapArenaBitmapWords not a power of 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// physPageSize没有初始化（该变量由osinit初始化）</span></span><br><span class="line">    <span class="keyword">if</span> physPageSize == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;failed to get system page size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// physPageSize大于524288</span></span><br><span class="line">    <span class="keyword">if</span> physPageSize &gt; maxPhysPageSize &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;system page size (&quot;</span>, physPageSize, <span class="string">&quot;) is larger than maximum page size (&quot;</span>, maxPhysPageSize, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad system page size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// physPageSize小于4096</span></span><br><span class="line">    <span class="keyword">if</span> physPageSize &lt; minPhysPageSize &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;system page size (&quot;</span>, physPageSize, <span class="string">&quot;) is smaller than minimum page size (&quot;</span>, minPhysPageSize, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad system page size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// physPageSize大小非2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> physPageSize&amp;(physPageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;system page size (&quot;</span>, physPageSize, <span class="string">&quot;) must be a power of 2\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad system page size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// physHugePageSize大小非2的倍数（由osinit初始化，只有linux才有）</span></span><br><span class="line">    <span class="keyword">if</span> physHugePageSize&amp;(physHugePageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;system huge page size (&quot;</span>, physHugePageSize, <span class="string">&quot;) must be a power of 2\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad system huge page size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大于4194304</span></span><br><span class="line">    <span class="keyword">if</span> physHugePageSize &gt; maxPhysHugePageSize &#123;</span><br><span class="line">        <span class="comment">// 改为不支持</span></span><br><span class="line">        physHugePageSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// physHugePageSize有正常数值</span></span><br><span class="line">    <span class="keyword">if</span> physHugePageSize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 计算physHugePageShift，使2^physHugePageShift==physHugePageSize</span></span><br><span class="line">        <span class="keyword">for</span> <span class="number">1</span>&lt;&lt;physHugePageShift != physHugePageSize &#123;</span><br><span class="line">            physHugePageShift++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8192%512</span></span><br><span class="line">    <span class="keyword">if</span> pagesPerArena%pagesPerSpanRoot != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;pagesPerArena (&quot;</span>, pagesPerArena, <span class="string">&quot;) is not divisible by pagesPerSpanRoot (&quot;</span>, pagesPerSpanRoot, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad pagesPerSpanRoot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8192%512</span></span><br><span class="line">    <span class="keyword">if</span> pagesPerArena%pagesPerReclaimerChunk != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;pagesPerArena (&quot;</span>, pagesPerArena, <span class="string">&quot;) is not divisible by pagesPerReclaimerChunk (&quot;</span>, pagesPerReclaimerChunk, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad pagesPerReclaimerChunk&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个最终的结果都为true</span></span><br><span class="line">    minSizeForMallocHeaderIsSizeClass := <span class="literal">false</span></span><br><span class="line">    sizeClassesUpToMinSizeForMallocHeaderAreOnePage := <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 68个元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(class_to_size); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> class_to_allocnpages[i] &gt; <span class="number">1</span> &#123;</span><br><span class="line">            sizeClassesUpToMinSizeForMallocHeaderAreOnePage = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 512 == class_to_size[i]</span></span><br><span class="line">        <span class="keyword">if</span> minSizeForMallocHeader == <span class="type">uintptr</span>(class_to_size[i]) &#123;</span><br><span class="line">            minSizeForMallocHeaderIsSizeClass = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !minSizeForMallocHeaderIsSizeClass &#123;</span><br><span class="line">        throw(<span class="string">&quot;min size of malloc header is not a size class boundary&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !sizeClassesUpToMinSizeForMallocHeaderAreOnePage &#123;</span><br><span class="line">        throw(<span class="string">&quot;expected all size classes up to min size for malloc header to fit in one-page spans&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 512/8 &gt; 8*8 =&gt; false</span></span><br><span class="line">    <span class="keyword">if</span> minSizeForMallocHeader/goarch.PtrSize &gt; <span class="number">8</span>*goarch.PtrSize &#123;</span><br><span class="line">        throw(<span class="string">&quot;max pointer/scan bitmap size for headerless objects is too large&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10 &gt; 19 =&gt; false</span></span><br><span class="line">    <span class="keyword">if</span> minTagBits &gt; taggedPointerBits &#123;</span><br><span class="line">        throw(<span class="string">&quot;taggedPointerBits too small&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行相关初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mheap初始化（感觉没什么好说的）</span></span><br><span class="line">    mheap_.init()</span><br><span class="line">    <span class="comment">// mcache0从cachealloc分配器申请内存初始化</span></span><br><span class="line">    mcache0 = allocmcache()</span><br><span class="line">    <span class="comment">// 锁初始化</span></span><br><span class="line">    lockInit(&amp;gcBitsArenas.lock, lockRankGcBitsArenas)</span><br><span class="line">    lockInit(&amp;profInsertLock, lockRankProfInsert)</span><br><span class="line">    lockInit(&amp;profBlockLock, lockRankProfBlock)</span><br><span class="line">    lockInit(&amp;profMemActiveLock, lockRankProfMemActive)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> profMemFutureLock &#123;</span><br><span class="line">        lockInit(&amp;profMemFutureLock[i], lockRankProfMemFuture)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局内存分配器</span></span><br><span class="line">    lockInit(&amp;globalAlloc.mutex, lockRankGlobalAlloc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是userArena的初始化，用以Arena包，让用户自己手动管理内存，可以先忽略</span></span><br><span class="line">    <span class="keyword">if</span> isSbrkPlatform &#123;</span><br><span class="line">        <span class="comment">// wasm（isSbrkPlatform默认为false）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">        <span class="comment">// 64位系统</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成hint-预规划地址，后期尽量调用sysMap直接映射，而不是sysAlloc让OS选择，减少碎片化</span></span><br><span class="line">        <span class="comment">// 为了防止冲突和区分用途，选择0x00c0作为该内存段的标记</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// i=127，共128个，每个arena间隔1&lt;&lt;40（即1TB），共128TB</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0x7f</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">            <span class="comment">// 第一步，计算p</span></span><br><span class="line">            <span class="keyword">var</span> p <span class="type">uintptr</span></span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> raceenabled: <span class="comment">// raceenabled默认为false，忽略</span></span><br><span class="line">                <span class="comment">// TSAN要求heap必须在[0x00c000000000, 0x00e000000000)范围内</span></span><br><span class="line">                p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">32</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">                <span class="keyword">if</span> p &gt;= uintptrMask&amp;<span class="number">0x00e000000000</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> GOARCH == <span class="string">&quot;arm64&quot;</span> &amp;&amp; GOOS == <span class="string">&quot;ios&quot;</span>: <span class="comment">// 忽略</span></span><br><span class="line">                p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">            <span class="keyword">case</span> GOARCH == <span class="string">&quot;arm64&quot;</span>: <span class="comment">// 忽略</span></span><br><span class="line">                p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0040</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">            <span class="keyword">case</span> GOOS == <span class="string">&quot;aix&quot;</span>: <span class="comment">// 忽略</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 防止跟mmap冲突（mmap使用0x0A00000000000000开始的地址）</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0xa0</span>&lt;&lt;<span class="number">52</span>)</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// 默认</span></span><br><span class="line">                <span class="comment">// p = (i*2^40)|(2^64-1)&amp;(0x00c0&lt;&lt;32)</span></span><br><span class="line">                <span class="comment">// i最大值为127，p总共占用47个位，&amp;优先级比|高</span></span><br><span class="line">                <span class="comment">// 如果i=127(0x7f)，p的结果是0x007FC00000000000（7f和c被保留）</span></span><br><span class="line">                p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二步，arenaHint链表</span></span><br><span class="line">            <span class="comment">// 下面判断中，127个hint中的前64个（即一半）hints由mheap直接管理，剩余的放入userArena</span></span><br><span class="line">            hintList := &amp;mheap_.arenaHints</span><br><span class="line">            <span class="comment">// raceenabled默认为false</span></span><br><span class="line">            <span class="keyword">if</span> (!raceenabled &amp;&amp; i &gt; <span class="number">0x3f</span>) || (raceenabled &amp;&amp; i &gt; <span class="number">0x5f</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果i &gt; 0x3f，走这里</span></span><br><span class="line">                hintList = &amp;mheap_.userArena.arenaHints</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从arenaHintAlloc里获取24字节作为arenaHint（内存不够用一次性申请16KB）</span></span><br><span class="line">            hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())</span><br><span class="line">            <span class="comment">// 纪录地址p</span></span><br><span class="line">            hint.addr = p</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 链成一个链表</span></span><br><span class="line">            <span class="comment">// hint0-&gt;hint1-&gt;...-&gt;hint127</span></span><br><span class="line">            <span class="comment">// curr.next = *prev; *prev = curr</span></span><br><span class="line">            hint.next, *hintList = *hintList, hint</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 32位系统，直接忽略</span></span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认2^64-1，可以通过GOMEMLIMIT环境变量修改</span></span><br><span class="line">    gcController.memoryLimit.Store(maxInt64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mheap-1"><a href="#mheap-1" class="headerlink" title="mheap"></a>mheap</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mheap初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> init() &#123;</span><br><span class="line">    <span class="comment">// 锁初始化</span></span><br><span class="line">    lockInit(&amp;h.lock, lockRankMheap)</span><br><span class="line">    lockInit(&amp;h.speciallock, lockRankMheapSpecial)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面全是初始化fixalloc结构体（allock时若数据量不足，则一次性申请16KB内存）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan，每个单元160字节</span></span><br><span class="line">    <span class="comment">// 每次alloc执行recordspan函数，其将分配的mspan纪录到allspans</span></span><br><span class="line">    h.spanalloc.init(unsafe.Sizeof(mspan&#123;&#125;), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)</span><br><span class="line">    <span class="comment">// mcache，每个单元1208字节</span></span><br><span class="line">    h.cachealloc.init(unsafe.Sizeof(mcache&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.mcache_sys)</span><br><span class="line">    <span class="comment">// specialfinalizer，每个单元56字节</span></span><br><span class="line">    h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    <span class="comment">// specialCleanup，每个单元40字节</span></span><br><span class="line">    h.specialCleanupAlloc.init(unsafe.Sizeof(specialCleanup&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    <span class="comment">// specialprofile，每个单元32字节</span></span><br><span class="line">    h.specialprofilealloc.init(unsafe.Sizeof(specialprofile&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    <span class="comment">// specialReachable，每个单元32字节</span></span><br><span class="line">    h.specialReachableAlloc.init(unsafe.Sizeof(specialReachable&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    <span class="comment">// specialPinCounter，每个单元32字节</span></span><br><span class="line">    h.specialPinCounterAlloc.init(unsafe.Sizeof(specialPinCounter&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    <span class="comment">// specialWeakHandle，每个单元32字节</span></span><br><span class="line">    h.specialWeakHandleAlloc.init(unsafe.Sizeof(specialWeakHandle&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.gcMiscSys)</span><br><span class="line">    <span class="comment">// arenaHint，每个单元24字节</span></span><br><span class="line">    h.arenaHintAlloc.init(unsafe.Sizeof(arenaHint&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan在alloc时，单元的内存不执行清零操作</span></span><br><span class="line">    h.spanalloc.zero = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// h-&gt;mapcache不需要初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 136个mcentral</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> h.central &#123;</span><br><span class="line">        <span class="comment">// 纪录spanclass、初始化锁</span></span><br><span class="line">        h.central[i].mcentral.init(spanClass(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pageAlloc初始化</span></span><br><span class="line">    h.pages.init(&amp;h.lock, &amp;memstats.gcMiscSys, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先清扫并释放至少n个页，然后获取mspan、分配n个页面、更新元信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> alloc(npages <span class="type">uintptr</span>, spanclass spanClass) *mspan &#123;</span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 清扫并释放至少n个页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// sweeper数量不为0 =&gt; 还在清扫阶段</span></span><br><span class="line">        <span class="keyword">if</span> !isSweepDone() &#123;</span><br><span class="line">            <span class="comment">// func (h *mheap) reclaim(npage uintptr)</span></span><br><span class="line">            <span class="comment">// 有额度先扣额度，没有额度则按页索引地址找到mspan并清扫，完成至少n个页清扫后返回（分批次清扫，每批512个页）</span></span><br><span class="line">            h.reclaim(npages)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// func (h *mheap) allocSpan(npages uintptr, typ spanAllocType, spanclass spanClass) (s *mspan)</span></span><br><span class="line">        <span class="comment">// 获取mspan、分配n个页面、更新元信息</span></span><br><span class="line">        s = h.allocSpan(npages, spanAllocHeap, spanclass)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取mspan、分配n个页面、更新元信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocManual(npages <span class="type">uintptr</span>, typ spanAllocType) *mspan &#123;</span><br><span class="line">    <span class="comment">// 类型异常</span></span><br><span class="line">    <span class="keyword">if</span> !typ.manual() &#123;</span><br><span class="line">        throw(<span class="string">&quot;manual span allocation called with non-manually-managed type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sizeclass=0</span></span><br><span class="line">    <span class="comment">// 获取mspan、分配n个页面、更新元信息</span></span><br><span class="line">    <span class="keyword">return</span> h.allocSpan(npages, typ, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heap扩容至少npage，返回实际扩容量和是否成功</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> grow(npage <span class="type">uintptr</span>) (<span class="type">uintptr</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总字节数 = npage按512的倍数向上取整，再乘于每页字节数8192</span></span><br><span class="line">    ask := alignUp(npage, pallocChunkPages) * pageSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际扩容量</span></span><br><span class="line">    totalGrowth := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// end地址</span></span><br><span class="line">    end := h.curArena.base + ask</span><br><span class="line">    <span class="comment">// 按physPageSize的倍数向上取整</span></span><br><span class="line">    nBase := alignUp(end, physPageSize)</span><br><span class="line">    <span class="comment">// 不够用，不管有没有溢出</span></span><br><span class="line">    <span class="keyword">if</span> nBase &gt; h.curArena.end || end &lt; h.curArena.base &#123;</span><br><span class="line">        <span class="comment">// func (h *mheap) sysAlloc(n uintptr, hintList **arenaHint, register bool) (v unsafe.Pointer, size uintptr)</span></span><br><span class="line">        <span class="comment">// 向系统申请size大小内存（Reserved），最低64MB，创建arenaHint、heapArena</span></span><br><span class="line">        av, asize := h.sysAlloc(ask, &amp;h.arenaHints, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">if</span> av == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 打印，返回</span></span><br><span class="line">            inUse := gcController.heapFree.load() + gcController.heapReleased.load() + gcController.heapInUse.load()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: out of memory: cannot allocate &quot;</span>, ask, <span class="string">&quot;-byte block (&quot;</span>, inUse, <span class="string">&quot; in use)\n&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个arena</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">uintptr</span>(av) == h.curArena.end &#123;</span><br><span class="line">            <span class="comment">// 更新end</span></span><br><span class="line">            h.curArena.end = <span class="type">uintptr</span>(av) + asize</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 可能有多个arena</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前arena剩余空间</span></span><br><span class="line">            <span class="keyword">if</span> size := h.curArena.end - h.curArena.base; size != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 使用sysMap直接映射，内存状态从Reserved改为Prepared</span></span><br><span class="line">                sysMap(unsafe.Pointer(h.curArena.base), size, &amp;gcController.heapReleased)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">                <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">                stats := memstats.heapStats.acquire()</span><br><span class="line">                <span class="comment">// 剩余内存大小加到released</span></span><br><span class="line">                atomic.Xaddint64(&amp;stats.released, <span class="type">int64</span>(size))</span><br><span class="line">                <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">                memstats.heapStats.release()</span><br><span class="line">                <span class="comment">// func (p *pageAlloc) grow(base, size uintptr)</span></span><br><span class="line">                <span class="comment">// 分配物理内存，更新并重新统计chunks信息，最后更新summary（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">                h.pages.grow(h.curArena.base, size)</span><br><span class="line">                <span class="comment">// 累计到实际扩容量</span></span><br><span class="line">                totalGrowth += size</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 切换到最新的arena</span></span><br><span class="line">            h.curArena.base = <span class="type">uintptr</span>(av)</span><br><span class="line">            h.curArena.end = <span class="type">uintptr</span>(av) + asize</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再算一遍</span></span><br><span class="line">        nBase = alignUp(h.curArena.base+ask, physPageSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原base</span></span><br><span class="line">    v := h.curArena.base</span><br><span class="line">    <span class="comment">// 新base</span></span><br><span class="line">    h.curArena.base = nBase</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用sysMap直接映射，内存状态从Reserved改为Prepared</span></span><br><span class="line">    sysMap(unsafe.Pointer(v), nBase-v, &amp;gcController.heapReleased)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    <span class="comment">// 申请内存大小加到released</span></span><br><span class="line">    atomic.Xaddint64(&amp;stats.released, <span class="type">int64</span>(nBase-v))</span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (p *pageAlloc) grow(base, size uintptr)</span></span><br><span class="line">    <span class="comment">// 分配物理内存，更新并重新统计chunks信息，最后更新summary（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">    h.pages.grow(v, nBase-v)</span><br><span class="line">    <span class="comment">// 累计到实际扩容量</span></span><br><span class="line">    totalGrowth += nBase - v</span><br><span class="line">    <span class="keyword">return</span> totalGrowth, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从mspancache末尾拿一个mspan，不触发扩容操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> tryAllocMSpan() *mspan &#123;</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有p or mspancache为空</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> || pp.mspancache.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从mspancache末尾拿一个mspan</span></span><br><span class="line">    s := pp.mspancache.buf[pp.mspancache.<span class="built_in">len</span><span class="number">-1</span>]</span><br><span class="line">    pp.mspancache.<span class="built_in">len</span>--</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从mspancache末尾拿一个mspan（不足时扩容）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocMSpanLocked() *mspan &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// 没有p</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// spanalloc分配一个mspan header</span></span><br><span class="line">        <span class="keyword">return</span> (*mspan)(h.spanalloc.alloc())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspancache为空</span></span><br><span class="line">    <span class="keyword">if</span> pp.mspancache.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 生成buf长度一半数量的mspan header</span></span><br><span class="line">        <span class="keyword">const</span> refillCount = <span class="built_in">len</span>(pp.mspancache.buf) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; refillCount; i++ &#123;</span><br><span class="line">            pp.mspancache.buf[i] = (*mspan)(h.spanalloc.alloc())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新len</span></span><br><span class="line">        pp.mspancache.<span class="built_in">len</span> = refillCount</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从mspancache末尾拿一个mspan</span></span><br><span class="line">    s := pp.mspancache.buf[pp.mspancache.<span class="built_in">len</span><span class="number">-1</span>]</span><br><span class="line">    pp.mspancache.<span class="built_in">len</span>--</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取mspan、分配n个页面、更新元信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocSpan(npages <span class="type">uintptr</span>, typ spanAllocType, spanclass spanClass) (s *mspan) &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 起始地址，被清理的页数（一般为0）</span></span><br><span class="line">    base, scav := <span class="type">uintptr</span>(<span class="number">0</span>), <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    growth := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// needPhysPageAlign默认false，所以固定返回true</span></span><br><span class="line">    <span class="comment">// 有p and n &lt; 16(=64/4)</span></span><br><span class="line">    <span class="keyword">if</span> !needPhysPageAlign &amp;&amp; pp != <span class="literal">nil</span> &amp;&amp; npages &lt; pageCachePages/<span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">// p.pcache</span></span><br><span class="line">        c := &amp;pp.pcache</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pcache的64个页都用完了</span></span><br><span class="line">        <span class="keyword">if</span> c.empty() &#123;</span><br><span class="line">            lock(&amp;h.lock)</span><br><span class="line">            <span class="comment">// 通过summary查找，找到一个最少包含一个可用页的块（共64个页信息）</span></span><br><span class="line">            *c = h.pages.allocToCache()</span><br><span class="line">            unlock(&amp;h.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// func (c *pageCache) alloc(npages uintptr) (uintptr, uintptr)</span></span><br><span class="line">        <span class="comment">// 从pcache找到连续n个页的起始地址，并判断这几个页是否被清理过（重用）</span></span><br><span class="line">        base, scav = c.alloc(npages)</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        <span class="keyword">if</span> base != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试从mspancache末尾拿一个mspan，不触发扩容操作</span></span><br><span class="line">            s = h.tryAllocMSpan()</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">goto</span> HaveSpan</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从pcache分配页失败</span></span><br><span class="line">    <span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// func (p *pageAlloc) alloc(npages uintptr) (addr uintptr, scav uintptr)</span></span><br><span class="line">        <span class="comment">// pageAlloc通过summary扫描寻找足以容纳n个页的地址</span></span><br><span class="line">        base, scav = h.pages.alloc(npages)</span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">            <span class="comment">// func (h *mheap) grow(npage uintptr) (uintptr, bool)</span></span><br><span class="line">            <span class="comment">// heap扩容至少npage，返回实际扩容量和是否成功（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">            growth, ok = h.grow(npages)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩容失败</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                unlock(&amp;h.lock)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩容成功，重试</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// func (p *pageAlloc) alloc(npages uintptr) (addr uintptr, scav uintptr)</span></span><br><span class="line">            <span class="comment">// pageAlloc通过summary扫描寻找足以容纳n个页的地址</span></span><br><span class="line">            base, scav = h.pages.alloc(npages)</span><br><span class="line">            <span class="comment">// 还是失败，异常</span></span><br><span class="line">            <span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;grew heap, but no adequate free space found&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan为nil</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从mspancache末尾拿一个mspan（不足时扩容）</span></span><br><span class="line">        s = h.allocMSpanLocked()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，page和mspan都准备好了</span></span><br><span class="line">HaveSpan:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存超限溢出的数量</span></span><br><span class="line">    bytesToScavenge := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 是否强制回收</span></span><br><span class="line">    forceScavenge := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU不限制GC使用</span></span><br><span class="line">    <span class="keyword">if</span> limit := gcController.memoryLimit.Load(); !gcCPULimiter.limiting() &#123;</span><br><span class="line">        <span class="comment">// 已映射且可用的内存量（总内存）</span></span><br><span class="line">        inuse := gcController.mappedReady.Load()</span><br><span class="line">        <span class="comment">// 重用的内存量+已映射且可用的内存量（总内存）超过限制</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">uint64</span>(scav)+inuse &gt; <span class="type">uint64</span>(limit) &#123;</span><br><span class="line">            <span class="comment">// 溢出量</span></span><br><span class="line">            bytesToScavenge = <span class="type">uintptr</span>(<span class="type">uint64</span>(scav) + inuse - <span class="type">uint64</span>(limit))</span><br><span class="line">            <span class="comment">// 强制回收</span></span><br><span class="line">            forceScavenge = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC触发临界点有设置限制 and mheap扩容了</span></span><br><span class="line">    <span class="keyword">if</span> goal := scavenge.gcPercentGoal.Load(); goal != ^<span class="type">uint64</span>(<span class="number">0</span>) &amp;&amp; growth &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// retained=heapInUse+heapFree（gcController）</span></span><br><span class="line">        <span class="comment">// 如果heap内存+扩容量超过临界点</span></span><br><span class="line">        <span class="keyword">if</span> retained := heapRetained(); retained+<span class="type">uint64</span>(growth) &gt; goal &#123;</span><br><span class="line">            <span class="comment">// 溢出量，先按扩容量为准</span></span><br><span class="line">            todo := growth</span><br><span class="line">            <span class="comment">// 扩容量比溢出量大</span></span><br><span class="line">            <span class="keyword">if</span> overage := <span class="type">uintptr</span>(retained + <span class="type">uint64</span>(growth) - goal); todo &gt; overage &#123;</span><br><span class="line">                <span class="comment">// 实际溢出量（按道理，一般都会走这个流程）</span></span><br><span class="line">                todo = overage</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// =max(bytesToScavenge,todo) =&gt; 哪个大就已哪个为准</span></span><br><span class="line">            <span class="keyword">if</span> todo &gt; bytesToScavenge &#123;</span><br><span class="line">                bytesToScavenge = todo</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> now <span class="type">int64</span></span><br><span class="line">    <span class="comment">// 有p and 内存超限</span></span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &amp;&amp; bytesToScavenge &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时刻</span></span><br><span class="line">        start := nanotime()</span><br><span class="line">        <span class="comment">// stamp存储limiterEventScavengeAssist和start</span></span><br><span class="line">        track := pp.limiterEvent.start(limiterEventScavengeAssist, start)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// func (p *pageAlloc) scavenge(nbytes uintptr, shouldStop func() bool, force bool) uintptr</span></span><br><span class="line">        <span class="comment">// 回收指定字节数量的内存</span></span><br><span class="line">        released := h.pages.scavenge(bytesToScavenge, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="comment">// CPU是否限制GC使用</span></span><br><span class="line">            <span class="keyword">return</span> gcCPULimiter.limiting()</span><br><span class="line">        &#125;, forceScavenge)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// releasedEager+=released</span></span><br><span class="line">        mheap_.pages.scav.releasedEager.Add(released)</span><br><span class="line"></span><br><span class="line">        now = nanotime()</span><br><span class="line">        <span class="keyword">if</span> track &#123;</span><br><span class="line">            <span class="comment">// 重置stamp字段，纪录耗时</span></span><br><span class="line">            pp.limiterEvent.stop(limiterEventScavengeAssist, now)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 纪录耗时</span></span><br><span class="line">        scavenge.assistTime.Add(now - start)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新mspan、arena</span></span><br><span class="line">    h.initSpan(s, typ, spanclass, base, npages)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数=npages * 8192</span></span><br><span class="line">    nbytes := npages * pageSize</span><br><span class="line">    <span class="keyword">if</span> scav != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 内存状态从Prepared改为Ready</span></span><br><span class="line">        sysUsed(unsafe.Pointer(base), nbytes, scav)</span><br><span class="line">        <span class="comment">// heap内存释放量</span></span><br><span class="line">        gcController.heapReleased.add(-<span class="type">int64</span>(scav))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap内存可复用量（这里需要减去释放回OS的量）</span></span><br><span class="line">    gcController.heapFree.add(-<span class="type">int64</span>(nbytes - scav))</span><br><span class="line">    <span class="comment">// heap内存</span></span><br><span class="line">    <span class="keyword">if</span> typ == spanAllocHeap &#123;</span><br><span class="line">        <span class="comment">// 累计到heap内存使用量</span></span><br><span class="line">        gcController.heapInUse.add(<span class="type">int64</span>(nbytes))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    atomic.Xaddint64(&amp;stats.committed, <span class="type">int64</span>(scav))</span><br><span class="line">    atomic.Xaddint64(&amp;stats.released, -<span class="type">int64</span>(scav))</span><br><span class="line">    <span class="keyword">switch</span> typ &#123;</span><br><span class="line">    <span class="keyword">case</span> spanAllocHeap:          <span class="comment">// 0-heap内存</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inHeap, <span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocStack:         <span class="comment">// 1-stack内存</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inStacks, <span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocPtrScalarBits: <span class="comment">// 3-GC bitmap</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inPtrScalarBits, <span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocWorkBuf:       <span class="comment">// 4-GC wbuf</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inWorkBufs, <span class="type">int64</span>(nbytes))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新mspan、arena</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> initSpan(s *mspan, typ spanAllocType, spanclass spanClass, base, npages <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 简单初始化，数据记录到startAddr、npages</span></span><br><span class="line">    s.init(base, npages)</span><br><span class="line">    <span class="comment">// heapArena分配地址空间，如果开始地址重用则needZero为true</span></span><br><span class="line">    <span class="keyword">if</span> h.allocNeedsZero(base, npages) &#123;</span><br><span class="line">        s.needzero = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数=npages * 8192</span></span><br><span class="line">    nbytes := npages * pageSize</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下是mspan元信息初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动分配管理</span></span><br><span class="line">    <span class="keyword">if</span> typ.manual() &#123;</span><br><span class="line">        s.manualFreeList = <span class="number">0</span></span><br><span class="line">        s.nelems = <span class="number">0</span></span><br><span class="line">        s.limit = s.base() + s.npages*pageSize</span><br><span class="line">        s.state.set(mSpanManual)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// heap类型</span></span><br><span class="line"></span><br><span class="line">        s.spanclass = spanclass</span><br><span class="line">        <span class="comment">// &gt;32KB</span></span><br><span class="line">        <span class="keyword">if</span> sizeclass := spanclass.sizeclass(); sizeclass == <span class="number">0</span> &#123;</span><br><span class="line">            s.elemsize = nbytes</span><br><span class="line">            s.nelems = <span class="number">1</span></span><br><span class="line">            s.divMul = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &lt;=32KB</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向上取整，如原size=20，经过计算sizeclass=3，新size=24</span></span><br><span class="line">            s.elemsize = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">            <span class="comment">// scan and elemsize&lt;=512B</span></span><br><span class="line">            <span class="keyword">if</span> !s.spanclass.noscan() &amp;&amp; heapBitsInSpan(s.elemsize) &#123;</span><br><span class="line">                <span class="comment">// =(总字节数-bitmap字节数)/elemsize</span></span><br><span class="line">                s.nelems = <span class="type">uint16</span>((nbytes - (nbytes / goarch.PtrSize / <span class="number">8</span>)) / s.elemsize)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// noscan or elemsize&gt;512B</span></span><br><span class="line">                <span class="comment">// 不需要加8个字节的header</span></span><br><span class="line">                s.nelems = <span class="type">uint16</span>(nbytes / s.elemsize)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用于优化除法运算</span></span><br><span class="line">            s.divMul = class_to_divmagic[sizeclass]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为0</span></span><br><span class="line">        s.freeindex = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 默认为0</span></span><br><span class="line">        s.freeIndexForScan = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 默认64位全为1</span></span><br><span class="line">        s.allocCache = ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从gcBitsArenas分配足以容纳nelems个位的内存（64的倍数向上取整）</span></span><br><span class="line">        s.gcmarkBits = newMarkBits(<span class="type">uintptr</span>(s.nelems))</span><br><span class="line">        <span class="comment">// 从gcBitsArenas分配足以容纳nelems个位的内存（64的倍数向上取整）</span></span><br><span class="line">        s.allocBits = newAllocBits(<span class="type">uintptr</span>(s.nelems))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用mheap的sweepgen更新mspan的</span></span><br><span class="line">        atomic.Store(&amp;s.sweepgen, h.sweepgen)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态设置</span></span><br><span class="line">        s.state.set(mSpanInUse)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan初始化完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ha.spans纪录heapArena内每个页对应的mspan</span></span><br><span class="line">    h.setSpans(s.base(), npages, s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非手动分配管理</span></span><br><span class="line">    <span class="keyword">if</span> !typ.manual() &#123;</span><br><span class="line">        <span class="comment">// 通过地址计算出heapArena、页起始索引、页起始位</span></span><br><span class="line">        arena, pageIdx, pageMask := pageIndexOf(s.base())</span><br><span class="line">        <span class="comment">// 汇编，按位或，看起来只有第一个页有设置</span></span><br><span class="line">        atomic.Or8(&amp;arena.pageInUse[pageIdx], pageMask)</span><br><span class="line">        <span class="comment">// heap内存页使用量（mSpanInUse） =&gt; pagesInUse+=n</span></span><br><span class="line">        h.pagesInUse.Add(npages)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有额度先扣额度，没有额度则按页索引地址找到mspan并清扫，完成至少n个页清扫后返回（分批次清扫，每批512个页）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> reclaim(npage <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// scavenger-回收器已完成工作</span></span><br><span class="line">    <span class="keyword">if</span> h.reclaimIndex.Load() &gt;= <span class="number">1</span>&lt;&lt;<span class="number">63</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allArenas快照 =&gt; []arenaIdx</span></span><br><span class="line">    arenas := h.sweepArenas</span><br><span class="line">    <span class="comment">// 是否已加锁</span></span><br><span class="line">    locked := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清扫至少n个页面</span></span><br><span class="line">    <span class="keyword">for</span> npage &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 还有额度</span></span><br><span class="line">        <span class="keyword">if</span> credit := h.reclaimCredit.Load(); credit &gt; <span class="number">0</span> &#123;</span><br><span class="line">            take := credit</span><br><span class="line">            <span class="comment">// 额度足够</span></span><br><span class="line">            <span class="keyword">if</span> take &gt; npage &#123;</span><br><span class="line">                <span class="comment">// 以n为准</span></span><br><span class="line">                take = npage</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拿走take额度</span></span><br><span class="line">            <span class="keyword">if</span> h.reclaimCredit.CompareAndSwap(credit, credit-take) &#123;</span><br><span class="line">                <span class="comment">// 调整，结果&gt;=0</span></span><br><span class="line">                npage -= take</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有额度了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取reclaimIndex =&gt; idx=reclaimIndex; reclaimIndex+=512</span></span><br><span class="line">        idx := <span class="type">uintptr</span>(h.reclaimIndex.Add(pagesPerReclaimerChunk) - pagesPerReclaimerChunk)</span><br><span class="line">        <span class="comment">// 获取heapArena的索引并判断是否越界 =&gt; idx/8192 &gt;= len(arenas)</span></span><br><span class="line">        <span class="keyword">if</span> idx/pagesPerArena &gt;= <span class="type">uintptr</span>(<span class="built_in">len</span>(arenas)) &#123;</span><br><span class="line">            <span class="comment">// 越界了</span></span><br><span class="line">            <span class="comment">// 设置为1 &lt;&lt; 63</span></span><br><span class="line">            h.reclaimIndex.Store(<span class="number">1</span> &lt;&lt; <span class="number">63</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁，用于访问reclaimChunk</span></span><br><span class="line">        <span class="keyword">if</span> !locked &#123;</span><br><span class="line">            lock(&amp;h.lock)</span><br><span class="line">            locked = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按页索引地址找到mspan并清扫，完成至少512个页清扫后返回</span></span><br><span class="line">        nfound := h.reclaimChunk(arenas, idx, pagesPerReclaimerChunk)</span><br><span class="line">        <span class="keyword">if</span> nfound &lt;= npage &#123;</span><br><span class="line">            npage -= nfound</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 释放了过多的页，则多余的量累计到回收额度</span></span><br><span class="line">            h.reclaimCredit.Add(nfound - npage)</span><br><span class="line">            npage = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复原锁状态</span></span><br><span class="line">    <span class="keyword">if</span> locked &#123;</span><br><span class="line">        unlock(&amp;h.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按页索引地址找到mspan并清扫，完成至少n个页清扫后返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> reclaimChunk(arenas []arenaIdx, pageIdx, n <span class="type">uintptr</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    <span class="comment">// 防止访问到过期的mspan指针</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    n0 := n <span class="comment">// 512</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> nFreed <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// 计数器加1，返回mheap_.sweepgen及sweepDrainedMask标记是否已设置</span></span><br><span class="line">    sl := sweep.active.begin()</span><br><span class="line">    <span class="comment">// sweeper数量为0 =&gt; sweep阶段结束</span></span><br><span class="line">    <span class="keyword">if</span> !sl.valid &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// =arenas[reclaimIndex/8192]</span></span><br><span class="line">        ai := arenas[pageIdx/pagesPerArena]</span><br><span class="line">        <span class="comment">// heapArena</span></span><br><span class="line">        ha := h.arenas[ai.l1()][ai.l2()]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在heapArena内的页索引=reclaimIndex%8192</span></span><br><span class="line">        arenaPage := <span class="type">uint</span>(pageIdx % pagesPerArena)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面两个都是bitmap，每个都有8K个位，找到n个页的bitmap区域</span></span><br><span class="line">        inUse := ha.pageInUse[arenaPage/<span class="number">8</span>:]</span><br><span class="line">        marked := ha.pageMarks[arenaPage/<span class="number">8</span>:]</span><br><span class="line">        <span class="comment">// uint8类型，可管理8个页</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">uintptr</span>(<span class="built_in">len</span>(inUse)) &gt; n/<span class="number">8</span> &#123;</span><br><span class="line">            inUse = inUse[:n/<span class="number">8</span>]</span><br><span class="line">            marked = marked[:n/<span class="number">8</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个字节</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> inUse &#123;</span><br><span class="line">            <span class="comment">// 找出标记为已使用但没有被GC标记的页（白色对象，应该要清扫的页）</span></span><br><span class="line">            inUseUnmarked := atomic.Load8(&amp;inUse[i]) &amp;^ marked[i]</span><br><span class="line">            <span class="comment">// 没有，继续</span></span><br><span class="line">            <span class="keyword">if</span> inUseUnmarked == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有需要清扫的页，找到具体的页</span></span><br><span class="line">            <span class="keyword">for</span> j := <span class="type">uint</span>(<span class="number">0</span>); j &lt; <span class="number">8</span>; j++ &#123;</span><br><span class="line">                <span class="comment">// 找到了</span></span><br><span class="line">                <span class="keyword">if</span> inUseUnmarked&amp;(<span class="number">1</span>&lt;&lt;j) != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 根据页ID找到mspan</span></span><br><span class="line">                    s := ha.spans[arenaPage+<span class="type">uint</span>(i)*<span class="number">8</span>+j]</span><br><span class="line">                    <span class="comment">// 尝试获得mspan的所有权</span></span><br><span class="line">                    <span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">                        npages := s.npages</span><br><span class="line">                        <span class="comment">// 解锁</span></span><br><span class="line">                        unlock(&amp;h.lock)</span><br><span class="line">                        <span class="comment">// func (sl *sweepLocked) sweep(preserve bool) bool</span></span><br><span class="line">                        <span class="comment">// 清扫一个mspan（不保留，被heap回收）</span></span><br><span class="line">                        <span class="keyword">if</span> s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line">                            nFreed += npages</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 重新加锁</span></span><br><span class="line">                        lock(&amp;h.lock)</span><br><span class="line">                        <span class="comment">// double-check，防止过期mspan指针</span></span><br><span class="line">                        inUseUnmarked = atomic.Load8(&amp;inUse[i]) &amp;^ marked[i]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共扫描inUse*8个页</span></span><br><span class="line">        <span class="comment">// 移动索引</span></span><br><span class="line">        pageIdx += <span class="type">uintptr</span>(<span class="built_in">len</span>(inUse) * <span class="number">8</span>)</span><br><span class="line">        <span class="comment">// 计数器调整，看是否还需要继续清扫</span></span><br><span class="line">        n -= <span class="type">uintptr</span>(<span class="built_in">len</span>(inUse) * <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清扫完毕</span></span><br><span class="line">    <span class="comment">// 计数器减1</span></span><br><span class="line">    sweep.active.end(sl)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line">    <span class="keyword">return</span> nFreed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放页和mspan，仅heap管理用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> freeSpan(s *mspan) &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lock(&amp;h.lock)</span><br><span class="line">        <span class="comment">// 释放页和mspan</span></span><br><span class="line">        h.freeSpanLocked(s, spanAllocHeap)</span><br><span class="line">        unlock(&amp;h.lock)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放页和mspan，仅手动分配用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> freeManual(s *mspan, typ spanAllocType) &#123;</span><br><span class="line">    <span class="comment">// 表示需要清0</span></span><br><span class="line">    s.needzero = <span class="number">1</span></span><br><span class="line">    lock(&amp;h.lock)</span><br><span class="line">    <span class="comment">// 释放页和mspan</span></span><br><span class="line">    h.freeSpanLocked(s, typ)</span><br><span class="line">    unlock(&amp;h.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放页和mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> freeSpanLocked(s *mspan, typ spanAllocType) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> s.state.get() &#123;</span><br><span class="line">    <span class="keyword">case</span> mSpanManual: <span class="comment">// 手动</span></span><br><span class="line">        <span class="keyword">if</span> s.allocCount != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;mheap.freeSpanLocked - invalid stack free&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> mSpanInUse: <span class="comment">// heap管理</span></span><br><span class="line">        <span class="keyword">if</span> s.isUserArenaChunk &#123;</span><br><span class="line">            throw(<span class="string">&quot;mheap.freeSpanLocked - invalid free of user arena chunk&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s.allocCount != <span class="number">0</span> || s.sweepgen != h.sweepgen &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;mheap.freeSpanLocked - span &quot;</span>, s, <span class="string">&quot; ptr &quot;</span>, hex(s.base()), <span class="string">&quot; allocCount &quot;</span>, s.allocCount, <span class="string">&quot; sweepgen &quot;</span>, s.sweepgen, <span class="string">&quot;/&quot;</span>, h.sweepgen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;mheap.freeSpanLocked - invalid free&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// heap内存页使用量（mSpanInUse） =&gt; pagesInUse-=n</span></span><br><span class="line">        h.pagesInUse.Add(-s.npages)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过地址计算出heapArena、页起始索引、页起始位</span></span><br><span class="line">        arena, pageIdx, pageMask := pageIndexOf(s.base())</span><br><span class="line">        <span class="comment">// 在pageInUse中将该页所在位设置为0</span></span><br><span class="line">        atomic.And8(&amp;arena.pageInUse[pageIdx], ^pageMask)</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 其他</span></span><br><span class="line">        throw(<span class="string">&quot;mheap.freeSpanLocked - invalid span state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新stat</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 总字节数</span></span><br><span class="line">    nbytes := s.npages * pageSize</span><br><span class="line">    <span class="comment">// heap内存可复用量（free时增加）</span></span><br><span class="line">    gcController.heapFree.add(<span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="comment">// heap内存</span></span><br><span class="line">    <span class="keyword">if</span> typ == spanAllocHeap &#123;</span><br><span class="line">        <span class="comment">// 累计到heap内存使用量</span></span><br><span class="line">        gcController.heapInUse.add(-<span class="type">int64</span>(nbytes))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    <span class="keyword">switch</span> typ &#123;</span><br><span class="line">    <span class="keyword">case</span> spanAllocHeap:          <span class="comment">// 0-heap内存</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inHeap, -<span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocStack:         <span class="comment">// 1-stack内存</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inStacks, -<span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocPtrScalarBits: <span class="comment">// 3-GC bitmap</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inPtrScalarBits, -<span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocWorkBuf:       <span class="comment">// 4-GC wbuf</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inWorkBufs, -<span class="type">int64</span>(nbytes))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新并重新统计chunks，最后更新summary（释放）</span></span><br><span class="line">    h.pages.free(s.base(), s.npages)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认状态</span></span><br><span class="line">    s.state.set(mSpanDead)</span><br><span class="line">    <span class="comment">// mspan放到mspancache末尾</span></span><br><span class="line">    h.freeMSpanLocked(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mspan放到mspancache末尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> freeMSpanLocked(s *mspan) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p不为空 and buf不满一半</span></span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &amp;&amp; pp.mspancache.<span class="built_in">len</span> &lt; <span class="built_in">len</span>(pp.mspancache.buf) &#123;</span><br><span class="line">        <span class="comment">// 放到mspancache末尾</span></span><br><span class="line">        pp.mspancache.buf[pp.mspancache.<span class="built_in">len</span>] = s</span><br><span class="line">        pp.mspancache.<span class="built_in">len</span>++</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有p</span></span><br><span class="line">    h.spanalloc.free(unsafe.Pointer(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向系统申请size大小内存（Reserved），最低64MB，创建arenaHint、heapArena（这是mheap的方法）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> sysAlloc(n <span class="type">uintptr</span>, hintList **arenaHint, register <span class="type">bool</span>) (v unsafe.Pointer, size <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按64MB的倍数向上取整</span></span><br><span class="line">    n = alignUp(n, heapArenaBytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般情况下都是</span></span><br><span class="line">    <span class="keyword">if</span> hintList == &amp;h.arenaHints &#123;</span><br><span class="line">        <span class="comment">// 忽略，这一步会失败，因为arena压根没初始化</span></span><br><span class="line">        v = h.arena.alloc(n, heapArenaBytes, &amp;gcController.heapReleased)</span><br><span class="line">        <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">            size = n</span><br><span class="line">            <span class="keyword">goto</span> mapped</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> *hintList != <span class="literal">nil</span> &#123;</span><br><span class="line">        hint := *hintList</span><br><span class="line">        <span class="comment">// 初始地址</span></span><br><span class="line">        p := hint.addr</span><br><span class="line">        <span class="comment">// 向下扩展</span></span><br><span class="line">        <span class="keyword">if</span> hint.down &#123;</span><br><span class="line">            p -= n</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p+n &lt; p &#123;</span><br><span class="line">            <span class="comment">// 溢出</span></span><br><span class="line">            v = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+n<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">            <span class="comment">// 地址越界</span></span><br><span class="line">            v = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 向系统申请n大小的内存（64MB的倍数，Reserved）</span></span><br><span class="line">            v = sysReserve(unsafe.Pointer(p), n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 申请成功</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="type">uintptr</span>(v) &#123;</span><br><span class="line">            <span class="comment">// 向上扩展</span></span><br><span class="line">            <span class="keyword">if</span> !hint.down &#123;</span><br><span class="line">                p += n</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新addr</span></span><br><span class="line">            hint.addr = p</span><br><span class="line">            size = n</span><br><span class="line">            <span class="comment">// 退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是申请失败</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 释放未使用的内存回收给操作系统</span></span><br><span class="line">            sysFreeOS(v, n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一个hint</span></span><br><span class="line">        *hintList = hint.next</span><br><span class="line">        <span class="comment">// hint回收放到free链表</span></span><br><span class="line">        h.arenaHintAlloc.free(unsafe.Pointer(hint))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的hint都失败了，申请64MB内存，但生成两个hint</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 默认false，忽略</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            throw(<span class="string">&quot;too many address space collisions for -race mode&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向系统申请n大小的内存（Reserved），按64MB对齐，返回对齐后的内存地址和大小，对齐时剩余的量全部释放回系统</span></span><br><span class="line">        v, size = sysReserveAligned(<span class="literal">nil</span>, n, heapArenaBytes)</span><br><span class="line">        <span class="comment">// 还是失败</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个新hint</span></span><br><span class="line">        hint := (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">        hint.addr, hint.down = <span class="type">uintptr</span>(v), <span class="literal">true</span></span><br><span class="line">        hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个新hint</span></span><br><span class="line">        hint = (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">        hint.addr = <span class="type">uintptr</span>(v) + size</span><br><span class="line">        hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> bad <span class="type">string</span></span><br><span class="line">        p := <span class="type">uintptr</span>(v)</span><br><span class="line">        <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">if</span> p+size &lt; p &#123;</span><br><span class="line">            bad = <span class="string">&quot;region exceeds uintptr range&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">            <span class="comment">// 地址越界</span></span><br><span class="line">            bad = <span class="string">&quot;base outside usable address space&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+size<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">            <span class="comment">// 地址越界</span></span><br><span class="line">            bad = <span class="string">&quot;end outside usable address space&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bad != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: memory allocated by OS [&quot;</span>, hex(p), <span class="string">&quot;, &quot;</span>, hex(p+size), <span class="string">&quot;) not in usable address space: &quot;</span>, bad, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;memory reservation exceeds address space limit&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 低26位不为0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(v)&amp;(heapArenaBytes<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;misrounded allocation in sysAlloc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存申请成功</span></span><br><span class="line"></span><br><span class="line">mapped:</span><br><span class="line">    <span class="comment">// 创建heapArena</span></span><br><span class="line">    <span class="keyword">for</span> ri := arenaIndex(<span class="type">uintptr</span>(v)); ri &lt;= arenaIndex(<span class="type">uintptr</span>(v)+size<span class="number">-1</span>); ri++ &#123;</span><br><span class="line">        <span class="comment">// l2数组，4M个heapArena指针</span></span><br><span class="line">        l2 := h.arenas[ri.l1()]</span><br><span class="line">        <span class="comment">// l2为nil</span></span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 直接向系统申请4M*8B=32MB内存（Ready）</span></span><br><span class="line">            l2 = (*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena)(sysAllocOS(unsafe.Sizeof(*l2)))</span><br><span class="line">            <span class="comment">// 申请失败</span></span><br><span class="line">            <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;out of memory allocating heap arena map&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> h.arenasHugePages &#123;</span><br><span class="line">                <span class="comment">// 按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line">                sysHugePage(unsafe.Pointer(l2), unsafe.Sizeof(*l2))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不使用huge page</span></span><br><span class="line">                sysNoHugePage(unsafe.Pointer(l2), unsafe.Sizeof(*l2))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// h.arenas[ri.l1()]=l2</span></span><br><span class="line">            atomic.StorepNoWB(unsafe.Pointer(&amp;h.arenas[ri.l1()]), unsafe.Pointer(l2))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已初始化</span></span><br><span class="line">        <span class="keyword">if</span> l2[ri.l2()] != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;arena already initialized&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> r *heapArena</span><br><span class="line">        <span class="comment">// 这一步会失败，因为压根没初始化</span></span><br><span class="line">        r = (*heapArena)(h.heapArenaAlloc.alloc(unsafe.Sizeof(*r), goarch.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">        <span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 调用sysAlloc向系统申请64KB大小的内存（Ready），按8倍数向上取整，统计</span></span><br><span class="line">            <span class="comment">// 超过64KB直接向系统申请，未超过64KB则一次性申请256KB内存后再分配</span></span><br><span class="line">            r = (*heapArena)(persistentalloc(unsafe.Sizeof(*r), goarch.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">            <span class="comment">// 失败，异常</span></span><br><span class="line">            <span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;out of memory allocating heap arena metadata&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要注册到allArenas</span></span><br><span class="line">        <span class="keyword">if</span> register &#123;</span><br><span class="line">            <span class="comment">// 容量不足</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(h.allArenas) == <span class="built_in">cap</span>(h.allArenas) &#123;</span><br><span class="line">                <span class="comment">// 总字节数（双倍容量）</span></span><br><span class="line">                size := <span class="number">2</span> * <span class="type">uintptr</span>(<span class="built_in">cap</span>(h.allArenas)) * goarch.PtrSize</span><br><span class="line">                <span class="comment">// 最小为一个页大小</span></span><br><span class="line">                <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">                    size = physPageSize</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 调用sysAlloc向系统申请64KB大小的内存（Ready），按align倍数向上取整，统计</span></span><br><span class="line">                <span class="comment">// 超过64KB直接向系统申请，未超过64KB则一次性申请256KB内存后再分配</span></span><br><span class="line">                newArray := (*notInHeap)(persistentalloc(size, goarch.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">                <span class="comment">// 申请失败</span></span><br><span class="line">                <span class="keyword">if</span> newArray == <span class="literal">nil</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;out of memory allocating allArenas&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 旧数组</span></span><br><span class="line">                oldSlice := h.allArenas</span><br><span class="line">                <span class="comment">// 替换为新数组</span></span><br><span class="line">                *(*notInHeapSlice)(unsafe.Pointer(&amp;h.allArenas)) = notInHeapSlice&#123;newArray, <span class="built_in">len</span>(h.allArenas), <span class="type">int</span>(size / goarch.PtrSize)&#125;</span><br><span class="line">                <span class="comment">// 复制旧数组内容</span></span><br><span class="line">                <span class="built_in">copy</span>(h.allArenas, oldSlice)</span><br><span class="line">                <span class="comment">// 不释放旧数组，可能存在并发读</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 放到数组末尾</span></span><br><span class="line">            h.allArenas = h.allArenas[:<span class="built_in">len</span>(h.allArenas)+<span class="number">1</span>]</span><br><span class="line">            h.allArenas[<span class="built_in">len</span>(h.allArenas)<span class="number">-1</span>] = ri</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// l2[ri.l2()] = r</span></span><br><span class="line">        atomic.StorepNoWB(unsafe.Pointer(&amp;l2[ri.l2()]), unsafe.Pointer(r))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ha.spans纪录heapArena内每个页对应的mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> setSpans(base, npage <span class="type">uintptr</span>, s *mspan) &#123;</span><br><span class="line">    <span class="comment">// = base/8192</span></span><br><span class="line">    p := base / pageSize</span><br><span class="line">    <span class="comment">// heapArena索引</span></span><br><span class="line">    ai := arenaIndex(base)</span><br><span class="line">    <span class="comment">// heapArena</span></span><br><span class="line">    ha := h.arenas[ai.l1()][ai.l2()]</span><br><span class="line">    <span class="comment">// 这几个页全局都要纪录mspan指针</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="type">uintptr</span>(<span class="number">0</span>); n &lt; npage; n++ &#123;</span><br><span class="line">        <span class="comment">// 索引=(p+n)%8192</span></span><br><span class="line">        i := (p + n) % pagesPerArena</span><br><span class="line">        <span class="comment">// 末尾/到了一个新的heapArena</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 重新读</span></span><br><span class="line">            ai = arenaIndex(base + n*pageSize)</span><br><span class="line">            ha = h.arenas[ai.l1()][ai.l2()]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// heapArena纪录mspan</span></span><br><span class="line">        ha.spans[i] = s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spanalloc分配的mspan纪录到allspans</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recordspan</span><span class="params">(vh unsafe.Pointer, p unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// mheap</span></span><br><span class="line">    h := (*mheap)(vh)</span><br><span class="line">    <span class="comment">// mspan</span></span><br><span class="line">    s := (*mspan)(p)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(h.allspans) &gt;= <span class="built_in">cap</span>(h.allspans) &#123;</span><br><span class="line">        <span class="comment">// 8KB</span></span><br><span class="line">        n := <span class="number">64</span> * <span class="number">1024</span> / goarch.PtrSize</span><br><span class="line">        <span class="comment">// 1.5倍</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="built_in">cap</span>(h.allspans)*<span class="number">3</span>/<span class="number">2</span> &#123;</span><br><span class="line">            n = <span class="built_in">cap</span>(h.allspans) * <span class="number">3</span> / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">new</span> []*mspan</span><br><span class="line">        sp := (*slice)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">        <span class="comment">// 直接向系统申请8*n内存（Ready）</span></span><br><span class="line">        sp.array = sysAlloc(<span class="type">uintptr</span>(n)*goarch.PtrSize, &amp;memstats.other_sys)</span><br><span class="line">        <span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">if</span> sp.array == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: cannot allocate memory&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 旧len</span></span><br><span class="line">        sp.<span class="built_in">len</span> = <span class="built_in">len</span>(h.allspans)</span><br><span class="line">        <span class="comment">// 新cap</span></span><br><span class="line">        sp.<span class="built_in">cap</span> = n</span><br><span class="line">        <span class="comment">// 复制</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(h.allspans) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">copy</span>(<span class="built_in">new</span>, h.allspans)</span><br><span class="line">        &#125;</span><br><span class="line">        oldAllspans := h.allspans</span><br><span class="line">        <span class="comment">// 替换旧allspans</span></span><br><span class="line">        *(*notInHeapSlice)(unsafe.Pointer(&amp;h.allspans)) = *(*notInHeapSlice)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">        <span class="comment">// 释放内存回系统</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(oldAllspans) != <span class="number">0</span> &#123;</span><br><span class="line">            sysFree(unsafe.Pointer(&amp;oldAllspans[<span class="number">0</span>]), <span class="type">uintptr</span>(<span class="built_in">cap</span>(oldAllspans))*unsafe.Sizeof(oldAllspans[<span class="number">0</span>]), &amp;memstats.other_sys)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放到末尾</span></span><br><span class="line">    h.allspans = h.allspans[:<span class="built_in">len</span>(h.allspans)+<span class="number">1</span>]</span><br><span class="line">    h.allspans[<span class="built_in">len</span>(h.allspans)<span class="number">-1</span>] = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heapArena分配地址空间，如果开始地址重用则needZero为true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocNeedsZero(base, npage <span class="type">uintptr</span>) (needZero <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> npage &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 转换为anera索引</span></span><br><span class="line">        ai := arenaIndex(base)</span><br><span class="line">        <span class="comment">// 找到heapArena</span></span><br><span class="line">        ha := h.arenas[ai.l1()][ai.l2()]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已清0的索引</span></span><br><span class="line">        zeroedBase := atomic.Loaduintptr(&amp;ha.zeroedBase)</span><br><span class="line">        <span class="comment">// 在heapArena内部的地址=base%64MB</span></span><br><span class="line">        arenaBase := base % heapArenaBytes</span><br><span class="line">        <span class="comment">// 重用，需要清0（zeroedBase后面的区域都为0）</span></span><br><span class="line">        <span class="keyword">if</span> arenaBase &lt; zeroedBase &#123;</span><br><span class="line">            needZero = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止地址=arenaBase+npage*8192</span></span><br><span class="line">        arenaLimit := arenaBase + npage*pageSize</span><br><span class="line">        <span class="comment">// 最大64MB</span></span><br><span class="line">        <span class="keyword">if</span> arenaLimit &gt; heapArenaBytes &#123;</span><br><span class="line">            arenaLimit = heapArenaBytes</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果limit超过zerobase，则替换掉zeroedBase</span></span><br><span class="line">        <span class="keyword">for</span> arenaLimit &gt; zeroedBase &#123;</span><br><span class="line">            <span class="comment">// ha.zeroedBase设置为arenaLimit</span></span><br><span class="line">            <span class="keyword">if</span> atomic.Casuintptr(&amp;ha.zeroedBase, zeroedBase, arenaLimit) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新读一遍</span></span><br><span class="line">            zeroedBase = atomic.Loaduintptr(&amp;ha.zeroedBase)</span><br><span class="line">            <span class="comment">// double-check</span></span><br><span class="line">            <span class="keyword">if</span> zeroedBase &lt;= arenaLimit &amp;&amp; zeroedBase &gt; arenaBase &#123;</span><br><span class="line">                <span class="comment">// 有交叉</span></span><br><span class="line">                throw(<span class="string">&quot;potentially overlapping in-use allocations detected&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base调整</span></span><br><span class="line">        base += arenaLimit - arenaBase</span><br><span class="line">        <span class="comment">// 这n个页可能分为两个heapArena，第一个计算完了，计算下一个</span></span><br><span class="line">        npage -= (arenaLimit - arenaBase) / pageSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/debug.freeOSMemory，手动管理</span></span><br><span class="line"><span class="comment">// 回收指定字节数量的内存，期间禁止malloc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> scavengeAll() &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 禁止malloc</span></span><br><span class="line">    gp.m.mallocing++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (p *pageAlloc) scavenge(nbytes uintptr, shouldStop func() bool, force bool) uintptr</span></span><br><span class="line">    <span class="comment">// 回收指定字节数量的内存</span></span><br><span class="line">    released := h.pages.scavenge(^<span class="type">uintptr</span>(<span class="number">0</span>), <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置，允许malloc</span></span><br><span class="line">    gp.m.mallocing--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debug.scavtrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">        printScavTrace(<span class="number">0</span>, released, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关内存如heapArena、chunk元素重新按huge_page的大小对齐（linux才有，不一定成功）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> enableMetadataHugePages() &#123;</span><br><span class="line">    <span class="comment">// chunk元素按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line">    h.pages.enableChunkHugePages()</span><br><span class="line"></span><br><span class="line">    lock(&amp;h.lock)</span><br><span class="line">    <span class="comment">// 已设置</span></span><br><span class="line">    <span class="keyword">if</span> h.arenasHugePages &#123;</span><br><span class="line">        unlock(&amp;h.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置</span></span><br><span class="line">    h.arenasHugePages = <span class="literal">true</span></span><br><span class="line">    unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历arenas</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> h.arenas &#123;</span><br><span class="line">        <span class="comment">// l2数组，4MB个数据</span></span><br><span class="line">        l2 := (*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena)(atomic.Loadp(unsafe.Pointer(&amp;h.arenas[i])))</span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line">        sysHugePage(unsafe.Pointer(l2), unsafe.Sizeof(*l2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mcentral-1"><a href="#mcentral-1" class="headerlink" title="mcentral"></a>mcentral</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mcentral初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> init(spc spanClass) &#123;</span><br><span class="line">    <span class="comment">// 纪录spanclass</span></span><br><span class="line">    c.spanclass = spc</span><br><span class="line">    <span class="comment">// 锁初始化</span></span><br><span class="line">    lockInit(&amp;c.partial[<span class="number">0</span>].spineLock, lockRankSpanSetSpine)</span><br><span class="line">    lockInit(&amp;c.partial[<span class="number">1</span>].spineLock, lockRankSpanSetSpine)</span><br><span class="line">    lockInit(&amp;c.full[<span class="number">0</span>].spineLock, lockRankSpanSetSpine)</span><br><span class="line">    lockInit(&amp;c.full[<span class="number">1</span>].spineLock, lockRankSpanSetSpine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从mcentral获取一个mspan，没有则从mheap获取，更新mspan状态并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> cacheSpan() *mspan &#123;</span><br><span class="line">    <span class="comment">// 计算mspan大小（字节）= 页数 * 8KB</span></span><br><span class="line">    spanBytes := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配内存时，如果sweeper还在清扫中且分配速度比清扫速度快，则协助sweeper清扫</span></span><br><span class="line">    deductSweepCredit(spanBytes, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环总预算</span></span><br><span class="line">    spanBudget := <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">    <span class="keyword">var</span> sl sweepLocker</span><br><span class="line"></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// =partial[sweepgen/2%2]</span></span><br><span class="line">    <span class="comment">// 尝试从已清扫有空对象的spanSet里获取一个mspan =&gt; partial[sweepgen/2%2]</span></span><br><span class="line">    <span class="keyword">if</span> s = c.partialSwept(sg).pop(); s != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 找到了</span></span><br><span class="line">        <span class="keyword">goto</span> havespan</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器加1，返回mheap_.sweepgen及sweepDrainedMask标记是否已设置</span></span><br><span class="line">    sl = sweep.active.begin()</span><br><span class="line">    <span class="comment">// sweeper数量不为0 =&gt; 还在清扫阶段</span></span><br><span class="line">    <span class="keyword">if</span> sl.valid &#123;</span><br><span class="line">        <span class="comment">// 100次</span></span><br><span class="line">        <span class="keyword">for</span> ; spanBudget &gt;= <span class="number">0</span>; spanBudget-- &#123;</span><br><span class="line">            <span class="comment">// =partial[1-sweepgen/2%2]</span></span><br><span class="line">            <span class="comment">// 尝试从未清扫有空对象的spanSet里获取一个mspan</span></span><br><span class="line">            s = c.partialUnswept(sg).pop()</span><br><span class="line">            <span class="comment">// partial为空</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// partial不为空</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试获得mspan的所有权</span></span><br><span class="line">            <span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">                <span class="comment">// 清扫一个mspan（保留）</span></span><br><span class="line">                s.sweep(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 计数器减1</span></span><br><span class="line">                sweep.active.end(sl)</span><br><span class="line">                <span class="comment">// 找到了</span></span><br><span class="line">                <span class="keyword">goto</span> havespan</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取mspan所有权失败，被其他工作线程清扫中，尝试别的mspan</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从partial获取mspan失败</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 100次</span></span><br><span class="line">        <span class="keyword">for</span> ; spanBudget &gt;= <span class="number">0</span>; spanBudget-- &#123;</span><br><span class="line">            <span class="comment">// 尝试从未清扫无空对象的spanSet里获取一个mspan</span></span><br><span class="line">            s = c.fullUnswept(sg).pop()</span><br><span class="line">            <span class="comment">// full为空</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试获得mspan的所有权</span></span><br><span class="line">            <span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">                <span class="comment">// 清扫一个mspan（保留）</span></span><br><span class="line">                s.sweep(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 获取freeindex</span></span><br><span class="line">                freeIndex := s.nextFreeIndex()</span><br><span class="line">                <span class="comment">// 有空余空间</span></span><br><span class="line">                <span class="keyword">if</span> freeIndex != s.nelems &#123;</span><br><span class="line">                    <span class="comment">// 更新freeindex</span></span><br><span class="line">                    s.freeindex = freeIndex</span><br><span class="line">                    <span class="comment">// 计数器减1</span></span><br><span class="line">                    sweep.active.end(sl)</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">goto</span> havespan</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 清扫后，mspan放到full[sweepgen/2%2]</span></span><br><span class="line">                c.fullSwept(sg).push(s.mspan)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从full获取mspan失败</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器减1</span></span><br><span class="line">        sweep.active.end(sl)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有从partial、full找到一个mspan</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (c *mcentral) grow() *mspan</span></span><br><span class="line">    <span class="comment">// 从mheap分配内存创建一个mspan（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">    s = c.grow()</span><br><span class="line">    <span class="comment">// 分配失败</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，mspan准备就绪</span></span><br><span class="line"></span><br><span class="line">havespan:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算剩余空间</span></span><br><span class="line">    n := <span class="type">int</span>(s.nelems) - <span class="type">int</span>(s.allocCount)</span><br><span class="line">    <span class="comment">// mspan没有剩余空间</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || s.freeindex == s.nelems || s.allocCount == s.nelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;span has no free objects&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按64倍数对齐</span></span><br><span class="line">    freeByteBase := s.freeindex &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 计算bitmap字节数</span></span><br><span class="line">    whichByte := freeByteBase / <span class="number">8</span></span><br><span class="line">    <span class="comment">// 从s.allocBits分配8个字节替换为新的s.allocCache</span></span><br><span class="line">    s.refillAllocCache(whichByte)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据freeindex调整，丢弃已用位</span></span><br><span class="line">    s.allocCache &gt;&gt;= s.freeindex % <span class="number">64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mspan已过期则清扫，未过期则根据是否mspan释放有剩余放到partial或full链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> uncacheSpan(s *mspan) &#123;</span><br><span class="line">    <span class="comment">// 异常，已分配对象数为0</span></span><br><span class="line">    <span class="keyword">if</span> s.allocCount == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;uncaching span but s.allocCount == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// 已过期 =&gt; mspan.sweepgen &lt; mheap_.sweepgen</span></span><br><span class="line">    stale := s.sweepgen == sg+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> stale &#123;</span><br><span class="line">        <span class="comment">// 已过期</span></span><br><span class="line">        <span class="comment">// 从 sg+1 改为 sg-1</span></span><br><span class="line">        atomic.Store(&amp;s.sweepgen, sg<span class="number">-1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未过期</span></span><br><span class="line">        <span class="comment">// 改为sg</span></span><br><span class="line">        atomic.Store(&amp;s.sweepgen, sg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已过期</span></span><br><span class="line">    <span class="keyword">if</span> stale &#123;</span><br><span class="line">        <span class="comment">// 封装mspan，获得所有权</span></span><br><span class="line">        ss := sweepLocked&#123;s&#125;</span><br><span class="line">        <span class="comment">// 清扫一个mspan（不保留，被heap回收）</span></span><br><span class="line">        ss.sweep(<span class="literal">false</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未过期</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mspan还有剩余</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">int</span>(s.nelems)-<span class="type">int</span>(s.allocCount) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 把mspan放入已清扫有空对象的spanSet =&gt; partial[sweepgen/2%2]</span></span><br><span class="line">            c.partialSwept(sg).push(s)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// mspan无剩余</span></span><br><span class="line">            <span class="comment">// full[sweepgen/2%2]</span></span><br><span class="line">            c.fullSwept(sg).push(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从mheap分配内存创建一个mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> grow() *mspan &#123;</span><br><span class="line">    <span class="comment">// 根据spanclass获取该mspan指定的页数</span></span><br><span class="line">    npages := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">    <span class="comment">// 根据spanclass获取该mspan的对象大小</span></span><br><span class="line">    size := <span class="type">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先清扫并释放至少n个页，然后获取mspan、分配n个页面、更新元信息</span></span><br><span class="line">    s := mheap_.alloc(npages, c.spanclass)</span><br><span class="line">    <span class="comment">// 分配失败</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算对象总数 = npages*8KB/size = (npages &lt;&lt; _PageShift) / size</span></span><br><span class="line">    n := s.divideByElemSize(npages &lt;&lt; _PageShift)</span><br><span class="line">    <span class="comment">// 终止地址</span></span><br><span class="line">    s.limit = s.base() + size*n</span><br><span class="line">    <span class="comment">// 初始化bitmap区域</span></span><br><span class="line">    s.initHeapBits()</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mcache-1"><a href="#mcache-1" class="headerlink" title="mcache"></a>mcache</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建mcache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocmcache</span><span class="params">()</span></span> *mcache &#123;</span><br><span class="line">    <span class="keyword">var</span> c *mcache</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// mheap加锁</span></span><br><span class="line">        lock(&amp;mheap_.lock)</span><br><span class="line">        <span class="comment">// 从cachealloc申请160字节作为mcache（内存不够用一次性申请16KB）</span></span><br><span class="line">        c = (*mcache)(mheap_.cachealloc.alloc())</span><br><span class="line">        <span class="comment">// sweepgen快照</span></span><br><span class="line">        c.flushGen.Store(mheap_.sweepgen)</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历136个mspan</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c.alloc &#123;</span><br><span class="line">        <span class="comment">// 全部指向emptymspan全局变量</span></span><br><span class="line">        c.alloc[i] = &amp;emptymspan</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存分配采样比例（memprof用）</span></span><br><span class="line">    <span class="comment">// 返回堆分析的下一个采样点（随机数：[0,MemProfileRate)）</span></span><br><span class="line">    c.nextSample = nextSample()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mcache重置放回free链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freemcache</span><span class="params">(c *mcache)</span></span> &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// tiny、alloc重置并释放mspan，更新内存统计信息</span></span><br><span class="line">        c.releaseAll()</span><br><span class="line">        <span class="comment">// 清空stackcache</span></span><br><span class="line">        stackcache_clear(c)</span><br><span class="line"></span><br><span class="line">        lock(&amp;mheap_.lock)</span><br><span class="line">        <span class="comment">// 放回free链表</span></span><br><span class="line">        mheap_.cachealloc.free(unsafe.Pointer(c))</span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tiny、alloc重置并释放mspan，更新内存统计信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> releaseAll() &#123;</span><br><span class="line">    <span class="comment">// 快照，需要被GC扫描的字节数</span></span><br><span class="line">    scanAlloc := <span class="type">int64</span>(c.scanAlloc)</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    c.scanAlloc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// 累计存活字节数</span></span><br><span class="line">    dHeapLive := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 所有mpsan清空</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c.alloc &#123;</span><br><span class="line">        <span class="comment">// mspan</span></span><br><span class="line">        s := c.alloc[i]</span><br><span class="line">        <span class="comment">// 不为空</span></span><br><span class="line">        <span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">            <span class="comment">// 已分配对象数</span></span><br><span class="line">            slotsUsed := <span class="type">int64</span>(s.allocCount) - <span class="type">int64</span>(s.allocCountBeforeCache)</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            s.allocCountBeforeCache = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">            <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">            stats := memstats.heapStats.acquire()</span><br><span class="line">            <span class="comment">// 累计到全局计数器</span></span><br><span class="line">            atomic.Xadd64(&amp;stats.smallAllocCount[spanClass(i).sizeclass()], slotsUsed)</span><br><span class="line">            <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">            memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 累计已分配字节数</span></span><br><span class="line">            gcController.totalAlloc.Add(slotsUsed * <span class="type">int64</span>(s.elemsize))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未过期</span></span><br><span class="line">            <span class="keyword">if</span> s.sweepgen != sg+<span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// -=剩余可用字节数</span></span><br><span class="line">                dHeapLive -= <span class="type">int64</span>(s.nelems-s.allocCount) * <span class="type">int64</span>(s.elemsize)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// mspan已过期则清扫，未过期则根据是否mspan释放有剩余放到partial或full链表</span></span><br><span class="line">            mheap_.central[i].mcentral.uncacheSpan(s)</span><br><span class="line">            <span class="comment">// 设置为空的mspan</span></span><br><span class="line">            c.alloc[i] = &amp;emptymspan</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tiny区域清扫</span></span><br><span class="line">    c.tiny = <span class="number">0</span></span><br><span class="line">    c.tinyoffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    <span class="comment">// 累计到全局tiny计数器</span></span><br><span class="line">    atomic.Xadd64(&amp;stats.tinyAllocCount, <span class="type">int64</span>(c.tinyAllocs))</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    c.tinyAllocs = <span class="number">0</span></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    gcController.update(dHeapLive, scanAlloc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协助sweeper清扫，从mheap分配内存、更新索引/gc等信息，mspan放到fullSwept</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> allocLarge(size <span class="type">uintptr</span>, noscan <span class="type">bool</span>) *mspan &#123;</span><br><span class="line">    <span class="comment">// 溢出</span></span><br><span class="line">    <span class="keyword">if</span> size+_PageSize &lt; size &#123;</span><br><span class="line">        throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页数（右移13位，即除于8KB）</span></span><br><span class="line">    npages := size &gt;&gt; _PageShift</span><br><span class="line">    <span class="comment">// 除后还有余量，n+=1</span></span><br><span class="line">    <span class="keyword">if</span> size&amp;_PageMask != <span class="number">0</span> &#123;</span><br><span class="line">        npages++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存时，如果sweeper还在清扫中且分配速度比清扫速度快，则协助sweeper清扫</span></span><br><span class="line">    deductSweepCredit(npages*_PageSize, npages)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合sizeclass和noscan成spanclass</span></span><br><span class="line">    spc := makeSpanClass(<span class="number">0</span>, noscan)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (h *mheap) alloc(npages uintptr, spanclass spanClass) *mspan</span></span><br><span class="line">    <span class="comment">// 先清扫并释放至少n个页，然后获取mspan、分配n个页面、更新元信息</span></span><br><span class="line">    s := mheap_.alloc(npages, spc)</span><br><span class="line">    <span class="comment">// 分配失败</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    <span class="comment">// 累计分配字节数</span></span><br><span class="line">    atomic.Xadd64(&amp;stats.largeAlloc, <span class="type">int64</span>(npages*pageSize))</span><br><span class="line">    <span class="comment">// 累计分配对象数</span></span><br><span class="line">    atomic.Xadd64(&amp;stats.largeAllocCount, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计已分配字节数</span></span><br><span class="line">    gcController.totalAlloc.Add(<span class="type">int64</span>(npages * pageSize))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    gcController.update(<span class="type">int64</span>(s.npages*pageSize), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把mspan放到full[sweepgen/2%2]</span></span><br><span class="line">    mheap_.central[spc].mcentral.fullSwept(mheap_.sweepgen).push(s)</span><br><span class="line">    <span class="comment">// 终止地址</span></span><br><span class="line">    s.limit = s.base() + size</span><br><span class="line">    <span class="comment">// 初始化bitmap区域（实际上为大对象时不需要执行）</span></span><br><span class="line">    s.initHeapBits()</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过64位的allocCache快速判断并分配对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span></span> gclinkptr &#123;</span><br><span class="line">    <span class="comment">// 64位二进制数的尾部的0的个数</span></span><br><span class="line">    theBit := sys.TrailingZeros64(s.allocCache)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocCache&gt;0（初始化时64位全为1）</span></span><br><span class="line">    <span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">        <span class="comment">// 下一个可用对象索引（二进制中为0的位置需要跳过）</span></span><br><span class="line">        result := s.freeindex + <span class="type">uint16</span>(theBit)</span><br><span class="line">        <span class="comment">// mspan空间没有用完</span></span><br><span class="line">        <span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">            <span class="comment">// 更新freeidx，指向下一个可分配对象</span></span><br><span class="line">            freeidx := result + <span class="number">1</span></span><br><span class="line">            <span class="comment">// 64个对象已经分配完（实际上是63个，这里的判断会跳过最后1个可用对象）</span></span><br><span class="line">            <span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 丢弃低x+1位（因为这几位已经被分配了）</span></span><br><span class="line">            s.allocCache &gt;&gt;= <span class="type">uint</span>(theBit + <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 更新freeidx</span></span><br><span class="line">            s.freeindex = freeidx</span><br><span class="line">            <span class="comment">// 计数器allocCount+=1</span></span><br><span class="line">            s.allocCount++</span><br><span class="line">            <span class="comment">// 返回对象的地址</span></span><br><span class="line">            <span class="keyword">return</span> gclinkptr(<span class="type">uintptr</span>(result)*s.elemsize + s.base())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allocCache=0，没有可分配对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mspan获取一个可用对象，如果mspan已满，则从mcentral获取新的mspan替换原mspan后重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> nextFree(spc spanClass) (v gclinkptr, s *mspan, checkGCTrigger <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据spanclass从mcache获取mspan</span></span><br><span class="line">    s = c.alloc[spc]</span><br><span class="line">    <span class="comment">// 是否需要触发GC清扫（分配了新的mspan）</span></span><br><span class="line">    checkGCTrigger = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 获取可用对象索引，如果allocCache用完则重新填充再计算索引（可能多次）</span></span><br><span class="line">    freeIndex := s.nextFreeIndex()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan已满</span></span><br><span class="line">    <span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> s.allocCount != s.nelems &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: s.allocCount=&quot;</span>, s.allocCount, <span class="string">&quot;s.nelems=&quot;</span>, s.nelems)</span><br><span class="line">            throw(<span class="string">&quot;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从mcentral分配新的mspan替换原mspan</span></span><br><span class="line">        c.refill(spc)</span><br><span class="line">        <span class="comment">// 需要触发GC清扫</span></span><br><span class="line">        checkGCTrigger = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 重新读一遍</span></span><br><span class="line">        s = c.alloc[spc]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取可用对象索引，如果allocCache用完则重新填充再计算索引（可能多次）</span></span><br><span class="line">        freeIndex = s.nextFreeIndex()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> freeIndex &gt;= s.nelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;freeIndex is not valid&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象地址</span></span><br><span class="line">    v = gclinkptr(<span class="type">uintptr</span>(freeIndex)*s.elemsize + s.base())</span><br><span class="line">    <span class="comment">// 计数器allocCount+=1</span></span><br><span class="line">    s.allocCount++</span><br><span class="line">    <span class="comment">// 异常，超过总量</span></span><br><span class="line">    <span class="keyword">if</span> s.allocCount &gt; s.nelems &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;s.allocCount=&quot;</span>, s.allocCount, <span class="string">&quot;s.nelems=&quot;</span>, s.nelems)</span><br><span class="line">        throw(<span class="string">&quot;s.allocCount &gt; s.nelems&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从mcentral分配新的mspan替换原mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> refill(spc spanClass) &#123;</span><br><span class="line">    <span class="comment">// 根据spanclass从mcache获取mspan</span></span><br><span class="line">    s := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常，还有可用对象</span></span><br><span class="line">    <span class="keyword">if</span> s.allocCount != s.nelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;refill of span with free space remaining&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">        <span class="comment">// 期望状态：已清扫并被mcache使用</span></span><br><span class="line">        <span class="keyword">if</span> s.sweepgen != mheap_.sweepgen+<span class="number">3</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad sweepgen in refill&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原mspan已过期则清扫，未过期则根据是否mspan释放有剩余放到partial或full链表</span></span><br><span class="line">        mheap_.central[spc].mcentral.uncacheSpan(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新heapStats</span></span><br><span class="line">        <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">        <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">        stats := memstats.heapStats.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已分配对象数</span></span><br><span class="line">        slotsUsed := <span class="type">int64</span>(s.allocCount) - <span class="type">int64</span>(s.allocCountBeforeCache)</span><br><span class="line">        <span class="comment">// 累计到小对象分配数</span></span><br><span class="line">        atomic.Xadd64(&amp;stats.smallAllocCount[spc.sizeclass()], slotsUsed)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是tiny分配</span></span><br><span class="line">        <span class="keyword">if</span> spc == tinySpanClass &#123;</span><br><span class="line">            <span class="comment">// 累计到微小对象数</span></span><br><span class="line">            atomic.Xadd64(&amp;stats.tinyAllocCount, <span class="type">int64</span>(c.tinyAllocs))</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            c.tinyAllocs = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">        memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已分配字节数</span></span><br><span class="line">        bytesAllocated := slotsUsed * <span class="type">int64</span>(s.elemsize)</span><br><span class="line">        <span class="comment">// 累计已分配字节数</span></span><br><span class="line">        gcController.totalAlloc.Add(bytesAllocated)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        s.allocCountBeforeCache = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新mspan</span></span><br><span class="line">    <span class="comment">// 从mcentral获取一个mspan</span></span><br><span class="line">    s = mheap_.central[spc].mcentral.cacheSpan()</span><br><span class="line">    <span class="comment">// 分配失败</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常，mspan空间用光了</span></span><br><span class="line">    <span class="keyword">if</span> s.allocCount == s.nelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;span has no free space&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已清扫并被mcache使用</span></span><br><span class="line">    s.sweepgen = mheap_.sweepgen + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到mcache前，纪录allocCount快照</span></span><br><span class="line">    s.allocCountBeforeCache = s.allocCount</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新heapLive</span></span><br><span class="line">    <span class="comment">// mspan已使用字节数</span></span><br><span class="line">    usedBytes := <span class="type">uintptr</span>(s.allocCount) * s.elemsize</span><br><span class="line">    <span class="comment">// mspan剩余可用字节纪录到heapLive，</span></span><br><span class="line">    gcController.update(<span class="type">int64</span>(s.npages*pageSize)-<span class="type">int64</span>(usedBytes), <span class="type">int64</span>(c.scanAlloc))</span><br><span class="line">    <span class="comment">// 清空scanAlloc</span></span><br><span class="line">    c.scanAlloc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    c.alloc[spc] = s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mspan-1"><a href="#mspan-1" class="headerlink" title="mspan"></a>mspan</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取可用对象索引，如果allocCache用完则重新填充再计算索引（可能多次）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span></span> nextFreeIndex() <span class="type">uint16</span> &#123;</span><br><span class="line">    <span class="comment">// 可用对象索引</span></span><br><span class="line">    sfreeindex := s.freeindex</span><br><span class="line">    <span class="comment">// mspan可存储对象数量</span></span><br><span class="line">    snelems := s.nelems</span><br><span class="line">    <span class="comment">// mspan已满</span></span><br><span class="line">    <span class="keyword">if</span> sfreeindex == snelems &#123;</span><br><span class="line">        <span class="keyword">return</span> sfreeindex</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">if</span> sfreeindex &gt; snelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;s.freeindex &gt; s.nelems&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64位bitmap</span></span><br><span class="line">    aCache := s.allocCache</span><br><span class="line">    <span class="comment">// allocCache尾部的0的个数（这个时候可能还剩余1个可分配对象）</span></span><br><span class="line">    bitIndex := sys.TrailingZeros64(aCache)</span><br><span class="line">    <span class="comment">// allocCache为0，全部已分配完</span></span><br><span class="line">    <span class="keyword">for</span> bitIndex == <span class="number">64</span> &#123;</span><br><span class="line">        <span class="comment">// 按64的倍数向上取整</span></span><br><span class="line">        sfreeindex = (sfreeindex + <span class="number">64</span>) &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// mspan已满</span></span><br><span class="line">        <span class="keyword">if</span> sfreeindex &gt;= snelems &#123;</span><br><span class="line">            s.freeindex = snelems</span><br><span class="line">            <span class="keyword">return</span> snelems</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mspan未满</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 字节数</span></span><br><span class="line">        whichByte := sfreeindex / <span class="number">8</span></span><br><span class="line">        <span class="comment">// 从s.allocBits分配8个字节替换为新的s.allocCache</span></span><br><span class="line">        s.refillAllocCache(whichByte)</span><br><span class="line">        <span class="comment">// 重新读一遍新的allocCache</span></span><br><span class="line">        aCache = s.allocCache</span><br><span class="line">        <span class="comment">// 顺利的话，这里的bitIndex应该为0</span></span><br><span class="line">        bitIndex = sys.TrailingZeros64(aCache)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还是用完了，继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可用对象的索引（二进制中为0的位置需要跳过）</span></span><br><span class="line">    result := sfreeindex + <span class="type">uint16</span>(bitIndex)</span><br><span class="line">    <span class="comment">// mspan已满</span></span><br><span class="line">    <span class="keyword">if</span> result &gt;= snelems &#123;</span><br><span class="line">        s.freeindex = snelems</span><br><span class="line">        <span class="keyword">return</span> snelems</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan未满</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 丢弃低x+1位（因为这几位已经被分配了）</span></span><br><span class="line">    s.allocCache &gt;&gt;= <span class="type">uint</span>(bitIndex + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 更新freeidx，指向下一个可分配对象</span></span><br><span class="line">    sfreeindex = result + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64个对象已经分配完（实际上是63个，这里的判断会跳过最后1个可用对象）</span></span><br><span class="line">    <span class="keyword">if</span> sfreeindex%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; sfreeindex != snelems &#123;</span><br><span class="line">        <span class="comment">// 字节数</span></span><br><span class="line">        whichByte := sfreeindex / <span class="number">8</span></span><br><span class="line">        <span class="comment">// 从s.allocBits分配8个字节替换为新的s.allocCache</span></span><br><span class="line">        s.refillAllocCache(whichByte)</span><br><span class="line">    &#125;</span><br><span class="line">    s.freeindex = sfreeindex</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回封装bitmap区域的slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> heapBits() []<span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 只有一个页</span></span><br><span class="line">    <span class="keyword">if</span> span.npages == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heapBitsSlice(span.base(), pageSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多个页</span></span><br><span class="line">    <span class="keyword">return</span> heapBitsSlice(span.base(), span.npages*pageSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装bitmap区域成slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapBitsSlice</span><span class="params">(spanBase, spanSize <span class="type">uintptr</span>)</span></span> []<span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// bitmap需要的字节数</span></span><br><span class="line">    bitmapSize := spanSize / goarch.PtrSize / <span class="number">8</span></span><br><span class="line">    <span class="comment">// 有多少个int</span></span><br><span class="line">    elems := <span class="type">int</span>(bitmapSize / goarch.PtrSize)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sl notInHeapSlice</span><br><span class="line">    <span class="comment">// 纪录bitmap区域的起始地址、所需int数</span></span><br><span class="line">    sl = notInHeapSlice&#123;(*notInHeap)(unsafe.Pointer(spanBase + spanSize - bitmapSize)), elems, elems&#125;</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="type">uintptr</span>)(unsafe.Pointer(&amp;sl))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化bitmap区域</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span></span> initHeapBits() &#123;</span><br><span class="line">    <span class="comment">// scan and sizeclass==1</span></span><br><span class="line">    <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &amp;&amp; !s.spanclass.noscan() &amp;&amp; s.spanclass.sizeclass() == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 返回封装bitmap区域的slice</span></span><br><span class="line">        b := s.heapBits()</span><br><span class="line">        <span class="comment">// 全部位设为1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">            b[i] = ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!s.spanclass.noscan() &amp;&amp; heapBitsInSpan(s.elemsize)) || s.isUserArenaChunk &#123;</span><br><span class="line">        <span class="comment">// (scan &amp;&amp; size&lt;=512B) or 手动管理内存</span></span><br><span class="line">        <span class="comment">// 返回封装bitmap区域的slice</span></span><br><span class="line">        b := s.heapBits()</span><br><span class="line">        <span class="comment">// 清0</span></span><br><span class="line">        clear(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap纪录指针位置，返回需要扫描的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSetTypeNoHeader</span><span class="params">(x, dataSize <span class="type">uintptr</span>, typ *_type, span *mspan)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// bitmap纪录指针位置，返回需要扫描的字节数</span></span><br><span class="line">    scanSize := span.writeHeapBitsSmall(x, dataSize, typ)</span><br><span class="line">    <span class="keyword">return</span> scanSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap纪录指针位置，返回需要扫描的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> writeHeapBitsSmall(x, dataSize <span class="type">uintptr</span>, typ *_type) (scanSize <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// type Example struct &#123;</span></span><br><span class="line">    <span class="comment">//     a *int8   // 8B (指针)</span></span><br><span class="line">    <span class="comment">//     b int16   // 2B (非指针，编译器会对齐b为8字节)</span></span><br><span class="line">    <span class="comment">//     c *int32  // 8B (指针)</span></span><br><span class="line">    <span class="comment">//     d float64 // 8B (非指针)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据类型的GCMask，如上为0b0101</span></span><br><span class="line">    src0 := readUintptr(getGCMask(typ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要扫描的总字节数，一般只会比Size_小一点</span></span><br><span class="line">    <span class="comment">// 从第一个字段开始到最后一个指针类型字段，如上为24字节</span></span><br><span class="line">    scanSize = typ.PtrBytes</span><br><span class="line"></span><br><span class="line">    src := src0</span><br><span class="line">    <span class="keyword">if</span> typ.Size_ == goarch.PtrSize &#123;</span><br><span class="line">        <span class="comment">// 8字节大小，单个指针</span></span><br><span class="line">        <span class="comment">// 掩码：(1&lt;&lt;x)-1 =&gt; 低位全为1</span></span><br><span class="line">        src = (<span class="number">1</span> &lt;&lt; (dataSize / goarch.PtrSize)) - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非8字节大小</span></span><br><span class="line">        <span class="comment">// 遍历所有对象</span></span><br><span class="line">        <span class="keyword">for</span> i := typ.Size_; i &lt; dataSize; i += typ.Size_ &#123;</span><br><span class="line">            <span class="comment">// 掩码累加（如上，2个Example，结果为 0b01010101)</span></span><br><span class="line">            src |= src0 &lt;&lt; (i / goarch.PtrSize)</span><br><span class="line">            <span class="comment">// 扩展指针扫描范围（如上，2个Example，结果为24+32=56）</span></span><br><span class="line">            scanSize += typ.Size_</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bitmap内存区域起始地址 =&gt; base+8192-128</span></span><br><span class="line">    dst := unsafe.Pointer(span.base() + pageSize - pageSize/goarch.PtrSize/<span class="number">8</span>)</span><br><span class="line">    <span class="comment">// 指针位置 =&gt; sizeclass范围是[0,32]，闭区间，分配的页数为1</span></span><br><span class="line">    o := (x - span.base()) / goarch.PtrSize</span><br><span class="line">    <span class="comment">// 第几个uint64</span></span><br><span class="line">    i := o / ptrBits</span><br><span class="line">    <span class="comment">// 具体bit位置</span></span><br><span class="line">    j := o % ptrBits</span><br><span class="line">    <span class="comment">// 指针数量</span></span><br><span class="line">    bits := span.elemsize / goarch.PtrSize</span><br><span class="line">    <span class="comment">// 超过64位，分成两个uint64处理</span></span><br><span class="line">    <span class="keyword">if</span> j+bits &gt; ptrBits &#123;</span><br><span class="line">        <span class="comment">// 第1个uint64要设置的位数量</span></span><br><span class="line">        bits0 := ptrBits - j</span><br><span class="line">        <span class="comment">// 第2个uint64要设置的位数量</span></span><br><span class="line">        bits1 := bits - bits0</span><br><span class="line">        dst0 := (*<span class="type">uintptr</span>)(add(dst, (i+<span class="number">0</span>)*goarch.PtrSize))</span><br><span class="line">        dst1 := (*<span class="type">uintptr</span>)(add(dst, (i+<span class="number">1</span>)*goarch.PtrSize))</span><br><span class="line">        <span class="comment">// src地bits0位纪录到dst0</span></span><br><span class="line">        *dst0 = (*dst0)&amp;(^<span class="type">uintptr</span>(<span class="number">0</span>)&gt;&gt;bits0) | (src &lt;&lt; j)</span><br><span class="line">        <span class="comment">// src高bits1位纪录到dst1</span></span><br><span class="line">        *dst1 = (*dst1)&amp;^((<span class="number">1</span>&lt;&lt;bits1)<span class="number">-1</span>) | (src &gt;&gt; bits0)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不超过64位，只写一个uint64</span></span><br><span class="line">        dst := (*<span class="type">uintptr</span>)(add(dst, i*goarch.PtrSize))</span><br><span class="line">        <span class="comment">// src纪录到dst</span></span><br><span class="line">        *dst = (*dst)&amp;^(((<span class="number">1</span>&lt;&lt;bits)<span class="number">-1</span>)&lt;&lt;j) | (src &lt;&lt; j)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pageCache"><a href="#pageCache" class="headerlink" title="pageCache"></a>pageCache</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从pcache找到连续n个页的起始地址，并判断这几个页是否被清理过（重用）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pageCache)</span></span> alloc(npages <span class="type">uintptr</span>) (<span class="type">uintptr</span>, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// bitmap为0，64个页全部用完</span></span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 64个页未用完</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配1个页</span></span><br><span class="line">    <span class="keyword">if</span> npages == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// cache尾部0个数，定位可用页的位置</span></span><br><span class="line">        i := <span class="type">uintptr</span>(sys.TrailingZeros64(c.cache))</span><br><span class="line">        <span class="comment">// 丢弃低i位后取最低位</span></span><br><span class="line">        scav := (c.scav &gt;&gt; i) &amp; <span class="number">1</span></span><br><span class="line">        <span class="comment">// 低i位清0，标记该页已使用</span></span><br><span class="line">        c.cache &amp;^= <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        <span class="comment">// 低i位清0，标记该页未清理</span></span><br><span class="line">        c.scav &amp;^= <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        <span class="comment">// 起始地址，被清理的页数</span></span><br><span class="line">        <span class="keyword">return</span> c.base + i*pageSize, <span class="type">uintptr</span>(scav) * pageSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找出连续n个1的起始位置（64个位），找不到返回64</span></span><br><span class="line">    <span class="keyword">return</span> c.allocN(npages)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出连续n个1的起始位置（64个位），找不到返回64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pageCache)</span></span> allocN(npages <span class="type">uintptr</span>) (<span class="type">uintptr</span>, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 找出连续n个1的起始位置（64个位），找不到返回64</span></span><br><span class="line">    i := findBitRange64(c.cache, <span class="type">uint</span>(npages))</span><br><span class="line">    <span class="comment">// 64代表没找到</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 低n个1向左移动i位</span></span><br><span class="line">    mask := ((<span class="type">uint64</span>(<span class="number">1</span>) &lt;&lt; npages) - <span class="number">1</span>) &lt;&lt; i</span><br><span class="line">    <span class="comment">// 计算1的数量</span></span><br><span class="line">    scav := sys.OnesCount64(c.scav &amp; mask)</span><br><span class="line">    <span class="comment">// 这连续n个位清0，标记已使用</span></span><br><span class="line">    c.cache &amp;^= mask</span><br><span class="line">    <span class="comment">// 这连续n个位清0，重置</span></span><br><span class="line">    c.scav &amp;^= mask</span><br><span class="line">    <span class="comment">// 起始地址，被清理的页数</span></span><br><span class="line">    <span class="keyword">return</span> c.base + <span class="type">uintptr</span>(i*pageSize), <span class="type">uintptr</span>(scav) * pageSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空pageCache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pageCache)</span></span> flush(p *pageAlloc) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为空不处理</span></span><br><span class="line">    <span class="keyword">if</span> c.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    ci := chunkIndex(c.base)</span><br><span class="line">    <span class="comment">// offset</span></span><br><span class="line">    pi := chunkPageIndex(c.base)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历bitmap，比对64个页</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint</span>(<span class="number">0</span>); i &lt; <span class="number">64</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 被使用</span></span><br><span class="line">        <span class="keyword">if</span> c.cache&amp;(<span class="number">1</span>&lt;&lt;i) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 该位置为0</span></span><br><span class="line">            p.chunkOf(ci).free1(pi + i)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">            p.scav.index.free(ci, pi+i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被标记为已清理</span></span><br><span class="line">        <span class="keyword">if</span> c.scav&amp;(<span class="number">1</span>&lt;&lt;i) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// pallocData.scavenged更新，指定位置为1</span></span><br><span class="line">            p.chunkOf(ci).scavenged.setRange(pi+i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果释放的页地址比searchAddr小</span></span><br><span class="line">    <span class="keyword">if</span> b := (offAddr&#123;c.base&#125;); b.lessThan(p.searchAddr) &#123;</span><br><span class="line">        p.searchAddr = b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">    p.update(c.base, pageCachePages, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">    *c = pageCache&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pageAlloc-1"><a href="#pageAlloc-1" class="headerlink" title="pageAlloc"></a>pageAlloc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> init(mheapLock *mutex, sysStat *sysMemStat, test <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个元素!=21</span></span><br><span class="line">    <span class="keyword">if</span> levelLogPages[<span class="number">0</span>] &gt; logMaxPackedValue &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: root level max pages = &quot;</span>, <span class="number">1</span>&lt;&lt;levelLogPages[<span class="number">0</span>], <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: summary max pages = &quot;</span>, maxPackedValue, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;root level max pages doesn&#x27;t fit in summary&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    p.sysStat = sysStat</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p.inUse初始化（ranges切片容量为256B）</span></span><br><span class="line">    p.inUse.init(sysStat)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从系统申请内存（Reserved）初始化p.summary数组（16KB~64MB）</span></span><br><span class="line">    p.sysInit(test)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大地址 = (2^48-1) + 0xffff800000000000</span></span><br><span class="line">    p.searchAddr = maxSearchAddr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mheap.lock</span></span><br><span class="line">    p.mheapLock = mheapLock</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scavenge.index初始化，但固定返回0</span></span><br><span class="line">    p.summaryMappedReady += p.scav.index.init(test, sysStat)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是测试调用</span></span><br><span class="line">    p.test = test</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pageAlloc通过summary扫描寻找足以容纳n个页的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> alloc(npages <span class="type">uintptr</span>) (addr <span class="type">uintptr</span>, scav <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索地址searchAddr越界</span></span><br><span class="line">    <span class="keyword">if</span> chunkIndex(p.searchAddr.addr()) &gt;= p.end &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =0xffff800000000000</span></span><br><span class="line">    searchAddr := minOffAddr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (512-(p.searchAddr%4194304/8192)) &gt;= n =&gt; 当前chunk的剩余量足够容纳n个页</span></span><br><span class="line">    <span class="keyword">if</span> pallocChunkPages-chunkPageIndex(p.searchAddr.addr()) &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从地址到索引，i = (p.searchAddr-0xffff800000000000)/4194304</span></span><br><span class="line">        i := chunkIndex(p.searchAddr.addr())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 第4层取第i个chunk的pallocSum的max段</span></span><br><span class="line">        <span class="comment">// 2. max &gt;= n =&gt; 当前chunk足够容纳n个页</span></span><br><span class="line">        <span class="keyword">if</span> max := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][i].max(); max &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">            <span class="comment">// func (b *pallocBits) find(npages uintptr, searchIdx uint) (uint, uint)</span></span><br><span class="line">            <span class="comment">// 在一个chunk中寻找可用的连续n个页的起始索引（最多512个页，从searchAddr开始搜索）</span></span><br><span class="line">            j, searchIdx := p.chunkOf(i).find(npages, chunkPageIndex(p.searchAddr.addr()))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 固定数值，表示寻找失败，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> j == ^<span class="type">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;runtime: max = &quot;</span>, max, <span class="string">&quot;, npages = &quot;</span>, npages, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;runtime: searchIdx = &quot;</span>, chunkPageIndex(p.searchAddr.addr()), <span class="string">&quot;, p.searchAddr = &quot;</span>, hex(p.searchAddr.addr()), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                throw(<span class="string">&quot;bad summary data&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连续n页内存的起始地址 = i*4194304+0xffff800000000000 + j*8192</span></span><br><span class="line">            addr = chunkBase(i) + <span class="type">uintptr</span>(j)*pageSize</span><br><span class="line">            <span class="comment">// chunk第一个可用页的位置 = i*4194304+0xffff800000000000 + searchIdx*8192</span></span><br><span class="line">            searchAddr = offAddr&#123;chunkBase(i) + <span class="type">uintptr</span>(searchIdx)*pageSize&#125;</span><br><span class="line">            <span class="keyword">goto</span> Found</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前组内存空间不足以容纳n个页（可能超过4MB）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (p *pageAlloc) find(npages uintptr) (uintptr, offAddr)</span></span><br><span class="line">    <span class="comment">// 从summary最顶层开始扫描，寻找足以容纳n个页的内存地址和不小于addr的最近可用地址</span></span><br><span class="line">    addr, searchAddr = p.find(npages)</span><br><span class="line">    <span class="comment">// 失败了</span></span><br><span class="line">    <span class="keyword">if</span> addr == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个页也失败了，可能达到了最大内存边界</span></span><br><span class="line">        <span class="keyword">if</span> npages == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 设置为最大内存边界 = (2^48-1) + 0xffff800000000000</span></span><br><span class="line">            p.searchAddr = maxSearchAddr()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Found:</span><br><span class="line">    <span class="comment">// 更新并重新统计chunks，最后更新summary（分配）</span></span><br><span class="line">    scav = p.allocRange(addr, npages)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最近可用地址比searchAddr大</span></span><br><span class="line">    <span class="keyword">if</span> p.searchAddr.lessThan(searchAddr) &#123;</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        p.searchAddr = searchAddr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr, scav</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新并重新统计chunks，最后更新summary（释放）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> free(base, npages <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果释放的页地址比searchAddr小</span></span><br><span class="line">    <span class="keyword">if</span> b := (offAddr&#123;base&#125;); b.lessThan(p.searchAddr) &#123;</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        p.searchAddr = b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个字节的地址</span></span><br><span class="line">    limit := base + npages*pageSize - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只释放一个页</span></span><br><span class="line">    <span class="keyword">if</span> npages == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// chunk索引</span></span><br><span class="line">        i := chunkIndex(base)</span><br><span class="line">        <span class="comment">// 位于512位bitmap的位置</span></span><br><span class="line">        pi := chunkPageIndex(base)</span><br><span class="line">        <span class="comment">// 该位置为0</span></span><br><span class="line">        p.chunkOf(i).free1(pi)</span><br><span class="line">        <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">        p.scav.index.free(i, pi, <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 释放多个页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 起始索引、终止索引</span></span><br><span class="line">        sc, ec := chunkIndex(base), chunkIndex(limit)</span><br><span class="line">        <span class="comment">// 位于512位bitmap的位置</span></span><br><span class="line">        si, ei := chunkPageIndex(base), chunkPageIndex(limit)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个chunk</span></span><br><span class="line">        <span class="keyword">if</span> sc == ec &#123;</span><br><span class="line">            <span class="comment">// 将这个范围的bitmap清0</span></span><br><span class="line">            p.chunkOf(sc).free(si, ei+<span class="number">1</span>-si)</span><br><span class="line">            <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">            p.scav.index.free(sc, si, ei+<span class="number">1</span>-si)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不同chunk</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个chunk</span></span><br><span class="line">            <span class="comment">// 将这个范围的bitmap清0</span></span><br><span class="line">            p.chunkOf(sc).free(si, pallocChunkPages-si)</span><br><span class="line">            <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">            p.scav.index.free(sc, si, pallocChunkPages-si)</span><br><span class="line">            <span class="comment">// 中间chunk</span></span><br><span class="line">            <span class="keyword">for</span> c := sc + <span class="number">1</span>; c &lt; ec; c++ &#123;</span><br><span class="line">                <span class="comment">// pallocBits清除所有位</span></span><br><span class="line">                p.chunkOf(c).freeAll()</span><br><span class="line">                <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">                p.scav.index.free(c, <span class="number">0</span>, pallocChunkPages)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后一个chunk</span></span><br><span class="line">            <span class="comment">// 将这个范围的bitmap清0</span></span><br><span class="line">            p.chunkOf(ec).free(<span class="number">0</span>, ei+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">            p.scav.index.free(ec, <span class="number">0</span>, ei+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">    p.update(base, npages, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配物理内存，更新并重新统计chunks信息，最后更新summary</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> grow(base, size <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base+size按4MB的倍数向上取整</span></span><br><span class="line">    limit := alignUp(base+size, pallocChunkBytes)</span><br><span class="line">    <span class="comment">// base按4MB的倍数向下取整</span></span><br><span class="line">    base = alignDown(base, pallocChunkBytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (p *pageAlloc) sysGrow(base, limit uintptr)</span></span><br><span class="line">    <span class="comment">// 在指定的虚拟地址范围内分配/映射物理内存，让该地址变为可用（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">    p.sysGrow(base, limit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (s *scavengeIndex) grow(base, limit uintptr, sysStat *sysMemStat) uintptr</span></span><br><span class="line">    <span class="comment">// 更新minHeapIdx，分配/映射物理内存使地址变为可用（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">    p.summaryMappedReady += p.scav.index.grow(base, limit, p.sysStat)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次走到这里</span></span><br><span class="line">    firstGrowth := p.start == <span class="number">0</span></span><br><span class="line">    <span class="comment">// 地址转索引</span></span><br><span class="line">    start, end := chunkIndex(base), chunkIndex(limit)</span><br><span class="line">    <span class="comment">// 如果是第一次走到这里，直接纪录，否则取最小值</span></span><br><span class="line">    <span class="comment">// p.start = min(p.start, start)</span></span><br><span class="line">    <span class="keyword">if</span> firstGrowth || start &lt; p.start &#123;</span><br><span class="line">        p.start = start</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// end会一直更新取最大值</span></span><br><span class="line">    <span class="keyword">if</span> end &gt; p.end &#123;</span><br><span class="line">        p.end = end</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base、limit索引纪录到inuse</span></span><br><span class="line">    p.inUse.add(makeAddrRange(base, limit))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果base比searchAddr小</span></span><br><span class="line">    <span class="keyword">if</span> b := (offAddr&#123;base&#125;); b.lessThan(p.searchAddr) &#123;</span><br><span class="line">        p.searchAddr = b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历这部份chunk</span></span><br><span class="line">    <span class="keyword">for</span> c := chunkIndex(base); c &lt; chunkIndex(limit); c++ &#123;</span><br><span class="line">        <span class="comment">// 如果chunk为nil，创建chunk</span></span><br><span class="line">        <span class="keyword">if</span> p.chunks[c.l1()] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 第二维有8192个指针</span></span><br><span class="line">            <span class="keyword">const</span> l2Size = unsafe.Sizeof(*p.chunks[<span class="number">0</span>])</span><br><span class="line">            <span class="comment">// 直接向系统申请8192*8B=64KB大小内存（Ready）</span></span><br><span class="line">            r := sysAlloc(l2Size, p.sysStat)</span><br><span class="line">            <span class="comment">// 申请失败</span></span><br><span class="line">            <span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;pageAlloc: out of memory&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非测试</span></span><br><span class="line">            <span class="keyword">if</span> !p.test &#123;</span><br><span class="line">                <span class="keyword">if</span> p.chunkHugePages &#123;</span><br><span class="line">                    <span class="comment">// 按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line">                    sysHugePage(r, l2Size)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不使用huge page</span></span><br><span class="line">                    sysNoHugePage(r, l2Size)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 纪录指针</span></span><br><span class="line">            *(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;p.chunks[c.l1()])) = <span class="type">uintptr</span>(r)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pallocData.scavenged更新，指定位置为1（0,512）</span></span><br><span class="line">        p.chunkOf(c).scavenged.setRange(<span class="number">0</span>, pallocChunkPages)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">    p.update(base, size/pageSize, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新并重新统计chunks，最后更新summary（分配）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> allocRange(base, npages <span class="type">uintptr</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个字节的地址</span></span><br><span class="line">    limit := base + npages*pageSize - <span class="number">1</span></span><br><span class="line">    <span class="comment">// chunk索引</span></span><br><span class="line">    sc, ec := chunkIndex(base), chunkIndex(limit)</span><br><span class="line">    <span class="comment">// 位于512位bitmap的位置</span></span><br><span class="line">    si, ei := chunkPageIndex(base), chunkPageIndex(limit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存重用后，scavenged还设置为1，需要统计这部份内存</span></span><br><span class="line">    scav := <span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 同一个chunk</span></span><br><span class="line">    <span class="keyword">if</span> sc == ec &#123;</span><br><span class="line">        chunk := p.chunkOf(sc)</span><br><span class="line">        <span class="comment">// 计算区间内1的数量</span></span><br><span class="line">        scav += chunk.scavenged.popcntRange(si, ei+<span class="number">1</span>-si)</span><br><span class="line">        <span class="comment">// 区间内的pallocBits设置为1、scavenged重置为0</span></span><br><span class="line">        chunk.allocRange(si, ei+<span class="number">1</span>-si)</span><br><span class="line">        <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">        p.scav.index.alloc(sc, ei+<span class="number">1</span>-si)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 多个chunk</span></span><br><span class="line">        <span class="comment">// 第一个chunk</span></span><br><span class="line">        chunk := p.chunkOf(sc)</span><br><span class="line">        <span class="comment">// 计算区间内1的数量</span></span><br><span class="line">        scav += chunk.scavenged.popcntRange(si, pallocChunkPages-si)</span><br><span class="line">        <span class="comment">// 区间内的pallocBits设置为1、scavenged重置为0</span></span><br><span class="line">        chunk.allocRange(si, pallocChunkPages-si)</span><br><span class="line">        <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">        p.scav.index.alloc(sc, pallocChunkPages-si)</span><br><span class="line">        <span class="comment">// 中间chunk</span></span><br><span class="line">        <span class="keyword">for</span> c := sc + <span class="number">1</span>; c &lt; ec; c++ &#123;</span><br><span class="line">            chunk := p.chunkOf(c)</span><br><span class="line">            <span class="comment">// 计算区间内1的数量</span></span><br><span class="line">            scav += chunk.scavenged.popcntRange(<span class="number">0</span>, pallocChunkPages)</span><br><span class="line">            <span class="comment">// 64位全设置为1</span></span><br><span class="line">            chunk.allocAll()</span><br><span class="line">            <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">            p.scav.index.alloc(c, pallocChunkPages)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个chunk</span></span><br><span class="line">        chunk = p.chunkOf(ec)</span><br><span class="line">        <span class="comment">// 计算区间内1的数量</span></span><br><span class="line">        scav += chunk.scavenged.popcntRange(<span class="number">0</span>, ei+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 区间内的pallocBits设置为1、scavenged重置为0</span></span><br><span class="line">        chunk.allocRange(<span class="number">0</span>, ei+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">        p.scav.index.alloc(ec, ei+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">    p.update(base, npages, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uintptr</span>(scav) * pageSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> update(base, npages <span class="type">uintptr</span>, contig, alloc <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向最后一个字节</span></span><br><span class="line">    limit := base + npages*pageSize - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 起始idx、终止idx（指针转idx）</span></span><br><span class="line">    sc, ec := chunkIndex(base), chunkIndex(limit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计chunks信息并更新到summary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一个chunk，4MB内存内</span></span><br><span class="line">    <span class="keyword">if</span> sc == ec &#123;</span><br><span class="line">        <span class="comment">// x = p.summary[4][sc] =&gt; pallocSum</span></span><br><span class="line">        x := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][sc]</span><br><span class="line">        <span class="comment">// 统计前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line">        <span class="comment">// chunk =&gt; p.chunks[sc&gt;&gt;13][sc&amp;(2^13-1)] =&gt; pallocData</span></span><br><span class="line">        y := p.chunkOf(sc).summarize()</span><br><span class="line">        <span class="comment">// 不需要更新</span></span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以实际统计为准</span></span><br><span class="line">        p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][sc] = y</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> contig &#123;</span><br><span class="line">        <span class="comment">// 不同一个chunk、连续</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// = p.summary[4]</span></span><br><span class="line">        summary := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新第一个chunk：统计前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line">        <span class="comment">// chunk =&gt; p.chunks[sc&gt;&gt;13][sc&amp;(2^13-1)] =&gt; pallocData</span></span><br><span class="line">        summary[sc] = p.chunkOf(sc).summarize()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中间chunk，不包含sc和ec</span></span><br><span class="line">        whole := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][sc+<span class="number">1</span> : ec]</span><br><span class="line">        <span class="keyword">if</span> alloc &#123;</span><br><span class="line">            <span class="comment">// 分配内存，整个chunk都被使用</span></span><br><span class="line">            <span class="comment">// 清0</span></span><br><span class="line">            clear(whole)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 刚从系统申请的内存或被GC清扫后的内存，重置为默认值</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">range</span> whole &#123;</span><br><span class="line">                <span class="comment">// = |0|512|512|512|</span></span><br><span class="line">                whole[i] = freeChunkSum</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最后一个chunk：统计前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line">        summary[ec] = p.chunkOf(ec).summarize()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不同一个chunk、不连续</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// = p.summary[4]</span></span><br><span class="line">        summary := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">// 遍历所有chunk</span></span><br><span class="line">        <span class="keyword">for</span> c := sc; c &lt;= ec; c++ &#123;</span><br><span class="line">            <span class="comment">// 更新summary：统计前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line">            summary[c] = p.chunkOf(c).summarize()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里已经算出每个chunk的sum信息，也就是summary最后一层已经计算完，需要往前更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示第l层需要更新</span></span><br><span class="line">    changed := <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 从后向前遍历剩下的summary</span></span><br><span class="line">    <span class="comment">// p.summary[3] ... p.summary[0]</span></span><br><span class="line">    <span class="keyword">for</span> l := <span class="built_in">len</span>(p.summary) - <span class="number">2</span>; l &gt;= <span class="number">0</span> &amp;&amp; changed; l-- &#123;</span><br><span class="line">        <span class="comment">// 合并后的sum没有变化，则提前退出循环</span></span><br><span class="line">        changed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般是3个bit，也就是除以8</span></span><br><span class="line">        logEntriesPerBlock := levelBits[l+<span class="number">1</span>]</span><br><span class="line">        <span class="comment">// 一个sum代表的页数量，第4层一个sum代表512页，每上一层数量*=8，这里取对数值</span></span><br><span class="line">        logMaxPages := levelLogPages[l+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// |16|14| 3| 3| 3| 3|22|</span></span><br><span class="line">        <span class="comment">// |  |l0|l1|l2|l3|l4|  |</span></span><br><span class="line">        <span class="comment">// 地址丢弃低22位，然后每上一层，丢弃3位</span></span><br><span class="line">        lo, hi := addrsToSummaryRange(l, base, limit+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一层的每8个sum汇总成一个sum</span></span><br><span class="line">        <span class="keyword">for</span> i := lo; i &lt; hi; i++ &#123;</span><br><span class="line">            <span class="comment">// 第i个block，每个block有logEntriesPerBlock个entry</span></span><br><span class="line">            children := p.summary[l+<span class="number">1</span>][i&lt;&lt;logEntriesPerBlock : (i+<span class="number">1</span>)&lt;&lt;logEntriesPerBlock]</span><br><span class="line">            <span class="comment">// 每8个sum汇总成一个sum</span></span><br><span class="line">            sum := mergeSummaries(children, logMaxPages)</span><br><span class="line">            old := p.summary[l][i]</span><br><span class="line">            <span class="comment">// 相同则不更新</span></span><br><span class="line">            <span class="keyword">if</span> old != sum &#123;</span><br><span class="line">                <span class="comment">// 不同，还要继续往上一层合并</span></span><br><span class="line">                changed = <span class="literal">true</span></span><br><span class="line">                p.summary[l][i] = sum</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每8个sum汇总成一个sum</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSummaries</span><span class="params">(sums []pallocSum, logMaxPagesPerSum <span class="type">uint</span>)</span></span> pallocSum &#123;</span><br><span class="line">    <span class="comment">// 解析第1个sum</span></span><br><span class="line">    start, most, end := sums[<span class="number">0</span>].unpack()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历剩下的sum</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(sums); i++ &#123;</span><br><span class="line">        <span class="comment">// 解析第i个sum</span></span><br><span class="line">        si, mi, ei := sums[i].unpack()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前导连续空闲页数</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="type">uint</span>(i)&lt;&lt;logMaxPagesPerSum &#123;</span><br><span class="line">            <span class="comment">// 如果start是512（更高层*8），代表前一个chunk没有被使用</span></span><br><span class="line">            start += si</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大连续空闲页数</span></span><br><span class="line">        most = max(most, end+si, mi)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 末尾连续空闲页数</span></span><br><span class="line">        <span class="keyword">if</span> ei == <span class="number">1</span>&lt;&lt;logMaxPagesPerSum &#123;</span><br><span class="line">            <span class="comment">// 如果end是512（更高层*8），代表当前chunk没有被使用</span></span><br><span class="line">            end += <span class="number">1</span> &lt;&lt; logMaxPagesPerSum</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = ei</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> packPallocSum(start, most, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出不小于addr的最近可用地址（一般情况下返回传入的参数）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> findMappedAddr(addr offAddr) offAddr &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为anera索引</span></span><br><span class="line">    ai := arenaIndex(addr.addr())</span><br><span class="line">    <span class="comment">// 测试中 or heapArena尚未分配或被释放</span></span><br><span class="line">    <span class="keyword">if</span> p.test || mheap_.arenas[ai.l1()] == <span class="literal">nil</span> || mheap_.arenas[ai.l1()][ai.l2()] == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 在inUse.ranges内找到不小于addr的地址</span></span><br><span class="line">        vAddr, ok := p.inUse.findAddrGreaterEqual(addr.addr())</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="comment">// 找到了</span></span><br><span class="line">            <span class="keyword">return</span> offAddr&#123;vAddr&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没找到</span></span><br><span class="line">            <span class="keyword">return</span> maxOffAddr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般情况下返回传入的参数</span></span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从summary最顶层开始扫描，寻找足以容纳n个页的内存地址和不小于addr的最近可用地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> find(npages <span class="type">uintptr</span>) (<span class="type">uintptr</span>, offAddr) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以认为是基地址的索引</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// base和bound基本覆盖了整个48位地址空间</span></span><br><span class="line">    firstFree := <span class="keyword">struct</span> &#123;</span><br><span class="line">        base, bound offAddr</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        base:  minOffAddr, <span class="comment">// 基地址 =&gt; 0xffff800000000000</span></span><br><span class="line">        bound: maxOffAddr, <span class="comment">// 终止地址 =&gt; (2^48-1) + 0xffff800000000000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该函数用于检查地址是否合法，合法则更新到firstFree变量，不合法则抛出异常</span></span><br><span class="line">    foundFree := <span class="function"><span class="keyword">func</span><span class="params">(addr offAddr, size <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 边界检测</span></span><br><span class="line">        <span class="keyword">if</span> firstFree.base.lessEqual(addr) &amp;&amp; addr.add(size<span class="number">-1</span>).lessEqual(firstFree.bound) &#123;</span><br><span class="line">            <span class="comment">// 合法，纪录</span></span><br><span class="line">            firstFree.base = addr</span><br><span class="line">            firstFree.bound = addr.add(size - <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> !(addr.add(size<span class="number">-1</span>).lessThan(firstFree.base) || firstFree.bound.lessThan(addr)) &#123;</span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: addr = &quot;</span>, hex(addr.addr()), <span class="string">&quot;, size = &quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: base = &quot;</span>, hex(firstFree.base.addr()), <span class="string">&quot;, bound = &quot;</span>, hex(firstFree.bound.addr()), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;range partially overlaps&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个参数debug用</span></span><br><span class="line">    <span class="comment">// 上一个sum-初始值表示全部已使用</span></span><br><span class="line">    lastSum := packPallocSum(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 上一个sum索引</span></span><br><span class="line">    lastSumIdx := <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">nextLevel:</span><br><span class="line">    <span class="comment">// 遍历summary，从最顶层到最底层</span></span><br><span class="line">    <span class="keyword">for</span> l := <span class="number">0</span>; l &lt; <span class="built_in">len</span>(p.summary); l++ &#123;</span><br><span class="line">        <span class="comment">// 每层需要扫描的的entry数量</span></span><br><span class="line">        <span class="comment">// 第0层全部16K个块都要扫描，每下一层只需要扫描8个块</span></span><br><span class="line">        entriesPerBlock := <span class="number">1</span> &lt;&lt; levelBits[l]</span><br><span class="line">        <span class="comment">// 一个sum代表的页数量，第4层一个sum代表512页（4MB），每上一层数量*=8，第0层代表2M个页（4GB）</span></span><br><span class="line">        logMaxPages := levelLogPages[l]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 地址索引，第0层乘于16K，但因为初始为0，所以结果还是0，而后每下一层，乘于8</span></span><br><span class="line">        <span class="comment">// i在后面还会累加偏移量j</span></span><br><span class="line">        i &lt;&lt;= levelBits[l]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从i位置开始扫描</span></span><br><span class="line">        <span class="comment">// 第0层全部16K个块都要扫描，每下一层只需要扫描8个块</span></span><br><span class="line">        entries := p.summary[l][i : i+entriesPerBlock]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偏移量</span></span><br><span class="line">        j0 := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 先将searchAddr转换为相对地址，再除于每层entry数量，获得数组索引</span></span><br><span class="line">        <span class="comment">// 2. searchIdx丢弃低位 =&gt; 块的起始地址，判断searchIdx是不是在i指向的块内</span></span><br><span class="line">        <span class="keyword">if</span> searchIdx := offAddrToLevelIndex(l, p.searchAddr); searchIdx&amp;^(entriesPerBlock<span class="number">-1</span>) == i &#123;</span><br><span class="line">            <span class="comment">// 取searchIdx低位 =&gt; 第i块内的偏移量</span></span><br><span class="line">            j0 = searchIdx &amp; (entriesPerBlock - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可用页的起始位置，累计总页数</span></span><br><span class="line">        <span class="keyword">var</span> base, size <span class="type">uint</span></span><br><span class="line">        <span class="comment">// 从0或j0的位置开始扫描整个entries数组</span></span><br><span class="line">        <span class="keyword">for</span> j := j0; j &lt; <span class="built_in">len</span>(entries); j++ &#123;</span><br><span class="line">            <span class="comment">// sum</span></span><br><span class="line">            sum := entries[j]</span><br><span class="line">            <span class="comment">// 全部已使用</span></span><br><span class="line">            <span class="keyword">if</span> sum == <span class="number">0</span> &#123;</span><br><span class="line">                size = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 部份已使用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 索引转绝对地址</span></span><br><span class="line">            <span class="comment">// 2. 检查地址是否合法，合法则更新到firstFree，不合法则抛出异常</span></span><br><span class="line">            foundFree(levelIndexToOffAddr(l, i+j), (<span class="type">uintptr</span>(<span class="number">1</span>)&lt;&lt;logMaxPages)*pageSize)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// start部份-前导连续空闲页数</span></span><br><span class="line">            s := sum.start()</span><br><span class="line">            <span class="comment">// 空间足够</span></span><br><span class="line">            <span class="keyword">if</span> size+s &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">                <span class="comment">// 调整起始位置</span></span><br><span class="line">                <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">                    base = <span class="type">uint</span>(j) &lt;&lt; logMaxPages</span><br><span class="line">                &#125;</span><br><span class="line">                size += s</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 空间不足</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// max部份-最大连续空闲页数，可以容纳n个页</span></span><br><span class="line">            <span class="keyword">if</span> sum.max() &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">                <span class="comment">// 进入块内部扫描</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 偏移量</span></span><br><span class="line">                i += j</span><br><span class="line">                <span class="comment">// 下面两个参数debug用</span></span><br><span class="line">                <span class="comment">// 上一层的偏移量</span></span><br><span class="line">                lastSumIdx = i</span><br><span class="line">                <span class="comment">// 上一层的sum</span></span><br><span class="line">                lastSum = sum</span><br><span class="line">                <span class="comment">// 向下一层寻找</span></span><br><span class="line">                <span class="keyword">continue</span> nextLevel</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果最大连续空闲页数不足以容纳n个页</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未开始累计 or 当前块部份使用</span></span><br><span class="line">            <span class="keyword">if</span> size == <span class="number">0</span> || s &lt; <span class="number">1</span>&lt;&lt;logMaxPages &#123;</span><br><span class="line">                <span class="comment">// end-末尾连续空闲页数</span></span><br><span class="line">                size = sum.end()</span><br><span class="line">                <span class="comment">// 更新base到正确的起始位置</span></span><br><span class="line">                base = <span class="type">uint</span>(j+<span class="number">1</span>)&lt;&lt;logMaxPages - size</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 已开始累计 and 当前块全部可用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接累加</span></span><br><span class="line">            size += <span class="number">1</span> &lt;&lt; logMaxPages</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，已经找到足够的n个页，或当前层的x个块已经扫描完了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 足以容纳n个页</span></span><br><span class="line">        <span class="keyword">if</span> size &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">            <span class="comment">// 1. 索引转绝对地址</span></span><br><span class="line">            <span class="comment">// 2. 检查地址是否合法，合法则更新到firstFree，不合法则抛出异常</span></span><br><span class="line">            addr := levelIndexToOffAddr(l, i).add(<span class="type">uintptr</span>(base) * pageSize).addr()</span><br><span class="line">            <span class="comment">// addr, 找出不小于addr的最近可用地址（一般情况下返回传入的参数）</span></span><br><span class="line">            <span class="keyword">return</span> addr, p.findMappedAddr(firstFree.base)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不足以容纳n个页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第0层，说明整个地址空间都扫描过了，内存不够用</span></span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, maxSearchAddr()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他层不应该出现这种情况，异常，打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: summary[&quot;</span>, l<span class="number">-1</span>, <span class="string">&quot;][&quot;</span>, lastSumIdx, <span class="string">&quot;] = &quot;</span>, lastSum.start(), <span class="string">&quot;, &quot;</span>, lastSum.max(), <span class="string">&quot;, &quot;</span>, lastSum.end(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: level = &quot;</span>, l, <span class="string">&quot;, npages = &quot;</span>, npages, <span class="string">&quot;, j0 = &quot;</span>, j0, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: p.searchAddr = &quot;</span>, hex(p.searchAddr.addr()), <span class="string">&quot;, i = &quot;</span>, i, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: levelShift[level] = &quot;</span>, levelShift[l], <span class="string">&quot;, levelBits[level] = &quot;</span>, levelBits[l], <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(entries); j++ &#123;</span><br><span class="line">            sum := entries[j]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: summary[&quot;</span>, l, <span class="string">&quot;][&quot;</span>, i+j, <span class="string">&quot;] = (&quot;</span>, sum.start(), <span class="string">&quot;, &quot;</span>, sum.max(), <span class="string">&quot;, &quot;</span>, sum.end(), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        throw(<span class="string">&quot;bad summary data&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兜底代码？按道理怎么也不会走到这里才对！！！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// chunk索引</span></span><br><span class="line">    ci := chunkIdx(i)</span><br><span class="line">    <span class="comment">// 在一个chunk中寻找可用的连续n个页的起始索引（最多512个页，从基地址开始搜索）</span></span><br><span class="line">    j, searchIdx := p.chunkOf(ci).find(npages, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定数值，表示寻找失败，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> j == ^<span class="type">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        sum := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: summary[&quot;</span>, <span class="built_in">len</span>(p.summary)<span class="number">-1</span>, <span class="string">&quot;][&quot;</span>, i, <span class="string">&quot;] = (&quot;</span>, sum.start(), <span class="string">&quot;, &quot;</span>, sum.max(), <span class="string">&quot;, &quot;</span>, sum.end(), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: npages = &quot;</span>, npages, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad summary data&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引转地址</span></span><br><span class="line">    addr := chunkBase(ci) + <span class="type">uintptr</span>(j)*pageSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引转地址</span></span><br><span class="line">    searchAddr := chunkBase(ci) + <span class="type">uintptr</span>(searchIdx)*pageSize</span><br><span class="line">    <span class="comment">// 检查地址是否合法，合法则更新到firstFree，不合法则抛出异常</span></span><br><span class="line">    foundFree(offAddr&#123;searchAddr&#125;, chunkBase(ci+<span class="number">1</span>)-searchAddr)</span><br><span class="line">    <span class="comment">// addr, 找出不小于addr的最近可用地址（一般情况下返回传入的参数）</span></span><br><span class="line">    <span class="keyword">return</span> addr, p.findMappedAddr(firstFree.base)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过summary查找，找到一个最少包含一个可用页的块（共64个页信息）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> allocToCache() pageCache &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址转索引，越界</span></span><br><span class="line">    <span class="keyword">if</span> chunkIndex(p.searchAddr.addr()) &gt;= p.end &#123;</span><br><span class="line">        <span class="keyword">return</span> pageCache&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未越界</span></span><br><span class="line">    c := pageCache&#123;&#125;</span><br><span class="line">    <span class="comment">// 起始索引</span></span><br><span class="line">    ci := chunkIndex(p.searchAddr.addr())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> chunk *pallocData</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][ci] != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 最底层的chunk的pallocSum有剩余的页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// chunk</span></span><br><span class="line">        chunk = p.chunkOf(ci)</span><br><span class="line">        <span class="comment">// func (b *pallocBits) find(npages uintptr, searchIdx uint) (uint, uint)</span></span><br><span class="line">        <span class="comment">// 在一个chunk中寻找可用的连续n个页的起始索引（最多512个页，从searchAddr开始搜索）</span></span><br><span class="line">        j, _ := chunk.find(<span class="number">1</span>, chunkPageIndex(p.searchAddr.addr()))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 固定数值，表示寻找失败，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> j == ^<span class="type">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad summary data&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了</span></span><br><span class="line">        c = pageCache&#123;</span><br><span class="line">            <span class="comment">// 对象地址 = 基地址 + [0,512)*8192</span></span><br><span class="line">            base:  chunkBase(ci) + alignDown(<span class="type">uintptr</span>(j), <span class="number">64</span>)*pageSize,</span><br><span class="line">            <span class="comment">// 64位取反，这里1表示页是可用的</span></span><br><span class="line">            cache: ^chunk.pages64(j),</span><br><span class="line">            <span class="comment">// 直接使用64位</span></span><br><span class="line">            scav:  chunk.scavenged.block64(j),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 最底层的chunk的pallocSum没有剩余的页 =&gt; 为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// func (p *pageAlloc) find(npages uintptr) (uintptr, offAddr)</span></span><br><span class="line">        <span class="comment">// 从summary最顶层开始扫描，寻找足以容纳1个页的内存地址和最近可用地址</span></span><br><span class="line">        addr, _ := p.find(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 失败了</span></span><br><span class="line">        <span class="keyword">if</span> addr == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 内存不足</span></span><br><span class="line">            p.searchAddr = maxSearchAddr()</span><br><span class="line">            <span class="keyword">return</span> pageCache&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        ci = chunkIndex(addr)</span><br><span class="line">        chunk = p.chunkOf(ci)</span><br><span class="line">        c = pageCache&#123;</span><br><span class="line">            <span class="comment">// 对象地址</span></span><br><span class="line">            base:  alignDown(addr, <span class="number">64</span>*pageSize),</span><br><span class="line">            <span class="comment">// 64位取反，这里1表示页是可用的</span></span><br><span class="line">            cache: ^chunk.pages64(chunkPageIndex(addr)),</span><br><span class="line">            <span class="comment">// 直接使用64位</span></span><br><span class="line">            scav:  chunk.scavenged.block64(chunkPageIndex(addr)),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这部份数据被缓存，原来的chunk需要更新为已使用</span></span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    cpi := chunkPageIndex(c.base)</span><br><span class="line">    <span class="comment">// 用cache的bitmap合并原chunk数据，这样原64位全为1</span></span><br><span class="line">    chunk.allocPages64(cpi, c.cache)</span><br><span class="line">    <span class="comment">// 如果一个页被使用，后被回收，scavenged的状态需要重置为0</span></span><br><span class="line">    chunk.scavenged.clearBlock64(cpi, c.cache&amp;c.scav)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">    p.update(c.base, pageCachePages, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (s *scavengeIndex) alloc(ci chunkIdx, npages uint)</span></span><br><span class="line">    <span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等。防止scavenger错误回收已分配的页</span></span><br><span class="line">    p.scav.index.alloc(ci, <span class="type">uint</span>(sys.OnesCount64(c.cache)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索地址往后移动63个页 =&gt; 8192*63</span></span><br><span class="line">    p.searchAddr = offAddr&#123;c.base + pageSize*(pageCachePages<span class="number">-1</span>)&#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定的虚拟地址范围内分配/映射物理内存，让该地址变为可用（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> sysGrow(base, limit <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 非4MB的倍数，异常</span></span><br><span class="line">    <span class="keyword">if</span> base%pallocChunkBytes != <span class="number">0</span> || limit%pallocChunkBytes != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: base = &quot;</span>, hex(base), <span class="string">&quot;, limit = &quot;</span>, hex(limit), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;sysGrow bounds not aligned to pallocChunkBytes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据地址找到sum的索引边界</span></span><br><span class="line">    addrRangeToSummaryRange := <span class="function"><span class="keyword">func</span><span class="params">(level <span class="type">int</span>, r addrRange)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">// |16|14| 3| 3| 3| 3|22|</span></span><br><span class="line">        <span class="comment">// |  |l0|l1|l2|l3|l4|  |</span></span><br><span class="line">        <span class="comment">// 地址丢弃低22位，然后每上一层，丢弃3位，l0时是一个14位的数，l4时是一个26位数</span></span><br><span class="line">        sumIdxBase, sumIdxLimit := addrsToSummaryRange(level, r.base.addr(), r.limit.addr())</span><br><span class="line">        <span class="comment">// 按指定倍数，base向下取整，limit向上取整，l0时倍数为2^14</span></span><br><span class="line">        <span class="keyword">return</span> blockAlignSummaryRange(level, sumIdxBase, sumIdxLimit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出当前层的summary的起始、终止索引</span></span><br><span class="line">    summaryRangeToSumAddrRange := <span class="function"><span class="keyword">func</span><span class="params">(level, sumIdxBase, sumIdxLimit <span class="type">int</span>)</span></span> addrRange &#123;</span><br><span class="line">        <span class="comment">// base*8，按physPageSize向下取整</span></span><br><span class="line">        baseOffset := alignDown(<span class="type">uintptr</span>(sumIdxBase)*pallocSumBytes, physPageSize)</span><br><span class="line">        <span class="comment">// limit*8，按physPageSize向上取整</span></span><br><span class="line">        limitOffset := alignUp(<span class="type">uintptr</span>(sumIdxLimit)*pallocSumBytes, physPageSize)</span><br><span class="line">        <span class="comment">// 当前层的第一个sum</span></span><br><span class="line">        base := unsafe.Pointer(&amp;p.summary[level][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> addrRange&#123;</span><br><span class="line">            offAddr&#123;<span class="type">uintptr</span>(add(base, baseOffset))&#125;,  <span class="comment">// 当前层的base索引</span></span><br><span class="line">            offAddr&#123;<span class="type">uintptr</span>(add(base, limitOffset))&#125;, <span class="comment">// 当前层的limit索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据地址计算出其在summary的起始、终止索引</span></span><br><span class="line">    addrRangeToSumAddrRange := <span class="function"><span class="keyword">func</span><span class="params">(level <span class="type">int</span>, r addrRange)</span></span> addrRange &#123;</span><br><span class="line">        <span class="comment">// 根据地址找到sum的索引边界</span></span><br><span class="line">        sumIdxBase, sumIdxLimit := addrRangeToSummaryRange(level, r)</span><br><span class="line">        <span class="comment">// 计算出当前层的summary的起始、终止索引</span></span><br><span class="line">        <span class="keyword">return</span> summaryRangeToSumAddrRange(level, sumIdxBase, sumIdxLimit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用二分法在inUse.ranges中寻找范围包含base的addrRange的索引</span></span><br><span class="line">    inUseIndex := p.inUse.findSucc(base)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历summary</span></span><br><span class="line">    <span class="keyword">for</span> l := <span class="keyword">range</span> p.summary &#123;</span><br><span class="line">        <span class="comment">// 根据地址找到sum的索引边界</span></span><br><span class="line">        needIdxBase, needIdxLimit := addrRangeToSummaryRange(l, makeAddrRange(base, limit))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止越界</span></span><br><span class="line">        <span class="keyword">if</span> needIdxLimit &gt; <span class="built_in">len</span>(p.summary[l]) &#123;</span><br><span class="line">            p.summary[l] = p.summary[l][:needIdxLimit]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出当前层的summary的起始、终止索引</span></span><br><span class="line">        need := summaryRangeToSumAddrRange(l, needIdxBase, needIdxLimit)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于是二分法，这个索引可能越界</span></span><br><span class="line">        <span class="keyword">if</span> inUseIndex &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 根据地址计算出其在summary的起始、终止索引</span></span><br><span class="line">            <span class="comment">// 2. need根据range的地址范围调整base和limit</span></span><br><span class="line">            <span class="comment">// 注意：inUseIndex索引下的地址范围可能会包含addr</span></span><br><span class="line">            need = need.subtract(addrRangeToSumAddrRange(l, p.inUse.ranges[inUseIndex<span class="number">-1</span>]))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> inUseIndex &lt; <span class="built_in">len</span>(p.inUse.ranges) &#123;</span><br><span class="line">            <span class="comment">// 1. 根据地址计算出其在summary的起始、终止索引</span></span><br><span class="line">            <span class="comment">// 2. need根据range的地址范围调整base和limit</span></span><br><span class="line">            <span class="comment">// 注意：inUseIndex索引下的地址范围不可能会包含addr</span></span><br><span class="line">            need = need.subtract(addrRangeToSumAddrRange(l, p.inUse.ranges[inUseIndex]))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.base &lt; a.base &lt; a.limit &lt; b.limit</span></span><br><span class="line">        <span class="comment">// 如果need的地址范围被包含在range的地址范围内时，base和limit设置为0</span></span><br><span class="line">        <span class="keyword">if</span> need.size() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 前往下一层</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 走到这里，need和range的地址范围有交叉，需要更新base或者limit</span></span><br><span class="line">        <span class="comment">// a.base &lt; b.limit &lt; a.limit =&gt; a.base=b.limit（此时b.base的位置随意）</span></span><br><span class="line">        <span class="comment">// a.base &lt; b.base  &lt; a.limit =&gt; a.limit=b.base（此时b.limit的位置随意）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用sysMap直接映射，内存状态从Reserved改为Prepared</span></span><br><span class="line">        sysMap(unsafe.Pointer(need.base.addr()), need.size(), p.sysStat)</span><br><span class="line">        <span class="comment">// 内存状态从Prepared改为Ready</span></span><br><span class="line">        sysUsed(unsafe.Pointer(need.base.addr()), need.size(), need.size())</span><br><span class="line">        <span class="comment">// 这部份内存是Ready状态，累计到summaryMappedReady</span></span><br><span class="line">        p.summaryMappedReady += need.size()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (s *scavengeIndex) sysGrow(base, limit uintptr, sysStat *sysMemStat) uintptr</span></span><br><span class="line">    <span class="comment">// 在指定的虚拟地址范围内分配/映射物理内存，让该地址变为可用（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">    p.summaryMappedReady += p.scav.index.sysGrow(base, limit, p.sysStat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// chunk元素按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> enableChunkHugePages() &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;mheap_.lock)</span><br><span class="line">    <span class="comment">// 已修改</span></span><br><span class="line">    <span class="keyword">if</span> p.chunkHugePages &#123;</span><br><span class="line">        <span class="comment">// 解锁返回</span></span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置标志</span></span><br><span class="line">    p.chunkHugePages = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inUse addrRanges</span><br><span class="line">    inUse.sysStat = p.sysStat</span><br><span class="line">    <span class="comment">// 复制p.inUse到inUse变量（如果inUse容量较小，还会进行扩容）</span></span><br><span class="line">    p.inUse.cloneInto(&amp;inUse)</span><br><span class="line">    unlock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有地址</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> p.inUse.ranges &#123;</span><br><span class="line">        <span class="keyword">for</span> i := chunkIndex(r.base.addr()).l1(); i &lt; chunkIndex(r.limit.addr()<span class="number">-1</span>).l1(); i++ &#123;</span><br><span class="line">            <span class="comment">// 按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line">            sysHugePage(unsafe.Pointer(p.chunks[i]), unsafe.Sizeof(*p.chunks[<span class="number">0</span>]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pallocBits"><a href="#pallocBits" class="headerlink" title="pallocBits"></a>pallocBits</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个chunk中寻找可用的连续n个页的起始索引（最多512个页）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *pallocBits)</span></span> find(npages <span class="type">uintptr</span>, searchIdx <span class="type">uint</span>) (<span class="type">uint</span>, <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> npages == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 1个page</span></span><br><span class="line">        <span class="comment">// 寻找可用的1个页的起始索引（最多1个页）</span></span><br><span class="line">        addr := b.find1(searchIdx)</span><br><span class="line">        <span class="keyword">return</span> addr, addr</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> npages &lt;= <span class="number">64</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;=64个page</span></span><br><span class="line">        <span class="comment">// 寻找可用的连续n个页的起始索引（最多64个页）</span></span><br><span class="line">        <span class="keyword">return</span> b.findSmallN(npages, searchIdx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;64个page</span></span><br><span class="line">    <span class="comment">// 寻找可用的连续n个页的起始索引（最多512个页）</span></span><br><span class="line">    <span class="keyword">return</span> b.findLargeN(npages, searchIdx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找可用的1个页的起始索引（最多1个页）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *pallocBits)</span></span> find1(searchIdx <span class="type">uint</span>) <span class="type">uint</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否为nil</span></span><br><span class="line">    _ = b[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// i = chunk二级索引/64 =&gt; 定位是第几个uint64</span></span><br><span class="line">    <span class="keyword">for</span> i := searchIdx / <span class="number">64</span>; i &lt; <span class="type">uint</span>(<span class="built_in">len</span>(b)); i++ &#123;</span><br><span class="line">        <span class="comment">// 64个位</span></span><br><span class="line">        x := b[i]</span><br><span class="line">        <span class="comment">// 取反，如0000 0111 -&gt; 1111 1000</span></span><br><span class="line">        <span class="keyword">if</span> ^x == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果x的64个位全为1，全部已分配，跳过</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位页起始索引 =&gt; i-&gt;基索引，64位二进制数的尾部的0的个数 -&gt; 空闲位</span></span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">64</span> + <span class="type">uint</span>(sys.TrailingZeros64(^x))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部已分配</span></span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找可用的连续n个页的起始索引（最多64个页）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *pallocBits)</span></span> findSmallN(npages <span class="type">uintptr</span>, searchIdx <span class="type">uint</span>) (<span class="type">uint</span>, <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// 高位连续0个数，chunk第一个可用页的位置</span></span><br><span class="line">    end, newSearchIdx := <span class="type">uint</span>(<span class="number">0</span>), ^<span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// i = chunk二级索引/64 =&gt; 范围：[0,8)，定位是第几个uint64</span></span><br><span class="line">    <span class="keyword">for</span> i := searchIdx / <span class="number">64</span>; i &lt; <span class="type">uint</span>(<span class="built_in">len</span>(b)); i++ &#123;</span><br><span class="line">        <span class="comment">// 64个位</span></span><br><span class="line">        bi := b[i]</span><br><span class="line">        <span class="comment">// 取反，如0000 0111 -&gt; 1111 1000</span></span><br><span class="line">        <span class="keyword">if</span> ^bi == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 说明bi的64个位全为1，全部已分配，跳过</span></span><br><span class="line">            end = <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有至少一个页可用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次走到这里</span></span><br><span class="line">        <span class="keyword">if</span> newSearchIdx == ^<span class="type">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// chunk第一个可用页的位置（后面判断可能发现不连续/不够用）</span></span><br><span class="line">            newSearchIdx = i*<span class="number">64</span> + <span class="type">uint</span>(sys.TrailingZeros64(^bi))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 低位连续0个数</span></span><br><span class="line">        start := <span class="type">uint</span>(sys.TrailingZeros64(bi))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断连续空闲页数是否满足需求，举例</span></span><br><span class="line">        <span class="comment">// 上一个64位bitmap =&gt; 0001 1111 ... =&gt;   end = 3</span></span><br><span class="line">        <span class="comment">// 当前的64位bitmap =&gt; 1111 0000 ... =&gt; start = 60</span></span><br><span class="line">        <span class="keyword">if</span> end+start &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">            <span class="comment">// 连续可用n页的起始位置，chunk第一个可用页的位置</span></span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">64</span> - end, newSearchIdx</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出连续n个1的起始位置（64个位），找不到返回64</span></span><br><span class="line">        j := findBitRange64(^bi, <span class="type">uint</span>(npages))</span><br><span class="line">        <span class="comment">// 有足够空间容纳连续npages</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">64</span> &#123;</span><br><span class="line">            <span class="comment">// 连续可用n页的起始位置，chunk第一个可用页的位置</span></span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">64</span> + j, newSearchIdx</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有足够空间容纳连续npages</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 高位连续0个数</span></span><br><span class="line">        end = <span class="type">uint</span>(sys.LeadingZeros64(bi))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">uint</span>(<span class="number">0</span>), newSearchIdx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找可用的连续n个页的起始索引（最多512个页）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *pallocBits)</span></span> findLargeN(npages <span class="type">uintptr</span>, searchIdx <span class="type">uint</span>) (<span class="type">uint</span>, <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// 连续可用n页的起始位置，连续1的数量，chunk第一个可用页的位置</span></span><br><span class="line">    start, size, newSearchIdx := ^<span class="type">uint</span>(<span class="number">0</span>), <span class="type">uint</span>(<span class="number">0</span>), ^<span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// i = chunk二级索引/64 =&gt; 定位是第几个uint64</span></span><br><span class="line">    <span class="keyword">for</span> i := searchIdx / <span class="number">64</span>; i &lt; <span class="type">uint</span>(<span class="built_in">len</span>(b)); i++ &#123;</span><br><span class="line">        <span class="comment">// 64个位</span></span><br><span class="line">        x := b[i]</span><br><span class="line">        <span class="comment">// 取反，如0000 0111 -&gt; 1111 1000</span></span><br><span class="line">        <span class="keyword">if</span> x == ^<span class="type">uint64</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果x的64个位全为1，全部已分配，跳过</span></span><br><span class="line">            size = <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有至少一个页可用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次走到这里</span></span><br><span class="line">        <span class="keyword">if</span> newSearchIdx == ^<span class="type">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// chunk第一个可用页的位置（后面判断可能发现不连续/不够用）</span></span><br><span class="line">            newSearchIdx = i*<span class="number">64</span> + <span class="type">uint</span>(sys.TrailingZeros64(^x))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未改动/被重置</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 高位连续0个数</span></span><br><span class="line">            size = <span class="type">uint</span>(sys.LeadingZeros64(x))</span><br><span class="line">            <span class="comment">// 连续可用n页的起始位置</span></span><br><span class="line">            start = i*<span class="number">64</span> + <span class="number">64</span> - size</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，起始位置已经确定，看能否找到足够的空间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 低位连续0个数</span></span><br><span class="line">        s := <span class="type">uint</span>(sys.TrailingZeros64(x))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断连续空闲页数是否满足需求，举例</span></span><br><span class="line">        <span class="comment">// 上一个64位bitmap =&gt; 0001 1111 ... =&gt;   end = 3</span></span><br><span class="line">        <span class="comment">// 当前的64位bitmap =&gt; 1111 0000 ... =&gt; start = 60</span></span><br><span class="line">        <span class="keyword">if</span> s+size &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">            <span class="comment">// 连续可用n页的起始位置，chunk第一个可用页的位置</span></span><br><span class="line">            <span class="keyword">return</span> start, newSearchIdx</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，64位扫描完了，还是不够用，继续扫描下一个64位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s!=64，64位中只有一部分可用，重置</span></span><br><span class="line">        <span class="keyword">if</span> s &lt; <span class="number">64</span> &#123;</span><br><span class="line">            <span class="comment">// 高位连续0个数</span></span><br><span class="line">            size = <span class="type">uint</span>(sys.LeadingZeros64(x))</span><br><span class="line">            <span class="comment">// 连续可用n页的起始位置</span></span><br><span class="line">            start = i*<span class="number">64</span> + <span class="number">64</span> - size</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 64位全部可用，直接累加</span></span><br><span class="line">        size += <span class="number">64</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不够</span></span><br><span class="line">    <span class="keyword">if</span> size &lt; <span class="type">uint</span>(npages) &#123;</span><br><span class="line">        <span class="keyword">return</span> ^<span class="type">uint</span>(<span class="number">0</span>), newSearchIdx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 够了</span></span><br><span class="line">    <span class="keyword">return</span> start, newSearchIdx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出连续n个1的起始位置（64个位），找不到返回64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBitRange64</span><span class="params">(c <span class="type">uint64</span>, n <span class="type">uint</span>)</span></span> <span class="type">uint</span> &#123;</span><br><span class="line">    <span class="comment">// 这个方法的神奇之处就是能够快速找出连续n个1的起始位置（64个位）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余位，每次循环后减k，k的范围：1,2,4,8,...</span></span><br><span class="line">    p := n - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 丢弃位的数量，每次循环后翻倍，取值范围：1,2,4,8...</span></span><br><span class="line">    k := <span class="type">uint</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一共会丢弃n-1个位</span></span><br><span class="line">    <span class="keyword">for</span> p &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 要保证k&lt;p</span></span><br><span class="line">        <span class="keyword">if</span> p &lt;= k &#123;</span><br><span class="line">            c &amp;= c &gt;&gt; (p &amp; <span class="number">63</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 丢弃k个位，如果有x个连续的1，经过这个操作，x-=k</span></span><br><span class="line">        c &amp;= c &gt;&gt; (k &amp; <span class="number">63</span>)</span><br><span class="line">        <span class="comment">// 还没操作完，但c已经为0了，表示连续的1数量不足以容纳n</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">64</span></span><br><span class="line">        &#125;</span><br><span class="line">        p -= k</span><br><span class="line">        <span class="comment">// 丢弃位的数量翻倍</span></span><br><span class="line">        k *= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时c内第一个1就是连续n个页的起始位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint</span>(sys.TrailingZeros64(c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *pallocBits)</span></span> summarize() pallocSum &#123;</span><br><span class="line">    <span class="comment">// 前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line">    <span class="keyword">var</span> start, most, cur <span class="type">uint</span></span><br><span class="line">    <span class="comment">// 特殊值</span></span><br><span class="line">    <span class="keyword">const</span> notSetYet = ^<span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">    start = notSetYet</span><br><span class="line">    <span class="comment">// 8个uint64，bitmap中1为已使用，0为未使用</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">        <span class="comment">// 第i个uint64</span></span><br><span class="line">        x := b[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 64个页均未使用</span></span><br><span class="line">            cur += <span class="number">64</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 64个页中有已使用的页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二进制数x尾部0个数</span></span><br><span class="line">        t := <span class="type">uint</span>(sys.TrailingZeros64(x))</span><br><span class="line">        <span class="comment">// 二进制数x头部0个数</span></span><br><span class="line">        l := <span class="type">uint</span>(sys.LeadingZeros64(x))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累计cur+t个页（未使用）</span></span><br><span class="line">        cur += t</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start为初始值，需要更新</span></span><br><span class="line">        <span class="keyword">if</span> start == notSetYet &#123;</span><br><span class="line">            <span class="comment">// 出现已使用的页，纪录该页的索引</span></span><br><span class="line">            start = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连续的未使用页数最大值</span></span><br><span class="line">        most = max(most, cur)</span><br><span class="line">        <span class="comment">// l累计到下一个uint64</span></span><br><span class="line">        cur = l</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 512个页都未被使用</span></span><br><span class="line">    <span class="keyword">if</span> start == notSetYet &#123;</span><br><span class="line">        <span class="comment">// n=512</span></span><br><span class="line">        <span class="keyword">const</span> n = <span class="type">uint</span>(<span class="number">64</span> * <span class="built_in">len</span>(b))</span><br><span class="line">        <span class="comment">// |0|512|512|512|</span></span><br><span class="line">        <span class="keyword">return</span> packPallocSum(n, n, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有使用的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得出最后的most</span></span><br><span class="line">    most = max(most, cur)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连续未分配页数量最大值超过62，就算 1xxxxx1 内部有0也不可能超过这个数</span></span><br><span class="line">    <span class="keyword">if</span> most &gt;= <span class="number">64</span><span class="number">-2</span> &#123;</span><br><span class="line">        <span class="comment">// |0|cur|most|start|</span></span><br><span class="line">        <span class="keyword">return</span> packPallocSum(start, most, cur)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，所有的uint64都不可能为0， 1xxxxx1 内部搜索连续0的数量，如果比most大，则更新most</span></span><br><span class="line"></span><br><span class="line">outer:</span><br><span class="line">    <span class="comment">// 重新扫描</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">        x := b[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 示例：000000 1xxxxx1 000000</span></span><br><span class="line">        <span class="comment">// 需要确保 1xxxxx1 内部没有连续0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 丢弃所有低位的0</span></span><br><span class="line">        x &gt;&gt;= sys.TrailingZeros64(x) &amp; <span class="number">63</span></span><br><span class="line">        <span class="keyword">if</span> x&amp;(x+<span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 内部没有0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部有0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩余量=连续0最大值</span></span><br><span class="line">        p := most</span><br><span class="line">        <span class="comment">// 1的数量</span></span><br><span class="line">        k := <span class="type">uint</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> p &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> p &lt;= k &#123;</span><br><span class="line">                    <span class="comment">// 用高位的p个1向右移位覆盖内部的0</span></span><br><span class="line">                    x |= x &gt;&gt; (p &amp; <span class="number">63</span>)</span><br><span class="line">                    <span class="keyword">if</span> x&amp;(x+<span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 内部0数量&lt;most，扫描下一组</span></span><br><span class="line">                        <span class="keyword">continue</span> outer</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 内部0数量超过most</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 用高位的k个1向右移位覆盖内部的0</span></span><br><span class="line">                x |= x &gt;&gt; (k &amp; <span class="number">63</span>)</span><br><span class="line">                <span class="keyword">if</span> x&amp;(x+<span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 内部0数量&lt;most，扫描下一组</span></span><br><span class="line">                    <span class="keyword">continue</span> outer</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 剩余量</span></span><br><span class="line">                p -= k</span><br><span class="line">                <span class="comment">// k翻倍</span></span><br><span class="line">                k *= <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内部0数量超过most</span></span><br><span class="line"></span><br><span class="line">            j := <span class="type">uint</span>(sys.TrailingZeros64(^x)) <span class="comment">// 尾部1的数量</span></span><br><span class="line">            x &gt;&gt;= j &amp; <span class="number">63</span>                       <span class="comment">// 丢弃尾部1</span></span><br><span class="line">            j = <span class="type">uint</span>(sys.TrailingZeros64(x))   <span class="comment">// 尾部0的数量</span></span><br><span class="line">            x &gt;&gt;= j &amp; <span class="number">63</span>                       <span class="comment">// 丢弃尾部0</span></span><br><span class="line">            most += j                          <span class="comment">// most+j就是 1xxxxx1 内部连续0的其中一个值</span></span><br><span class="line">            <span class="keyword">if</span> x&amp;(x+<span class="number">1</span>) == <span class="number">0</span> &#123;                  <span class="comment">// 没有其他0了，扫描下一组</span></span><br><span class="line">                <span class="keyword">continue</span> outer</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比如 1xxxxx1 内部连续0的数量有6、5两种情况，而most为4，只计算到了5，6没有计算到</span></span><br><span class="line">            p = j <span class="comment">// 剩余量从j开始</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// |0|cur|most|start|</span></span><br><span class="line">    <span class="keyword">return</span> packPallocSum(start, most, cur)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GC助攻-1"><a href="#GC助攻-1" class="headerlink" title="GC助攻"></a>GC助攻</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 降低g的Assist额度，如果额度用光了，则g需要协助GC标记（g会被挂起）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deductAssistCredit</span><span class="params">(size <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    assistG := getg()</span><br><span class="line">    <span class="comment">// 重复，避免当前g是调度的g0</span></span><br><span class="line">    <span class="keyword">if</span> assistG.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">        assistG = assistG.m.curg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 额度-=size</span></span><br><span class="line">    assistG.gcAssistBytes -= <span class="type">int64</span>(size)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 额度用光了</span></span><br><span class="line">    <span class="keyword">if</span> assistG.gcAssistBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 协助GC标记，全局额度bgScanCredit有数据则偷额度，没有则协助标记还债，还不清则挂起等待</span></span><br><span class="line">        gcAssistAlloc(assistG)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配内存时，如果sweeper还在清扫中且分配速度比清扫速度快，则协助sweeper清扫</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deductSweepCredit</span><span class="params">(spanBytes <span class="type">uintptr</span>, callerSweepPages <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 清扫完毕</span></span><br><span class="line">    <span class="keyword">if</span> mheap_.sweepPagesPerByte == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还在清扫中</span></span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// pagesSwept快照-已完成清扫的页数量（标记终止阶段时纪录）</span></span><br><span class="line">    sweptBasis := mheap_.pagesSweptBasis.Load()</span><br><span class="line">    <span class="comment">// heap存活字节数（标记终止阶段纪录或分配内存时调整）</span></span><br><span class="line">    live := gcController.heapLive.Load()</span><br><span class="line">    <span class="comment">// heapLive快照（标记终止阶段时纪录）</span></span><br><span class="line">    liveBasis := mheap_.sweepHeapLiveBasis</span><br><span class="line">    <span class="comment">// mspan字节数</span></span><br><span class="line">    newHeapLive := spanBytes</span><br><span class="line">    <span class="comment">// 一般情况下heapLive&gt;=sweepHeapLiveBasis</span></span><br><span class="line">    <span class="keyword">if</span> liveBasis &lt; live &#123;</span><br><span class="line">        <span class="comment">// 累加内存分配时增加的字节数</span></span><br><span class="line">        newHeapLive += <span class="type">uintptr</span>(live - liveBasis)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标页数=每分配1字节需要清扫的页数*总字节数-n个页</span></span><br><span class="line">    pagesTarget := <span class="type">int64</span>(mheap_.sweepPagesPerByte*<span class="type">float64</span>(newHeapLive)) - <span class="type">int64</span>(callerSweepPages)</span><br><span class="line">    <span class="comment">// 目标页数 &gt; sweeper清扫的页总数 =&gt; 短时间内分配大量内存</span></span><br><span class="line">    <span class="keyword">for</span> pagesTarget &gt; <span class="type">int64</span>(mheap_.pagesSwept.Load()-sweptBasis) &#123;</span><br><span class="line">        <span class="comment">// 不断的逐个清扫mspan</span></span><br><span class="line">        <span class="keyword">if</span> sweepone() == ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// sweeper清扫完了</span></span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sweeper还没清扫完</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// GCPercent/MemoryLimit有变动</span></span><br><span class="line">        <span class="keyword">if</span> mheap_.pagesSweptBasis.Load() != sweptBasis &#123;</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">goto</span> retry</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协助GC标记，全局额度bgScanCredit有数据则偷额度，没有则协助标记还债，还不清则挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcAssistAlloc</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// g0不可被抢占</span></span><br><span class="line">    <span class="keyword">if</span> getg() == gp.m.g0 &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被抢占</span></span><br><span class="line">    <span class="keyword">if</span> mp := getg().m; mp.locks &gt; <span class="number">0</span> || mp.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        sg := gp.syncGroup</span><br><span class="line">        gp.syncGroup = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            gp.syncGroup = sg</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要协助GC标记</span></span><br><span class="line">    enteredMarkAssistForTracing := <span class="literal">false</span></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// CPU限制GC使用</span></span><br><span class="line">    <span class="keyword">if</span> gcCPULimiter.limiting() &#123;</span><br><span class="line">        <span class="comment">// 如果先前已经协助GC标记</span></span><br><span class="line">        <span class="keyword">if</span> enteredMarkAssistForTracing &#123;</span><br><span class="line">            <span class="comment">// 不协助GC标记，降低GC对CPU的使用（trace相关的代码我删了）</span></span><br><span class="line">            gp.inMarkAssist = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不限制</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换参数</span></span><br><span class="line">    assistWorkPerByte := gcController.assistWorkPerByte.Load()</span><br><span class="line">    assistBytesPerWork := gcController.assistBytesPerWork.Load()</span><br><span class="line">    <span class="comment">// 额度/欠债，此时gcAssistBytes为负数</span></span><br><span class="line">    debtBytes := -gp.gcAssistBytes</span><br><span class="line">    <span class="comment">// 任务量</span></span><br><span class="line">    scanWork := <span class="type">int64</span>(assistWorkPerByte * <span class="type">float64</span>(debtBytes))</span><br><span class="line">    <span class="comment">// 最低64K</span></span><br><span class="line">    <span class="keyword">if</span> scanWork &lt; gcOverAssistWork &#123;</span><br><span class="line">        <span class="comment">// 设置为64K</span></span><br><span class="line">        scanWork = gcOverAssistWork</span><br><span class="line">        <span class="comment">// 总欠债</span></span><br><span class="line">        debtBytes = <span class="type">int64</span>(assistBytesPerWork * <span class="type">float64</span>(scanWork))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局扫描额度</span></span><br><span class="line">    bgScanCredit := gcController.bgScanCredit.Load()</span><br><span class="line">    stolen := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 全局额度还有一定数量</span></span><br><span class="line">    <span class="keyword">if</span> bgScanCredit &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> bgScanCredit &lt; scanWork &#123;</span><br><span class="line">            <span class="comment">// 剩余额度不足</span></span><br><span class="line">            <span class="comment">// 剩余的全部拿走</span></span><br><span class="line">            stolen = bgScanCredit</span><br><span class="line">            <span class="comment">// 调整欠债</span></span><br><span class="line">            gp.gcAssistBytes += <span class="number">1</span> + <span class="type">int64</span>(assistBytesPerWork*<span class="type">float64</span>(stolen))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 剩余额度充足</span></span><br><span class="line">            <span class="comment">// 一次解决欠债</span></span><br><span class="line">            stolen = scanWork</span><br><span class="line">            gp.gcAssistBytes += debtBytes</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 经过上面的操作，gcAssistBytes可能为正</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局扫描额度更新，并发情况下，可能为负数</span></span><br><span class="line">        gcController.bgScanCredit.Add(-stolen)</span><br><span class="line"></span><br><span class="line">        scanWork -= stolen</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偷走的额度跟欠债一致</span></span><br><span class="line">        <span class="keyword">if</span> scanWork == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果先前已经协助GC标记</span></span><br><span class="line">            <span class="keyword">if</span> enteredMarkAssistForTracing &#123;</span><br><span class="line">                <span class="comment">// 不协助GC标记，降低GC对CPU的使用（trace相关的代码我删了）</span></span><br><span class="line">                gp.inMarkAssist = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还有欠债</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有额度 或 额度不足以偿还</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有欠债，且没有协助GC标记过（洗盘子还债去吧）</span></span><br><span class="line">    <span class="keyword">if</span> !enteredMarkAssistForTracing &#123;</span><br><span class="line">        <span class="comment">// 有欠债，需要协助GC标记（trace相关的代码我删了）</span></span><br><span class="line">        gp.inMarkAssist = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 设置为true，进入协助标记流程</span></span><br><span class="line">        enteredMarkAssistForTracing = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到g0运行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 协助GC标记</span></span><br><span class="line">        gcAssistAlloc1(gp, scanWork)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是最后一个mark worker，param为当前g的指针</span></span><br><span class="line">    completed := gp.param != <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// mark已结束</span></span><br><span class="line">    <span class="keyword">if</span> completed &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        gcMarkDone()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仍有欠债</span></span><br><span class="line">    <span class="keyword">if</span> gp.gcAssistBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 偷不到额度，也没有完成足够的任务偿还欠债</span></span><br><span class="line">        <span class="comment">// 被抢占</span></span><br><span class="line">        <span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">            <span class="comment">// 同协程yield关键字，当前g让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">            Gosched()</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">goto</span> retry</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局bgScanCredit没有额度则把g放到assist队列并挂起休眠，否则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> !gcParkAssist() &#123;</span><br><span class="line">            <span class="comment">// 有额度，不挂起休眠</span></span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">goto</span> retry</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有新的额度，被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果先前已经协助GC标记 =&gt; return前把相关字段复原</span></span><br><span class="line">    <span class="keyword">if</span> enteredMarkAssistForTracing &#123;</span><br><span class="line">        <span class="comment">// 不协助GC标记，降低GC对CPU的使用（trace相关的代码我删了）</span></span><br><span class="line">        gp.inMarkAssist = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协助GC标记</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcAssistAlloc1</span><span class="params">(gp *g, scanWork <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 重置，需要利用param字段传递数据</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC未启动/停止</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;gcBlackenEnabled) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 欠债归0</span></span><br><span class="line">        gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始时刻</span></span><br><span class="line">    startTime := nanotime()</span><br><span class="line">    <span class="comment">// stamp存储limiterEventMarkAssist和startTime</span></span><br><span class="line">    trackLimiterEvent := gp.m.p.ptr().limiterEvent.start(limiterEventMarkAssist, startTime)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动worker，计数器减1</span></span><br><span class="line">    decnwait := atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 异常，nproc始终&gt;=nwait</span></span><br><span class="line">    <span class="keyword">if</span> decnwait == work.nproc &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: work.nwait =&quot;</span>, decnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">        throw(<span class="string">&quot;nwait &gt; work.nprocs&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">    casGToWaitingForGC(gp, _Grunning, waitReasonGCAssistMarking)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf</span></span><br><span class="line">    gcw := &amp;getg().m.p.ptr().gcw</span><br><span class="line">    <span class="comment">// 从本地队列获取并扫描灰色对象，或扫描根对象，直到达到指定额度</span></span><br><span class="line">    <span class="comment">// （workDone可能大于scanWork，也可能因为mark阶段结束而小于scanWork）</span></span><br><span class="line">    workDone := gcDrainN(gcw, scanWork)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Gwaiting状态改为_Grunning（非_Grunnable）</span></span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换参数</span></span><br><span class="line">    assistBytesPerWork := gcController.assistBytesPerWork.Load()</span><br><span class="line">    <span class="comment">// 额度调整，这里加1是向上取整</span></span><br><span class="line">    gp.gcAssistBytes += <span class="number">1</span> + <span class="type">int64</span>(assistBytesPerWork*<span class="type">float64</span>(workDone))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复原，worker计数器加1</span></span><br><span class="line">    incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 异常，nproc始终&gt;=nwait</span></span><br><span class="line">    <span class="keyword">if</span> incnwait &gt; work.nproc &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: work.nwait=&quot;</span>, incnwait,</span><br><span class="line">            <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">        throw(<span class="string">&quot;work.nwait &gt; work.nproc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列为空（最后一个mark worker） and 没有标记任务可以执行</span></span><br><span class="line">    <span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 指针</span></span><br><span class="line">        gp.param = unsafe.Pointer(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 耗时</span></span><br><span class="line">    duration := now - startTime</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line">    <span class="comment">// 累计到gcAssistTime</span></span><br><span class="line">    pp.gcAssistTime += duration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> trackLimiterEvent &#123;</span><br><span class="line">        <span class="comment">// 重置stamp字段，纪录耗时</span></span><br><span class="line">        pp.limiterEvent.stop(limiterEventMarkAssist, now)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt; 5000ns =&gt; gcAssistTime每达到5000ns则刷新到全局计数器里</span></span><br><span class="line">    <span class="keyword">if</span> pp.gcAssistTime &gt; gcAssistTimeSlack &#123;</span><br><span class="line">        <span class="comment">// 累计到全局GC助攻累计耗时</span></span><br><span class="line">        gcController.assistTime.Add(pp.gcAssistTime)</span><br><span class="line">        <span class="comment">// 尝试加锁并调用updateLocked</span></span><br><span class="line">        gcCPULimiter.update(now)</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        pp.gcAssistTime = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局bgScanCredit没有额度则把g放到assist队列并挂起休眠，否则直接返回</span></span><br><span class="line"><span class="comment">// 与gcFlushBgCredit成对使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcParkAssist</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    lock(&amp;work.assistQueue.lock)</span><br><span class="line">    <span class="comment">// GC未启动/停止</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;gcBlackenEnabled) == <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;work.assistQueue.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 快照</span></span><br><span class="line">    oldList := work.assistQueue.q</span><br><span class="line">    <span class="comment">// 当前g放到队列末尾</span></span><br><span class="line">    work.assistQueue.q.pushBack(gp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有额度</span></span><br><span class="line">    <span class="keyword">if</span> gcController.bgScanCredit.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 用快照恢复队列（是否会有并发问题？）</span></span><br><span class="line">        work.assistQueue.q = oldList</span><br><span class="line">        <span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> oldList.tail != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// next指针置为nil</span></span><br><span class="line">            oldList.tail.ptr().schedlink.set(<span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;work.assistQueue.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有额度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前g让出CPU，g0执行调度运行其他g（在内部g、m解除绑定后会解锁lock）</span></span><br><span class="line">    goparkunlock(&amp;work.assistQueue.lock, waitReasonGCAssistWait, traceBlockGCMarkAssist, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcmarknewobject</span><span class="params">(span *mspan, obj <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> useCheckmark &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcmarknewobject called while doing checkmark&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应该在mark阶段</span></span><br><span class="line">    <span class="keyword">if</span> gcphase == _GCmarktermination &#123;</span><br><span class="line">        throw(<span class="string">&quot;mallocgc called with gcphase == _GCmarktermination&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset-对象在mspan内的位置</span></span><br><span class="line">    objIndex := span.objIndex(obj)</span><br><span class="line">    <span class="comment">// 返回对象在gcmarkBits的字节索引和字节内offset</span></span><br><span class="line">    <span class="comment">// 设置该位（gcmarkBits指定字节、指定位设置为1）</span></span><br><span class="line">    span.markBitsForIndex(objIndex).setMarked()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记mspan</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过地址计算出heapArena、页起始索引、页起始位</span></span><br><span class="line">    arena, pageIdx, pageMask := pageIndexOf(span.base())</span><br><span class="line">    <span class="comment">// 未设置</span></span><br><span class="line">    <span class="keyword">if</span> arena.pageMarks[pageIdx]&amp;pageMask == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 汇编，按位或，看起来只有第一个页有设置</span></span><br><span class="line">        atomic.Or8(&amp;arena.pageMarks[pageIdx], pageMask)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p.gcw</span></span><br><span class="line">    gcw := &amp;getg().m.p.ptr().gcw</span><br><span class="line">    gcw.bytesMarked += <span class="type">uint64</span>(span.elemsize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OS内存申请"><a href="#OS内存申请" class="headerlink" title="OS内存申请"></a>OS内存申请</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向系统申请内存，返回对齐后的内存地址和大小，对齐后剩余的量全部释放回系统</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserveAligned</span><span class="params">(v unsafe.Pointer, size, align <span class="type">uintptr</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// wasm（isSbrkPlatform默认为false）</span></span><br><span class="line">    <span class="keyword">if</span> isSbrkPlatform &#123;</span><br><span class="line">        <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;unexpected heap arena hint on sbrk platform&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sysReserveAlignedSbrk(size, align)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// windows才有，忽略</span></span><br><span class="line">    retries := <span class="number">0</span></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 向系统申请内存（Reserved）</span></span><br><span class="line">    p := <span class="type">uintptr</span>(sysReserve(v, size+align))</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> p == <span class="number">0</span>: <span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> p&amp;(align<span class="number">-1</span>) == <span class="number">0</span>: <span class="comment">// 已对齐</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(p), size + align</span><br><span class="line">    <span class="keyword">case</span> GOOS == <span class="string">&quot;windows&quot;</span>: <span class="comment">// 忽略</span></span><br><span class="line">        sysFreeOS(unsafe.Pointer(p), size+align)</span><br><span class="line">        p = alignUp(p, align)</span><br><span class="line">        p2 := sysReserve(unsafe.Pointer(p), size)</span><br><span class="line">        <span class="keyword">if</span> p != <span class="type">uintptr</span>(p2) &#123;</span><br><span class="line">            sysFreeOS(p2, size)</span><br><span class="line">            <span class="keyword">if</span> retries++; retries == <span class="number">100</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;failed to allocate aligned heap memory; too many retries&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> retry</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2, size</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 其他情况</span></span><br><span class="line">        <span class="comment">// p按align的倍数向上取整</span></span><br><span class="line">        pAligned := alignUp(p, align)</span><br><span class="line">        <span class="comment">// p和pAligned的间隔部份释放回系统</span></span><br><span class="line">        sysFreeOS(unsafe.Pointer(p), pAligned-p)</span><br><span class="line">        <span class="comment">// end</span></span><br><span class="line">        end := pAligned + size</span><br><span class="line">        <span class="comment">// 申请内存的end跟实际end的间隔（align剩余部份）</span></span><br><span class="line">        endLen := (p + size + align) - end</span><br><span class="line">        <span class="keyword">if</span> endLen &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// align剩余部份也释放回系统</span></span><br><span class="line">            sysFreeOS(unsafe.Pointer(end), endLen)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(pAligned), size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用sysAlloc向系统申请size大小的内存（Ready），按align倍数向上取整，统计</span></span><br><span class="line"><span class="comment">// 超过64KB直接向系统申请，未超过64KB则一次性申请256KB内存后再分配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">persistentalloc</span><span class="params">(size, align <span class="type">uintptr</span>, sysStat *sysMemStat)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="keyword">var</span> p *notInHeap</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 申请size大小的内存，按align倍数向上取整，统计</span></span><br><span class="line">        p = persistentalloc1(size, align, sysStat)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用sysAlloc向系统申请size大小的内存（Ready），按align倍数向上取整，统计</span></span><br><span class="line"><span class="comment">// 超过64KB直接向系统申请，未超过64KB则一次性申请256KB内存后再分配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">persistentalloc1</span><span class="params">(size, align <span class="type">uintptr</span>, sysStat *sysMemStat)</span></span> *notInHeap &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        <span class="comment">// 64KB</span></span><br><span class="line">        maxBlock = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size不能为0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;persistentalloc: size == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> align != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 2的倍数</span></span><br><span class="line">        <span class="keyword">if</span> align&amp;(align<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;persistentalloc: align is not a power of 2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能大于8K</span></span><br><span class="line">        <span class="keyword">if</span> align &gt; _PageSize &#123;</span><br><span class="line">            throw(<span class="string">&quot;persistentalloc: align is too large&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 默认8字节对齐</span></span><br><span class="line">        align = <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过64KB</span></span><br><span class="line">    <span class="keyword">if</span> size &gt;= maxBlock &#123;</span><br><span class="line">        <span class="comment">// 直接向系统申请size大小内存（Ready）</span></span><br><span class="line">        <span class="keyword">return</span> (*notInHeap)(sysAlloc(size, sysStat))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未超过64KB</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="keyword">var</span> persistent *persistentAlloc</span><br><span class="line">    <span class="comment">// p不为空</span></span><br><span class="line">    <span class="keyword">if</span> mp != <span class="literal">nil</span> &amp;&amp; mp.p != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 使用p的palloc</span></span><br><span class="line">        persistent = &amp;mp.p.ptr().palloc</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用全局alloc</span></span><br><span class="line">        lock(&amp;globalAlloc.mutex)</span><br><span class="line">        persistent = &amp;globalAlloc.persistentAlloc</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// offset按align（默认8字节）的倍数向上取整</span></span><br><span class="line">    persistent.off = alignUp(persistent.off, align)</span><br><span class="line">    <span class="comment">// offset+size超过256KB or base为nil</span></span><br><span class="line">    <span class="keyword">if</span> persistent.off+size &gt; persistentChunkSize || persistent.base == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接向系统申请256KB大小的内存（Ready）</span></span><br><span class="line">        persistent.base = (*notInHeap)(sysAlloc(persistentChunkSize, &amp;memstats.other_sys))</span><br><span class="line">        <span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">if</span> persistent.base == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> persistent == &amp;globalAlloc.persistentAlloc &#123;</span><br><span class="line">                unlock(&amp;globalAlloc.mutex)</span><br><span class="line">            &#125;</span><br><span class="line">            throw(<span class="string">&quot;runtime: cannot allocate memory&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请成功</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 旧块：persistentAlloc全局变量指针</span></span><br><span class="line">            chunks := <span class="type">uintptr</span>(unsafe.Pointer(persistentChunks))</span><br><span class="line">            <span class="comment">// 新块的开头8字节存储旧块的指针</span></span><br><span class="line">            *(*<span class="type">uintptr</span>)(unsafe.Pointer(persistent.base)) = chunks</span><br><span class="line">            <span class="comment">// 更新persistentAlloc</span></span><br><span class="line">            <span class="keyword">if</span> atomic.Casuintptr((*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;persistentChunks)), chunks, <span class="type">uintptr</span>(unsafe.Pointer(persistent.base))) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// offset=8</span></span><br><span class="line">        persistent.off = alignUp(goarch.PtrSize, align)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动8个字节指向初始地址</span></span><br><span class="line">    p := persistent.base.add(persistent.off)</span><br><span class="line">    <span class="comment">// 分配size大小的内存</span></span><br><span class="line">    persistent.off += size</span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">if</span> persistent == &amp;globalAlloc.persistentAlloc &#123;</span><br><span class="line">        unlock(&amp;globalAlloc.mutex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计</span></span><br><span class="line">    <span class="keyword">if</span> sysStat != &amp;memstats.other_sys &#123;</span><br><span class="line">        sysStat.add(<span class="type">int64</span>(size))</span><br><span class="line">        memstats.other_sys.add(-<span class="type">int64</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断地址是否在persistentChunks</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inPersistentAlloc</span><span class="params">(p <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    chunk := atomic.Loaduintptr((*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;persistentChunks)))</span><br><span class="line">    <span class="keyword">for</span> chunk != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 在chunk内存地址范围内（256KB）</span></span><br><span class="line">        <span class="keyword">if</span> p &gt;= chunk &amp;&amp; p &lt; chunk+persistentChunkSize &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找下一个chunk</span></span><br><span class="line">        chunk = *(*<span class="type">uintptr</span>)(unsafe.Pointer(chunk))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="profile相关"><a href="#profile相关" class="headerlink" title="profile相关"></a>profile相关</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回堆分析的下一个采样点（随机数：[0,MemProfileRate)）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextSample</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> MemProfileRate == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 永不采样</span></span><br><span class="line">        <span class="keyword">return</span> maxInt64</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> MemProfileRate == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 立刻采样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">if</span> GOOS == <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// plan9在note handler不支持浮点数</span></span><br><span class="line">        <span class="keyword">if</span> gp := getg(); gp == gp.m.gsignal &#123;</span><br><span class="line">            <span class="keyword">return</span> nextSampleNoFP()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(fastexprand(MemProfileRate))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">profilealloc</span><span class="params">(mp *m, x unsafe.Pointer, size <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;profilealloc called without a P or outside bootstrapping&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置，默认512KB，可以通过GODEBUG修改</span></span><br><span class="line">    c.memProfRate = MemProfileRate</span><br><span class="line">    <span class="comment">// 返回堆分析的下一个采样点（随机数：[0,MemProfileRate)）</span></span><br><span class="line">    c.nextSample = nextSample()</span><br><span class="line">    <span class="comment">// 记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">    mProf_Malloc(mp, x, size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存区域批量清0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memclrNoHeapPointersChunked</span><span class="params">(size <span class="type">uintptr</span>, x unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    v := <span class="type">uintptr</span>(x)</span><br><span class="line">    <span class="comment">// 按批次清0，每批256KB</span></span><br><span class="line">    <span class="keyword">const</span> chunkBytes = <span class="number">256</span> * <span class="number">1024</span></span><br><span class="line">    vsize := v + size</span><br><span class="line">    <span class="keyword">for</span> voff := v; voff &lt; vsize; voff = voff + chunkBytes &#123;</span><br><span class="line">        <span class="comment">// 被抢占</span></span><br><span class="line">        <span class="keyword">if</span> getg().preempt &#123;</span><br><span class="line">            <span class="comment">// 可能持有锁</span></span><br><span class="line">            goschedguarded()</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将min(avail, lump)个字节清0</span></span><br><span class="line">        n := vsize - voff</span><br><span class="line">        <span class="keyword">if</span> n &gt; chunkBytes &#123;</span><br><span class="line">            n = chunkBytes</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 内存区域清0（只有你知道该区域不存在指针才能调用）</span></span><br><span class="line">        memclrNoHeapPointers(unsafe.Pointer(voff), n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://medium.com/safetycultureengineering/an-overview-of-memory-management-in-go-9a72ec7c76a8">An overview of memory management in Go</a><br><a target="_blank" rel="noopener" href="https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">A visual guide to Go Memory Allocator from scratch (Golang)</a><br><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">Go: Memory Management and Allocation</a><br><a target="_blank" rel="noopener" href="https://andrestc.com/post/go-memory-allocation-pt1/">Go’s Memory Allocator - Overview</a><br><a target="_blank" rel="noopener" href="https://deepu.tech/memory-management-in-golang/">Visualizing memory management in Golang</a><br><a target="_blank" rel="noopener" href="https://about.sourcegraph.com/blog/go/gophercon-2018-allocator-wrestling">GopherCon 2018 - Allocator Wrestling</a><br><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">7.1 内存分配器</a><br><a target="_blank" rel="noopener" href="https://agis.io/post/contiguous-stacks-golang/">Contiguous stacks in Go</a><br><a target="_blank" rel="noopener" href="https://medium.com/@kai.chihkaiyu/golang-memory-management-based-on-1-12-5-51fcc97f3c92">Golang Memory Management (based on 1.12.5)</a><br><a target="_blank" rel="noopener" href="https://mhh12121.github.io/2020/02/24/Go/memManage/">Golang Memory Allocator</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/golang-series-bootstrap-and-gmp-model/" rel="prev" title="golang系列之-程序运行流程及GMP模型">
                  <i class="fa fa-angle-left"></i> golang系列之-程序运行流程及GMP模型
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">y2k38</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">133k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Y2k38/y2k38.github.io","repo_id":"R_kgDOMZGvZA","category":"Announcements","category_id":"DIC_kwDOMZGvZM4CirXX","mapping":"pathname","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"preferred_color_scheme","lang":"zh-CN","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
