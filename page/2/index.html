<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"y2k38.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="个人笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="noname">
<meta property="og:url" content="https://y2k38.github.io/page/2/index.html">
<meta property="og:site_name" content="noname">
<meta property="og:description" content="个人笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="y2k38">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://y2k38.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>noname</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">noname</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">y2k38</p>
  <div class="site-description" itemprop="description">个人笔记</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-sync-waitgroup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-sync-waitgroup/" class="post-title-link" itemprop="url">golang系列之-sync.Waitgroup</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-16 20:48:45" itemprop="dateCreated datePublished" datetime="2025-02-16T20:48:45+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-20 08:31:21" itemprop="dateModified" datetime="2025-02-20T08:31:21+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>714</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>并发情况下，如果需要等待所有的goroutine完成任务，需要使用Waitgroup等待</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>先简单列举一个使用案例，了解Waitgroup的使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d starting\n&quot;</span>, id)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// counter++</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// counter--</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            worker(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码执行后，系统输出如下，可以看到系统等待5个goroutine完成任务后才退出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># Worker 5 starting</span></span><br><span class="line"><span class="comment"># Worker 2 starting</span></span><br><span class="line"><span class="comment"># Worker 1 starting</span></span><br><span class="line"><span class="comment"># Worker 3 starting</span></span><br><span class="line"><span class="comment"># Worker 4 starting</span></span><br><span class="line"><span class="comment"># Worker 4 done</span></span><br><span class="line"><span class="comment"># Worker 5 done</span></span><br><span class="line"><span class="comment"># Worker 2 done</span></span><br><span class="line"><span class="comment"># Worker 3 done</span></span><br><span class="line"><span class="comment"># Worker 1 done</span></span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>Waitgroup的数据结构由noCopy、state、sema三个字段组成，其中state是goroutine、waiter的计数器，sema使waiter陷入等待</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    state atomic.Uint64 <span class="comment">// high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line">    sema  <span class="type">uint32</span>        <span class="comment">// semaphore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>state的高32位：正在运行中的goroutine数量<br>state低低32为：等待中的goroutine数量</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>WaitGroup只提供了Add、Done、Wait三个方法</p>
<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>Add方法的大概逻辑如下</p>
<ol>
<li>counter+&#x3D;delta</li>
<li>counter小于0，数值异常</li>
<li>发现goroutine出现并发调用Add、Wait，异常</li>
<li>有正在运行的goroutine或者没有等待的goroutine，返回（成功）</li>
<li>唤醒所有等待中的goroutine</li>
</ol>
<p>具体源代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) &#123;</span><br><span class="line">    state := wg.state.Add(<span class="type">uint64</span>(delta) &lt;&lt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">// counter：还在运行中的goroutine数量</span></span><br><span class="line">    w := <span class="type">uint32</span>(state)      <span class="comment">// waiter_counter：等待中的goroutine数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// counter不能为负，只能大于等于0</span></span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常，这个场景不好想象，先忽略</span></span><br><span class="line">    <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="type">int32</span>(delta) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有正在运行的goroutine or 没有等待的goroutine</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有等待中的goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> wg.state.Load() != state &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性将waiter_counter清零</span></span><br><span class="line">    wg.state.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有等待中的goroutine</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(&amp;wg.sema, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h3><p>Done方法时add方法的一种封装，不多介绍，见Add</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter--</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() &#123;</span><br><span class="line">    wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><p>Wait本质是一个无限循环，一直等待sema释放</p>
<ol>
<li>counter&#x3D;&#x3D;0，不需要等待，返回</li>
<li>waiter_counter++，当前goroutine挂起等待</li>
<li>被唤醒后直接返回</li>
</ol>
<p>具体源代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait blocks until the [WaitGroup] counter is zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := wg.state.Load()</span><br><span class="line"></span><br><span class="line">        v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)     <span class="comment">// counter：还在运行中的goroutine数量</span></span><br><span class="line">        w := <span class="type">uint32</span>(state)          <span class="comment">// waiter_counter：等待中的goroutine数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有在运行中的goroutine，不需要等待</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// waiter_counter++</span></span><br><span class="line">        <span class="keyword">if</span> wg.state.CompareAndSwap(state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 挂起等待</span></span><br><span class="line">            runtime_SemacquireWaitGroup(&amp;wg.sema)</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            <span class="keyword">if</span> wg.state.Load() != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_SemacquireWaitGroup sync.runtime_SemacquireWaitGroup</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_SemacquireWaitGroup</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	semacquire1(addr, <span class="literal">false</span>, semaBlockProfile, <span class="number">0</span>, waitReasonSyncWaitGroupWait)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://victoriametrics.com/blog/go-sync-waitgroup/index.html">Go sync.WaitGroup and The Alignment Problem</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-sync-atomic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-sync-atomic/" class="post-title-link" itemprop="url">golang系列之-sync/atomic</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-16 16:29:07" itemprop="dateCreated datePublished" datetime="2025-02-16T16:29:07+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-20 08:31:21" itemprop="dateModified" datetime="2025-02-20T08:31:21+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>sync&#x2F;atomic标准库包中提供的原子操作。原子操作是无锁的，直接通过CPU指令实现。</p>
<p>当你想要在多个goroutine中无锁访问一个变量时，就可以考虑使用atomic包提供的数据类型实现</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>以下是一个使用atomic.Uint64数据类型实现的计数器，它确保了多个goroutine按顺序正确更新数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ops atomic.Uint64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line"></span><br><span class="line">                ops.Add(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;ops:&quot;</span>, ops.Load())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><p>sync&#x2F;atomic包中，通用的数据结构有</p>
<ul>
<li><code>Value</code></li>
</ul>
<p>使用Value可以存储任意类型的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    v any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// efaceWords is interface&#123;&#125; internal representation.</span></span><br><span class="line"><span class="keyword">type</span> efaceWords <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ  unsafe.Pointer</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他具体的数据结构有</p>
<ul>
<li><code>Bool</code></li>
<li><code>Int32</code></li>
<li><code>Int64</code></li>
<li><code>Uint32</code></li>
<li><code>Uint64</code></li>
<li><code>Uintptr</code></li>
<li><code>Pointer</code></li>
</ul>
<p>举个例子，Pointer类型的数据结构如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Pointer is an atomic pointer of type *T. The zero value is a nil *T.</span></span><br><span class="line"><span class="keyword">type</span> Pointer[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Mention *T in a field to disallow conversion between Pointer types.</span></span><br><span class="line">    <span class="comment">// See go.dev/issue/56603 for more details.</span></span><br><span class="line">    <span class="comment">// Use *T, not T, to avoid spurious recursive type definition errors.</span></span><br><span class="line">    _ [<span class="number">0</span>]*T</span><br><span class="line"></span><br><span class="line">    _ noCopy</span><br><span class="line">    v unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>基本上，atomic提供的数据类型有几个通用的方法：Load、Store、Swap、CompareAndSwap</p>
<p>下面展示一个基本的使用方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init  -&gt; v=nil</span></span><br><span class="line">v := atomic.Value&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store -&gt; v=1</span></span><br><span class="line">v.Store(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// load</span></span><br><span class="line"><span class="comment">// print 1</span></span><br><span class="line">fmt.Println(v.Load())</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap  -&gt; v=2</span></span><br><span class="line"><span class="comment">// print 1</span></span><br><span class="line">fmt.Println(v.Swap(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// print 2</span></span><br><span class="line">fmt.Println(v.Load())</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS   -&gt; v=3</span></span><br><span class="line"><span class="comment">// print true</span></span><br><span class="line">fmt.Println(v.CompareAndSwap(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// print 3</span></span><br><span class="line">fmt.Println(v.Load())</span><br></pre></td></tr></table></figure>

<h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>获取atomic类型存储的数值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load returns the value set by the most recent Store.</span></span><br><span class="line"><span class="comment">// It returns nil if there has been no call to Store for this Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (val any) &#123;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">    <span class="keyword">if</span> typ == <span class="literal">nil</span> || typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">        <span class="comment">// First store not yet completed.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    data := LoadPointer(&amp;vp.data)</span><br><span class="line">    vlp := (*efaceWords)(unsafe.Pointer(&amp;val))</span><br><span class="line">    vlp.typ = typ</span><br><span class="line">    vlp.data = data</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>更新&#x2F;覆盖atomic类型的数值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store sets the value of the [Value] v to val.</span></span><br><span class="line"><span class="comment">// All calls to Store for a given Value must use values of the same concrete type.</span></span><br><span class="line"><span class="comment">// Store of an inconsistent type panics, as does Store(nil).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(val any) &#123;</span><br><span class="line">    <span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of nil value into Value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    vlp := (*efaceWords)(unsafe.Pointer(&amp;val))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Attempt to start first store.</span></span><br><span class="line">            <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">            <span class="comment">// active spin wait to wait for completion.</span></span><br><span class="line">            runtime_procPin()</span><br><span class="line">            <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">                runtime_procUnpin()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Complete first store.</span></span><br><span class="line">            StorePointer(&amp;vp.data, vlp.data)</span><br><span class="line">            StorePointer(&amp;vp.typ, vlp.typ)</span><br><span class="line">            runtime_procUnpin()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">            <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">            <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">            <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">        <span class="keyword">if</span> typ != vlp.typ &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        StorePointer(&amp;vp.data, vlp.data)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>类似Store，更新atomic类型的数值-&gt;newVal，并返回先前数值-&gt;oldVal</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap stores new into Value and returns the previous value. It returns nil if</span></span><br><span class="line"><span class="comment">// the Value is empty.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All calls to Swap for a given Value must use values of the same concrete</span></span><br><span class="line"><span class="comment">// type. Swap of an inconsistent type panics, as does Swap(nil).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Swap(<span class="built_in">new</span> any) (old any) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: swap of nil value into Value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    np := (*efaceWords)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Attempt to start first store.</span></span><br><span class="line">            <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">            <span class="comment">// active spin wait to wait for completion; and so that</span></span><br><span class="line">            <span class="comment">// GC does not see the fake type accidentally.</span></span><br><span class="line">            runtime_procPin()</span><br><span class="line">            <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">                runtime_procUnpin()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Complete first store.</span></span><br><span class="line">            StorePointer(&amp;vp.data, np.data)</span><br><span class="line">            StorePointer(&amp;vp.typ, np.typ)</span><br><span class="line">            runtime_procUnpin()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">            <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">            <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">            <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">        <span class="keyword">if</span> typ != np.typ &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: swap of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        op := (*efaceWords)(unsafe.Pointer(&amp;old))</span><br><span class="line">        op.typ, op.data = np.typ, SwapPointer(&amp;vp.data, np.data)</span><br><span class="line">        <span class="keyword">return</span> old</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h3><p>对比atomic类型当前数值，相同则更新并返回true，否则不处理并返回false</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompareAndSwap executes the compare-and-swap operation for the [Value].</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All calls to CompareAndSwap for a given Value must use values of the same</span></span><br><span class="line"><span class="comment">// concrete type. CompareAndSwap of an inconsistent type panics, as does</span></span><br><span class="line"><span class="comment">// CompareAndSwap(old, nil).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> CompareAndSwap(old, <span class="built_in">new</span> any) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of nil value into Value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    np := (*efaceWords)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">    op := (*efaceWords)(unsafe.Pointer(&amp;old))</span><br><span class="line">    <span class="keyword">if</span> op.typ != <span class="literal">nil</span> &amp;&amp; np.typ != op.typ &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of inconsistently typed values&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Attempt to start first store.</span></span><br><span class="line">            <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">            <span class="comment">// active spin wait to wait for completion; and so that</span></span><br><span class="line">            <span class="comment">// GC does not see the fake type accidentally.</span></span><br><span class="line">            runtime_procPin()</span><br><span class="line">            <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">                runtime_procUnpin()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Complete first store.</span></span><br><span class="line">            StorePointer(&amp;vp.data, np.data)</span><br><span class="line">            StorePointer(&amp;vp.typ, np.typ)</span><br><span class="line">            runtime_procUnpin()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">            <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">            <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">            <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">        <span class="keyword">if</span> typ != np.typ &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Compare old and current via runtime equality check.</span></span><br><span class="line">        <span class="comment">// This allows value types to be compared, something</span></span><br><span class="line">        <span class="comment">// not offered by the package functions.</span></span><br><span class="line">        <span class="comment">// CompareAndSwapPointer below only ensures vp.data</span></span><br><span class="line">        <span class="comment">// has not changed since LoadPointer.</span></span><br><span class="line">        data := LoadPointer(&amp;vp.data)</span><br><span class="line">        <span class="keyword">var</span> i any</span><br><span class="line">        (*efaceWords)(unsafe.Pointer(&amp;i)).typ = typ</span><br><span class="line">        (*efaceWords)(unsafe.Pointer(&amp;i)).data = data</span><br><span class="line">        <span class="keyword">if</span> i != old &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CompareAndSwapPointer(&amp;vp.data, data, np.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特定类型方法"><a href="#特定类型方法" class="headerlink" title="特定类型方法"></a>特定类型方法</h2><p>相对于其他，整型数有几个额外方法：Add、And、Or，相关类型是</p>
<ul>
<li><code>Int32</code></li>
<li><code>Int64</code></li>
<li><code>Uint32</code></li>
<li><code>Uint64</code></li>
<li><code>Uintptr</code></li>
</ul>
<p>示例代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">counter := <span class="type">int32</span>(<span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter += 1</span></span><br><span class="line">counter = atomic.AddInt32(&amp;counter, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// print 100</span></span><br><span class="line">fmt.Println(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0110 0100 &amp; 0000 0111 -&gt; 0000 0100 =&gt; 4</span></span><br><span class="line"><span class="comment">// print 100</span></span><br><span class="line">fmt.Println(atomic.AndInt32(&amp;counter, <span class="number">7</span>))</span><br><span class="line"><span class="comment">// print 4</span></span><br><span class="line">fmt.Println(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0100 | 0000 0010 -&gt; 0000 0110 =&gt; 6</span></span><br><span class="line"><span class="comment">// print 4</span></span><br><span class="line">fmt.Println(atomic.OrInt32(&amp;counter, <span class="number">2</span>))</span><br><span class="line"><span class="comment">// print 6</span></span><br><span class="line">fmt.Println(counter)</span><br></pre></td></tr></table></figure>

<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a><code>Add</code></h3><p>原子加法操作，两个数相加，返回结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/atomic/atomic_amd64.s</span></span><br><span class="line"><span class="comment">// src/sync/atomic/type.go</span></span><br><span class="line"><span class="comment">// Add atomically adds delta to x and returns the new value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int64)</span></span> Add(delta <span class="type">int64</span>) (<span class="built_in">new</span> <span class="type">int64</span>) &#123; <span class="keyword">return</span> AddInt64(&amp;x.v, delta) &#125;</span><br></pre></td></tr></table></figure>

<p>AddInt64汇编代码如下，本人对汇编代码不了解，下面的注释是由ChatGPT提供的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// uint64 Xadd64(uint64 volatile *val, int64 delta)</span><br><span class="line">// Atomically:</span><br><span class="line">//    *val += delta;</span><br><span class="line">//    return *val;</span><br><span class="line">TEXT ·Xadd64(SB), NOSPLIT, $0-24</span><br><span class="line">    MOVQ    ptr+0(FP), BX       // ptr（val 的地址）被加载到寄存器 BX 中</span><br><span class="line">    MOVQ    delta+8(FP), AX     // delta 被加载到寄存器 AX 中</span><br><span class="line">    MOVQ    AX, CX              // 复制 AX 的值到 CX，以便后面能把 delta 加到返回值中</span><br><span class="line">    LOCK                        // 确保接下来的操作是原子性的</span><br><span class="line">    XADDQ    AX, 0(BX)           // 指令会将 AX 加到 BX 指向的值，并返回加法操作前的旧值（旧值会存入 AX）</span><br><span class="line">    ADDQ    CX, AX              // 将之前存储的delta加回AX上，得到最终结果</span><br><span class="line">    MOVQ    AX, ret+16(FP)      // 把最终的结果存入返回值地址</span><br><span class="line">    RET                         // 返回</span><br><span class="line"></span><br><span class="line">TEXT ·Xaddint64(SB), NOSPLIT, $0-24</span><br><span class="line">    JMP    ·Xadd64(SB)</span><br></pre></td></tr></table></figure>

<p>更多的注释如下</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>TEXT</code></td>
<td align="left">标志这段代码是一个函数</td>
</tr>
<tr>
<td align="left"><code>·Xadd64(SB)</code></td>
<td align="left">函数名称</td>
</tr>
<tr>
<td align="left"><code>SB</code></td>
<td align="left">是指向当前函数栈帧的偏移量，传递给 racecallatomic 作为栈帧的指针。</td>
</tr>
<tr>
<td align="left"><code>NOSPLIT</code></td>
<td align="left">表示该函数不会执行栈分割，也就是说，它不会访问 Go 层的栈分配</td>
</tr>
<tr>
<td align="left"><code>$0-24</code></td>
<td align="left">指示函数参数的大小范围，在这种情况下，0-24 意味着该函数有 24 字节的局部空间（用于存储传入的参数等）</td>
</tr>
</tbody></table>
<h3 id="And"><a href="#And" class="headerlink" title="And"></a><code>And</code></h3><p>原子位与（&amp;）操作，新结果写入变量，返回旧的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// And atomically performs a bitwise AND operation on x using the bitmask</span></span><br><span class="line"><span class="comment">// provided as mask and returns the old value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int64)</span></span> And(mask <span class="type">int64</span>) (old <span class="type">int64</span>) &#123; <span class="keyword">return</span> AndInt64(&amp;x.v, mask) &#125;</span><br></pre></td></tr></table></figure>

<p>AndInt64汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT    sync∕atomic·AndInt64(SB), NOSPLIT|NOFRAME, $0-24    // </span><br><span class="line">    GO_ARGS</span><br><span class="line">    MOVQ    $__tsan_go_atomic64_fetch_and(SB), AX</span><br><span class="line">    CALL    racecallatomic&lt;&gt;(SB)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<p>相关注释如下，只展示与AddInt64汇编代码不同的部份</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>GO_ARGS</code></td>
<td align="left">这是一个宏，表示处理传入的 Go 参数，具体的参数内容会根据函数调用的上下文进行调整。这是 Go 编译器用来处理函数调用时的一些约定。它会将传入的参数从 Go 栈中提取到寄存器中</td>
</tr>
<tr>
<td align="left"><code>__tsan_go_atomic64_fetch_and</code></td>
<td align="left">是一个标识符，Go 在进行原子操作时，通常会使用一个特殊的函数来标识和追踪潜在的数据竞争。这种操作确保了线程安全，并且在并发环境中避免了出现未同步的数据访问</td>
</tr>
<tr>
<td align="left"><code>racecallatomic</code></td>
<td align="left">Go 的一个内建函数，用来执行原子操作并同时为 ThreadSanitizer（TSan）提供监控支持。它会根据 AX 寄存器中存储的函数地址（即 __tsan_go_atomic64_fetch_and）执行对应的操作</td>
</tr>
<tr>
<td align="left"><code>&lt;&gt;</code></td>
<td align="left">表示泛型类型参数，在 Go 汇编中表示函数的参数类型。racecallatomic 函数会根据这些类型参数来处理实际的原子操作。</td>
</tr>
</tbody></table>
<h3 id="Or"><a href="#Or" class="headerlink" title="Or"></a><code>Or</code></h3><p>原子位或（|）操作，新结果写入变量，返回旧的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Or atomically performs a bitwise OR operation on x using the bitmask</span></span><br><span class="line"><span class="comment">// provided as mask and returns the old value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int64)</span></span> Or(mask <span class="type">int64</span>) (old <span class="type">int64</span>) &#123; <span class="keyword">return</span> OrInt64(&amp;x.v, mask) &#125;</span><br></pre></td></tr></table></figure>

<p>OrInt64的汇编代码如下，不再展示注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT    sync∕atomic·OrInt64(SB), NOSPLIT|NOFRAME, $0-24</span><br><span class="line">    GO_ARGS</span><br><span class="line">    MOVQ    $__tsan_go_atomic64_fetch_or(SB), AX</span><br><span class="line">    CALL    racecallatomic&lt;&gt;(SB)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync/atomic">atomic</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-sync-pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-sync-pool/" class="post-title-link" itemprop="url">golang系列之-sync.Pool</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-16 14:24:10" itemprop="dateCreated datePublished" datetime="2025-02-16T14:24:10+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-20 08:31:21" itemprop="dateModified" datetime="2025-02-20T08:31:21+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>sync.Pool-临时对象池，是golang一个很关键的数据结构，通过复用历史对象，缓解因频繁创建、删除对象而导致的内存分配压力、GC压力，在社区中被广泛使用，有如go-gin、kubernetes等</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>下面展示一个简单的使用示例，用于帮助用户快速上手</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> JobState <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    JobStateFresh JobState = <span class="literal">iota</span></span><br><span class="line">    JobStateRunning</span><br><span class="line">    JobStateRecycled</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    state JobState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *Job)</span></span> Run() &#123;</span><br><span class="line">    <span class="keyword">switch</span> j.state &#123;</span><br><span class="line">    <span class="keyword">case</span> JobStateRecycled:</span><br><span class="line">        fmt.Println(<span class="string">&quot;this job came from the pool&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> JobStateFresh:</span><br><span class="line">        fmt.Println(<span class="string">&quot;this job just got allocated&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j.state = JobStateRunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个对象池</span></span><br><span class="line">    pool := &amp;sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;Job&#123;state: JobStateFresh&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个对象，可以是新建的或者是历史使用过的</span></span><br><span class="line">    job := pool.Get().(*Job)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行业务代码</span></span><br><span class="line">    job.Run()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset状态并放回池子里，方便下次使用</span></span><br><span class="line">    job.state = JobStateRecycled</span><br><span class="line">    pool.Put(job)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>sync.Pool的源代码注释被我删除了，建议自行查看源代码，简单总结如下</p>
<ol>
<li>sync.Pool用于临时对象服务存储&#x2F;获取（临时对象可能随时被清理掉）</li>
<li>sync.Pool是线程安全的</li>
<li>sync.Pool使用后不应该也不能被复制</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pool -&gt; local -&gt; poolLocal_0 -&gt; poolChainElt_0(head) -&gt; poolDequeue(2^(3+N)</span></span><br><span class="line"><span class="comment">//                                  ↕</span></span><br><span class="line"><span class="comment">//                              -&gt; poolChainElt_1       -&gt; poolDequeue(2^(3+N-1)</span></span><br><span class="line"><span class="comment">//                              -&gt; ...</span></span><br><span class="line"><span class="comment">//                              -&gt; poolChainElt_N(tail) -&gt; poolDequeue(2^3=8个数据)</span></span><br><span class="line"><span class="comment">//               -&gt; ...</span></span><br><span class="line"><span class="comment">//               -&gt; poolLocal_P</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      -&gt; victim</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/pool.go</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    local     unsafe.Pointer  <span class="comment">// 临时对象数组指针，真实结构是[P]poolLocal，每个P一个poolLocal链表</span></span><br><span class="line">    localSize <span class="type">uintptr</span>         <span class="comment">// local数组的大小，一般情况下与P的数量相同</span></span><br><span class="line">    victim     unsafe.Pointer <span class="comment">// 前local数组，被GC搬过来的</span></span><br><span class="line">    victimSize <span class="type">uintptr</span>        <span class="comment">// 前local数组的大小</span></span><br><span class="line">    New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any            <span class="comment">// New 用于创建临时对象，如果池子内没有数据的话</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">    poolLocalInternal         <span class="comment">// 实际数据存储位置-链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevents false sharing on widespread platforms with</span></span><br><span class="line">    <span class="comment">// 128 mod (cache line size) = 0 .</span></span><br><span class="line">    <span class="comment">// pad在amd64平台下是96个字节大小</span></span><br><span class="line">    pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">    private any               <span class="comment">// 单个数据，优化读写，该字段只被当前P访问</span></span><br><span class="line">    shared  poolChain         <span class="comment">// 链表，当前P读写都在头部，其他P没数据时从末尾偷</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 新的poolChainElt在head，容量是上一个poolChainElt的双倍</span></span><br><span class="line">    head *poolChainElt                      <span class="comment">// 头部 数据读写 =&gt; 1 write</span></span><br><span class="line">    tail atomic.Pointer[poolChainElt]       <span class="comment">// 尾部 数据读取 =&gt; N read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">    poolDequeue                             <span class="comment">// 数据部份-环形数组</span></span><br><span class="line">    <span class="comment">// next and prev link to the adjacent poolChainElts in this</span></span><br><span class="line">    <span class="comment">// poolChain.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// next is written atomically by the producer and read</span></span><br><span class="line">    <span class="comment">// atomically by the consumer. It only transitions from nil to</span></span><br><span class="line">    <span class="comment">// non-nil.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// prev is written atomically by the consumer and read</span></span><br><span class="line">    <span class="comment">// atomically by the producer. It only transitions from</span></span><br><span class="line">    <span class="comment">// non-nil to nil.</span></span><br><span class="line">    <span class="comment">// prev指向旧poolChainElt</span></span><br><span class="line">    <span class="comment">// next指向新poolChainElt</span></span><br><span class="line">    next, prev atomic.Pointer[poolChainElt]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ptr -&gt; | tail |      |      |      | head |     |</span></span><br><span class="line">    <span class="comment">// idx -&gt; | 0    | 1    | ...  | 98   | 99   | ... |</span></span><br><span class="line">    <span class="comment">// val -&gt; | 1    | 2    | ...  | 98   | nil  | nil |</span></span><br><span class="line">    headTail atomic.Uint64                  <span class="comment">// head(高32bit) + tail(低32bit)</span></span><br><span class="line">    vals []eface                            <span class="comment">// 环形数组 初始容量=8 =&gt; 2的乘方，最大不能超过2^30 =&gt; 1GB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里有几个全局变量用于纪录所有创建的池子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// Pool创建或者local扩容时使用</span></span><br><span class="line">    allPoolsMu Mutex</span><br><span class="line">    <span class="comment">// 所有创建的Pool都纪录到这里</span></span><br><span class="line">    allPools []*Pool</span><br><span class="line">    <span class="comment">// allPools的上一个历史版本，每次GC都会将allPools移动到oldPools</span></span><br><span class="line">    oldPools []*Pool</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>Get和Put操作都依赖的几个公共方法放在这里，可以先看后续的读写代码再回头看这部份</p>
<ol>
<li>pin - 用于绑定goroutine和P，阻止进入抢占模式，并返回pid</li>
<li>indexLocal - 获取local数组中指定的P的poolLocal索引</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pin pins the current goroutine to P, disables preemption and</span></span><br><span class="line"><span class="comment">// returns poolLocal pool for the P and the P&#x27;s id.</span></span><br><span class="line"><span class="comment">// Caller must call runtime_procUnpin() when done with the pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// pool不能为nil</span></span><br><span class="line">    <span class="comment">// Check whether p is nil to get a panic.</span></span><br><span class="line">    <span class="comment">// Otherwise the nil dereference happens while the m is pinned,</span></span><br><span class="line">    <span class="comment">// causing a fatal error rather than a panic.</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;nil Pool&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取pid</span></span><br><span class="line">    pid := runtime_procPin()</span><br><span class="line">    <span class="comment">// In pinSlow we store to local and then to localSize, here we load in opposite order.</span></span><br><span class="line">    <span class="comment">// Since we&#x27;ve disabled preemption, GC cannot happen in between.</span></span><br><span class="line">    <span class="comment">// Thus here we must observe local at least as large localSize.</span></span><br><span class="line">    <span class="comment">// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).</span></span><br><span class="line">    s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">    l := p.local                              <span class="comment">// load-consume</span></span><br><span class="line">    <span class="comment">// 正常情况或P缩小了</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">        <span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// P扩容了，池子不够大</span></span><br><span class="line">    <span class="keyword">return</span> p.pinSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// Retry under the mutex.</span></span><br><span class="line">    <span class="comment">// Can not lock the mutex while pinned.</span></span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    allPoolsMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> allPoolsMu.Unlock()</span><br><span class="line">    <span class="comment">// 重新pin</span></span><br><span class="line">    pid := runtime_procPin()</span><br><span class="line">    <span class="comment">// poolCleanup won&#x27;t be called while we are pinned.</span></span><br><span class="line">    s := p.localSize</span><br><span class="line">    l := p.local</span><br><span class="line">    <span class="comment">// 其他goroutine完成了扩容？</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">        <span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的池子，注册到allPools</span></span><br><span class="line">    <span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;</span><br><span class="line">        allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span></span><br><span class="line">    size := runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 一个P一个poolLocal</span></span><br><span class="line">    local := <span class="built_in">make</span>([]poolLocal, size)</span><br><span class="line">    atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release</span></span><br><span class="line">    runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release</span></span><br><span class="line">    <span class="keyword">return</span> &amp;local[pid], pid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// local数组索引，根据P的值定位poolLocal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexLocal</span><span class="params">(l unsafe.Pointer, i <span class="type">int</span>)</span></span> *poolLocal &#123;</span><br><span class="line">    lp := unsafe.Pointer(<span class="type">uintptr</span>(l) + <span class="type">uintptr</span>(i)*unsafe.Sizeof(poolLocal&#123;&#125;))</span><br><span class="line">    <span class="keyword">return</span> (*poolLocal)(lp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取一个对象"><a href="#获取一个对象" class="headerlink" title="获取一个对象"></a>获取一个对象</h3><p>大概逻辑如下</p>
<ol>
<li>根据P的值定位poolLocal链表</li>
<li>如果private有数值，返回该值</li>
<li>从shared(head)获取一个数据</li>
<li>从所有P的poolLocal链表找数据（从下一个P开始）<ul>
<li>从local查找              -&gt; private      -&gt; shared(tail)</li>
<li>从victim查找（只使用一次） -&gt; shared(tail)</li>
</ul>
</li>
<li>使用New方法生成一个新对象</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() any &#123;</span><br><span class="line">    <span class="comment">// 获取pid和poolLocal链表</span></span><br><span class="line">    l, pid := p.pin()</span><br><span class="line">    <span class="comment">// 直接读取private字段，如果有数据的话，这是一个优化，避免去查队列</span></span><br><span class="line">    x := l.private</span><br><span class="line">    l.private = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 如果private没有数据</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从shared头部获取一个数据</span></span><br><span class="line">        x, _ = l.shared.popHead()</span><br><span class="line">        <span class="comment">// 还是没有</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 从别的P偷一个回来</span></span><br><span class="line">            x = p.getSlow(pid)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unpin</span></span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">    <span class="comment">// 也没偷到</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 调用New函数</span></span><br><span class="line">        x = p.New()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) any &#123;</span><br><span class="line">    size := runtime_LoadAcquintptr(&amp;p.localSize)</span><br><span class="line">    locals := p.local</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 在local找</span></span><br><span class="line">    <span class="comment">// P可能扩容也可能缩容</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">        <span class="comment">// local数组索引，根据P的值定位poolLocal</span></span><br><span class="line">        <span class="comment">// 遍历所有P，从下一个P开始</span></span><br><span class="line">        l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size))</span><br><span class="line">        <span class="comment">// 从shared尾部获取一个数据</span></span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在victim找</span></span><br><span class="line">    size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">    <span class="comment">// 1. gc后P扩容了，没有当前P的数据</span></span><br><span class="line">    <span class="comment">// 2. victim被其他P访问过了</span></span><br><span class="line">    <span class="comment">// 3. victim为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有扩容或者缩容了</span></span><br><span class="line">    locals = p.victim</span><br><span class="line">    <span class="comment">// local数组索引，根据P的值定位poolLocal</span></span><br><span class="line">    l := indexLocal(locals, pid)</span><br><span class="line">    <span class="comment">// 下面同Get方法 </span></span><br><span class="line">    <span class="comment">// -&gt; private -&gt; shared</span></span><br><span class="line">    <span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;</span><br><span class="line">        l.private = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">        l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))</span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// victimSize设置为0</span></span><br><span class="line">    atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// poolChainElt</span></span><br><span class="line">    d := c.head</span><br><span class="line">    <span class="comment">// 从head扫描到tail</span></span><br><span class="line">    <span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 找到一个数据</span></span><br><span class="line">        <span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> val, ok</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// prev？</span></span><br><span class="line">        d = d.prev.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// poolChainElt</span></span><br><span class="line">    d := c.tail.Load()</span><br><span class="line">    <span class="comment">// shared链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// next？</span></span><br><span class="line">        d2 := d.next.Load()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前d找到一个数据</span></span><br><span class="line">        <span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> val, ok</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next为nil</span></span><br><span class="line">        <span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前d没数据，next不为nil，修改tail指针以及prev指针</span></span><br><span class="line">        <span class="keyword">if</span> c.tail.CompareAndSwap(d, d2) &#123;</span><br><span class="line">            d2.prev.Store(<span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        d = d2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> slot *eface</span><br><span class="line">    <span class="comment">// vals是一个环形数组</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ptrs := d.headTail.Load()</span><br><span class="line">        <span class="comment">// 从headTail解析</span></span><br><span class="line">        head, tail := d.unpack(ptrs)</span><br><span class="line">        <span class="comment">// 数组是空的</span></span><br><span class="line">        <span class="keyword">if</span> tail == head &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挪动指针</span></span><br><span class="line">        head--</span><br><span class="line">        ptrs2 := d.pack(head, tail)</span><br><span class="line">        <span class="comment">// 回写成功</span></span><br><span class="line">        <span class="keyword">if</span> d.headTail.CompareAndSwap(ptrs, ptrs2) &#123;</span><br><span class="line">            slot = &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">    <span class="comment">// nil特殊处理判断</span></span><br><span class="line">    <span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">        val = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Zero the slot. Unlike popTail, this isn&#x27;t racing with</span></span><br><span class="line">    <span class="comment">// pushHead, so we don&#x27;t need to be careful here.</span></span><br><span class="line">    *slot = eface&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> slot *eface</span><br><span class="line">    <span class="comment">// vals是一个环形数组</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ptrs := d.headTail.Load()</span><br><span class="line">        <span class="comment">// 从headTail解析</span></span><br><span class="line">        head, tail := d.unpack(ptrs)</span><br><span class="line">        <span class="comment">// 数组是空的</span></span><br><span class="line">        <span class="keyword">if</span> tail == head &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        ptrs2 := d.pack(head, tail+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 回写成功</span></span><br><span class="line">        <span class="keyword">if</span> d.headTail.CompareAndSwap(ptrs, ptrs2) &#123;</span><br><span class="line">            slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We now own slot.</span></span><br><span class="line">    val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">    <span class="comment">// nil特殊处理判断</span></span><br><span class="line">    <span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">        val = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell pushHead that we&#x27;re done with this slot. Zeroing the</span></span><br><span class="line">    <span class="comment">// slot is also important so we don&#x27;t leave behind references</span></span><br><span class="line">    <span class="comment">// that could keep this object live longer than necessary.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We write to val first and then publish that we&#x27;re done with</span></span><br><span class="line">    <span class="comment">// this slot by atomically writing to typ.</span></span><br><span class="line">    slot.val = <span class="literal">nil</span></span><br><span class="line">    atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>) <span class="comment">// 读写判断该字段</span></span><br><span class="line">    <span class="comment">// At this point pushHead owns the slot.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保存一个对象"><a href="#保存一个对象" class="headerlink" title="保存一个对象"></a>保存一个对象</h3><p>大概逻辑如下</p>
<ol>
<li>如果对象为nil，不处理</li>
<li>根据P的值定位poolLocal链表</li>
<li>如果private为nil，直接写入</li>
<li>如果private有数据，写入shared(head)<ul>
<li>shared链表为空，创建链表（初始数据量为8）</li>
<li>写入成功？返回</li>
<li>写入失败？扩容后再次写入（数据量最大不能超过2^30&#x3D;1GB）</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sync/pool.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x any) &#123;</span><br><span class="line">    <span class="comment">// x=nil，不操作</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取pid和poolLocal链表</span></span><br><span class="line">    l, _ := p.pin()</span><br><span class="line">    <span class="comment">// private字段是空的？直接写入</span></span><br><span class="line">    <span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.private = x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 放置在shared头部</span></span><br><span class="line">        l.shared.pushHead(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unpin</span></span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val any) &#123;</span><br><span class="line">    d := c.head</span><br><span class="line">    <span class="comment">// shared链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个poolChainElt，关联head和tail</span></span><br><span class="line">        <span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2</span></span><br><span class="line">        d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">        d.vals = <span class="built_in">make</span>([]eface, initSize)</span><br><span class="line">        c.head = d</span><br><span class="line">        c.tail.Store(d)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入成功</span></span><br><span class="line">    <span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入失败</span></span><br><span class="line">    <span class="comment">// 当前poolChainElt数据满了，双倍扩容</span></span><br><span class="line">    newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line">    <span class="comment">// 最大不能超过2^30 =&gt; 1GB</span></span><br><span class="line">    <span class="keyword">if</span> newSize &gt;= dequeueLimit &#123;</span><br><span class="line">        newSize = dequeueLimit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d2 := &amp;poolChainElt&#123;&#125;</span><br><span class="line">    d2.prev.Store(d)</span><br><span class="line">    d2.vals = <span class="built_in">make</span>([]eface, newSize)</span><br><span class="line">    c.head = d2</span><br><span class="line">    d.next.Store(d2)</span><br><span class="line">    d2.pushHead(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val any) <span class="type">bool</span> &#123;</span><br><span class="line">    ptrs := d.headTail.Load()</span><br><span class="line">    <span class="comment">// 从headTail解析</span></span><br><span class="line">    head, tail := d.unpack(ptrs)</span><br><span class="line">    <span class="comment">// (tail_idx+size)&amp;mask == head</span></span><br><span class="line">    <span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;</span><br><span class="line">        <span class="comment">// Queue is full.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标slot还有数据</span></span><br><span class="line">    <span class="comment">// Check if the head slot has been released by popTail.</span></span><br><span class="line">    typ := atomic.LoadPointer(&amp;slot.typ)</span><br><span class="line">    <span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Another goroutine is still cleaning up the tail, so</span></span><br><span class="line">        <span class="comment">// the queue is actually still full.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil转换</span></span><br><span class="line">    <span class="comment">// The head slot is free, so we own it.</span></span><br><span class="line">    <span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">        val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    *(*any)(unsafe.Pointer(slot)) = val</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increment head. This passes ownership of slot to popTail</span></span><br><span class="line">    <span class="comment">// and acts as a store barrier for writing the slot.</span></span><br><span class="line">    d.headTail.Add(<span class="number">1</span> &lt;&lt; dequeueBits)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h3><p>每当GC进入STW状态时，清理Pool相关数据</p>
<ol>
<li>Pool内数据过期：local -&gt; victim &amp; victim -&gt; nil</li>
<li>全局变量数据过期：allPools -&gt; oldPools &amp; oldPools -&gt; nil</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// This function is called with the world stopped, at the beginning of a garbage collection.</span></span><br><span class="line">    <span class="comment">// It must not allocate and probably should not call any runtime functions.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Because the world is stopped, no pool user can be in a</span></span><br><span class="line">    <span class="comment">// pinned section (in effect, this has all Ps pinned).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drop victim caches from all pools.</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">        p.victim = <span class="literal">nil</span></span><br><span class="line">        p.victimSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move primary cache to victim cache.</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">        p.victim = p.local</span><br><span class="line">        p.victimSize = p.localSize</span><br><span class="line">        p.local = <span class="literal">nil</span></span><br><span class="line">        p.localSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The pools with non-empty primary caches now have non-empty</span></span><br><span class="line">    <span class="comment">// victim caches and no pools have primary caches.</span></span><br><span class="line">    oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储切片注意"><a href="#存储切片注意" class="headerlink" title="存储切片注意"></a>存储切片注意</h2><p>当使用sync.Pool存储切片时，sync.Pool会如何处理呢？看下面示例代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool = sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := pool.Get().([]<span class="type">byte</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...do something with b</span></span><br><span class="line">    _ = b</span><br><span class="line"></span><br><span class="line">    pool.Put(b) <span class="comment">// this is line 21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码看，我们创建了一个可以重复利用的切片&#x2F;缓存区。打开Escape Analysis-逃逸分析运行看看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags=<span class="string">&quot;-m&quot;</span> hello.go  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># # command-line-arguments</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: can inline init.0.func1</span></span><br><span class="line"><span class="comment"># ./hello.go:7:6: can inline init.0</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ./hello.go:10:15: make([]byte, 4096) escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:10:15: make([]byte, 4096) escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: func literal escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:21:11: b escapes to heap</span></span><br></pre></td></tr></table></figure>

<p>当创建一个slice-切片时，我们得到的是一个header，系统判断其不仅局限于New函数，使其逃逸至heap上分配，而b也是一个header，同样，系统也会使其逃逸至heap</p>
<p>重新调整代码，改为一个指向slice的指针，如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool = sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">            b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> &amp;b</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bPtr := pool.Get().(*[]<span class="type">byte</span>)</span><br><span class="line">    b := *bPtr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...do something with b</span></span><br><span class="line">    _ = b</span><br><span class="line"></span><br><span class="line">    pool.Put(bPtr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再一次运行逃逸分析，得到结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags=<span class="string">&quot;-m&quot;</span> hello.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # command-line-arguments</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: can inline init.0.func1</span></span><br><span class="line"><span class="comment"># ./hello.go:7:6: can inline init.0</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ./hello.go:10:4: moved to heap: b</span></span><br><span class="line"><span class="comment"># ./hello.go:10:13: make([]byte, 4096) escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: func literal escapes to heap</span></span><br></pre></td></tr></table></figure>

<p>这一次，把原始指针放回Pool就不会发生逃逸现象</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://unskilled.blog/posts/lets-dive-a-tour-of-sync.pool-internals/">Let’s dive: a tour of sync.Pool internals</a><br><a target="_blank" rel="noopener" href="https://www.cyhone.com/articles/think-in-sync-pool/">深度分析 Golang sync.Pool 底层原理</a><br><a target="_blank" rel="noopener" href="https://victoriametrics.com/blog/go-sync-pool/index.html">Go sync.Pool and the Mechanics Behind It</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-sync-once/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-sync-once/" class="post-title-link" itemprop="url">golang系列之-sync.Once</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-16 10:09:57" itemprop="dateCreated datePublished" datetime="2025-02-16T10:09:57+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-20 08:31:21" itemprop="dateModified" datetime="2025-02-20T08:31:21+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如果要实现如Singleton、Lazy Initialization模式，那么你需要了解sync.Once，它可以用于保证如：只加载一次配置文件、只初始化一次数据库连接等，此外它还可以帮助实现更好的Plugin封装</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>以下代码展示了如何使用sync.Once实现singleton模式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    data <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Creating Singleton instance&quot;</span>)</span><br><span class="line">        instance = &amp;Singleton&#123;data: <span class="string">&quot;I&#x27;m the only one!&quot;</span>&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, GetInstance())</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for goroutines to finish</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>sync.Once的数据结构由一个atomic类型和一个mutex锁组成，通过加锁访问done标志判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// done indicates whether the action has been performed.</span></span><br><span class="line">    <span class="comment">// It is first in the struct because it is used in the hot path.</span></span><br><span class="line">    <span class="comment">// The hot path is inlined at every call site.</span></span><br><span class="line">    <span class="comment">// Placing done first allows more compact instructions on some architectures (amd64/386),</span></span><br><span class="line">    <span class="comment">// and fewer instructions (to calculate offset) on other architectures.</span></span><br><span class="line">    done atomic.Uint32</span><br><span class="line">    m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h3><p>Do方法的逻辑如下</p>
<ol>
<li>通过CAS原子操作读取done字段数据，如果值是1-已执行则立即返回，否则进入加锁状态</li>
<li>加锁，执行传入的函数代码，并更新done的数值</li>
</ol>
<p>原本代码的注释挺有用的，就不再赘述了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do calls the function f if and only if Do is being called for the</span></span><br><span class="line"><span class="comment">// first time for this instance of [Once]. In other words, given</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    var once Once</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// if once.Do(f) is called multiple times, only the first call will invoke f,</span></span><br><span class="line"><span class="comment">// even if f has a different value in each invocation. A new instance of</span></span><br><span class="line"><span class="comment">// Once is required for each function to execute.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do is intended for initialization that must be run exactly once. Since f</span></span><br><span class="line"><span class="comment">// is niladic, it may be necessary to use a function literal to capture the</span></span><br><span class="line"><span class="comment">// arguments to a function to be invoked by Do:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    config.once.Do(func() &#123; config.init(filename) &#125;)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because no call to Do returns until the one call to f returns, if f causes</span></span><br><span class="line"><span class="comment">// Do to be called, it will deadlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, Do considers it to have returned; future calls of Do return</span></span><br><span class="line"><span class="comment">// without calling f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">    <span class="comment">// Note: Here is an incorrect implementation of Do:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    if o.done.CompareAndSwap(0, 1) &#123;</span></span><br><span class="line">    <span class="comment">//        f()</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do guarantees that when it returns, f has finished.</span></span><br><span class="line">    <span class="comment">// This implementation would not implement that guarantee:</span></span><br><span class="line">    <span class="comment">// given two simultaneous calls, the winner of the cas would</span></span><br><span class="line">    <span class="comment">// call f, and the second would return immediately, without</span></span><br><span class="line">    <span class="comment">// waiting for the first&#x27;s call to f to complete.</span></span><br><span class="line">    <span class="comment">// This is why the slow path falls back to a mutex, and why</span></span><br><span class="line">    <span class="comment">// the o.done.Store must be delayed until after f returns.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> o.done.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">        o.doSlow(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="keyword">if</span> o.done.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> o.done.Store(<span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>从1.21版本开始，Austin Clements添加了三个sync.Once的封装：OnceFunc、OnceValue、OnceValues，方便写出更简洁紧凑的代码</p>
<h3 id="OnceFunc"><a href="#OnceFunc" class="headerlink" title="OnceFunc"></a>OnceFunc</h3><p>OnceFunc适合无任何返回值的业务逻辑，不适合用作Singleton、Lazy Initialization模式，下面是一个简单的示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    onceVoid := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    call := sync.OnceFunc(onceVoid)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        call()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnceFunc内部实现逻辑如下</p>
<ol>
<li>定义状态、封装传入的函数</li>
<li>只要f执行成功，更新状态，如将valid设置为true（已执行）</li>
<li>如果f的执行有panic，继续向上抛出异常</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnceFunc returns a function that invokes f only once. The returned function</span></span><br><span class="line"><span class="comment">// may be called concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, the returned function will panic with the same value on every call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceFunc</span><span class="params">(f <span class="keyword">func</span>()</span></span>) <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        once  Once</span><br><span class="line">        valid <span class="type">bool</span></span><br><span class="line">        p     any</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// Construct the inner closure just once to reduce costs on the fast path.</span></span><br><span class="line">    g := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            p = <span class="built_in">recover</span>()</span><br><span class="line">            <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                <span class="comment">// Re-panic immediately so on the first call the user gets a</span></span><br><span class="line">                <span class="comment">// complete stack trace into f.</span></span><br><span class="line">                <span class="built_in">panic</span>(p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        f()</span><br><span class="line">        f = <span class="literal">nil</span>      <span class="comment">// Do not keep f alive after invoking it.</span></span><br><span class="line">        valid = <span class="literal">true</span> <span class="comment">// Set only if f does not panic.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        once.Do(g)</span><br><span class="line">        <span class="keyword">if</span> !valid &#123;</span><br><span class="line">            <span class="built_in">panic</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OnceValue"><a href="#OnceValue" class="headerlink" title="OnceValue"></a>OnceValue</h3><p>一般情况下，我们的业务逻辑使用用OnceValue即可，不够的话，还可以使用OnceValues，下面是使用OnceValue改造后的【快速上手】的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    data <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例/惰性加载</span></span><br><span class="line"><span class="keyword">var</span> instance = sync.OnceValue(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Creating Singleton instance&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;Singleton&#123;data: <span class="string">&quot;I&#x27;m the only one!&quot;</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, instance)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for goroutines to finish</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnceValue内部实现逻辑与OnceFunc一致，不同的是，内部增加了result字段用于缓存函数的返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnceValue returns a function that invokes f only once and returns the value</span></span><br><span class="line"><span class="comment">// returned by f. The returned function may be called concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, the returned function will panic with the same value on every call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceValue</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(f <span class="keyword">func</span>()</span></span> T) <span class="function"><span class="keyword">func</span><span class="params">()</span></span> T &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        once   Once</span><br><span class="line">        valid  <span class="type">bool</span></span><br><span class="line">        p      any</span><br><span class="line">        result T</span><br><span class="line">    )</span><br><span class="line">    g := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            p = <span class="built_in">recover</span>()</span><br><span class="line">            <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                <span class="built_in">panic</span>(p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        result = f()</span><br><span class="line">        f = <span class="literal">nil</span></span><br><span class="line">        valid = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> T &#123;</span><br><span class="line">        once.Do(g)</span><br><span class="line">        <span class="keyword">if</span> !valid &#123;</span><br><span class="line">            <span class="built_in">panic</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OnceValues"><a href="#OnceValues" class="headerlink" title="OnceValues"></a>OnceValues</h3><p>与OnceValue不同的是，OnceValues会返回两个数值，很适合用于加载配置文件、创建数据库连接等。下面代码展示了如何使用OnceValues创建数据库连接</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/golang/go/issues/56102</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    db <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*sql.DB, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(dbPath <span class="type">string</span>)</span></span> *Server &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Server&#123;</span><br><span class="line">        db: sync.OnceFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*sql.DB, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sql.Open(<span class="string">&quot;sqlite&quot;</span>, dbPath)</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> DoSomething() <span class="type">error</span> &#123;</span><br><span class="line">    db, err := s.db()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    _ = db <span class="comment">// do something with db</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnceValues内部实现逻辑与OnceValue一致，不同的是，内部使用的是r1、r2两个字段用于缓存函数的返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnceValues returns a function that invokes f only once and returns the values</span></span><br><span class="line"><span class="comment">// returned by f. The returned function may be called concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, the returned function will panic with the same value on every call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceValues</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(f <span class="keyword">func</span>()</span></span> (T1, T2)) <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (T1, T2) &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        once  Once</span><br><span class="line">        valid <span class="type">bool</span></span><br><span class="line">        p     any</span><br><span class="line">        r1    T1</span><br><span class="line">        r2    T2</span><br><span class="line">    )</span><br><span class="line">    g := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            p = <span class="built_in">recover</span>()</span><br><span class="line">            <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                <span class="built_in">panic</span>(p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        r1, r2 = f()</span><br><span class="line">        f = <span class="literal">nil</span></span><br><span class="line">        valid = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (T1, T2) &#123;</span><br><span class="line">        once.Do(g)</span><br><span class="line">        <span class="keyword">if</span> !valid &#123;</span><br><span class="line">            <span class="built_in">panic</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1, r2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://cristiancurteanu.com/understanding-go-sync-once/">Understanding Golang’s sync.Once: Practical Examples in 2024</a><br><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/56102">sync: add OnceFunc, OnceValue, OnceValues</a><br><a target="_blank" rel="noopener" href="https://victoriametrics.com/blog/go-sync-once/index.html">Go sync.Once is Simple… Does It Really?</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-map-swiss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-map-swiss/" class="post-title-link" itemprop="url">golang系列之-swiss map</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-15 23:45:02" itemprop="dateCreated datePublished" datetime="2025-02-15T23:45:02+08:00">2025-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-23 17:17:47" itemprop="dateModified" datetime="2025-02-23T17:17:47+08:00">2025-02-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>30 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>map&#x2F;哈希表，是golang常用的数据结构之一，也充当set数据结构的存在，相对slice要复杂很多。从1.24开始，swiss table替代noswiss成为默认实现，swiss与noswiss区别在于，swiss使用开放地址法，noswiss使用拉链法</p>
<p>当前go版本：1.24</p>
<blockquote>
<p>swiss map的开关放在文件<code>src/internal/buildcfg/exp.go</code>的函数<code>ParseGOEXPERIMENT</code>中</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table-groups是二维数组，算上slot的话是三维</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// map_header -&gt; table1 -&gt; group1(8个slot)</span></span><br><span class="line"><span class="comment">//                      -&gt; group2</span></span><br><span class="line"><span class="comment">//                      ...</span></span><br><span class="line"><span class="comment">//                      -&gt; group127</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//            -&gt; table2</span></span><br><span class="line"><span class="comment">//            -&gt; ...</span></span><br><span class="line"><span class="comment">//            -&gt; tableN</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当hint&lt;=8时，map_header直接指向一个group，全量扫描操作</span></span><br><span class="line"><span class="comment">// 当hint&gt;8 and hint&lt;=1024*7/8时，一个table，2~128个group</span></span><br><span class="line"><span class="comment">// 当hint&gt;1024*7/8时，多个table，多个group</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// hash高B位 - 用于定位table</span></span><br><span class="line"><span class="comment">// h1-hash高57位 - 用于定位group</span></span><br><span class="line"><span class="comment">// h2-hash低7位 - 用于匹配hash，类似tophash</span></span><br></pre></td></tr></table></figure>

<p>核心数据结构包括Map、table、groupsReference、groupReference，具体如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    used <span class="type">uint64</span>            <span class="comment">// 已用slot，当数据量&lt;=8时用来替换table的used使用</span></span><br><span class="line">    seed <span class="type">uintptr</span>           <span class="comment">// 哈希函数种子</span></span><br><span class="line">    dirPtr unsafe.Pointer  <span class="comment">// table数组指针/group指针</span></span><br><span class="line">    dirLen <span class="type">int</span>             <span class="comment">// table数组大小</span></span><br><span class="line">    globalDepth <span class="type">uint8</span>      <span class="comment">// log2(dirLen)（相当于旧版的B）</span></span><br><span class="line">    globalShift <span class="type">uint8</span>      <span class="comment">// 64-globalDepth，高B位用做table的索引</span></span><br><span class="line">    writing <span class="type">uint8</span>          <span class="comment">// 是否正在写入，乐观锁</span></span><br><span class="line">    clearSeq <span class="type">uint64</span>        <span class="comment">// 执行过多少次clear，扩容时，获取数据判断用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="keyword">type</span> table <span class="keyword">struct</span> &#123;</span><br><span class="line">    used <span class="type">uint16</span>            <span class="comment">// 已用slot，最多能写入1024*7/8=896个slot</span></span><br><span class="line">    capacity <span class="type">uint16</span>        <span class="comment">// slot容量 &lt;=1024（由hint算出，2的乘方向上取整）</span></span><br><span class="line">    growthLeft <span class="type">uint16</span>      <span class="comment">// 可用slot，与used相反，初始值最大为896</span></span><br><span class="line">    localDepth <span class="type">uint8</span>       <span class="comment">// &gt;globalDepth？分裂/遍历时使用</span></span><br><span class="line">    index <span class="type">int</span>              <span class="comment">// 上层directory数组中的index（-1-过期，作用类似localDepth）</span></span><br><span class="line">    groups groupsReference <span class="comment">// group数组，8个slot为一组，最多1024/8=128组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/group.go</span></span><br><span class="line"><span class="keyword">type</span> groupsReference <span class="keyword">struct</span> &#123;</span><br><span class="line">    data unsafe.Pointer    <span class="comment">// group数组，8个slot为一组，具体结构看下方</span></span><br><span class="line">    lengthMask <span class="type">uint64</span>      <span class="comment">// 长度固定为2^N，因此mask=2^N-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> groupReference <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 结构如下</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// type group struct &#123;</span></span><br><span class="line">    <span class="comment">//     ctrls ctrlGroup                    // 8个8bit的ctrl，共三种状态</span></span><br><span class="line">    <span class="comment">//     slots [abi.SwissMapGroupSlots]slot // 8个slot(key/value对)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 三种状态如下：</span></span><br><span class="line">    <span class="comment">//      empty: 1 0 0 0 0 0 0 0</span></span><br><span class="line">    <span class="comment">//    deleted: 1 1 1 1 1 1 1 0</span></span><br><span class="line">    <span class="comment">//       full: 0 h h h h h h h  // h represents the H2 hash bits</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// type slot struct &#123;</span></span><br><span class="line">    <span class="comment">//     key  typ.Key  // 键</span></span><br><span class="line">    <span class="comment">//     elem typ.Elem // 值</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    data unsafe.Pointer <span class="comment">// ctrls数组+slots数组</span></span><br><span class="line">    <span class="comment">// 内存布局如下（C语言开发者真的很喜欢这种内存布局啊）</span></span><br><span class="line">    <span class="comment">// | ctrls         | slots         |</span></span><br><span class="line">    <span class="comment">// |ctrl7|...|ctrl0|slot0|...|slot7|</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量初始化调用的是maplit，具体看代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/walk/complit.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maplit</span><span class="params">(n *ir.CompLitExpr, m ir.Node, init *ir.Nodes)</span></span> &#123;</span><br><span class="line">    args := []ir.Node&#123;ir.TypeNode(n.Type()), ir.NewInt(base.Pos, n.Len+<span class="type">int64</span>(<span class="built_in">len</span>(n.List)))&#125;</span><br><span class="line">    a := typecheck.Expr(ir.NewCallExpr(base.Pos, ir.OMAKE, <span class="literal">nil</span>, args)).(*ir.MakeExpr)</span><br><span class="line">    a.RType = n.RType</span><br><span class="line">    a.SetEsc(n.Esc())</span><br><span class="line">    appendWalkStmt(init, ir.NewAssignStmt(base.Pos, m, a))</span><br><span class="line"></span><br><span class="line">    entries := n.List</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> entries &#123;</span><br><span class="line">        r := r.(*ir.KeyExpr)</span><br><span class="line">        <span class="keyword">if</span> !isStaticCompositeLiteral(r.Key) || !isStaticCompositeLiteral(r.Value) &#123;</span><br><span class="line">            base.Fatalf(<span class="string">&quot;maplit: entry is not a literal: %v&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(entries) &gt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// loop adding structure elements to map</span></span><br><span class="line">        <span class="comment">// for i = 0; i &lt; len(vstatk); i++ &#123;</span></span><br><span class="line">        <span class="comment">//    map[vstatk[i]] = vstate[i]</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，如果小于等于25个元素，直接赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>如果，大于25个元素，分key&#x2F;value两组，使用for循环进行赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstatk); i++ &#123;</span><br><span class="line">    <span class="keyword">map</span>[vstatk[i]] = vstate[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>当使用make关键字初始化map时，调用的是makemap，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *abi.SwissMapType, hint <span class="type">int</span>, m *maps.Map)</span></span> *maps.Map &#123;</span><br><span class="line">    <span class="keyword">if</span> hint &lt; <span class="number">0</span> &#123;</span><br><span class="line">        hint = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maps.NewMap(t, <span class="type">uintptr</span>(hint), m, maxAlloc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMap</span><span class="params">(mt *abi.SwissMapType, hint <span class="type">uintptr</span>, m *Map, maxAlloc <span class="type">uintptr</span>)</span></span> *Map &#123;</span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> &#123;</span><br><span class="line">        m = <span class="built_in">new</span>(Map)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希种子</span></span><br><span class="line">    m.seed = <span class="type">uintptr</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hint&lt;=8</span></span><br><span class="line">    <span class="keyword">if</span> hint &lt;= abi.SwissMapGroupSlots &#123;</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// capacity = hint*8/7 =&gt; 每个group最多容纳7个slot，不能直接按hint计算group数量</span></span><br><span class="line">    targetCapacity := (hint * abi.SwissMapGroupSlots) / maxAvgGroupLoad</span><br><span class="line">    <span class="keyword">if</span> targetCapacity &lt; hint &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirSize = (capacity+1024-1)/1024 =&gt; table数量 =&gt; 一个table=128个group=1024个slot</span></span><br><span class="line">    dirSize := (<span class="type">uint64</span>(targetCapacity) + maxTableCapacity - <span class="number">1</span>) / maxTableCapacity</span><br><span class="line">    <span class="comment">// 2的乘方向上取整，如dirSize=40? =&gt; dirSize=64</span></span><br><span class="line">    dirSize, overflow := alignUpPow2(dirSize)</span><br><span class="line">    <span class="comment">// overflow?</span></span><br><span class="line">    <span class="keyword">if</span> overflow || dirSize &gt; <span class="type">uint64</span>(math.MaxUintptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reject hints that are obviously too large.</span></span><br><span class="line">    <span class="comment">// ngroup = dirSize*1024</span></span><br><span class="line">    groups, overflow := math.MulUintptr(<span class="type">uintptr</span>(dirSize), maxTableCapacity)</span><br><span class="line">    <span class="keyword">if</span> overflow &#123;</span><br><span class="line">        <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ngroup*GroupSize overflow?</span></span><br><span class="line">        mem, overflow := math.MulUintptr(groups, mt.GroupSize)</span><br><span class="line">        <span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">            <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// globalDepth = 二进制数dirSize末尾有多少个0 =&gt; 2^globalDepth=dirSize</span></span><br><span class="line">    m.globalDepth = <span class="type">uint8</span>(sys.TrailingZeros64(dirSize))</span><br><span class="line">    <span class="comment">// globalShift = 64-globalDepth</span></span><br><span class="line">    m.globalShift = depthToShift(m.globalDepth)</span><br><span class="line"></span><br><span class="line">    directory := <span class="built_in">make</span>([]*table, dirSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建table</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> directory &#123;</span><br><span class="line">        <span class="comment">// (type, a/b, i, d)</span></span><br><span class="line">        <span class="comment">// capacity = a/b &lt;= 1024</span></span><br><span class="line">        directory[i] = newTable(mt, <span class="type">uint64</span>(targetCapacity)/dirSize, i, m.globalDepth)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m.dirPtr = unsafe.Pointer(&amp;directory[<span class="number">0</span>])</span><br><span class="line">    m.dirLen = <span class="built_in">len</span>(directory) <span class="comment">// 为什么不能直接用dirSize？</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="comment">// 创建table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTable</span><span class="params">(typ *abi.SwissMapType, capacity <span class="type">uint64</span>, index <span class="type">int</span>, localDepth <span class="type">uint8</span>)</span></span> *table &#123;</span><br><span class="line">    <span class="comment">// capacity最小值为8</span></span><br><span class="line">    <span class="keyword">if</span> capacity &lt; abi.SwissMapGroupSlots &#123;</span><br><span class="line">        capacity = abi.SwissMapGroupSlots</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t := &amp;table&#123;</span><br><span class="line">        index:      index,      <span class="comment">// 上层directory数组中的index</span></span><br><span class="line">        localDepth: localDepth, <span class="comment">// &lt;= globalDepth</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;1024 =&gt; 异常</span></span><br><span class="line">    <span class="keyword">if</span> capacity &gt; maxTableCapacity &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;initial table capacity too large&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2的乘方向上取整</span></span><br><span class="line">    capacity, overflow := alignUpPow2(capacity)</span><br><span class="line">    <span class="keyword">if</span> overflow &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;rounded-up capacity overflows uint64&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建groups</span></span><br><span class="line">    t.reset(typ, <span class="type">uint16</span>(capacity))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要职责 =&gt; 创建groups</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> reset(typ *abi.SwissMapType, capacity <span class="type">uint16</span>) &#123;</span><br><span class="line">    <span class="comment">// 8个slot为一组，最多1024/8=128组</span></span><br><span class="line">    groupCount := <span class="type">uint64</span>(capacity) / abi.SwissMapGroupSlots</span><br><span class="line">    <span class="comment">// 创建groups</span></span><br><span class="line">    t.groups = newGroups(typ, groupCount)</span><br><span class="line">    t.capacity = capacity</span><br><span class="line">    <span class="comment">// 根据capacity重置growthLeft字段</span></span><br><span class="line">    t.resetGrowthLeft()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于for i, g := range t.groups </span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">        g := t.groups.group(typ, i)</span><br><span class="line">        <span class="comment">// 每组有8个slot，每个slot对应的ctrl都设置为empty =&gt; 0b10000000</span></span><br><span class="line">        g.ctrls().setEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置table的growthLeft字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> resetGrowthLeft() &#123;</span><br><span class="line">    <span class="keyword">var</span> growthLeft <span class="type">uint16</span></span><br><span class="line">    <span class="keyword">if</span> t.capacity == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 1. capacity不能为0</span></span><br><span class="line">        <span class="comment">// No real reason to support zero capacity table, since an</span></span><br><span class="line">        <span class="comment">// empty Map simply won&#x27;t have a table.</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;table must have positive capacity&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.capacity &lt;= abi.SwissMapGroupSlots &#123;</span><br><span class="line">        <span class="comment">// 2. capacity &lt;= 8</span></span><br><span class="line">        <span class="comment">// If the map fits in a single group then we&#x27;re able to fill all of</span></span><br><span class="line">        <span class="comment">// the slots except 1 (an empty slot is needed to terminate find</span></span><br><span class="line">        <span class="comment">// operations).</span></span><br><span class="line">        growthLeft = t.capacity - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. capacity &gt; 8</span></span><br><span class="line">        <span class="comment">// capacity*7 &lt; capacity？</span></span><br><span class="line">        <span class="keyword">if</span> t.capacity*maxAvgGroupLoad &lt; t.capacity &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;overflow&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// growthLeft = capacity*7/8</span></span><br><span class="line">        growthLeft = (t.capacity * maxAvgGroupLoad) / abi.SwissMapGroupSlots</span><br><span class="line">    &#125;</span><br><span class="line">    t.growthLeft = growthLeft</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/group.go</span></span><br><span class="line"><span class="comment">// length =&gt; 2^N</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGroups</span><span class="params">(typ *abi.SwissMapType, length <span class="type">uint64</span>)</span></span> groupsReference &#123;</span><br><span class="line">    <span class="keyword">return</span> groupsReference&#123;</span><br><span class="line">        data:       newarray(typ.Group, <span class="type">int</span>(length)), <span class="comment">// 申请一片内存</span></span><br><span class="line">        lengthMask: length - <span class="number">1</span>, <span class="comment">// 2^N-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// group=8*ctrl+8*slot</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *groupsReference)</span></span> group(typ *abi.SwissMapType, i <span class="type">uint64</span>) groupReference &#123;</span><br><span class="line">    offset := <span class="type">uintptr</span>(i) * typ.GroupSize</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> groupReference&#123;</span><br><span class="line">        data: unsafe.Pointer(<span class="type">uintptr</span>(g.data) + offset),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对旧版，新版的逻辑看起来会复杂一些，大概的逻辑如下</p>
<ol>
<li>如果hint的数量不超过8，生成map header返回</li>
<li>如果hint的数量超过8<ul>
<li>新版map只能容纳7&#x2F;8的数据量，因此需要根据公式<code>hint*8/7</code>重新计算容量</li>
<li>根据容量计算table数量、group数量，基本都是2的乘方向上取整</li>
<li>生成table数组、group数组</li>
<li>map header、table、group等参数初始化</li>
</ul>
</li>
</ol>
<p>globalDepth、globalShift一部份数据示例如下</p>
<table>
<thead>
<tr>
<th align="left">dirSize(10)</th>
<th align="left">dirSize(2)</th>
<th align="left">globalDepth</th>
<th align="left">globalShift</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">0001</td>
<td align="left">0</td>
<td align="left">64</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">0010</td>
<td align="left">1</td>
<td align="left">63</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">0100</td>
<td align="left">2</td>
<td align="left">62</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">1000</td>
<td align="left">3</td>
<td align="left">61</td>
</tr>
</tbody></table>
<p>其他：</p>
<ol>
<li>table数量、group数量固定为2的乘方</li>
<li>table最大容量&#x3D;1024个slot&#x3D;128个group</li>
<li>group最大容量&#x3D;8个slot</li>
</ol>
<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>swiss table使用二次探测法法用于定位group，而终止扫描依赖group的ctrls字段，只要该字段中有一个处于empty状态，立即终止扫描，具体通过probeSeq实现</p>
<p>使用的二次探测法公式为：<code>p(i) := (i^2 + i)/2 + hash (mod mask+1)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quadratic probing - 二次探测法</span></span><br><span class="line"><span class="keyword">type</span> probeSeq <span class="keyword">struct</span> &#123;</span><br><span class="line">    mask   <span class="type">uint64</span> <span class="comment">// groups数组的索引的最大值=2^N-1</span></span><br><span class="line">    offset <span class="type">uint64</span> <span class="comment">// groups数组索引（取hash的低N位）</span></span><br><span class="line">    index  <span class="type">uint64</span> <span class="comment">// 扫描计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeProbeSeq</span><span class="params">(hash <span class="type">uintptr</span>, mask <span class="type">uint64</span>)</span></span> probeSeq &#123;</span><br><span class="line">    <span class="keyword">return</span> probeSeq&#123;</span><br><span class="line">        mask:   mask,</span><br><span class="line">        offset: <span class="type">uint64</span>(hash) &amp; mask,</span><br><span class="line">        index:  <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s probeSeq)</span></span> next() probeSeq &#123;</span><br><span class="line">    s.index++</span><br><span class="line">    <span class="comment">// 从offset的位置开始循环groups数组扫描</span></span><br><span class="line">    <span class="comment">// 保证不超过groups数组的最大索引</span></span><br><span class="line">    <span class="comment">// p(i) := (i^2 + i)/2 + hash (mod mask+1)</span></span><br><span class="line">    s.offset = (s.offset + s.index) &amp; s.mask</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>probeSeq的使用示例如下，其中offset是group的定位索引，看起来还是比较均匀的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">seq := makeProbeSeq(<span class="number">12345678</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, seq)</span><br><span class="line">    seq = seq.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:6 index:0&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:7 index:1&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:1 index:2&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:4 index:3&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:0 index:4&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:5 index:5&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:3 index:6&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:2 index:7&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:2 index:8&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:3 index:9&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h3><p>使用索引获取map的数值有两种</p>
<ol>
<li>仅接受一个参数</li>
<li>接受两个参数</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅接受一个参数</span></span><br><span class="line">v := h[key]</span><br><span class="line"><span class="comment">// 接受两个参数</span></span><br><span class="line">v, ok := h[key]</span><br></pre></td></tr></table></figure>

<p>当仅接受一个参数时，底层使用runtime_mapaccess1，当接受两个参数时，底层使用runtime_mapaccess2，其与runtime_mapaccess1只有返回值的不同</p>
<p>这里的runtime_mapaccess1逻辑与Get方法相似，因此只介绍maps包的接口方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/maps/runtime_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_mapaccess1</span><span class="params">(typ *abi.SwissMapType, m *Map, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_mapaccess2</span><span class="params">(typ *abi.SwissMapType, m *Map, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Get(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m.getWithoutKey(typ, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回key、value指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> getWithKey(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 无数据</span></span><br><span class="line">    <span class="keyword">if</span> m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个table一个group，数据量&lt;8</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.getWithKeySmall(typ, hash, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">    idx := m.directoryIndex(hash)</span><br><span class="line">    <span class="comment">// 找到table再找group最后找slot</span></span><br><span class="line">    <span class="keyword">return</span> m.directoryAt(idx).getWithKey(typ, hash, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回value指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> getWithoutKey(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 无数据</span></span><br><span class="line">    <span class="keyword">if</span> m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个table一个group，数据量&lt;8</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        _, elem, ok := m.getWithKeySmall(typ, hash, key)</span><br><span class="line">        <span class="keyword">return</span> elem, ok</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">    idx := m.directoryIndex(hash)</span><br><span class="line">    <span class="comment">// 找到table再找group最后找slot</span></span><br><span class="line">    <span class="keyword">return</span> m.directoryAt(idx).getWithoutKey(typ, hash, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据量小于等于8时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> getWithKeySmall(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 只有一个table一个group</span></span><br><span class="line">    <span class="comment">// table.groups不是第一个字段也能cast？</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取哈希值低7位</span></span><br><span class="line">    h2 := <span class="type">uint8</span>(h2(hash))</span><br><span class="line">    <span class="comment">// data的前64位为ctrls</span></span><br><span class="line">    ctrls := *g.ctrls()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8个slot</span></span><br><span class="line">    <span class="comment">// |ctrl7|...|ctrl0|slot0|...|slot7|</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.SwissMapGroupSlots; i++ &#123;</span><br><span class="line">        <span class="comment">// ctrls从后往前扫描，但i从0开始</span></span><br><span class="line">        c := <span class="type">uint8</span>(ctrls)</span><br><span class="line">        ctrls &gt;&gt;= <span class="number">8</span></span><br><span class="line">        <span class="keyword">if</span> c != h2 &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slot从前往后扫描</span></span><br><span class="line">        <span class="comment">// key</span></span><br><span class="line">        slotKey := g.key(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value</span></span><br><span class="line">        <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slotKey, slotElem, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是table相关</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> getWithKey(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">        match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match不为0，至少找到一个（假阳性）</span></span><br><span class="line">        <span class="comment">// |ctrl7|...|ctrl0|slot0|...|slot7|</span></span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            <span class="comment">// 看样子同一个i会被用很多次</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">                slotElem := g.elem(typ, i)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slotKey, slotElem, <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">            match = match.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmpty将非empty的ctrl全部置为0，如果8个ctrl都有数据，如full或者deleted状态，那么match=0</span></span><br><span class="line">        match = g.ctrls().matchEmpty()</span><br><span class="line">        <span class="keyword">if</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Finding an empty slot means we&#x27;ve reached the end of</span></span><br><span class="line">            <span class="comment">// the probe sequence.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与getWithKey相同，只有返回值不同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> getWithoutKey(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历访问"><a href="#遍历访问" class="headerlink" title="遍历访问"></a>遍历访问</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用for range遍历整个map时，依赖Iter数据结构实现该操作，大概过程如下</p>
<ol>
<li>创建Iter，纪录map的快照信息、生成随机数作为table、slot的索引偏移</li>
<li>调用Next方法，获取并存储第一个key&#x2F;value地址</li>
<li>上层函数继续调用Next方法，获取并存储下一个key&#x2F;value地址，或者主动退出循环</li>
</ol>
<p>注意：如果发生了扩容，iter.tab的index显示是已过时，需要从旧的table获取key，从新的table获取新的key&#x2F;value</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Iter <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  unsafe.Pointer     <span class="comment">// key指针 为nil结束遍历</span></span><br><span class="line">    elem unsafe.Pointer     <span class="comment">// value指针</span></span><br><span class="line">    typ  *abi.SwissMapType  <span class="comment">// 类型</span></span><br><span class="line">    m    *Map               <span class="comment">// map指针</span></span><br><span class="line">    entryOffset <span class="type">uint64</span>      <span class="comment">// slot计数器的偏移量（随机）</span></span><br><span class="line">    dirOffset   <span class="type">uint64</span>      <span class="comment">// table索引初始偏移（随机） -&gt; head</span></span><br><span class="line">    clearSeq <span class="type">uint64</span>         <span class="comment">// 执行过多少次clear</span></span><br><span class="line">    globalDepth <span class="type">uint8</span>       <span class="comment">// log2(dirLen)（相当于以前的B）</span></span><br><span class="line">    dirIdx <span class="type">int</span>              <span class="comment">// table索引 -&gt; curr</span></span><br><span class="line">    tab *table              <span class="comment">// table指针，不同dirIdx可以指向同一个tab</span></span><br><span class="line">    group groupReference    <span class="comment">// group指针</span></span><br><span class="line">    entryIdx <span class="type">uint64</span>         <span class="comment">// 整个table的slot计数器 [0,1023]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapIterStart</span><span class="params">(t *abi.SwissMapType, m *maps.Map, it *maps.Iter)</span></span> &#123;</span><br><span class="line">    it.Init(t, m)</span><br><span class="line">    it.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> Init(typ *abi.SwissMapType, m *Map) &#123;</span><br><span class="line">    it.typ = typ</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> || m.used == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    dirIdx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> groupSmall groupReference</span><br><span class="line">    <span class="comment">// 只有一个table一个group，数据量&lt;8</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Use dirIdx == -1 as sentinel for small maps.</span></span><br><span class="line">        dirIdx = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">        groupSmall.data = m.dirPtr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it.m = m</span><br><span class="line">    it.entryOffset = rand()        <span class="comment">// slot索引初始偏移</span></span><br><span class="line">    it.dirOffset = rand()          <span class="comment">// table索引初始偏移</span></span><br><span class="line">    it.globalDepth = m.globalDepth <span class="comment">// 2^B个table</span></span><br><span class="line">    it.dirIdx = dirIdx             <span class="comment">// 0-默认 -1-small map</span></span><br><span class="line">    it.group = groupSmall          <span class="comment">// nil-默认 否则 small map</span></span><br><span class="line">    it.clearSeq = m.clearSeq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapIterNext</span><span class="params">(it *maps.Iter)</span></span> &#123;</span><br><span class="line">    it.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> Next() &#123;</span><br><span class="line">    <span class="comment">// 空map，直接终止</span></span><br><span class="line">    <span class="keyword">if</span> it.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        it.key = <span class="literal">nil</span></span><br><span class="line">        it.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> it.m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. small map ，单个group</span></span><br><span class="line">    <span class="keyword">if</span> it.dirIdx &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有slot，从entryOffset开始</span></span><br><span class="line">        <span class="keyword">for</span> ; it.entryIdx &lt; abi.SwissMapGroupSlots; it.entryIdx++ &#123;</span><br><span class="line">            k := <span class="type">uintptr</span>(it.entryIdx+it.entryOffset) % abi.SwissMapGroupSlots</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除的或空的slot？跳过（small map删除直接设置为empty）</span></span><br><span class="line">            <span class="keyword">if</span> (it.group.ctrls().get(k) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            key := it.group.key(it.typ, k)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            grown := it.m.dirLen &gt; <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">            <span class="comment">// 还在扩容中</span></span><br><span class="line">            <span class="keyword">if</span> grown &#123;</span><br><span class="line">                <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">                <span class="comment">// 从扩容后的map获取</span></span><br><span class="line">                newKey, newElem, ok := it.m.getWithKey(it.typ, key)</span><br><span class="line">                <span class="comment">// 找不到</span></span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">// key是NaN</span></span><br><span class="line">                    <span class="comment">// NaN无法被update/delete，只能clear，如果很幸运，没有clear过，那么可以从旧的table里拿到数据</span></span><br><span class="line">                    <span class="comment">// 详细可以看grownKeyElem注释</span></span><br><span class="line">                    <span class="keyword">if</span> it.clearSeq == it.m.clearSeq &amp;&amp; !it.typ.Key.Equal(key, key) &#123;</span><br><span class="line">                        elem = it.group.elem(it.typ, k)</span><br><span class="line">                        <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                            elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 被删除了</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 按新的key/value为准</span></span><br><span class="line">                    key = newKey</span><br><span class="line">                    elem = newElem</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有扩容</span></span><br><span class="line">                elem = it.group.elem(it.typ, k)</span><br><span class="line">                <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新iter，方便下次调用</span></span><br><span class="line">            it.entryIdx++  <span class="comment">// [0,1023]</span></span><br><span class="line">            it.key = key   <span class="comment">// 上层读取数据用</span></span><br><span class="line">            it.elem = elem <span class="comment">// 上层读取数据用</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经扫描完所有slot</span></span><br><span class="line">        it.key = <span class="literal">nil</span></span><br><span class="line">        it.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 常规map</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果map在iter的过程中分裂了</span></span><br><span class="line">    <span class="keyword">if</span> it.globalDepth != it.m.globalDepth &#123;</span><br><span class="line">        <span class="comment">// Consider:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Before:</span></span><br><span class="line">        <span class="comment">// - 0: *t1</span></span><br><span class="line">        <span class="comment">// - 1: *t2  &lt;- dirIdx</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// After:</span></span><br><span class="line">        <span class="comment">// - 0: *t1a (split)</span></span><br><span class="line">        <span class="comment">// - 1: *t1b (split)</span></span><br><span class="line">        <span class="comment">// - 2: *t2  &lt;- dirIdx</span></span><br><span class="line">        <span class="comment">// - 3: *t2</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// dirIdx*(2^分裂次数)即可指向正确的table</span></span><br><span class="line">        <span class="comment">// 具体公式如下</span></span><br><span class="line">        <span class="comment">// dirIdx := (it.dirIdx + it.dirOffset) % it.m.dirLen</span></span><br><span class="line">        <span class="comment">// 需要保证结果为正</span></span><br><span class="line">        orders := it.m.globalDepth - it.globalDepth <span class="comment">// 分裂次数</span></span><br><span class="line">        it.dirIdx &lt;&lt;= orders    <span class="comment">// 2^orders</span></span><br><span class="line">        it.dirOffset &lt;&lt;= orders</span><br><span class="line">        <span class="comment">// it.m.dirLen // 调整directory时已经调整了dirLen，这里不需要再处理</span></span><br><span class="line">        it.globalDepth = it.m.globalDepth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描所有table [0,dirLen]，当然nextDirIdx会根据分裂等情况调整table的索引</span></span><br><span class="line">    <span class="keyword">for</span> ; it.dirIdx &lt; it.m.dirLen; it.nextDirIdx() &#123;</span><br><span class="line">        <span class="comment">// table第一次扫描时</span></span><br><span class="line">        <span class="keyword">if</span> it.tab == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// local dirIdx</span></span><br><span class="line">            dirIdx := <span class="type">int</span>((<span class="type">uint64</span>(it.dirIdx) + it.dirOffset) &amp; <span class="type">uint64</span>(it.m.dirLen<span class="number">-1</span>))</span><br><span class="line">            <span class="comment">// 找到目标table</span></span><br><span class="line">            newTab := it.m.directoryAt(<span class="type">uintptr</span>(dirIdx))</span><br><span class="line">            <span class="comment">// 解决随机dirIdx可能引发的问题</span></span><br><span class="line">            <span class="comment">// 扩容/分裂后，两个dirIdx可能指向同一个table</span></span><br><span class="line">            <span class="keyword">if</span> newTab.index != dirIdx &#123;</span><br><span class="line">                diff := dirIdx - newTab.index</span><br><span class="line">                <span class="comment">// 调整dirOffset，使其能指向table的index</span></span><br><span class="line">                it.dirOffset -= <span class="type">uint64</span>(diff)</span><br><span class="line">                <span class="comment">// 以table的index为准</span></span><br><span class="line">                dirIdx = newTab.index</span><br><span class="line">            &#125;</span><br><span class="line">            it.tab = newTab</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        entryMask := <span class="type">uint64</span>(it.tab.capacity) - <span class="number">1</span></span><br><span class="line">        <span class="comment">// 全局计数器超过table的容量时，扫描下一个table</span></span><br><span class="line">        <span class="keyword">if</span> it.entryIdx &gt; entryMask &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 Fast path：只判断当前idx指向的ctrl，这要比匹配一组ctrls快</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// slot全局计数器</span></span><br><span class="line">        entryIdx := (it.entryIdx + it.entryOffset) &amp; entryMask</span><br><span class="line">        <span class="comment">// slot局部计数器-按8取模</span></span><br><span class="line">        slotIdx := <span class="type">uintptr</span>(entryIdx &amp; (abi.SwissMapGroupSlots - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slotIdx重新回到0 or 第一次遍历当前table</span></span><br><span class="line">        <span class="keyword">if</span> slotIdx == <span class="number">0</span> || it.group.data == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// groupIdx=entryIdx丢弃低3位 =&gt; [0,127]</span></span><br><span class="line">            groupIdx := entryIdx &gt;&gt; abi.SwissMapGroupSlotsBits</span><br><span class="line">            it.group = it.tab.groups.group(it.typ, groupIdx)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，table、group、slot的索引都已经确认了，只判断单个slot即可</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前slot是刚好是有值的，ctrl=full</span></span><br><span class="line">        <span class="keyword">if</span> (it.group.ctrls().get(slotIdx) &amp; ctrlEmpty) == <span class="number">0</span> &#123;</span><br><span class="line">            key := it.group.key(it.typ, slotIdx)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            grown := it.tab.index == <span class="number">-1</span></span><br><span class="line">            <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">            <span class="comment">// 扩容中</span></span><br><span class="line">            <span class="keyword">if</span> grown &#123;</span><br><span class="line">                <span class="comment">// 从新table拿数据，如果拿不到，确认是NaN还是已删除</span></span><br><span class="line">                newKey, newElem, ok := it.grownKeyElem(key, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">// 没找到，走slow path</span></span><br><span class="line">                    <span class="keyword">goto</span> next</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    key = newKey</span><br><span class="line">                    elem = newElem</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非扩容</span></span><br><span class="line">                elem = it.group.elem(it.typ, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 纪录key/value</span></span><br><span class="line">            it.entryIdx++</span><br><span class="line">            it.key = key</span><br><span class="line">            it.elem = elem</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    next:</span><br><span class="line">        <span class="comment">// 计数器+1</span></span><br><span class="line">        it.entryIdx++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 Slow path：批量匹配一组ctrl</span></span><br><span class="line">        <span class="comment">// 如果map比较稀疏效率会比较高</span></span><br><span class="line">        <span class="comment">// 如果是中等负载运行效果亦佳，如每个group有3-4个empty的slot</span></span><br><span class="line">        <span class="comment">// 遍历过程可能会发生删除等操作，需要double-check</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> groupMatch bitset</span><br><span class="line">        <span class="keyword">for</span> it.entryIdx &lt;= entryMask &#123;</span><br><span class="line">            <span class="comment">// slot全局计数器</span></span><br><span class="line">            entryIdx := (it.entryIdx + it.entryOffset) &amp; entryMask</span><br><span class="line">            <span class="comment">// slot局部计数器-按8取模</span></span><br><span class="line">            slotIdx := <span class="type">uintptr</span>(entryIdx &amp; (abi.SwissMapGroupSlots - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// slotIdx重新回到0 or 第一次遍历当前table</span></span><br><span class="line">            <span class="keyword">if</span> slotIdx == <span class="number">0</span> || it.group.data == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// groupIdx=entryIdx丢弃低3位 =&gt; [0,127]</span></span><br><span class="line">                groupIdx := entryIdx &gt;&gt; abi.SwissMapGroupSlotsBits</span><br><span class="line">                it.group = it.tab.groups.group(it.typ, groupIdx)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 刚开始 或者 上一轮没找到</span></span><br><span class="line">            <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 寻找ctrl=full状态的slot</span></span><br><span class="line">                groupMatch = it.group.ctrls().matchFull()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> slotIdx != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 把当前group的idx&lt;slotIdx的ctrl全部置为0，即丢弃掉</span></span><br><span class="line">                    <span class="comment">// 扫描过？or 随机？</span></span><br><span class="line">                    groupMatch = groupMatch.removeBelow(slotIdx)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有找到</span></span><br><span class="line">                <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 扫描下一个group</span></span><br><span class="line">                    it.entryIdx += abi.SwissMapGroupSlots - <span class="type">uint64</span>(slotIdx)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到一组数据了</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取第一个full slot</span></span><br><span class="line">                i := groupMatch.first()</span><br><span class="line">                <span class="comment">// 调整计数器，使其指向当前slot =&gt; slotIdx=i</span></span><br><span class="line">                it.entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">                <span class="comment">// 扫描了table全部数据了，扫描下一个table</span></span><br><span class="line">                <span class="comment">// idx roll over了，这个数据之前已经返回过了</span></span><br><span class="line">                <span class="keyword">if</span> it.entryIdx &gt; entryMask &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这句源代码应该是写重复了</span></span><br><span class="line">                entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">                slotIdx = i</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            key := it.group.key(it.typ, slotIdx)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            grown := it.tab.index == <span class="number">-1</span></span><br><span class="line">            <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">            <span class="comment">// 扩容/分裂后</span></span><br><span class="line">            <span class="keyword">if</span> grown &#123;</span><br><span class="line">                <span class="comment">// 从新table拿数据，如果拿不到，确认是NaN还是已删除</span></span><br><span class="line">                newKey, newElem, ok := it.grownKeyElem(key, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">// 没找到</span></span><br><span class="line">                    <span class="comment">// groupMatch末尾第一个1将会被置为0</span></span><br><span class="line">                    groupMatch = groupMatch.removeFirst()</span><br><span class="line">                    <span class="comment">// 当前组的slot扫描完了</span></span><br><span class="line">                    <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 指向下一个group开始位置</span></span><br><span class="line">                        it.entryIdx += abi.SwissMapGroupSlots - <span class="type">uint64</span>(slotIdx)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 下一个非空的slot的idx</span></span><br><span class="line">                    i := groupMatch.first()</span><br><span class="line">                    it.entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    key = newKey</span><br><span class="line">                    elem = newElem</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非扩容</span></span><br><span class="line">                elem = it.group.elem(it.typ, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// groupMatch末尾第一个1将会被置为0</span></span><br><span class="line">            groupMatch = groupMatch.removeFirst()</span><br><span class="line">            <span class="comment">// 当前组的slot扫描完了</span></span><br><span class="line">            <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 指向下一个group开始位置</span></span><br><span class="line">                it.entryIdx += abi.SwissMapGroupSlots - <span class="type">uint64</span>(slotIdx)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一个非空的slot的idx</span></span><br><span class="line">                i := groupMatch.first()</span><br><span class="line">                it.entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it.key = key</span><br><span class="line">            it.elem = elem</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Continue to next table.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描完所有table，结束</span></span><br><span class="line">    it.key = <span class="literal">nil</span></span><br><span class="line">    it.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个dirIdx，原文已经详细介绍了原理，不再赘述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> nextDirIdx() &#123;</span><br><span class="line">    <span class="comment">// Consider this directory:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// - 0: *t1</span></span><br><span class="line">    <span class="comment">// - 1: *t1</span></span><br><span class="line">    <span class="comment">// - 2: *t2a</span></span><br><span class="line">    <span class="comment">// - 3: *t2b</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果随机的dirIdx指向1，调整为0，上层代码已处理</span></span><br><span class="line">    <span class="comment">// 如果dirIdx指向0，下一个dirIdx指向2，跳过1</span></span><br><span class="line">    <span class="comment">// 如果此时t1分裂了，而我们的tab指向是旧的t1而不是t1a、t1b，依然要指跳过1</span></span><br><span class="line">    entries := <span class="number">1</span> &lt;&lt; (it.m.globalDepth - it.tab.localDepth)</span><br><span class="line">    it.dirIdx += entries</span><br><span class="line">    it.tab = <span class="literal">nil</span></span><br><span class="line">    it.group = groupReference&#123;&#125;</span><br><span class="line">    it.entryIdx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从新table拿数据，如果拿不到，确认是NaN还是已删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> grownKeyElem(key unsafe.Pointer, slotIdx <span class="type">uintptr</span>) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    newKey, newElem, ok := it.m.getWithKey(it.typ, key)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// Key has likely been deleted, and</span></span><br><span class="line">        <span class="comment">// should be skipped.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// One exception is keys that don&#x27;t</span></span><br><span class="line">        <span class="comment">// compare equal to themselves (e.g.,</span></span><br><span class="line">        <span class="comment">// NaN). These keys cannot be looked</span></span><br><span class="line">        <span class="comment">// up, so getWithKey will fail even if</span></span><br><span class="line">        <span class="comment">// the key exists.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// However, we are in luck because such</span></span><br><span class="line">        <span class="comment">// keys cannot be updated and they</span></span><br><span class="line">        <span class="comment">// cannot be deleted except with clear.</span></span><br><span class="line">        <span class="comment">// Thus if no clear has occurred, the</span></span><br><span class="line">        <span class="comment">// key/elem must still exist exactly as</span></span><br><span class="line">        <span class="comment">// in the old groups, so we can return</span></span><br><span class="line">        <span class="comment">// them from there.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// TODO(prattmic): Consider checking</span></span><br><span class="line">        <span class="comment">// clearSeq early. If a clear occurred,</span></span><br><span class="line">        <span class="comment">// Next could always return</span></span><br><span class="line">        <span class="comment">// immediately, as iteration doesn&#x27;t</span></span><br><span class="line">        <span class="comment">// need to return anything added after</span></span><br><span class="line">        <span class="comment">// clear.</span></span><br><span class="line">        <span class="keyword">if</span> it.clearSeq == it.m.clearSeq &amp;&amp; !it.typ.Key.Equal(key, key) &#123;</span><br><span class="line">            elem := it.group.elem(it.typ, slotIdx)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> key, elem, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This entry doesn&#x27;t exist anymore.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newKey, newElem, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">v1[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>系统调用runtime_mapassign实现map的赋值操作，其代码逻辑与Put方法相似，大概逻辑如下</p>
<ol>
<li>如果是小map，扫描group，找到空位置返回地址</li>
<li>如果是常规大小的map，根据哈希值找到table，用二次探测法找到合适的group，最后找到空位置返回地址</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_mapassign</span><span class="params">(typ *abi.SwissMapType, m *Map, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Put(typ *abi.SwissMapType, key, elem unsafe.Pointer) &#123;</span><br><span class="line">    slotElem := m.PutSlot(typ, key)</span><br><span class="line">    typedmemmove(typ.Elem, slotElem, elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutSlot returns a pointer to the element slot where an inserted element</span></span><br><span class="line"><span class="comment">// should be written.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PutSlot never returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> PutSlot(typ *abi.SwissMapType, key unsafe.Pointer) unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set writing after calling Hasher, since Hasher may panic, in which</span></span><br><span class="line">    <span class="comment">// case we have not actually done a write.</span></span><br><span class="line">    m.writing ^= <span class="number">1</span> <span class="comment">// toggle, see comment on writing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空的，原因有很多，这里初始化一个table一个group</span></span><br><span class="line">    <span class="keyword">if</span> m.dirPtr == <span class="literal">nil</span> &#123;</span><br><span class="line">        m.growToSmall(typ)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// used&lt;8</span></span><br><span class="line">        <span class="keyword">if</span> m.used &lt; abi.SwissMapGroupSlots &#123;</span><br><span class="line">            <span class="comment">// value指针</span></span><br><span class="line">            elem := m.putSlotSmall(typ, hash, key)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">            <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">                fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取消writing标志</span></span><br><span class="line">            m.writing ^= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> elem</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// used&gt;=8？扩容</span></span><br><span class="line">        <span class="comment">// 单个group到完整的table-groups结构</span></span><br><span class="line">        m.growToTable(typ)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirLen&gt;0 or used&gt;=8</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">        idx := m.directoryIndex(hash)</span><br><span class="line">        elem, ok := m.directoryAt(idx).PutSlot(typ, m, hash, key)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">        <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">            fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取消writing标志</span></span><br><span class="line">        m.writing ^= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// small map初始化group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> growToSmall(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 创建一个group</span></span><br><span class="line">    grp := newGroups(typ, <span class="number">1</span>)</span><br><span class="line">    m.dirPtr = grp.data</span><br><span class="line"></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个slot对应的ctrl都设置为empty =&gt; 0b10000000</span></span><br><span class="line">    g.ctrls().setEmpty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个group到完整的table-groups结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> growToTable(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 一个table，两个group</span></span><br><span class="line">    <span class="comment">// capacity=16 index=0 localDepth=0</span></span><br><span class="line">    tab := newTable(typ, <span class="number">2</span>*abi.SwissMapGroupSlots, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原先的group指针</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.SwissMapGroupSlots; i++ &#123;</span><br><span class="line">        <span class="comment">// 空的不处理</span></span><br><span class="line">        <span class="keyword">if</span> (g.ctrls().get(i) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">            <span class="comment">// Empty</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key地址</span></span><br><span class="line">        key := g.key(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            key = *((*unsafe.Pointer)(key))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value地址</span></span><br><span class="line">        elem := g.elem(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">            elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key的hash</span></span><br><span class="line">        hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">        tab.uncheckedPutSlot(typ, hash, key, elem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个table</span></span><br><span class="line">    directory := <span class="built_in">make</span>([]*table, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    directory[<span class="number">0</span>] = tab</span><br><span class="line"></span><br><span class="line">    m.dirPtr = unsafe.Pointer(&amp;directory[<span class="number">0</span>])</span><br><span class="line">    m.dirLen = <span class="built_in">len</span>(directory)</span><br><span class="line"></span><br><span class="line">    m.globalDepth = <span class="number">0</span> <span class="comment">// 2^0=1</span></span><br><span class="line">    m.globalShift = depthToShift(m.globalDepth) <span class="comment">// 64-0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有一个table一个group时，或者说只有一个group时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> putSlotSmall(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">    match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已存在（假阳性）</span></span><br><span class="line">    <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个非空的slot</span></span><br><span class="line">        i := match.first()</span><br><span class="line"></span><br><span class="line">        slotKey := g.key(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">            <span class="keyword">if</span> typ.NeedKeyUpdate() &#123;</span><br><span class="line">                typedmemmove(typ.Key, slotKey, key)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回value的地址</span></span><br><span class="line">            <span class="keyword">return</span> slotElem</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">        match = match.removeFirst()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// matchEmptyOrDeleted将full状态的ctrl全部置为0，找到empty和deleted的slot</span></span><br><span class="line">    <span class="comment">// small map不能删除slot</span></span><br><span class="line">    match = g.ctrls().matchEmptyOrDeleted()</span><br><span class="line">    <span class="comment">// 8个slot都被使用了</span></span><br><span class="line">    <span class="keyword">if</span> match == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;small map with no empty slot (concurrent map writes?)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过上一步，empty跟delete标记的slot都被找出来了</span></span><br><span class="line">    i := match.first()</span><br><span class="line"></span><br><span class="line">    slotKey := g.key(typ, i)</span><br><span class="line">    <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">        kmem := newobject(typ.Key)</span><br><span class="line">        *(*unsafe.Pointer)(slotKey) = kmem</span><br><span class="line">        slotKey = kmem</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemmove(typ.Key, slotKey, key)</span><br><span class="line"></span><br><span class="line">    slotElem := g.elem(typ, i)</span><br><span class="line">    <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">        emem := newobject(typ.Elem)</span><br><span class="line">        *(*unsafe.Pointer)(slotElem) = emem</span><br><span class="line">        slotElem = emem</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctrl状态更新</span></span><br><span class="line">    g.ctrls().set(i, ctrl(h2(hash)))</span><br><span class="line">    <span class="comment">// 计数器更新，small map用的是map结构体的used</span></span><br><span class="line">    m.used++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slotElem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> PutSlot(typ *abi.SwissMapType, m *Map, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录第一个已删除slot的group指针和slot索引</span></span><br><span class="line">    <span class="keyword">var</span> firstDeletedGroup groupReference</span><br><span class="line">    <span class="keyword">var</span> firstDeletedSlot <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line">        <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">        match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match不为0，至少找到一个（假阳性）</span></span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            <span class="comment">// 看样子同一个i会被用很多次</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">                <span class="comment">// 更新key？</span></span><br><span class="line">                <span class="keyword">if</span> typ.NeedKeyUpdate() &#123;</span><br><span class="line">                    typedmemmove(typ.Key, slotKey, key)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// value</span></span><br><span class="line">                slotElem := g.elem(typ, i)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// debug时开启，忽略</span></span><br><span class="line">                t.checkInvariants(typ, m)</span><br><span class="line">                <span class="keyword">return</span> slotElem, <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">            match = match.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmptyOrDeleted将full状态的ctrl全部置为0，找到empty和deleted的slot</span></span><br><span class="line">        match = g.ctrls().matchEmptyOrDeleted()</span><br><span class="line">        <span class="comment">// 8个slot都被使用了，看是否在其他group</span></span><br><span class="line">        <span class="keyword">if</span> match == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// nothing but filled slots. Keep probing.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有空的或被删除的slot</span></span><br><span class="line">        i := match.first()</span><br><span class="line">        <span class="comment">// 该slot已删除，继续找其他group</span></span><br><span class="line">        <span class="comment">// todo 其他index都是已删除吗？为什么不继续找当前group</span></span><br><span class="line">        <span class="keyword">if</span> g.ctrls().get(i) == ctrlDeleted &#123;</span><br><span class="line">            <span class="comment">// 纪录group指针和slot的index</span></span><br><span class="line">            <span class="keyword">if</span> firstDeletedGroup.data == <span class="literal">nil</span> &#123;</span><br><span class="line">                firstDeletedGroup = g</span><br><span class="line">                firstDeletedSlot = i</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// empty代表探测的末尾，不用再找了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we found a deleted slot along the way, we can</span></span><br><span class="line">        <span class="comment">// replace it without consuming growthLeft.</span></span><br><span class="line">        <span class="keyword">if</span> firstDeletedGroup.data != <span class="literal">nil</span> &#123;</span><br><span class="line">            g = firstDeletedGroup</span><br><span class="line">            i = firstDeletedSlot</span><br><span class="line">            t.growthLeft++ <span class="comment">// will be decremented below to become a no-op.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is room left to grow, just insert the new entry.</span></span><br><span class="line">        <span class="keyword">if</span> t.growthLeft &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                kmem := newobject(typ.Key)</span><br><span class="line">                *(*unsafe.Pointer)(slotKey) = kmem</span><br><span class="line">                slotKey = kmem</span><br><span class="line">            &#125;</span><br><span class="line">            typedmemmove(typ.Key, slotKey, key)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                emem := newobject(typ.Elem)</span><br><span class="line">                *(*unsafe.Pointer)(slotElem) = emem</span><br><span class="line">                slotElem = emem</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// map/table/group状态更新</span></span><br><span class="line">            g.ctrls().set(i, ctrl(h2(hash)))</span><br><span class="line">            t.growthLeft--</span><br><span class="line">            t.used++</span><br><span class="line">            m.used++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// debug时开启，忽略</span></span><br><span class="line">            t.checkInvariants(typ, m)</span><br><span class="line">            <span class="keyword">return</span> slotElem, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// table扩容，如果超过限制的1024个slot，分裂并更新map</span></span><br><span class="line">        t.rehash(typ, m)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时用，复制旧的table的slot数据到新的table</span></span><br><span class="line"><span class="comment">// 1. growthLeft-- used++</span></span><br><span class="line"><span class="comment">// 2. 不能有已删除的slot</span></span><br><span class="line"><span class="comment">// 3. indirect的key和value可以直接复制，由调用者保证key/value数据不变</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> uncheckedPutSlot(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key, elem unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> t.growthLeft == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;invariant failed: growthLeft is unexpectedly 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmptyOrDeleted将full状态的ctrl全部置为0，找到empty和deleted的slot</span></span><br><span class="line">        match := g.ctrls().matchEmptyOrDeleted()</span><br><span class="line">        <span class="comment">// match不为0，至少找到一个</span></span><br><span class="line">        <span class="keyword">if</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(slotKey) = key</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                typedmemmove(typ.Key, slotKey, key)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制value</span></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(slotElem) = elem</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                typedmemmove(typ.Elem, slotElem, elem)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 状态更新</span></span><br><span class="line">            t.growthLeft--</span><br><span class="line">            t.used++</span><br><span class="line">            g.ctrls().set(i, ctrl(h2(hash)))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>map使用growthLeft作为可用的slot大小，该值一般为capacity*7&#x2F;8，最大值为896。每次写入都会消耗growthLeft，当growthLeft减少到0时，触发扩容，扩容函数为rehash</p>
<p>大概逻辑如下</p>
<ol>
<li>如果扩容后到容量没有超过单个table的容量限制<ul>
<li>创建双倍容量的新table，将旧table的数据拷贝到新的table</li>
<li>dirPtr按指定索引替换掉table指针</li>
</ul>
</li>
<li>如果扩容后容量超过单个table的容量限制<ul>
<li>创建两个容量为1024的table_a和table_b</li>
<li>按哈希值高B+1位疏散slot数据到新的table</li>
<li>疏散完毕后，双倍扩容dirPtr数组</li>
<li>重新调整dirPtr数组指针</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table扩容，如果超过限制的1024个slot，分裂并更新map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> rehash(typ *abi.SwissMapType, m *Map) &#123;</span><br><span class="line">    <span class="comment">// 双倍容量</span></span><br><span class="line">    newCapacity := <span class="number">2</span> * t.capacity</span><br><span class="line">    <span class="comment">// 没有超过单个table的容量限制 -&gt; 扩容</span></span><br><span class="line">    <span class="keyword">if</span> newCapacity &lt;= maxTableCapacity &#123;</span><br><span class="line">        t.grow(typ, m, newCapacity)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过单个table容量限制 -&gt; 分裂</span></span><br><span class="line">    t.split(typ, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> grow(typ *abi.SwissMapType, m *Map, newCapacity <span class="type">uint16</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建table</span></span><br><span class="line">    newTable := newTable(typ, <span class="type">uint64</span>(newCapacity), t.index, t.localDepth)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里还能等于0？</span></span><br><span class="line">    <span class="keyword">if</span> t.capacity &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有group</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">            g := t.groups.group(typ, i)</span><br><span class="line">            <span class="comment">// 遍历所有slot</span></span><br><span class="line">            <span class="keyword">for</span> j := <span class="type">uintptr</span>(<span class="number">0</span>); j &lt; abi.SwissMapGroupSlots; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> (g.ctrls().get(j) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">                    <span class="comment">// Empty or deleted</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// key</span></span><br><span class="line">                key := g.key(typ, j)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                    key = *((*unsafe.Pointer)(key))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// value</span></span><br><span class="line">                elem := g.elem(typ, j)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// hash</span></span><br><span class="line">                hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 复制key和value到newTable</span></span><br><span class="line">                newTable.uncheckedPutSlot(typ, hash, key, elem)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug时开启，忽略</span></span><br><span class="line">    newTable.checkInvariants(typ, m)</span><br><span class="line">    <span class="comment">// dirPtr指定index关联newTable</span></span><br><span class="line">    m.replaceTable(newTable)</span><br><span class="line">    <span class="comment">// 旧的table标记为过期</span></span><br><span class="line">    t.index = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// table分裂</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    directory (globalDepth=2)</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="comment">//    | 00 | --\</span></span><br><span class="line"><span class="comment">//    +----+    +--&gt; table (localDepth=1)</span></span><br><span class="line"><span class="comment">//    | 01 | --/</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="comment">//    | 10 | ------&gt; table (localDepth=2)</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="comment">//    | 11 | ------&gt; table (localDepth=2)</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> split(typ *abi.SwissMapType, m *Map) &#123;</span><br><span class="line">    localDepth := t.localDepth</span><br><span class="line">    localDepth++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// capacity=1024 index=-1 localDepth=localDepth+1</span></span><br><span class="line">    <span class="comment">// 两个table设置为已过期</span></span><br><span class="line">    left := newTable(typ, maxTableCapacity, <span class="number">-1</span>, localDepth)</span><br><span class="line">    right := newTable(typ, maxTableCapacity, <span class="number">-1</span>, localDepth)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1&lt;&lt;(64-localDepth) 高(B+1)位所谓索引</span></span><br><span class="line">    <span class="comment">// origin_depth=1 index =&gt; [0,1]</span></span><br><span class="line">    <span class="comment">// current_depth=2 index =&gt; [0,1,2,3]</span></span><br><span class="line">    mask := localDepthMask(localDepth)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有group</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">        g := t.groups.group(typ, i)</span><br><span class="line">        <span class="comment">// 遍历所有slot</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="type">uintptr</span>(<span class="number">0</span>); j &lt; abi.SwissMapGroupSlots; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.ctrls().get(j) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">                <span class="comment">// Empty or deleted</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            key := g.key(typ, j)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            elem := g.elem(typ, j)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// hash</span></span><br><span class="line">            hash := typ.Hasher(key, m.seed)</span><br><span class="line">            <span class="keyword">var</span> newTable *table</span><br><span class="line">            <span class="comment">// 按hash新的bit进行分组</span></span><br><span class="line">            <span class="keyword">if</span> hash&amp;mask == <span class="number">0</span> &#123;</span><br><span class="line">                newTable = left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newTable = right</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 复制key和value到newTable</span></span><br><span class="line">            newTable.uncheckedPutSlot(typ, hash, key, elem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    m.installTableSplit(t, left, right)</span><br><span class="line">    <span class="comment">// 旧的table标记为过期</span></span><br><span class="line">    t.index = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据table的index，更新dirPtr数组的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> replaceTable(nt *table) &#123;</span><br><span class="line">    <span class="comment">// The number of entries that reference the same table doubles for each</span></span><br><span class="line">    <span class="comment">// time the globalDepth grows without the table splitting.</span></span><br><span class="line">    entries := <span class="number">1</span> &lt;&lt; (m.globalDepth - nt.localDepth)</span><br><span class="line">    <span class="comment">// 有分裂？更新多个dirPtr数组的table指针，没有分裂就会只有一个index</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; entries; i++ &#123;</span><br><span class="line">        <span class="comment">//m.directory[nt.index+i] = nt</span></span><br><span class="line">        m.directorySet(<span class="type">uintptr</span>(nt.index+i), nt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> installTableSplit(old, left, right *table) &#123;</span><br><span class="line">    <span class="comment">// table分裂了，dirPtr数组需要扩容</span></span><br><span class="line">    <span class="comment">// 第一个分裂的table</span></span><br><span class="line">    <span class="keyword">if</span> old.localDepth == m.globalDepth &#123;</span><br><span class="line">        <span class="comment">// 双倍扩容</span></span><br><span class="line">        newDir := <span class="built_in">make</span>([]*table, m.dirLen*<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> m.dirLen &#123;</span><br><span class="line">            t := m.directoryAt(<span class="type">uintptr</span>(i))</span><br><span class="line">            <span class="comment">// 指向同一个table</span></span><br><span class="line">            newDir[<span class="number">2</span>*i] = t</span><br><span class="line">            newDir[<span class="number">2</span>*i+<span class="number">1</span>] = t</span><br><span class="line">            <span class="comment">// t may already exist in multiple indicies. We should</span></span><br><span class="line">            <span class="comment">// only update t.index once. Since the index must</span></span><br><span class="line">            <span class="comment">// increase, seeing the original index means this must</span></span><br><span class="line">            <span class="comment">// be the first time we&#x27;ve encountered this table.</span></span><br><span class="line">            <span class="keyword">if</span> t.index == i &#123;</span><br><span class="line">                t.index = <span class="number">2</span> * i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m.globalDepth++</span><br><span class="line">        m.globalShift--</span><br><span class="line">        m.dirPtr = unsafe.Pointer(&amp;newDir[<span class="number">0</span>])</span><br><span class="line">        m.dirLen = <span class="built_in">len</span>(newDir)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// N.B. left and right may still consume multiple indicies if the</span></span><br><span class="line">    <span class="comment">// directory has grown multiple times since old was last split.</span></span><br><span class="line">    left.index = old.index</span><br><span class="line">    <span class="comment">// dirPtr指定index关联newTable</span></span><br><span class="line">    m.replaceTable(left)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他table可能分裂多次，导致localDepth远小于globalDepth，无法直接+1</span></span><br><span class="line">    entries := <span class="number">1</span> &lt;&lt; (m.globalDepth - left.localDepth)</span><br><span class="line">    right.index = left.index + entries</span><br><span class="line">    <span class="comment">// dirPtr指定index关联newTable</span></span><br><span class="line">    m.replaceTable(right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(v1, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当使用关键字delete删除指定key时，调用mapdelete，大概逻辑如下</p>
<ol>
<li>如果map的slot数量小于等于8，small map，直接扫描dirPtr指向的group，删除key&#x2F;value并将对应的ctrl改为empty</li>
<li>如果map的slot数量大于8，根据hash使用二次探测查找法定位table、group，找到目标slot<ul>
<li>如果该group是满数据的，将ctrl改为deleted</li>
<li>如果该group是有空位的，将ctrl改为empty</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *abi.SwissMapType, m *maps.Map, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    m.Delete(t, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(typ *abi.SwissMapType, key unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> || m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := mapKeyError(typ, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set writing after calling Hasher, since Hasher may panic, in which</span></span><br><span class="line">    <span class="comment">// case we have not actually done a write.</span></span><br><span class="line">    m.writing ^= <span class="number">1</span> <span class="comment">// toggle, see comment on writing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        m.deleteSmall(typ, hash, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">        idx := m.directoryIndex(hash)</span><br><span class="line">        m.directoryAt(idx).Delete(typ, m, hash, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删光了？重置hash种子</span></span><br><span class="line">    <span class="keyword">if</span> m.used == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Reset the hash seed to make it more difficult for attackers</span></span><br><span class="line">        <span class="comment">// to repeatedly trigger hash collisions. See</span></span><br><span class="line">        <span class="comment">// https://go.dev/issue/25237.</span></span><br><span class="line">        m.seed = <span class="type">uintptr</span>(rand())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消writing标志</span></span><br><span class="line">    m.writing ^= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有一个table一个group时，或者说只有一个group时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> deleteSmall(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">    match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到了（假阳性）</span></span><br><span class="line">    <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 按顺序比对ctrl</span></span><br><span class="line">        i := match.first()</span><br><span class="line">        slotKey := g.key(typ, i)</span><br><span class="line">        origSlotKey := slotKey</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key比对成功</span></span><br><span class="line">        <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">            <span class="comment">// 计数器更新，small map用的是map结构体的used</span></span><br><span class="line">            m.used--</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key是一个指针，直接置为nil</span></span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                *(*unsafe.Pointer)(origSlotKey) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> typ.Key.Pointers() &#123;</span><br><span class="line">                <span class="comment">// key存储的是一个指针</span></span><br><span class="line">                <span class="comment">// Only bother clearing if there are pointers.</span></span><br><span class="line">                typedmemclr(typ.Key, slotKey)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                *(*unsafe.Pointer)(slotElem) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Unlike keys, always clear the elem (even if</span></span><br><span class="line">                <span class="comment">// it contains no pointers), as compound</span></span><br><span class="line">                <span class="comment">// assignment operations depend on cleared</span></span><br><span class="line">                <span class="comment">// deleted values. See</span></span><br><span class="line">                <span class="comment">// https://go.dev/issue/25936.</span></span><br><span class="line">                typedmemclr(typ.Elem, slotElem)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置为empty而不是deleted</span></span><br><span class="line">            <span class="comment">// We only have 1 group, so it is OK to immediately</span></span><br><span class="line">            <span class="comment">// reuse deleted slots.</span></span><br><span class="line">            g.ctrls().set(i, ctrlEmpty)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">        match = match.removeFirst()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> Delete(typ *abi.SwissMapType, m *Map, hash <span class="type">uintptr</span>, key unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line">        <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">        match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了（假阳性）</span></span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            origSlotKey := slotKey</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key比对成功</span></span><br><span class="line">            <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">                <span class="comment">// 计数器更新</span></span><br><span class="line">                t.used--</span><br><span class="line">                m.used--</span><br><span class="line"></span><br><span class="line">                <span class="comment">// key是一个指针，直接置为nil</span></span><br><span class="line">                <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                    <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                    *(*unsafe.Pointer)(origSlotKey) = <span class="literal">nil</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> typ.Key.Pointers() &#123;</span><br><span class="line">                    <span class="comment">// key存储的是一个指针</span></span><br><span class="line">                    <span class="comment">// Only bothing clear the key if there</span></span><br><span class="line">                    <span class="comment">// are pointers in it.</span></span><br><span class="line">                    typedmemclr(typ.Key, slotKey)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// value</span></span><br><span class="line">                slotElem := g.elem(typ, i)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                    *(*unsafe.Pointer)(slotElem) = <span class="literal">nil</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Unlike keys, always clear the elem (even if</span></span><br><span class="line">                    <span class="comment">// it contains no pointers), as compound</span></span><br><span class="line">                    <span class="comment">// assignment operations depend on cleared</span></span><br><span class="line">                    <span class="comment">// deleted values. See</span></span><br><span class="line">                    <span class="comment">// https://go.dev/issue/25936.</span></span><br><span class="line">                    typedmemclr(typ.Elem, slotElem)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// matchEmpty将非empty的ctrl全部置为0，如果8个ctrl都有数据，如full或者deleted状态，那么match=0</span></span><br><span class="line">                <span class="comment">// Only a full group can appear in the middle</span></span><br><span class="line">                <span class="comment">// of a probe sequence (a group with at least</span></span><br><span class="line">                <span class="comment">// one empty slot terminates probing). Once a</span></span><br><span class="line">                <span class="comment">// group becomes full, it stays full until</span></span><br><span class="line">                <span class="comment">// rehashing/resizing. So if the group isn&#x27;t</span></span><br><span class="line">                <span class="comment">// full now, we can simply remove the element.</span></span><br><span class="line">                <span class="comment">// Otherwise, we create a tombstone to mark the</span></span><br><span class="line">                <span class="comment">// slot as deleted.</span></span><br><span class="line">                <span class="keyword">if</span> g.ctrls().matchEmpty() != <span class="number">0</span> &#123;</span><br><span class="line">                    g.ctrls().set(i, ctrlEmpty)</span><br><span class="line">                    t.growthLeft++</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// tombstone</span></span><br><span class="line">                    g.ctrls().set(i, ctrlDeleted)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// debug时开启，忽略</span></span><br><span class="line">                t.checkInvariants(typ, m)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">            match = match.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmpty将非empty的ctrl全部置为0，如果8个ctrl都有数据，如full或者deleted状态，那么match=0</span></span><br><span class="line">        match = g.ctrls().matchEmpty()</span><br><span class="line">        <span class="keyword">if</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Finding an empty slot means we&#x27;ve reached the end of</span></span><br><span class="line">            <span class="comment">// the probe sequence.</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line">clear(v1)</span><br></pre></td></tr></table></figure>

<p>使用clear清理map的所有元素时，系统调用mapclear进行处理，大概逻辑如下</p>
<ol>
<li>如果是small map，直接清理掉group数据</li>
<li>如果是常规map，遍历table、group清理</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclear</span><span class="params">(t *abi.SwissMapType, m *maps.Map)</span></span> &#123;</span><br><span class="line">    m.Clear(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Clear(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> || m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    m.writing ^= <span class="number">1</span> <span class="comment">// toggle, see comment on writing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        m.clearSmall(typ)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> lastTab *table</span><br><span class="line">        <span class="comment">// 遍历所有table</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> m.dirLen &#123;</span><br><span class="line">            t := m.directoryAt(<span class="type">uintptr</span>(i))</span><br><span class="line">            <span class="comment">// 分裂时，会指向同一个table</span></span><br><span class="line">            <span class="keyword">if</span> t == lastTab &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清理groups、重置table状态</span></span><br><span class="line">            t.Clear(typ)</span><br><span class="line">            lastTab = t</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置map状态</span></span><br><span class="line">        m.used = <span class="number">0</span></span><br><span class="line">        m.clearSeq++</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> shrink directory?</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置hash种子</span></span><br><span class="line">    <span class="comment">// Reset the hash seed to make it more difficult for attackers to</span></span><br><span class="line">    <span class="comment">// repeatedly trigger hash collisions. See https://go.dev/issue/25237.</span></span><br><span class="line">    m.seed = <span class="type">uintptr</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消writing标志</span></span><br><span class="line">    m.writing ^= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> clearSmall(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    typedmemclr(typ.Group, g.data) <span class="comment">// slot数据</span></span><br><span class="line">    g.ctrls().setEmpty() <span class="comment">// ctrl状态</span></span><br><span class="line"></span><br><span class="line">    m.used = <span class="number">0</span></span><br><span class="line">    m.clearSeq++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> Clear(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 遍历所有group</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">        g := t.groups.group(typ, i)</span><br><span class="line">        typedmemclr(typ.Group, g.data) <span class="comment">// slot数据</span></span><br><span class="line">        g.ctrls().setEmpty() <span class="comment">// ctrl状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.used = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 根据capacity重置growthLeft字段</span></span><br><span class="line">    t.resetGrowthLeft()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下非克隆，只是复制了header</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = v1</span><br><span class="line"></span><br><span class="line"><span class="comment">// go 1.21</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = maps.Clone(v1)</span><br></pre></td></tr></table></figure>

<p>当使用maps.Clone复制数据时，系统使用mapclone2实现该操作，大概逻辑如下大概逻辑如下</p>
<ol>
<li>创建一个Iter</li>
<li>不断调用Next获取数据，写入新的map</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclone2</span><span class="params">(t *abi.SwissMapType, src *maps.Map)</span></span> *maps.Map &#123;</span><br><span class="line">    dst := makemap(t, <span class="type">int</span>(src.Used()), <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iter maps.Iter</span><br><span class="line">    iter.Init(t, src)</span><br><span class="line">    <span class="keyword">for</span> iter.Next(); iter.Key() != <span class="literal">nil</span>; iter.Next() &#123;</span><br><span class="line">        dst.Put(t, iter.Key(), iter.Elem())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-map-noswiss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-map-noswiss/" class="post-title-link" itemprop="url">golang系列之-map</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-15 23:44:59" itemprop="dateCreated datePublished" datetime="2025-02-15T23:44:59+08:00">2025-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-23 17:17:29" itemprop="dateModified" datetime="2025-02-23T17:17:29+08:00">2025-02-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>map&#x2F;哈希表，是golang常用的数据结构之一，也充当set数据结构的存在，相对slice要复杂很多。从1.24开始，swiss table替代noswiss成为默认实现，swiss与noswiss区别在于，swiss使用开放地址法，noswiss使用拉链法</p>
<p>当前go版本：1.23</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// hmap -&gt; oldbuckets</span></span><br><span class="line"><span class="comment">//      -&gt; buckets         -&gt; bmap0(8个key/value对) </span></span><br><span class="line"><span class="comment">//                         -&gt; bmap1 -&gt; overflow0(bmapX) -&gt; overflow1(bmapZ)</span></span><br><span class="line"><span class="comment">//                         -&gt; ...  </span></span><br><span class="line"><span class="comment">//                         -&gt; bmapM -&gt; overflow0(bmapY)</span></span><br><span class="line"><span class="comment">//                         -&gt; bmapN</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      -&gt; extra.overflow  -&gt; bmapX(pre-alloc)</span></span><br><span class="line"><span class="comment">//                         -&gt; bmapY(pre-alloc)</span></span><br><span class="line"><span class="comment">//                         -&gt; ...</span></span><br><span class="line"><span class="comment">//                         -&gt; bmapZ(new-alloc)</span></span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure>

<p>map的数据结构如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span>              <span class="comment">// 元素数量-key/value对</span></span><br><span class="line">    flags     <span class="type">uint8</span>            <span class="comment">// 1-iter正在使用buckets字段 2-iter正在使用oldbuckets字段 4-正在写入 8-同等大小扩容</span></span><br><span class="line">    B         <span class="type">uint8</span>            <span class="comment">// buckets数量=(loadFactor * 2^B)</span></span><br><span class="line">    noverflow <span class="type">uint16</span>           <span class="comment">// 统计溢出buckets的数量，当B大于15时不是精确值</span></span><br><span class="line">    hash0     <span class="type">uint32</span>           <span class="comment">// 哈希种子，计算hash用</span></span><br><span class="line">    buckets    unsafe.Pointer  <span class="comment">// buckets数组</span></span><br><span class="line">    oldbuckets unsafe.Pointer  <span class="comment">// 旧buckets数组，扩容时用</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>         <span class="comment">// 下一个未疏散的bucket索引</span></span><br><span class="line">    clearSeq   <span class="type">uint64</span>          <span class="comment">// 执行过多少次clear</span></span><br><span class="line">    extra *mapextra            <span class="comment">// 可选字段，不是每个map都需要，同时也需要为gc考虑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key/value都不是指针才会使用下面几个字段</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap       <span class="comment">// 溢出buckets，buckets链接使用</span></span><br><span class="line">    oldoverflow *[]*bmap       <span class="comment">// 溢出buckets，oldbuckets链接使用，扩容时</span></span><br><span class="line">    nextOverflow *bmap         <span class="comment">// 下一个可用/未使用overflow的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket结构，可存储8个key/value对及其他数据，编译时自动补充其余结构，真实结构如下</span></span><br><span class="line"><span class="comment">//    A &quot;bucket&quot; is a &quot;struct&quot; &#123;</span></span><br><span class="line"><span class="comment">//          tophash [abi.MapBucketCount]uint8  // hash的高8位</span></span><br><span class="line"><span class="comment">//          keys [abi.MapBucketCount]keyType   // 所有key</span></span><br><span class="line"><span class="comment">//          elems [abi.MapBucketCount]elemType // 所有value</span></span><br><span class="line"><span class="comment">//          overflow *bucket // 下一个溢出桶指针</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">// 详细可见MapBucketType函数（src/cmd/compile/internal/reflectdata/reflect.go）</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// abi.MapBucketCount=8</span></span><br><span class="line">    <span class="comment">// 0-默认状态 1-已删除 2-疏散到x 3-疏散到y 4-不需要疏散 5-guard xyz(&gt;5)-正常tophash值</span></span><br><span class="line">    <span class="comment">// 状态转移如下：</span></span><br><span class="line">    <span class="comment">// 0/xyz -&gt; 2/3/4 =&gt; 如果所有bucket都疏散完毕，会一次性清空释放</span></span><br><span class="line">    <span class="comment">// 0/xyz -&gt; 1 删除 =&gt; 如果idx+1的状态是0，则向前寻找状态为1数据并改为0</span></span><br><span class="line">    tophash [abi.MapBucketCount]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面数据结构中中比较关键的是</p>
<ul>
<li><code>hmap</code> - header部份，var变量存储的也是这部份</li>
<li><code>buckets</code> - 指向一片连续内存区域，bucket数组</li>
<li><code>bmap</code> - bucket的具体实现，可以存储8个key&#x2F;value对，尾部overflow是溢出bucket的指针</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>map的初始化方式有两种</p>
<ol>
<li>使用字面量创建map</li>
<li>使用关键字make创建</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(v1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// make关键字</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">v2[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">fmt.Println(v2)</span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量初始化调用的是maplit，具体看代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/walk/complit.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maplit</span><span class="params">(n *ir.CompLitExpr, m ir.Node, init *ir.Nodes)</span></span> &#123;</span><br><span class="line">    args := []ir.Node&#123;ir.TypeNode(n.Type()), ir.NewInt(base.Pos, n.Len+<span class="type">int64</span>(<span class="built_in">len</span>(n.List)))&#125;</span><br><span class="line">    a := typecheck.Expr(ir.NewCallExpr(base.Pos, ir.OMAKE, <span class="literal">nil</span>, args)).(*ir.MakeExpr)</span><br><span class="line">    a.RType = n.RType</span><br><span class="line">    a.SetEsc(n.Esc())</span><br><span class="line">    appendWalkStmt(init, ir.NewAssignStmt(base.Pos, m, a))</span><br><span class="line"></span><br><span class="line">    entries := n.List</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> entries &#123;</span><br><span class="line">        r := r.(*ir.KeyExpr)</span><br><span class="line">        <span class="keyword">if</span> !isStaticCompositeLiteral(r.Key) || !isStaticCompositeLiteral(r.Value) &#123;</span><br><span class="line">            base.Fatalf(<span class="string">&quot;maplit: entry is not a literal: %v&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(entries) &gt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// loop adding structure elements to map</span></span><br><span class="line">        <span class="comment">// for i = 0; i &lt; len(vstatk); i++ &#123;</span></span><br><span class="line">        <span class="comment">//    map[vstatk[i]] = vstate[i]</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，如果小于等于25个元素，直接赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>如果，大于25个元素，分key&#x2F;value两组，使用for循环进行赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstatk); i++ &#123;</span><br><span class="line">    <span class="keyword">map</span>[vstatk[i]] = vstate[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>当使用make关键字初始化map时，调用的是makemap，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">    <span class="comment">// 1. mem（连续内存区域大小） = 元素类型占用大小(type_size)*数量(hint)</span></span><br><span class="line">    <span class="comment">// 2. overflow（是否溢出） = !(type_size|hint &lt; 4GB or type_size=0 or hint &gt; uint_max/type_size)</span></span><br><span class="line">    mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.Bucket.Size_)</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">        hint = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize Hmap</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h = <span class="built_in">new</span>(hmap)</span><br><span class="line">    &#125;</span><br><span class="line">    h.hash0 = <span class="type">uint32</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算B的大小</span></span><br><span class="line">    <span class="comment">// hint &lt;= 8 ？=&gt; B = 0</span></span><br><span class="line">    B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 数据量大于8且已经超过80%的饱和度</span></span><br><span class="line">    <span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">        B++</span><br><span class="line">    &#125;</span><br><span class="line">    h.B = B</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// B!=0则申请内存创建buckets和overflow</span></span><br><span class="line">    <span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">        h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">            h.extra.nextOverflow = nextOverflow</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量超过8且超到80%的饱和度（13/16 =&gt; 81.25%）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 数量 &gt; 8 and 数量 &gt; (13*2^B/2)</span></span><br><span class="line">    <span class="keyword">return</span> count &gt; abi.MapBucketCount &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buckets、overflow等字段初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">    base := bucketShift(b) <span class="comment">// 2^b</span></span><br><span class="line">    nbuckets := base</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于等于2^4=16个元素时，多准备b-4个bucket用于overflow</span></span><br><span class="line">    <span class="comment">// 比如b=4时，共有16个元素，极端情况下都放在同一个bucket，那么需要一个额外的overflow</span></span><br><span class="line">    <span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">        nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">        sz := t.Bucket.Size_ * nbuckets</span><br><span class="line">        up := roundupsize(sz, !t.Bucket.Pointers()) <span class="comment">// 按tcmalloc规则向上取整</span></span><br><span class="line">        <span class="keyword">if</span> up != sz &#123;</span><br><span class="line">            nbuckets = up / t.Bucket.Size_</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新map</span></span><br><span class="line">    <span class="keyword">if</span> dirtyalloc == <span class="literal">nil</span> &#123;</span><br><span class="line">        buckets = newarray(t.Bucket, <span class="type">int</span>(nbuckets))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 清理dirtyalloc，一般用于mapclear</span></span><br><span class="line">        buckets = dirtyalloc</span><br><span class="line">        size := t.Bucket.Size_ * nbuckets</span><br><span class="line">        <span class="keyword">if</span> t.Bucket.Pointers() &#123;</span><br><span class="line">            memclrHasPointers(buckets, size)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memclrNoHeapPointers(buckets, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有overflow，计算nextOverflow指针</span></span><br><span class="line">    <span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">        nextOverflow = (*bmap)(add(buckets, base*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        last.setoverflow(t, (*bmap)(buckets)) <span class="comment">// 防止nil pointer，将其弄成环形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概的逻辑如下</p>
<ol>
<li>新生成hmap</li>
<li>初始状态修改<ul>
<li>hash种子初始化</li>
<li>计算B，如果hint&lt;&#x3D;8则B为0</li>
</ul>
</li>
<li>如果B!&#x3D;0，初始化buckets数组</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>hint超过BUCKETSIZE则放置在heap，否则放在stack</li>
<li>key与value最大为128个字节，超过这个值则会转成指针</li>
</ol>
<p>B的计算示例如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">50</span> &#123;</span><br><span class="line">    b := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> overLoadFactor(i, b) &#123;</span><br><span class="line">        b++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;hint=%d; b=%d\n&quot;</span>, i, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<table>
<thead>
<tr>
<th align="left">hint</th>
<th align="left">B</th>
<th align="left">bucket count</th>
<th align="left">capacity</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[0,8]</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">[9,13]</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">[14,26]</td>
<td align="left">2</td>
<td align="left">4</td>
<td align="left">32</td>
</tr>
<tr>
<td align="left">[27,52]</td>
<td align="left">3</td>
<td align="left">8</td>
<td align="left">64</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
</tbody></table>
<p>loadFactorNum&#x3D;13是一个关键数据，右边界&#x3D;13*2^(B-1)</p>
<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><h3 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h3><p>使用索引获取map的数值有两种</p>
<ol>
<li>仅接受一个参数</li>
<li>接受两个参数</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅接受一个参数</span></span><br><span class="line">v := h[key]</span><br><span class="line"><span class="comment">// 接受两个参数</span></span><br><span class="line">v, ok := h[key]</span><br></pre></td></tr></table></figure>

<p>当仅接受一个参数时，底层使用mapaccess1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := mapKeyError(t, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">    <span class="comment">// 2^b-1</span></span><br><span class="line">    m := bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，扩容中</span></span><br><span class="line">    <span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 不是同等大小扩容，mask丢弃一位</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上，计算并移动指针指向目标bucket，这里是oldbuckets</span></span><br><span class="line">        oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        <span class="comment">// 是否已疏散，否，数据还在原位</span></span><br><span class="line">        <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">            b = oldb</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">    <span class="comment">// 进入循环</span></span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对tophash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="comment">// index后面的索引位置都为空，退出循环</span></span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不是目标数据，继续比对下一个</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="comment">// bucket的key是指针</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两个key相等</span></span><br><span class="line">            <span class="keyword">if</span> t.Key.Equal(key, k) &#123;</span><br><span class="line">                <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="comment">// bucket的value是指针</span></span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    e = *((*unsafe.Pointer)(e))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到，返回0值</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当接受两个参数时，底层使用mapaccess2，其与mapaccess1只有返回值的不同</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// mapaccess2与mapaccess1基本一致，只是返回值不同</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>]), <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里补充两个用到的函数注释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否已疏散</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuated</span><span class="params">(b *bmap)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    h := b.tophash[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 如果第一个tophash的值在(1,5)之间，说明这个bucket已经疏散了</span></span><br><span class="line">    <span class="keyword">return</span> h &gt; emptyOne &amp;&amp; h &lt; minTopHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">    <span class="comment">// 获取hash的高8位</span></span><br><span class="line">    top := <span class="type">uint8</span>(hash &gt;&gt; (goarch.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">    <span class="comment">// 异常处理，加上偏移值minTopHash=5，否则容易与预设值冲突导致误判</span></span><br><span class="line">    <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历访问"><a href="#遍历访问" class="headerlink" title="遍历访问"></a>遍历访问</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用for range遍历整个map时，依赖hiter、mapiterinit、mapiternext实现该操作，大概过程如下</p>
<ol>
<li>调用mapiterinit创建hiter</li>
<li>纪录指定map的状态信息<ul>
<li>复制指定map的状态属性</li>
<li>用随机数计算出一个bucket的索引和offset，用来无序化输出</li>
<li>返回第一个key&#x2F;value对</li>
</ul>
</li>
<li>调用mapiternext，获取并存储第一个key&#x2F;value地址</li>
<li>上层函数继续调用mapiternext，获取并存储下一个key&#x2F;value地址，或者主动终止循环</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go</span></span><br><span class="line"><span class="comment">// 纪录指定map状态</span></span><br><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    key         unsafe.Pointer <span class="comment">// key，为nil时表示结束</span></span><br><span class="line">    elem        unsafe.Pointer <span class="comment">// value</span></span><br><span class="line">    t           *maptype       <span class="comment">// 类型</span></span><br><span class="line">    h           *hmap          <span class="comment">// header</span></span><br><span class="line">    buckets     unsafe.Pointer <span class="comment">// bucket指针</span></span><br><span class="line">    bptr        *bmap          <span class="comment">// 当前bucket指针</span></span><br><span class="line">    overflow    *[]*bmap       <span class="comment">// 指向overflow</span></span><br><span class="line">    oldoverflow *[]*bmap       <span class="comment">// 指向oldoverflow</span></span><br><span class="line">    startBucket <span class="type">uintptr</span>        <span class="comment">// 初始bucket索引 -&gt; head</span></span><br><span class="line">    offset      <span class="type">uint8</span>          <span class="comment">// 初始偏移-用于tophash索引匹配</span></span><br><span class="line">    wrapped     <span class="type">bool</span>           <span class="comment">// rand_idx -&gt; max_idx(7) -&gt; min_idx(0) -&gt; rand_idx</span></span><br><span class="line">    B           <span class="type">uint8</span>          <span class="comment">// h.B</span></span><br><span class="line">    i           <span class="type">uint8</span>          <span class="comment">// tophash索引</span></span><br><span class="line">    bucket      <span class="type">uintptr</span>        <span class="comment">// 当前bucket索引 -&gt; curr</span></span><br><span class="line">    checkBucket <span class="type">uintptr</span>        <span class="comment">// 扩容中且未疏散指定bucket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建hiter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">    it.t = t</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iter大小异常？</span></span><br><span class="line">    <span class="keyword">if</span> unsafe.Sizeof(hiter&#123;&#125;)/goarch.PtrSize != <span class="number">12</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;hash_iter size incorrect&quot;</span>) <span class="comment">// see cmd/compile/internal/reflectdata/reflect.go</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指向map</span></span><br><span class="line">    it.h = h</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制map当前属性</span></span><br><span class="line">    it.B = h.B</span><br><span class="line">    it.buckets = h.buckets</span><br><span class="line">    <span class="keyword">if</span> !t.Bucket.Pointers() &#123;</span><br><span class="line">        h.createOverflow()</span><br><span class="line">        it.overflow = h.extra.overflow</span><br><span class="line">        it.oldoverflow = h.extra.oldoverflow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一个随机的bucket索引以及offset作为扫描的开始地址</span></span><br><span class="line">    r := <span class="type">uintptr</span>(rand())</span><br><span class="line">    <span class="comment">// 取低B位-&gt;bucket索引</span></span><br><span class="line">    it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 丢掉低B位后再取低3位作为offset</span></span><br><span class="line">    it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (abi.MapBucketCount - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// curr指向head</span></span><br><span class="line">    it.bucket = it.startBucket</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个iter</span></span><br><span class="line">    <span class="keyword">if</span> old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;</span><br><span class="line">        atomic.Or8(&amp;h.flags, iterator|oldIterator)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapiternext(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指向map</span></span><br><span class="line">    h := it.h</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t := it.t</span><br><span class="line">    <span class="comment">// curr索引</span></span><br><span class="line">    bucket := it.bucket</span><br><span class="line">    <span class="comment">// nil-初始值（第一次访问的时候）</span></span><br><span class="line">    b := it.bptr</span><br><span class="line">    <span class="comment">// 0-初始值（第一次访问的时候）</span></span><br><span class="line">    i := it.i</span><br><span class="line">    <span class="comment">// 0-初始值（第一次访问的时候）</span></span><br><span class="line">    checkBucket := it.checkBucket</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">    <span class="comment">// 开始/结束时</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 回到了最初的位置，终止</span></span><br><span class="line">        <span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line">            it.key = <span class="literal">nil</span> <span class="comment">// 表示终止</span></span><br><span class="line">            it.elem = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是扩容时创建的iter</span></span><br><span class="line">        <span class="keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;</span><br><span class="line">            <span class="comment">// 先看oldbuckets</span></span><br><span class="line">            oldbucket := bucket &amp; it.h.oldbucketmask()</span><br><span class="line">            b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            <span class="comment">// 还没疏散</span></span><br><span class="line">            <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">                checkBucket = bucket</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 已疏散</span></span><br><span class="line">                b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">                checkBucket = noCheck</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有发生扩容或者扩容前创建的iter</span></span><br><span class="line">            b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            checkBucket = noCheck</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针继续指向下一个bucket</span></span><br><span class="line">        bucket++</span><br><span class="line">        <span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">            bucket = <span class="number">0</span></span><br><span class="line">            it.wrapped = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tophash索引回到0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bucket以及overflow逐个元素扫描</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">        <span class="comment">// 因为有offset的原因，offi =&gt; offset -&gt; 7 -&gt; 0 -&gt; offset</span></span><br><span class="line">        offi := (i + it.offset) &amp; (abi.MapBucketCount - <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 该位置全新或已删除或已疏散</span></span><br><span class="line">        <span class="keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">        k := add(unsafe.Pointer(b), dataOffset+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">            k = *((*unsafe.Pointer)(k))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">        e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">        <span class="comment">// 双倍扩容且未疏散</span></span><br><span class="line">        <span class="keyword">if</span> checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="keyword">if</span> t.ReflexiveKey() || t.Key.Equal(k, k) &#123;</span><br><span class="line">                hash := t.Hasher(k, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">                <span class="comment">// iter以新index为准，如果疏散的目的index与新index不同，跳过</span></span><br><span class="line">                <span class="keyword">if</span> hash&amp;bucketMask(it.B) != checkBucket &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// NaN判断，同上，checkBucket最高位与tophash最低位比较，不相等则跳过，一切以新index为准</span></span><br><span class="line">                <span class="keyword">if</span> checkBucket&gt;&gt;(it.B<span class="number">-1</span>) != <span class="type">uintptr</span>(b.tophash[offi]&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前面已经排除了空值</span></span><br><span class="line">        <span class="comment">// 未疏散 or key!=key（NaN）</span></span><br><span class="line">        <span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||</span><br><span class="line">            !(t.ReflexiveKey() || t.Key.Equal(k, k)) &#123;</span><br><span class="line">            <span class="comment">// NaN无法被更新/删除，无需再判断是否为nil</span></span><br><span class="line">            it.key = k</span><br><span class="line">            <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                e = *((*unsafe.Pointer)(e))</span><br><span class="line">            &#125;</span><br><span class="line">            it.elem = e</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已疏散 用mapaccessK获取key/value</span></span><br><span class="line">            rk, re := mapaccessK(t, h, k)</span><br><span class="line">            <span class="keyword">if</span> rk == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">// key has been deleted</span></span><br><span class="line">            &#125;</span><br><span class="line">            it.key = rk</span><br><span class="line">            it.elem = re</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存iter状态</span></span><br><span class="line">        it.bucket = bucket</span><br><span class="line">        <span class="keyword">if</span> it.bptr != b &#123; <span class="comment">// avoid unnecessary write barrier; see issue 14921</span></span><br><span class="line">            it.bptr = b</span><br><span class="line">        &#125;</span><br><span class="line">        it.i = i + <span class="number">1</span></span><br><span class="line">        it.checkBucket = checkBucket</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描overflow</span></span><br><span class="line">    b = b.overflow(t)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时，根据key从新的bucket数组获取key/value地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccessK</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">    <span class="comment">// 2^b-1</span></span><br><span class="line">    m := bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，扩容中</span></span><br><span class="line">    <span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 不是同等大小扩容，mask丢弃一位</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上，计算并移动指针指向目标bucket，这里是oldbuckets</span></span><br><span class="line">        oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        <span class="comment">// 是否已疏散，否，数据还在原位</span></span><br><span class="line">        <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">            b = oldb</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对tophash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 当前位置以及后面位置都没有数据了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不是目标数据，继续比对下一个</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两个key相等</span></span><br><span class="line">            <span class="keyword">if</span> t.Key.Equal(key, k) &#123;</span><br><span class="line">                <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    e = *((*unsafe.Pointer)(e))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> k, e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">v1[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>系统调用mapassign实现map的赋值操作，大概逻辑如下</p>
<ol>
<li>确保map已经初始化</li>
<li>计算key的hash值</li>
<li>判断是否需要扩容？是，则先扩容</li>
<li>算出目标bucket的位置</li>
<li>判断是否在扩容中？是，则疏散旧bucket</li>
<li>扫描整个目标bucket，包括overflow，找到可写入的位置</li>
<li>返回value的指针，由上层更新数值</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据key查找value并获得指向value的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 为nil，未初始化</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;assignment to entry in nil map&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置flag，防止同时写入</span></span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时B=0，延迟</span></span><br><span class="line">    <span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        h.buckets = newobject(t.Bucket) <span class="comment">// newarray(t.Bucket, 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 获取低B位hash值，用于计算桶索引</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，即为扩容中</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// 疏散指定bucket</span></span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inserti *<span class="type">uint8</span> <span class="comment">// tophash索引</span></span><br><span class="line">    <span class="keyword">var</span> insertk unsafe.Pointer <span class="comment">// key索引</span></span><br><span class="line">    <span class="keyword">var</span> elem unsafe.Pointer <span class="comment">// value索引</span></span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对hash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="comment">// 1. 没找到key</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 该位置全新或已删除 and index还没找到 -&gt; 找到一个空的位置</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">                    inserti = &amp;b.tophash[i]</span><br><span class="line">                    <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">                    insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                    <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">                    elem = add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 按上面的顺序来说，后面基本都是0，因此执行上面代码后，到这里就可以break了</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="comment">// index后面的索引位置都为空，退出循环</span></span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前位置不为空，寻找下一个可写入位置</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 找到一个key，至少tophash是相等的</span></span><br><span class="line">            <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="comment">// bucket的key是指针</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tophash相等但key值不相等，继续寻找下一个</span></span><br><span class="line">            <span class="keyword">if</span> !t.Key.Equal(key, k) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指针？数据需要更新？</span></span><br><span class="line">            <span class="keyword">if</span> t.NeedKeyUpdate() &#123;</span><br><span class="line">                typedmemmove(t.Key, k, key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">            elem = add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            <span class="keyword">goto</span> done</span><br><span class="line">        &#125;</span><br><span class="line">        ovf := b.overflow(t)</span><br><span class="line">        <span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        b = ovf</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非扩容状态，但已经达到80%的饱和度或者数据非常稀疏</span></span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        hashGrow(t, h)</span><br><span class="line">        <span class="comment">// 扩容后，重新找位置</span></span><br><span class="line">        <span class="keyword">goto</span> again</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全满了，没有位置了</span></span><br><span class="line">    <span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从预申请获取或直接创建新的bucket，作为overflow bucket</span></span><br><span class="line">        newb := h.newoverflow(t, b)</span><br><span class="line">        <span class="comment">// overflow第一个位置</span></span><br><span class="line">        inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        elem = add(insertk, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">        kmem := newobject(t.Key)</span><br><span class="line">        *(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">        insertk = kmem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">        vmem := newobject(t.Elem)</span><br><span class="line">        *(*unsafe.Pointer)(elem) = vmem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把key拷贝到哈希表的key里</span></span><br><span class="line">    typedmemmove(t.Key, insertk, key)</span><br><span class="line">    <span class="comment">// tophash更新</span></span><br><span class="line">    *inserti = top</span><br><span class="line">    <span class="comment">// 总数量更新</span></span><br><span class="line">    h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// flag被修改了，异常</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除修改标记</span></span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">    <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">        elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回value位置的指针，上层代码会更新value</span></span><br><span class="line">    <span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疏散旧bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// todo ？ 保证当前是一次全新的扩容？</span></span><br><span class="line">    evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容中</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// 疏散</span></span><br><span class="line">        evacuate(t, h, h.nevacuate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疏散用，纪录bucket信息</span></span><br><span class="line"><span class="keyword">type</span> evacDst <span class="keyword">struct</span> &#123;</span><br><span class="line">    b *bmap          <span class="comment">// bucket指针</span></span><br><span class="line">    i <span class="type">int</span>            <span class="comment">// tophash地址</span></span><br><span class="line">    k unsafe.Pointer <span class="comment">// key地址</span></span><br><span class="line">    e unsafe.Pointer <span class="comment">// value地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疏散旧bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket，这里是oldbuckets</span></span><br><span class="line">    b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// 2^(b-1) -&gt; oldbucket+1</span></span><br><span class="line">    newbit := h.noldbuckets()</span><br><span class="line">    <span class="comment">// 如果tophash[0]的值不在在(1,5)之间</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">        <span class="comment">// 将新的buckets分为x和y两部份</span></span><br><span class="line">        <span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">        <span class="comment">// 低地址部份</span></span><br><span class="line">        x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">        x.b = (*bmap)(add(h.buckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">        x.e = add(x.k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是双倍扩容</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="comment">// 高地址部份</span></span><br><span class="line">            y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">            y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">            y.e = add(y.k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描正常桶以及溢出桶，这里是oldbuckets</span></span><br><span class="line">        <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">            <span class="comment">// key基地址</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">            <span class="comment">// value基地址</span></span><br><span class="line">            e := add(k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="comment">// 每个桶可存储8个数据，搬空所有</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; abi.MapBucketCount; i, k, e = i+<span class="number">1</span>, add(k, <span class="type">uintptr</span>(t.KeySize)), add(e, <span class="type">uintptr</span>(t.ValueSize)) &#123;</span><br><span class="line">                top := b.tophash[i]</span><br><span class="line">                <span class="comment">// 该位置全新或已删除</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(top) &#123;</span><br><span class="line">                    <span class="comment">// 设置为4-不需要疏散</span></span><br><span class="line">                    b.tophash[i] = evacuatedEmpty</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不为0，但小于5，异常</span></span><br><span class="line">                <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不为0，还未疏散</span></span><br><span class="line">                k2 := k</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> useY <span class="type">uint8</span></span><br><span class="line">                <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">                    <span class="comment">// 计算hash值</span></span><br><span class="line">                    hash := t.Hasher(k2, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 有goroutine在遍历新的buckets</span></span><br><span class="line">                    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.ReflexiveKey() &amp;&amp; !t.Key.Equal(k2, k2) &#123;</span><br><span class="line">                        <span class="comment">// 浮点数，NaN != NaN，无法判断，拿top的最低位判断应该放在哪里</span></span><br><span class="line">                        useY = top &amp; <span class="number">1</span></span><br><span class="line">                        top = tophash(hash)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 根据hash&amp;B判断是否要放在高地址部份</span></span><br><span class="line">                        <span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">                            useY = <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 异常数值？</span></span><br><span class="line">                <span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY || evacuatedX^<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad evacuatedN&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置为2或3</span></span><br><span class="line">                b.tophash[i] = evacuatedX + useY</span><br><span class="line">                <span class="comment">// 疏散的目标地址</span></span><br><span class="line">                dst := &amp;xy[useY]</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 溢出了</span></span><br><span class="line">                <span class="keyword">if</span> dst.i == abi.MapBucketCount &#123;</span><br><span class="line">                    <span class="comment">// 链接overflow并使用第一个地址</span></span><br><span class="line">                    dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">                    dst.i = <span class="number">0</span></span><br><span class="line">                    dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">                    dst.e = add(dst.k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                &#125;</span><br><span class="line">                dst.b.tophash[dst.i&amp;(abi.MapBucketCount<span class="number">-1</span>)] = top</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.Key, dst.k, k) <span class="comment">// copy elem</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.Elem, dst.e, e)</span><br><span class="line">                &#125;</span><br><span class="line">                dst.i++</span><br><span class="line">                dst.k = add(dst.k, <span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                dst.e = add(dst.e, <span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 旧的bucket已经清空且无iter在使用</span></span><br><span class="line">        <span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.Bucket.Pointers() &#123;</span><br><span class="line">            b := add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize))</span><br><span class="line">            ptr := add(b, dataOffset)</span><br><span class="line">            n := <span class="type">uintptr</span>(t.BucketSize) - dataOffset</span><br><span class="line">            <span class="comment">// 把key/value数据全部清空，方便gc做？</span></span><br><span class="line">            memclrHasPointers(ptr, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 惰性清理函数，不会每次都触发，只有oldbucket索引刚好跟nevacuate值相等才行</span></span><br><span class="line">    <span class="comment">// [0 1 2 3]共四个bucket</span></span><br><span class="line">    <span class="comment">// 当疏散了idx=2的bucket，此时nevacuate=0，不触发</span></span><br><span class="line">    <span class="comment">// 当疏散了idx=0的bucket时，与nevacuate相等，触发，将nevacuate指向1</span></span><br><span class="line">    <span class="comment">// 当nevacuate=4时，说明疏散了所有bucket，清理掉buckets数组，更新状态</span></span><br><span class="line">    <span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">        advanceEvacuationMark(h, t, newbit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否疏散完毕，是=&gt;清理oldbucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指向下一个bucket，不管有没有清理</span></span><br><span class="line">    h.nevacuate++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard，实际保证能nevacuate&lt;newbit即可</span></span><br><span class="line">    stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">    <span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">        stop = newbit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nevacuate指向下一个未清理的bucket索引</span></span><br><span class="line">    <span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">        h.nevacuate++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部疏散完毕</span></span><br><span class="line">    <span class="keyword">if</span> h.nevacuate == newbit &#123;</span><br><span class="line">        <span class="comment">// 删除oldbuckets</span></span><br><span class="line">        h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 删除oldoverflow</span></span><br><span class="line">        <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取消sameSizeGrow标记？</span></span><br><span class="line">        h.flags &amp;^= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请一个新的overflow bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> newoverflow(t *maptype, b *bmap) *bmap &#123;</span><br><span class="line">    <span class="keyword">var</span> ovf *bmap</span><br><span class="line">    <span class="comment">// 有预申请的overflow直接使用</span></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        ovf = h.extra.nextOverflow</span><br><span class="line">        <span class="comment">// next为nil，说明申请的overflow还有很多</span></span><br><span class="line">        <span class="keyword">if</span> ovf.overflow(t) == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 写上next指针，不然下一次没法用</span></span><br><span class="line">            h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), <span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用完了，bucket的overflow指针清空</span></span><br><span class="line">            ovf.setoverflow(t, <span class="literal">nil</span>)</span><br><span class="line">            h.extra.nextOverflow = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有预申请或者用完了预申请的</span></span><br><span class="line">        ovf = (*bmap)(newobject(t.Bucket))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// noverflow counter调整</span></span><br><span class="line">    <span class="comment">// &lt;16时noverflow是个精确值</span></span><br><span class="line">    <span class="comment">// &gt;=16时noverflow指数级衰减</span></span><br><span class="line">    h.incrnoverflow()</span><br><span class="line">    <span class="comment">// 不包含指针</span></span><br><span class="line">    <span class="keyword">if</span> !t.Bucket.Pointers() &#123;</span><br><span class="line">        <span class="comment">// 确保extra跟overflow已初始化</span></span><br><span class="line">        h.createOverflow()</span><br><span class="line">        <span class="comment">// 追加到末尾，超过容量还是会触发slice扩容</span></span><br><span class="line">        *h.extra.overflow = <span class="built_in">append</span>(*h.extra.overflow, ovf)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bucket的overflow指针指向ovf</span></span><br><span class="line">    b.setoverflow(t, ovf)</span><br><span class="line">    <span class="keyword">return</span> ovf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当map的元素数量超过8且达到80%的饱和度时，会触发扩容，扩容函数为hashGrow。</p>
<p><strong>注意</strong>：hashGrow只负责扩容，不负责疏散oldbucket，只有每次调用mapassign时才会去疏散旧的bucket</p>
<p>大概逻辑如下</p>
<ol>
<li>判断是双倍扩容还是同等大小扩容</li>
<li>将buckets数组搬到oldbuckets</li>
<li>更新hmap状态</li>
<li>有overflow？搬到oldoverflow并更新extra状态</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只管扩容，下一次写的时候才疏散对应的bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断是双倍扩容还是同等大小扩容</span></span><br><span class="line">    bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 未达到80%的饱和度，同等大小扩容</span></span><br><span class="line">    <span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">        bigger = <span class="number">0</span></span><br><span class="line">        h.flags |= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迁移旧的buckets</span></span><br><span class="line">    oldbuckets := h.buckets</span><br><span class="line">    <span class="comment">// 创建新的buckets</span></span><br><span class="line">    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除iterator/oldIterator标记</span></span><br><span class="line">    flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">    <span class="comment">// 加上oldIterator标记？</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= oldIterator</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    h.B += bigger</span><br><span class="line">    h.flags = flags</span><br><span class="line">    h.oldbuckets = oldbuckets</span><br><span class="line">    h.buckets = newbuckets</span><br><span class="line">    h.nevacuate = <span class="number">0</span></span><br><span class="line">    h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理overflow</span></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常状态</span></span><br><span class="line">        <span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;oldoverflow is not nil&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">        h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(v1, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当使用关键字delete删除指定key时，调用mapdelete，大概逻辑如下</p>
<ol>
<li>计算hash值，找到目标bucket</li>
<li>是否在扩容中？是，则疏散旧bucket</li>
<li>对比tophash和key，找到value的地址，清空tophash、key、value</li>
<li>idx+1位置的tophash都是0-默认值？从idx开始往前扫描，将所有tophash&#x3D;emptyOne改成0</li>
<li>更新map状态</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := mapKeyError(t, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置flag，防止同时写入</span></span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取低B位hash值，用于计算桶索引</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，即为扩容中</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// 疏散指定bucket</span></span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    bOrig := b</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">search:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对hash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="comment">// 1. 没找到key</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 后面基本都是0，到这里就可以break了</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> search</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 找到一个key，至少tophash是相等的</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            k2 := k</span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tophash相等但key值不相等，继续寻找下一个</span></span><br><span class="line">            <span class="keyword">if</span> !t.Key.Equal(key, k2) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Only clear key if there are pointers in it.</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Key.Pointers() &#123;</span><br><span class="line">                memclrHasPointers(k, t.Key.Size_)</span><br><span class="line">            &#125;</span><br><span class="line">            e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Elem.Pointers() &#123;</span><br><span class="line">                memclrHasPointers(e, t.Elem.Size_)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                memclrNoHeapPointers(e, t.Elem.Size_)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除了一个数据</span></span><br><span class="line">            b.tophash[i] = emptyOne</span><br><span class="line">            <span class="comment">// index=7，指向了bucket最后一个数据</span></span><br><span class="line">            <span class="keyword">if</span> i == abi.MapBucketCount<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="comment">// 还不是最终的数据，不处理</span></span><br><span class="line">                <span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">                    <span class="keyword">goto</span> notLast</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// index&lt;7 且 后续的元素也不为空，不处理</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">                    <span class="keyword">goto</span> notLast</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前以及前面tophash=emptyOne的tophash设置为0-默认值</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                b.tophash[i] = emptyRest</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">                        <span class="keyword">break</span> <span class="comment">// beginning of initial bucket, we&#x27;re done.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Find previous bucket, continue at its last entry.</span></span><br><span class="line">                    c := b</span><br><span class="line">                    <span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i = abi.MapBucketCount - <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i--</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        notLast:</span><br><span class="line">            h.count--</span><br><span class="line">            <span class="comment">// Reset the hash seed to make it more difficult for attackers to</span></span><br><span class="line">            <span class="comment">// repeatedly trigger hash collisions. See issue 25237.</span></span><br><span class="line">            <span class="keyword">if</span> h.count == <span class="number">0</span> &#123;</span><br><span class="line">                h.hash0 = <span class="type">uint32</span>(rand())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span> search</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常状态</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除标记</span></span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line">clear(v1)</span><br></pre></td></tr></table></figure>

<p>使用clear清理map的所有元素时，系统调用mapclear进行处理，大概逻辑如下</p>
<ol>
<li>循环将每一个bucket的tophash都设置为0，包括oldbuckets</li>
<li>重置map的所有状态、seed等</li>
<li>调用makeBucketArray，清理所有key&#x2F;value数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclear</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置flag，防止同时写入</span></span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark buckets empty, so existing iterators can be terminated, see issue #59411.</span></span><br><span class="line">    markBucketsEmpty := <span class="function"><span class="keyword">func</span><span class="params">(bucket unsafe.Pointer, mask <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt;= mask; i++ &#123;</span><br><span class="line">            b := (*bmap)(add(bucket, i*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">                <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">                    b.tophash[i] = emptyRest</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2^b-1</span></span><br><span class="line">    markBucketsEmpty(h.buckets, bucketMask(h.B))</span><br><span class="line">    <span class="keyword">if</span> oldBuckets := h.oldbuckets; oldBuckets != <span class="literal">nil</span> &#123;</span><br><span class="line">        markBucketsEmpty(oldBuckets, h.oldbucketmask())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩下的没什么好说的</span></span><br><span class="line">    h.flags &amp;^= sameSizeGrow</span><br><span class="line">    h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">    h.nevacuate = <span class="number">0</span></span><br><span class="line">    h.noverflow = <span class="number">0</span></span><br><span class="line">    h.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the hash seed to make it more difficult for attackers to</span></span><br><span class="line">    <span class="comment">// repeatedly trigger hash collisions. See issue 25237.</span></span><br><span class="line">    h.hash0 = <span class="type">uint32</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep the mapextra allocation but clear any extra information.</span></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">        *h.extra = mapextra&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// makeBucketArray clears the memory pointed to by h.buckets</span></span><br><span class="line">    <span class="comment">// and recovers any overflow buckets by generating them</span></span><br><span class="line">    <span class="comment">// as if h.buckets was newly alloced.</span></span><br><span class="line">    _, nextOverflow := makeBucketArray(t, h.B, h.buckets)</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// If overflow buckets are created then h.extra</span></span><br><span class="line">        <span class="comment">// will have been allocated during initial bucket creation.</span></span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下非克隆，只是复制了header</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = v1</span><br><span class="line"></span><br><span class="line"><span class="comment">// go 1.21</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = maps.Clone(v1)</span><br></pre></td></tr></table></figure>

<p>go 1.21增加了maps.Clone用于克隆整个map数据，系统调用mapclone2实现该操作，大概逻辑如下</p>
<ol>
<li>创建目标哈希表dst，复制源哈希表src的状态等相关数据</li>
<li>复制src的数据到dst<ul>
<li>如果B&#x3D;0且key&#x2F;value非指针，直接赋值一个bucket即可，复制完毕直接退出</li>
<li>如果dst.B&#x3D;src.B，1:1复制bucket数组</li>
<li>如果dst.B&lt;&#x3D;src.B，直接看代码吧</li>
</ul>
</li>
<li>src是否在扩容中？是，则复制src的oldbucket数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclone2</span><span class="params">(t *maptype, src *hmap)</span></span> *hmap &#123;</span><br><span class="line">    <span class="comment">// 数据量</span></span><br><span class="line">    hint := src.count</span><br><span class="line">    <span class="comment">// 已经达到80%的饱和度</span></span><br><span class="line">    <span class="keyword">if</span> overLoadFactor(hint, src.B) &#123;</span><br><span class="line">        <span class="comment">// 13*2^B/2 (why？)</span></span><br><span class="line">        hint = <span class="type">int</span>(loadFactorNum * (bucketShift(src.B) / loadFactorDen))</span><br><span class="line">    &#125;</span><br><span class="line">    dst := makemap(t, hint, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 共用hash seed</span></span><br><span class="line">    dst.hash0 = src.hash0</span><br><span class="line">    dst.nevacuate = <span class="number">0</span></span><br><span class="line">    <span class="comment">// flags不需要拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数量为0，不处理</span></span><br><span class="line">    <span class="keyword">if</span> src.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> src.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map clone and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b=0 and key跟value非指针</span></span><br><span class="line">    <span class="keyword">if</span> src.B == <span class="number">0</span> &amp;&amp; !(t.IndirectKey() &amp;&amp; t.NeedKeyUpdate()) &amp;&amp; !t.IndirectElem() &#123;</span><br><span class="line">        <span class="comment">// Quick copy for small maps.</span></span><br><span class="line">        dst.buckets = newobject(t.Bucket)</span><br><span class="line">        dst.count = src.count</span><br><span class="line">        typedmemmove(t.Bucket, dst.buckets, src.buckets)</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b=0 key或value为指针类型</span></span><br><span class="line">    <span class="keyword">if</span> dst.B == <span class="number">0</span> &#123;</span><br><span class="line">        dst.buckets = newobject(t.Bucket)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dst.B &lt;= src.B</span></span><br><span class="line">    dstArraySize := <span class="type">int</span>(bucketShift(dst.B))</span><br><span class="line">    srcArraySize := <span class="type">int</span>(bucketShift(src.B))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; dstArraySize; i++ &#123;</span><br><span class="line">        <span class="comment">// dst bucket指针</span></span><br><span class="line">        dstBmap := (*bmap)(add(dst.buckets, <span class="type">uintptr</span>(i*<span class="type">int</span>(t.BucketSize))))</span><br><span class="line">        pos := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; srcArraySize; j += dstArraySize &#123;</span><br><span class="line">            <span class="comment">// src bucket指针</span></span><br><span class="line">            <span class="comment">// 如果dst.B = src.B，1:1复制，否则多余部份wrapped写到dst前面几个bucket</span></span><br><span class="line">            srcBmap := (*bmap)(add(src.buckets, <span class="type">uintptr</span>((i+j)*<span class="type">int</span>(t.BucketSize))))</span><br><span class="line">            <span class="keyword">for</span> srcBmap != <span class="literal">nil</span> &#123;</span><br><span class="line">                dstBmap, pos = moveToBmap(t, dst, dstBmap, pos, srcBmap)</span><br><span class="line">                <span class="comment">// 包括overflow</span></span><br><span class="line">                srcBmap = srcBmap.overflow(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非扩容</span></span><br><span class="line">    <span class="keyword">if</span> src.oldbuckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面全是跟oldbuckets相关的</span></span><br><span class="line">    oldB := src.B</span><br><span class="line">    srcOldbuckets := src.oldbuckets</span><br><span class="line">    <span class="keyword">if</span> !src.sameSizeGrow() &#123;</span><br><span class="line">        oldB--</span><br><span class="line">    &#125;</span><br><span class="line">    oldSrcArraySize := <span class="type">int</span>(bucketShift(oldB))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; oldSrcArraySize; i++ &#123;</span><br><span class="line">        srcBmap := (*bmap)(add(srcOldbuckets, <span class="type">uintptr</span>(i*<span class="type">int</span>(t.BucketSize))))</span><br><span class="line">        <span class="comment">// 已疏散</span></span><br><span class="line">        <span class="keyword">if</span> evacuated(srcBmap) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// oldB比dst的B还要更大，按dst的B取hash的低位作为bucket索引</span></span><br><span class="line">        <span class="comment">// dst.B &lt;= src.B and dst.B &lt;= (src.B-1)</span></span><br><span class="line">        <span class="keyword">if</span> oldB &gt;= dst.B &#123; <span class="comment">// main bucket bits in dst is less than oldB bits in src</span></span><br><span class="line">            <span class="comment">// src.oldbuckets =&gt; dst.buckets</span></span><br><span class="line">            <span class="comment">// 索引按dst.B取低位</span></span><br><span class="line">            dstBmap := (*bmap)(add(dst.buckets, (<span class="type">uintptr</span>(i)&amp;bucketMask(dst.B))*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            <span class="keyword">for</span> dstBmap.overflow(t) != <span class="literal">nil</span> &#123;</span><br><span class="line">                dstBmap = dstBmap.overflow(t)</span><br><span class="line">            &#125;</span><br><span class="line">            pos := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> srcBmap != <span class="literal">nil</span> &#123;</span><br><span class="line">                dstBmap, pos = moveToBmap(t, dst, dstBmap, pos, srcBmap)</span><br><span class="line">                srcBmap = srcBmap.overflow(t)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// oldB &lt; dst.B (说明dst.B == src.B ?)</span></span><br><span class="line">        <span class="keyword">for</span> srcBmap != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// oldbuckets分成x/y两个部份疏散</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">                <span class="comment">// 该位置全新或已删除</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(srcBmap.tophash[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// // 有goroutine在写入，不允许</span></span><br><span class="line">                <span class="keyword">if</span> src.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">                    fatal(<span class="string">&quot;concurrent map clone and map write&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                srcK := add(unsafe.Pointer(srcBmap), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    srcK = *((*unsafe.Pointer)(srcK))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                srcEle := add(unsafe.Pointer(srcBmap), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    srcEle = *((*unsafe.Pointer)(srcEle))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到key在dst的位置，然后复制数据</span></span><br><span class="line">                dstEle := mapassign(t, dst, srcK)</span><br><span class="line">                typedmemmove(t.Elem, dstEle, srcEle)</span><br><span class="line">            &#125;</span><br><span class="line">            srcBmap = srcBmap.overflow(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveToBmap</span><span class="params">(t *maptype, h *hmap, dst *bmap, pos <span class="type">int</span>, src *bmap)</span></span> (*bmap, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// src的bucket数据复制到dst的bucket，overflow在上一层做处理</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">        <span class="comment">// src-该位置全新或已删除</span></span><br><span class="line">        <span class="keyword">if</span> isEmpty(src.tophash[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 索引 0-7</span></span><br><span class="line">        <span class="keyword">for</span> ; pos &lt; abi.MapBucketCount; pos++ &#123;</span><br><span class="line">            <span class="comment">// dst-找到一个可写入的位置</span></span><br><span class="line">            <span class="keyword">if</span> isEmpty(dst.tophash[pos]) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dst写满了，加一个overflow bucket</span></span><br><span class="line">        <span class="keyword">if</span> pos == abi.MapBucketCount &#123;</span><br><span class="line">            dst = h.newoverflow(t, dst)</span><br><span class="line">            pos = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srcK := add(unsafe.Pointer(src), dataOffset+<span class="type">uintptr</span>(i)*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        srcEle := add(unsafe.Pointer(src), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+<span class="type">uintptr</span>(i)*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">        dstK := add(unsafe.Pointer(dst), dataOffset+<span class="type">uintptr</span>(pos)*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        dstEle := add(unsafe.Pointer(dst), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+<span class="type">uintptr</span>(pos)*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制tophash</span></span><br><span class="line">        dst.tophash[pos] = src.tophash[i]</span><br><span class="line">        <span class="comment">// 复制key</span></span><br><span class="line">        <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">            srcK = *(*unsafe.Pointer)(srcK)</span><br><span class="line">            <span class="keyword">if</span> t.NeedKeyUpdate() &#123;</span><br><span class="line">                kStore := newobject(t.Key)</span><br><span class="line">                typedmemmove(t.Key, kStore, srcK)</span><br><span class="line">                srcK = kStore</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Note: if NeedKeyUpdate is false, then the memory</span></span><br><span class="line">            <span class="comment">// used to store the key is immutable, so we can share</span></span><br><span class="line">            <span class="comment">// it between the original map and its clone.</span></span><br><span class="line">            *(*unsafe.Pointer)(dstK) = srcK</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typedmemmove(t.Key, dstK, srcK)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制value</span></span><br><span class="line">        <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">            srcEle = *(*unsafe.Pointer)(srcEle)</span><br><span class="line">            eStore := newobject(t.Elem)</span><br><span class="line">            typedmemmove(t.Elem, eStore, srcEle)</span><br><span class="line">            *(*unsafe.Pointer)(dstEle) = eStore</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typedmemmove(t.Elem, dstEle, srcEle)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// counter更新</span></span><br><span class="line">        pos++</span><br><span class="line">        h.count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst, pos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">3.3 哈希表</a><br><a target="_blank" rel="noopener" href="https://victoriametrics.com/blog/go-map/">Go Maps Explained: How Key-Value Pairs Are Actually Stored</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-slice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-slice/" class="post-title-link" itemprop="url">golang系列之-slice</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-15 23:44:53" itemprop="dateCreated datePublished" datetime="2025-02-15T23:44:53+08:00">2025-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-20 08:31:21" itemprop="dateModified" datetime="2025-02-20T08:31:21+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>slice&#x2F;切片-动态数组，golang常用的数据结构之一，相对于数组，slice可以追加元素，在容量不足时自动扩容</p>
<p>当前go版本：1.24</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>slice数据结构如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li><code>array</code> - 指向一片连续内存区域的第一个元素</li>
<li><code>len</code> - 已有元素数量</li>
<li><code>cap</code> - 可容纳元素总数量</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>slice初始化方式有三种</p>
<ol>
<li>使用字面量创建新切片</li>
<li>使用关键字make创建切片</li>
<li>通过下标获取数组或切片的一部份</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// len=3 cap=3</span></span><br><span class="line"><span class="keyword">var</span> v1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// len=10 cap=10</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>) <span class="comment">// var v2 = make([]int, 0, 10)</span></span><br><span class="line"><span class="comment">// len=4 cap=9</span></span><br><span class="line"><span class="keyword">var</span> v3 = v2[<span class="number">1</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>使用<code>ssa</code>包打印<code>var v1 = []int&#123;1, 2, 3&#125;</code>，得到结果如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t0 = new [3]int (slicelit)                                      *[3]int</span><br><span class="line">t1 = &amp;t0[0:int]                                                    *int</span><br><span class="line">*t1 = 1:int</span><br><span class="line">t2 = &amp;t0[1:int]                                                    *int</span><br><span class="line">*t2 = 2:int</span><br><span class="line">t3 = &amp;t0[2:int]                                                    *int</span><br><span class="line">*t3 = 3:int</span><br><span class="line">t4 = slice t0[:]   </span><br></pre></td></tr></table></figure>

<ol>
<li>根据字面量的数量创建一个数组t0</li>
<li>初始化数组元素t1&#x2F;t2&#x2F;t3</li>
<li>在t0基础上创建一个切片t4</li>
</ol>
<p><code>src/cmd/compile/internal/walk/complit.go</code>slicelit</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>使用<code>ssa</code>包打印<code>var v2 = make([]int, 10)</code>，得到结果如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t0 = new [10]int (makeslice)                                   *[10]int</span><br><span class="line">t1 = slice t0[:10:int]                                            []int</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个数组t0</li>
<li>在t0基础上创建一个切片t1</li>
</ol>
<p><code>makeslice</code>源代码如下，做了一些精简</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 1. mem（连续内存区域大小） = 元素类型占用大小(type_size)*容量大小(cap)</span></span><br><span class="line">    <span class="comment">// 2. overflow（是否溢出） = !(type_size|cap &lt; 4GB or type_size=0 or cap &gt; uint_max/type_size)</span></span><br><span class="line">    mem, overflow := math.MulUintptr(et.Size_, <span class="type">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">        mem, overflow := math.MulUintptr(et.Size_, <span class="type">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">        <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            panicmakeslicelen()</span><br><span class="line">        &#125;</span><br><span class="line">        panicmakeslicecap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v2 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> v3 = v2[<span class="number">1</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>使用<code>ssa</code>包打印上述代码，得到结果如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t0 = new [10]int (makeslice)                                   *[10]int</span><br><span class="line">t1 = slice t0[:10:int]                                            []int</span><br><span class="line">t2 = slice t1[1:int:5:int]                                        []int</span><br></pre></td></tr></table></figure>

<ol>
<li>使用关键字make创建一个切片t1</li>
<li>在上一步基础上，创建一个切片t2，指定下标left&#x3D;1 right&#x3D;5</li>
</ol>
<h2 id="追加和扩容"><a href="#追加和扩容" class="headerlink" title="追加和扩容"></a>追加和扩容</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">v1 = <span class="built_in">append</span>(v1, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>slice使用<code>append</code>关键字实现追加操作，当数据量超过底层cap大小时，触发扩容，扩容代码精简后如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(oldPtr unsafe.Pointer, newLen, oldCap, num <span class="type">int</span>, et *_type)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 根据当前cap以及新len计算新cap</span></span><br><span class="line">    newcap := nextslicecap(newLen, oldCap)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line">    <span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line">    noscan := !et.Pointers() <span class="comment">// 指针？</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="comment">// ... （优化）</span></span><br><span class="line">    <span class="comment">// 以下是通用操作</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen) * et.Size_</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen) * et.Size_</span><br><span class="line">        capmem, overflow = math.MulUintptr(et.Size_, <span class="type">uintptr</span>(newcap))</span><br><span class="line">        capmem = roundupsize(capmem, noscan)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / et.Size_)</span><br><span class="line">        capmem = <span class="type">uintptr</span>(newcap) * et.Size_</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextslicecap</span><span class="params">(newLen, oldCap <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 双倍cap仍然小于newLen，直接返回newLen</span></span><br><span class="line">    newcap := oldCap</span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> newLen &gt; doublecap &#123;</span><br><span class="line">        <span class="keyword">return</span> newLen</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 双倍cap小于512，返回双倍cap</span></span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">    <span class="keyword">if</span> oldCap &lt; threshold &#123;</span><br><span class="line">        <span class="keyword">return</span> doublecap</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 计算公式：x = 5/4*x + 192，直到x&gt;=newLen</span></span><br><span class="line">        newcap += (newcap + <span class="number">3</span>*threshold) &gt;&gt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">uint</span>(newcap) &gt;= <span class="type">uint</span>(newLen) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出？</span></span><br><span class="line">    <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newLen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newcap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在1.18版本，Keith Randall对slice的growth factor进行了调整，使其增长更为平滑，详细见提交：<code>https://github.com/golang/go/blob/2dda92ff6f9f07eeb110ecbf0fc2d7a0ddd27f9d/src/runtime/slice.go</code></p>
<p>不同cap对应的扩容因子如下</p>
<table>
<thead>
<tr>
<th align="left">starting cap</th>
<th align="left">growth factor</th>
</tr>
</thead>
<tbody><tr>
<td align="left">256</td>
<td align="left">2.0</td>
</tr>
<tr>
<td align="left">512</td>
<td align="left">1.63</td>
</tr>
<tr>
<td align="left">1024</td>
<td align="left">1.44</td>
</tr>
<tr>
<td align="left">2048</td>
<td align="left">1.35</td>
</tr>
<tr>
<td align="left">4096</td>
<td align="left">1.30</td>
</tr>
</tbody></table>
<h2 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h2><p>切片的拷贝也归类于appendSlice，具体在<code>src/cmd/compile/internal/walk/assign.go:appendSlice</code>。</p>
<p>这里的copy可能与我们预期不一样，并不是浅层或深层拷贝，是拷贝与目标dst的len长度一致的数据，与容量cap无关</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 []<span class="type">int</span> <span class="comment">// or `var v2 = make([]int, 0, 3)`</span></span><br><span class="line"><span class="built_in">copy</span>(v2, v1) <span class="comment">// v2仍然是空切片</span></span><br></pre></td></tr></table></figure>

<p>slicecopy函数具体如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(toPtr unsafe.Pointer, toLen <span class="type">int</span>, fromPtr unsafe.Pointer, fromLen <span class="type">int</span>, width <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// fromLen和toLen都为0，不处理</span></span><br><span class="line">    <span class="keyword">if</span> fromLen == <span class="number">0</span> || toLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n=min(fromLen, toLen)</span></span><br><span class="line">    n := fromLen</span><br><span class="line">    <span class="keyword">if</span> toLen &lt; n &#123;</span><br><span class="line">        n = toLen</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// type_size大小为0</span></span><br><span class="line">    <span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size := <span class="type">uintptr</span>(n) * width</span><br><span class="line">    <span class="comment">// copy</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span> &#123;</span><br><span class="line">        *(*<span class="type">byte</span>)(toPtr) = *(*<span class="type">byte</span>)(fromPtr)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memmove(toPtr, fromPtr, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://gist.github.com/Integralist/22ced4b4700df1e6cbec88c1074c8b2d">1. Memory Allocation Summary.md</a><br><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/">3.2 切片</a><br><a target="_blank" rel="noopener" href="https://pkg.go.dev/golang.org/x/tools/go/ssa#example-package-BuildPackage">ssa</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/install-containerd-and-nerdctl-on-ubuntu24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/install-containerd-and-nerdctl-on-ubuntu24/" class="post-title-link" itemprop="url">在ubuntu上安装containerd和nerdctl</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-08 10:18:47 / 修改时间：13:45:49" itemprop="dateCreated datePublished" datetime="2025-02-08T10:18:47+08:00">2025-02-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>以<code>Ubuntu 24.04</code>为例，安装<code>nerdctl</code>以及<code>containerd</code></p>
<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><ul>
<li>安装uidmap</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install -y uidmap</span><br></pre></td></tr></table></figure>

<ul>
<li>AppArmor配置</li>
</ul>
<p>由于懒人安装方式跟单独安装方式bin目录不一致，配置内容会有些许差异，放在下面章节各自介绍</p>
<h3 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/containerd/nerdctl">nerdctl</a>（懒人安装下载nerdctl-full即可，该软件包已包含下方所列软件）</li>
<li><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd">containerd</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rootless-containers/rootlesskit">rootlesskit</a> &amp; <a target="_blank" rel="noopener" href="https://github.com/rootless-containers/slirp4netns">slirp4netns</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/moby/buildkit">buildkit</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/containernetworking/cni">cni</a></li>
</ul>
<h2 id="懒人安装"><a href="#懒人安装" class="headerlink" title="懒人安装"></a>懒人安装</h2><p>解压缩<code>nerdctl-full-2.0.3-linux-amd64.tar.gz</code>到<code>~/.local</code>，并将<code>~/.local/bin</code>目录添加到<code>PATH</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxf nerdctl-full-2.0.3-linux-amd64.tar.gz -C ~/.local</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.local/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>看起来已完成安装，但还不行，当你执行<code>nerdctl</code>，这里将会看到一些报错，以下报错表示先需要安装运行rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nerdctl</span><br><span class="line"><span class="comment"># FATA[0000] rootless containerd not running? (hint: use `containerd-rootless-setuptool.sh install` to start rootless containerd): stat /run/user/1000/containerd-rootless: no such file or directory</span></span><br></pre></td></tr></table></figure>

<p>安装rootless containerd第一次尝试，以下报错是因为ubuntu 24.04加强了应用限制，需要通过AppArmor配置非特权用户命名空间应用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br><span class="line"><span class="comment"># [INFO] Checking RootlessKit functionality</span></span><br><span class="line"><span class="comment"># [rootlesskit:parent] error: failed to start the child: fork/exec /proc/self/exe: operation not permitted</span></span><br><span class="line"><span class="comment"># [ERROR] RootlessKit failed, see the error messages and https://rootlesscontaine.rs/getting-started/common/ .</span></span><br></pre></td></tr></table></figure>

<p>配置apparmor</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rootlesskit放在了~/.local/bin目录</span></span><br><span class="line">filename=$(<span class="built_in">echo</span> <span class="variable">$HOME</span>/.local/bin/rootlesskit | sed -e s@^/@@ -e s@/@.@g)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; ~/$&#123;filename&#125;</span></span><br><span class="line"><span class="string">abi &lt;abi/4.0&gt;,</span></span><br><span class="line"><span class="string">include &lt;tunables/global&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;$HOME/.local/bin/rootlesskit&quot; flags=(unconfined) &#123;</span></span><br><span class="line"><span class="string">  userns,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  include if exists &lt;local/$&#123;filename&#125;&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> ~/<span class="variable">$&#123;filename&#125;</span> /etc/apparmor.d/<span class="variable">$&#123;filename&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart apparmor.service</span><br></pre></td></tr></table></figure>

<p>安装并启动rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br><span class="line"></span><br><span class="line"><span class="comment"># [INFO] Checking RootlessKit functionality</span></span><br><span class="line"><span class="comment"># [INFO] Checking cgroup v2</span></span><br><span class="line"><span class="comment"># [INFO] Checking overlayfs</span></span><br><span class="line"><span class="comment"># [INFO] Requirements are satisfied</span></span><br><span class="line"><span class="comment"># [INFO] Creating &quot;/home/vagrant/.config/systemd/user/containerd.service&quot;</span></span><br><span class="line"><span class="comment"># [INFO] Starting systemd unit &quot;containerd.service&quot;</span></span><br><span class="line"><span class="comment"># + systemctl --user start containerd.service</span></span><br><span class="line"><span class="comment"># + sleep 3</span></span><br><span class="line"><span class="comment"># + systemctl --user --no-pager --full status containerd.service</span></span><br><span class="line"><span class="comment"># ● containerd.service - containerd (Rootless)</span></span><br><span class="line"><span class="comment">#      Loaded: loaded (/home/vagrant/.config/systemd/user/containerd.service; disabled; preset: enabled)</span></span><br><span class="line"><span class="comment">#      Active: active (running) since Sat 2025-02-08 09:10:49 CST; 3s ago</span></span><br><span class="line"><span class="comment">#    Main PID: 3535 (rootlesskit)</span></span><br><span class="line"><span class="comment">#       Tasks: 28</span></span><br><span class="line"><span class="comment">#      Memory: 15.2M (peak: 19.2M)</span></span><br><span class="line"><span class="comment">#         CPU: 287ms</span></span><br><span class="line"><span class="comment">#      CGroup: /user.slice/user-1000.slice/user@1000.service/app.slice/containerd.service</span></span><br><span class="line"><span class="comment">#              ├─3535 rootlesskit --state-dir=/run/user/1000/containerd-rootless --net=slirp4netns --mtu=65520 --slirp4netns-sandbox=auto --slirp4netns-seccomp=auto --disable-host-loopback --port-driver=builtin --copy-up=/etc --copy-up=/run --copy-up=/var/lib --propagation=rslave --detach-netns /home/vagrant/.local/bin/containerd-rootless.sh</span></span><br><span class="line"><span class="comment">#              ├─3553 /proc/self/exe --state-dir=/run/user/1000/containerd-rootless --net=slirp4netns --mtu=65520 --slirp4netns-sandbox=auto --slirp4netns-seccomp=auto --disable-host-loopback --port-driver=builtin --copy-up=/etc --copy-up=/run --copy-up=/var/lib --propagation=rslave --detach-netns /home/vagrant/.local/bin/containerd-rootless.sh</span></span><br><span class="line"><span class="comment">#              ├─3574 slirp4netns --mtu 65520 -r 3 --disable-host-loopback --enable-seccomp --userns-path=/proc/3553/ns/user --netns-type=path /proc/3553/root/run/user/1000/containerd-rootless/netns tap0</span></span><br><span class="line"><span class="comment">#              └─3582 containerd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684164811+08:00&quot; level=info msg=&quot;Start recovering state&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684269626+08:00&quot; level=info msg=serving... address=/run/containerd/containerd.sock</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684288884+08:00&quot; level=info msg=&quot;Start event monitor&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684345921+08:00&quot; level=info msg=&quot;Start cni network conf syncer for default&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684355097+08:00&quot; level=info msg=&quot;Start streaming server&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684362261+08:00&quot; level=info msg=&quot;Registered namespace \&quot;k8s.io\&quot; with NRI&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684406574+08:00&quot; level=info msg=&quot;runtime interface starting up...&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684412963+08:00&quot; level=info msg=&quot;starting plugins...&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684427341+08:00&quot; level=info msg=&quot;Synchronizing NRI (plugin) with current runtime state&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684492554+08:00&quot; level=info msg=&quot;containerd successfully booted in 0.037003s&quot;</span></span><br><span class="line"><span class="comment"># + systemctl --user enable containerd.service</span></span><br><span class="line"><span class="comment"># Created symlink /home/vagrant/.config/systemd/user/default.target.wants/containerd.service → /home/vagrant/.config/systemd/user/containerd.service.</span></span><br><span class="line"><span class="comment"># [INFO] Installed &quot;containerd.service&quot; successfully.</span></span><br><span class="line"><span class="comment"># [INFO] To control &quot;containerd.service&quot;, run: `systemctl --user (start|stop|restart) containerd.service`</span></span><br><span class="line"><span class="comment"># [INFO] To run &quot;containerd.service&quot; on system startup automatically, run: `sudo loginctl enable-linger vagrant`</span></span><br><span class="line"><span class="comment"># [INFO] ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># [INFO] Use `nerdctl` to connect to the rootless containerd.</span></span><br><span class="line"><span class="comment"># [INFO] You do NOT need to specify $CONTAINERD_ADDRESS explicitly.</span></span><br></pre></td></tr></table></figure>

<p>为<code>nerdctl build</code>安装并运行buildkit</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nerdctl build</span></span><br><span class="line"><span class="comment"># ERRO[0000] `buildctl` needs to be installed and `buildkitd` needs to be running, see https://github.com/moby/buildkit , and `containerd-rootless-setuptool.sh install-buildkit` for OCI worker or `containerd-rootless-setuptool.sh install-buildkit-containerd` for containerd worker  error=&quot;failed to ping to host unix:///run/user/1000/buildkit-default/buildkitd.sock: exit status 1\nfailed to ping to host unix:///run/user/1000/buildkit/buildkitd.sock: exit status 1&quot;</span></span><br><span class="line"><span class="comment"># FATA[0000] no buildkit host is available, tried 2 candidates: failed to ping to host unix:///run/user/1000/buildkit-default/buildkitd.sock: exit status 1</span></span><br><span class="line"><span class="comment"># failed to ping to host unix:///run/user/1000/buildkit/buildkitd.sock: exit status 1</span></span><br><span class="line"></span><br><span class="line">containerd-rootless-setuptool.sh install-buildkit</span><br></pre></td></tr></table></figure>

<p>到这里，nerdctl以及containerd已经基本可用了</p>
<h2 id="单独安装"><a href="#单独安装" class="headerlink" title="单独安装"></a>单独安装</h2><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>安装containerd</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tar zxf /vagrant/containerd-2.0.2-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> ./bin/* /usr/local/bin/</span><br><span class="line"></span><br><span class="line">tree /usr/local/bin</span><br><span class="line"><span class="comment"># 输出如下所示</span></span><br><span class="line"><span class="comment"># /usr/local/bin</span></span><br><span class="line"><span class="comment"># ├── containerd</span></span><br><span class="line"><span class="comment"># ├── containerd-shim-runc-v2</span></span><br><span class="line"><span class="comment"># ├── containerd-stress</span></span><br><span class="line"><span class="comment"># └── ctr</span></span><br></pre></td></tr></table></figure>

<p>安装nerdctl</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装到/usr/local/bin/</span></span><br><span class="line"><span class="built_in">sudo</span> tar zxf nerdctl-2.0.3-linux-amd64.tar.gz -C /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">tree /usr/local/bin</span><br><span class="line"><span class="comment"># 输出如下所示</span></span><br><span class="line"><span class="comment"># /usr/local/bin</span></span><br><span class="line"><span class="comment"># ├── containerd</span></span><br><span class="line"><span class="comment"># ├── containerd-rootless-setuptool.sh</span></span><br><span class="line"><span class="comment"># ├── containerd-rootless.sh</span></span><br><span class="line"><span class="comment"># ├── containerd-shim-runc-v2</span></span><br><span class="line"><span class="comment"># ├── containerd-stress</span></span><br><span class="line"><span class="comment"># ├── ctr</span></span><br><span class="line"><span class="comment"># └── nerdctl</span></span><br></pre></td></tr></table></figure>

<p>安装rootlesskit以及slirp4netns</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装到/usr/local/bin/</span></span><br><span class="line"><span class="built_in">sudo</span> tar zxf rootlesskit-x86_64.tar.gz -C /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x slirp4netns</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> slirp4netns /usr/local/bin</span><br></pre></td></tr></table></figure>

<p>安装buildkit</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar zxf buildkit-v0.19.0.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> ./bin/* /usr/local/bin/</span><br></pre></td></tr></table></figure>

<p>安装cni</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cni安装目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /opt/cni/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> tar zxf cni-plugins-linux-amd64-v1.6.2.tgz -C /opt/cni/bin/</span><br><span class="line"></span><br><span class="line">tree /opt/cni/bin</span><br><span class="line"><span class="comment"># /opt/cni/bin</span></span><br><span class="line"><span class="comment"># ├── LICENSE</span></span><br><span class="line"><span class="comment"># ├── README.md</span></span><br><span class="line"><span class="comment"># ├── bandwidth</span></span><br><span class="line"><span class="comment"># ├── bridge</span></span><br><span class="line"><span class="comment"># ├── dhcp</span></span><br><span class="line"><span class="comment"># ├── dummy</span></span><br><span class="line"><span class="comment"># ├── firewall</span></span><br><span class="line"><span class="comment"># ├── host-device</span></span><br><span class="line"><span class="comment"># ├── host-local</span></span><br><span class="line"><span class="comment"># ├── ipvlan</span></span><br><span class="line"><span class="comment"># ├── loopback</span></span><br><span class="line"><span class="comment"># ├── macvlan</span></span><br><span class="line"><span class="comment"># ├── portmap</span></span><br><span class="line"><span class="comment"># ├── ptp</span></span><br><span class="line"><span class="comment"># ├── sbr</span></span><br><span class="line"><span class="comment"># ├── static</span></span><br><span class="line"><span class="comment"># ├── tap</span></span><br><span class="line"><span class="comment"># ├── tuning</span></span><br><span class="line"><span class="comment"># ├── vlan</span></span><br><span class="line"><span class="comment"># └── vrf</span></span><br></pre></td></tr></table></figure>

<h3 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h3><p>执行<code>nerdctl</code>，报错需要安装运行rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nerdctl</span><br><span class="line"><span class="comment"># FATA[0000] rootless containerd not running? (hint: use `containerd-rootless-setuptool.sh install` to start rootless containerd): stat /run/user/1000/containerd-rootless: no such file or directory</span></span><br></pre></td></tr></table></figure>

<p>安装rootless containerd第一次尝试，报错表示需要配置AppArmor授权</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br><span class="line"><span class="comment"># [INFO] Checking RootlessKit functionality</span></span><br><span class="line"><span class="comment"># [rootlesskit:parent] error: failed to start the child: fork/exec /proc/self/exe: operation not permitted</span></span><br><span class="line"><span class="comment"># [ERROR] RootlessKit failed, see the error messages and https://rootlesscontaine.rs/getting-started/common/ .</span></span><br></pre></td></tr></table></figure>

<p>配置apparmor</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rootlesskit放在了/usr/local/bin目录</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOT | sudo tee &quot;/etc/apparmor.d/usr.local.bin.rootlesskit&quot;</span></span><br><span class="line"><span class="string">abi &lt;abi/4.0&gt;,</span></span><br><span class="line"><span class="string">include &lt;tunables/global&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/usr/local/bin/rootlesskit flags=(unconfined) &#123;</span></span><br><span class="line"><span class="string">  userns,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # Site-specific additions and overrides. See local/README for details.</span></span><br><span class="line"><span class="string">  include if exists &lt;local/usr.local.bin.rootlesskit&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOT</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart apparmor.service</span><br></pre></td></tr></table></figure>

<p>安装并启动rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br></pre></td></tr></table></figure>

<p>为<code>nerdctl build</code>安装并运行buildkit</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install-buildkit</span><br></pre></td></tr></table></figure>

<p>完成安装！</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://github.com/containerd/nerdctl">nerdctl</a><br><a target="_blank" rel="noopener" href="https://rootlesscontaine.rs/getting-started/common/">Common steps (Read first!)</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/rootless/">Rootless mode</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/use-colima-as-an-alternative-to-docker-mac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/use-colima-as-an-alternative-to-docker-mac/" class="post-title-link" itemprop="url">使用colima作为docker desktop的替代</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-03 16:30:30 / 修改时间：16:33:13" itemprop="dateCreated datePublished" datetime="2025-02-03T16:30:30+08:00">2025-02-03</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>296</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>简单介绍下macOS当前docker运行环境的最新选择：colima，一个开源产品，使用体验与vagrant类似，感觉非常不错</p>
<h2 id="colima"><a href="#colima" class="headerlink" title="colima"></a>colima</h2><p>根据<a target="_blank" rel="noopener" href="https://github.com/abiosoft/colima">colima</a>官方仓库指导安装colima</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install colima</span><br></pre></td></tr></table></figure>

<p>colima默认的runtime是docker，因为k8s已经剥离了docker，只保留containerd，所以为了跟k8s保持一致，另外也不想再多安装一个软件，就选择了只用containerd</p>
<p>但如果你使用了docker compose，那么最好还是根据教程安装docker以及docker-compose</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像并创建vm</span></span><br><span class="line">colima start --cpu 1 --memory 2 --disk 50 --runtime containerd</span><br><span class="line"><span class="comment"># 这里还可以开启kubernetes支持</span></span><br><span class="line"><span class="comment"># colima start --cpu 4 --memory 8 --disk 100 --runtime containerd --kubernetes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看vm列表</span></span><br><span class="line">colima list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接vm</span></span><br><span class="line">colima ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装nerdctl用于支持containerd</span></span><br><span class="line">colima nerdctl install</span><br></pre></td></tr></table></figure>

<h2 id="nerdctl"><a href="#nerdctl" class="headerlink" title="nerdctl"></a>nerdctl</h2><p>nerdctl是containerd的非核心命令行管理工具，与docker命令完全兼容，<code>containerd + nerdctl = docker</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker镜像列表，相当于docker image ls</span></span><br><span class="line">nerdctl image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">nerdctl pull mysql:9.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建container</span></span><br><span class="line">nerdctl run --name mysql9 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=a123456 -d mysql:9.2 --character-set-server=utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看container列表</span></span><br><span class="line">nerdctl ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接container</span></span><br><span class="line">nerdctl <span class="built_in">exec</span> -it mysql9 bash</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://github.com/abiosoft/colima">colima</a><br><a target="_blank" rel="noopener" href="https://github.com/containerd/nerdctl">nerdctl</a><br><a target="_blank" rel="noopener" href="https://smallsharpsoftwaretools.com/tutorials/use-colima-to-run-docker-containers-on-macos/">Use Colima to Run Docker Containers on macOS</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/the-difference-between-mysql-and-postgresql-for-web-developer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/the-difference-between-mysql-and-postgresql-for-web-developer/" class="post-title-link" itemprop="url">MySQL与PostgreSQL的使用区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-03 14:43:46" itemprop="dateCreated datePublished" datetime="2025-02-03T14:43:46+08:00">2025-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-04 15:29:56" itemprop="dateModified" datetime="2025-02-04T15:29:56+08:00">2025-02-04</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>以<code>MySQL 9</code>以及<code>PostgreSQL 17</code>为例，从Web开发者的角度出发，列举两个数据库在使用方面的差异，仅介绍与CRUD依赖的操作，存储过程&#x2F;主从复制暂不介绍</p>
<h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h3 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h3><p><code>MySQL</code>创建管理员账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建mydb_admin管理员账户</span></span><br><span class="line"><span class="comment">-- 格式：`CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED WITH authentication_plugin BY &#x27;password&#x27;;`</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;mydb_admin&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> caching_sha2_password <span class="keyword">BY</span> <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 授权数据库/表访问权限</span></span><br><span class="line"><span class="comment">-- 格式：`GRANT PRIVILEGE ON database.table TO &#x27;username&#x27;@&#x27;host&#x27;;`</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;mydb_admin&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 如果不清楚有哪些权限，执行</span></span><br><span class="line"><span class="comment">-- SHOW PRIVILEGES;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 立即生效</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 查看账户列表核对</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.user;</span><br><span class="line"><span class="comment">-- SELECT * FROM mysql.user WHERE User=&#x27;mydb_admin&#x27; AND Host=&#x27;%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.查看账户授权</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;mydb_admin&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>创建管理员账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建mydb_admin管理员账户</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE mydb_admin LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 授权数据库/表访问权限（需要多条语句）</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="comment">-- 如果不想让账号访问其他db</span></span><br><span class="line"><span class="comment">-- REVOKE CONNECT ON DATABASE otherdb1 FROM PUBLIC;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 所有跟public相关的授权都需要先切换到指定数据库</span></span><br><span class="line">\c mydb</span><br><span class="line"><span class="comment">-- 授权public</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="comment">-- 后续所有变更自动授权（由super admin执行）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> SEQUENCES <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> FUNCTIONS <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 删除角色</span></span><br><span class="line"><span class="comment">-- DROP OWNED BY mydb_admin;</span></span><br><span class="line"><span class="comment">-- DROP ROLE mydb_admin;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p><code>MySQL</code>通过上面配置即可对外提供访问，<code>PostgreSQL</code>还需要配置<code>pg_hba.conf</code>，此外，如果删除后重建mydb，需要重新授权</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class="line"># host  all             all             0.0.0.0/32              scram-sha-256</span><br><span class="line">host    mydb mydb_admin 0.0.0.0/32 scram-sha-256</span><br><span class="line"># hostssl mydb mydb_admin 0.0.0.0/32 scram-sha-256</span><br></pre></td></tr></table></figure>

<h3 id="Web读写"><a href="#Web读写" class="headerlink" title="Web读写"></a>Web读写</h3><p><code>MySQL</code>创建CRUD账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建读写账户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;mydb_write&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> caching_sha2_password <span class="keyword">BY</span> <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;mydb_write&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建只读账户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;mydb_read&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> caching_sha2_password <span class="keyword">BY</span> <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;mydb_read&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>创建CRUD账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建读写账户</span></span><br><span class="line"><span class="comment">-- 创建角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE mydb_write_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色授权，只能连接mydb</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CONNECT</span> <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"><span class="comment">-- 所有跟public相关的授权都需要先切换到指定数据库</span></span><br><span class="line">\c mydb;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"><span class="comment">-- 后续所有变更自动授权（由super admin以及mydb_admin执行）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户并关联角色</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> mydb_write_user <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> mydb_write_role <span class="keyword">TO</span> mydb_write_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建只读账户</span></span><br><span class="line"><span class="comment">-- 创建角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE mydb_read_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CONNECT</span> <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"><span class="comment">-- 所有跟public相关的授权都需要先切换到指定数据库</span></span><br><span class="line">\c mydb;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"><span class="comment">-- 后续所有变更自动授权（由super admin以及mydb_admin执行）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户并关联角色</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> mydb_read_user <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> mydb_read_role <span class="keyword">TO</span> mydb_read_user;</span><br></pre></td></tr></table></figure>

<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h3><p><code>MySQL</code>建库操作如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 列出所有数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建mydb数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mydb;</span><br><span class="line"><span class="comment">-- 创建并设置charset</span></span><br><span class="line"><span class="comment">-- CREATE DATABASE mydb CHARACTER SET utf8mb4;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看建库sql</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 查看数据库列表核对</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.SCHEMATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 切换到mydb</span></span><br><span class="line">USE mydb;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>建库操作如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 列出所有数据库</span></span><br><span class="line">\l<span class="operator">+</span></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> datname <span class="keyword">FROM</span> pg_database;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建mydb数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 切换到mydb</span></span><br><span class="line">\c mydb</span><br></pre></td></tr></table></figure>

<h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p><code>MySQL</code>建表操作如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建数据表</span></span><br><span class="line"><span class="comment">-- 指定innodb、纪录备注、创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main(</span><br><span class="line">  `id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY COMMENT &quot;ID&quot;,</span><br><span class="line">  `order_number` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;order number&quot;,</span><br><span class="line">  `user_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;user id&quot;,</span><br><span class="line">  `product_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;product id&quot;,</span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(`order_number`),</span><br><span class="line">  INDEX `idx_user_id` (`user_id`)</span><br><span class="line">) ENGINE InnoDB <span class="keyword">DEFAULT</span> CHARSET utf8mb4 COMMENT &quot;order main&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单独创建索引示例如下</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX `idx_product_id` <span class="keyword">ON</span> `order_main`(`product_id`);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查看数据表列表核对</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="comment">-- SHOW TABLES LIKE &#x27;%order_main%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看建表语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>建表操作如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建数据表</span></span><br><span class="line"><span class="comment">-- 与关键字相同的字段需要使用双引号，不支持备注</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main(</span><br><span class="line">  &quot;id&quot; <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  &quot;order_number&quot; <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &quot;user_id&quot; <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &quot;product_id&quot; <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line">  <span class="keyword">UNIQUE</span>(&quot;order_number&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 非pk以及unique索引需要单独创建，名称需要区分数据表</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX &quot;order_main_idx_product_id&quot; <span class="keyword">ON</span> &quot;order_main&quot;(&quot;product_id&quot;);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查看数据表列表核对</span></span><br><span class="line">\dt<span class="operator">+</span></span><br><span class="line"><span class="comment">-- 列出所有数据库表</span></span><br><span class="line"><span class="comment">-- \dt *</span></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_catalog.pg_tables <span class="keyword">WHERE</span> schemaname <span class="operator">!=</span> <span class="string">&#x27;pg_catalog&#x27;</span> <span class="keyword">AND</span> schemaname <span class="operator">!=</span> <span class="string">&#x27;information_schema&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看数据表结构，不支持查看建表sql</span></span><br><span class="line">\d order_main</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="命令行显示优化"><a href="#命令行显示优化" class="headerlink" title="命令行显示优化"></a>命令行显示优化</h3><p><code>MySQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将;改为\G，以扩展模式输出</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main\G</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mysql 所有输出自带命令执行耗时时长，单位：秒</span></span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当内容长度超过一行自动切换为扩展模式输出</span></span><br><span class="line">\x auto</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出sql命令执行使用的时间，单位：毫秒</span></span><br><span class="line">\timing <span class="keyword">on</span></span><br></pre></td></tr></table></figure>

<h3 id="导入-导出sql"><a href="#导入-导出sql" class="headerlink" title="导入&#x2F;导出sql"></a>导入&#x2F;导出sql</h3><p><code>MySQL</code>如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入</span></span><br><span class="line">mysql -h localhost -u mydb_admin -P 3306 -p mydb &lt; mydb.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出</span></span><br><span class="line">mysqldump -h localhost -u mydb_admin -P 3306 -p mydb album &gt; mydb.album.sql</span><br></pre></td></tr></table></figure>

<p>或者使用sql导入文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 文件需要放在指定目录</span></span><br><span class="line">SOURCE <span class="operator">/</span>tmp<span class="operator">/</span>mydb.album.sql</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入，非if not exists，有数据会报错</span></span><br><span class="line">psql -d mydb -f mydb.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出</span></span><br><span class="line">pg_dump -t public.album mydb &gt; mydb.album.sql</span><br></pre></td></tr></table></figure>

<h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p><code>MySQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看服务器相关配置</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看服务器与buffer_pool相关的配置</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%buffer_pool%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改max_connections</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_connections<span class="operator">=</span><span class="number">1024</span>;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看服务器相关配置</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ALL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看max_connections</span></span><br><span class="line"><span class="keyword">SHOW</span> max_connections;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看服务器以max开头的配置</span></span><br><span class="line"><span class="keyword">SELECT</span> name, setting <span class="keyword">FROM</span> pg_settings <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;max_%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改timezone</span></span><br><span class="line"><span class="keyword">SET</span> timezone<span class="operator">=</span><span class="string">&#x27;Asia/Hong_kong&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p><code>MySQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前活动过进程</span></span><br><span class="line"><span class="keyword">SHOW</span> PROCESSLIST;</span><br><span class="line"><span class="comment">-- SHOW FULL PROCESSLIST;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结束进程</span></span><br><span class="line">KILL _pid_;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前活动过进程</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_stat_activity;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结束进程</span></span><br><span class="line"><span class="keyword">SELECT</span> pg_cancel_backend(_pid_);</span><br><span class="line"><span class="keyword">SELECT</span> pg_terminate_backend(_pid_);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重新加载配置</span></span><br><span class="line"><span class="keyword">SELECT</span> pg_reload_conf();</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">y2k38</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">81k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:54</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Y2k38/y2k38.github.io","repo_id":"R_kgDOMZGvZA","category":"Announcements","category_id":"DIC_kwDOMZGvZM4CirXX","mapping":"pathname","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"preferred_color_scheme","lang":"zh-CN","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
