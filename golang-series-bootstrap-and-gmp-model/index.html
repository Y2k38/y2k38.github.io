<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"y2k38.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文仅介绍程序运行流程以及GMP如何寻找g并运行，其他如抢占、死锁、信号处理、profiling等内容不打算深入。当前go版本：1.24 前提先讲几个概念 进程、线程、协程  进程：程序的一个实例，也是操作系统的一个task，操作系统的资源分配最小单位 线程：一种概念，操作系统调度的最小单位，一个进程可以包含多个线程，线程之间共享内存、文件描述符等资源。不同操作系统的实现并不一致，linux下进程">
<meta property="og:type" content="article">
<meta property="og:title" content="golang系列之-程序运行流程及GMP模型">
<meta property="og:url" content="https://y2k38.github.io/golang-series-bootstrap-and-gmp-model/index.html">
<meta property="og:site_name" content="noname">
<meta property="og:description" content="本文仅介绍程序运行流程以及GMP如何寻找g并运行，其他如抢占、死锁、信号处理、profiling等内容不打算深入。当前go版本：1.24 前提先讲几个概念 进程、线程、协程  进程：程序的一个实例，也是操作系统的一个task，操作系统的资源分配最小单位 线程：一种概念，操作系统调度的最小单位，一个进程可以包含多个线程，线程之间共享内存、文件描述符等资源。不同操作系统的实现并不一致，linux下进程">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-30T05:12:29.000Z">
<meta property="article:modified_time" content="2025-03-30T09:09:17.763Z">
<meta property="article:author" content="y2k38">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://y2k38.github.io/golang-series-bootstrap-and-gmp-model/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://y2k38.github.io/golang-series-bootstrap-and-gmp-model/","path":"golang-series-bootstrap-and-gmp-model/","title":"golang系列之-程序运行流程及GMP模型"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>golang系列之-程序运行流程及GMP模型 | noname</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">noname</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E6%8F%90"><span class="nav-number">1.</span> <span class="nav-text">前提</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">go程序的运行流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#G-goroutine"><span class="nav-number">3.1.</span> <span class="nav-text">G - goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#M-machine"><span class="nav-number">3.2.</span> <span class="nav-text">M - machine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P-processor"><span class="nav-number">3.3.</span> <span class="nav-text">P - processor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#schedt-%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">3.4.</span> <span class="nav-text">schedt - 调度器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#schedinit-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">schedinit - 调度器初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAg%E8%B4%9F%E8%B4%A3%E8%BF%90%E8%A1%8Cmain%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">创建g负责运行main函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#newproc-%E5%88%9B%E5%BB%BAgoroutine"><span class="nav-number">5.1.</span> <span class="nav-text">newproc - 创建goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-main-%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3"><span class="nav-number">5.2.</span> <span class="nav-text">runtime.main - 程序入口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime%C2%B7mstart-%E8%BF%90%E8%A1%8C%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">runtime·mstart - 运行调度函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mstart0"><span class="nav-number">6.1.</span> <span class="nav-text">mstart0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#schedule-%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">schedule - 调度函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#findRunnable-%E5%AF%BB%E6%89%BE%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%9A%84g"><span class="nav-number">6.3.</span> <span class="nav-text">findRunnable - 寻找可运行的g</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">相关依赖函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#goroutine"><span class="nav-number">7.1.</span> <span class="nav-text">goroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA"><span class="nav-number">7.1.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2"><span class="nav-number">7.1.2.</span> <span class="nav-text">终止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gFree-%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-number">7.1.3.</span> <span class="nav-text">gFree - 空闲链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#user-sys%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="nav-number">7.1.4.</span> <span class="nav-text">user&#x2F;sys类型判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#status%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">7.1.5.</span> <span class="nav-text">status状态管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#allg-%E5%85%A8%E5%B1%80%E5%88%97%E8%A1%A8"><span class="nav-number">7.1.6.</span> <span class="nav-text">allg-全局列表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#machine"><span class="nav-number">7.2.</span> <span class="nav-text">machine</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E9%AA%8C%E8%AF%81"><span class="nav-number">7.2.1.</span> <span class="nav-text">结构体验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-1"><span class="nav-number">7.2.2.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">7.2.3.</span> <span class="nav-text">通用初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">7.2.4.</span> <span class="nav-text">信号处理初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%A2%9EID"><span class="nav-number">7.2.5.</span> <span class="nav-text">自增ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E9%87%8F%E9%99%90%E5%88%B6%E6%A3%80%E6%B5%8B"><span class="nav-number">7.2.6.</span> <span class="nav-text">数量限制检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#midle-%E5%85%A8%E5%B1%80%E7%A9%BA%E9%97%B2%E9%98%9F%E5%88%97"><span class="nav-number">7.2.7.</span> <span class="nav-text">midle-全局空闲队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#m%E5%90%AF%E5%8A%A8-%E5%81%9C%E6%AD%A2"><span class="nav-number">7.2.8.</span> <span class="nav-text">m启动&#x2F;停止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-number">7.2.9.</span> <span class="nav-text">线程退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E7%AD%89%E5%BE%85"><span class="nav-number">7.2.10.</span> <span class="nav-text">自旋等待</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#processor"><span class="nav-number">7.3.</span> <span class="nav-text">processor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-%E5%AE%B9%E9%87%8F%E8%B0%83%E6%95%B4"><span class="nav-number">7.3.1.</span> <span class="nav-text">创建&#x2F;容量调整</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">7.3.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pidle-%E5%85%A8%E5%B1%80%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-number">7.3.3.</span> <span class="nav-text">pidle-全局空闲链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%80%E6%AF%81"><span class="nav-number">7.3.4.</span> <span class="nav-text">销毁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#runq-%E6%9C%AC%E5%9C%B0goroutine%E9%98%9F%E5%88%97"><span class="nav-number">7.3.5.</span> <span class="nav-text">runq-本地goroutine队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="nav-number">7.4.</span> <span class="nav-text">调度器相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#g-m%E6%8C%82%E8%B5%B7%E3%80%81%E5%94%A4%E9%86%92"><span class="nav-number">7.4.1.</span> <span class="nav-text">g&#x2F;m挂起、唤醒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96p"><span class="nav-number">7.4.2.</span> <span class="nav-text">获取p</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%B7%E5%8F%96%E4%BB%BB%E5%8A%A1"><span class="nav-number">7.4.3.</span> <span class="nav-text">偷取任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#runq-%E5%85%A8%E5%B1%80%E9%98%9F%E5%88%97"><span class="nav-number">7.4.4.</span> <span class="nav-text">runq-全局队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#g-m%E7%BB%91%E5%AE%9A%E3%80%81%E8%A7%A3%E7%BB%91"><span class="nav-number">7.4.5.</span> <span class="nav-text">g&#x2F;m绑定、解绑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#m-p%E7%BB%91%E5%AE%9A%E3%80%81%E8%A7%A3%E7%BB%91"><span class="nav-number">7.4.6.</span> <span class="nav-text">m&#x2F;p绑定、解绑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#netpoll"><span class="nav-number">7.4.7.</span> <span class="nav-text">netpoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9"><span class="nav-number">7.4.8.</span> <span class="nav-text">安全点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98"><span class="nav-number">7.4.9.</span> <span class="nav-text">寄存器数据保存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E7%9B%B8%E5%85%B3"><span class="nav-number">7.4.10.</span> <span class="nav-text">抢占相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">7.4.11.</span> <span class="nav-text">系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E7%9B%B8%E5%85%B3"><span class="nav-number">7.5.</span> <span class="nav-text">main相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#init%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">7.5.1.</span> <span class="nav-text">init初始化函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E7%9B%B8%E5%85%B3"><span class="nav-number">7.6.</span> <span class="nav-text">GC相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8sweeper%E3%80%81scavenger"><span class="nav-number">7.6.1.</span> <span class="nav-text">启动sweeper、scavenger</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC%E8%B0%83%E5%BA%A6"><span class="nav-number">7.6.2.</span> <span class="nav-text">GC调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sysmon%E7%9B%B8%E5%85%B3"><span class="nav-number">7.7.</span> <span class="nav-text">sysmon相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cgo%E7%9B%B8%E5%85%B3"><span class="nav-number">7.8.</span> <span class="nav-text">cgo相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#profiling%E7%9B%B8%E5%85%B3"><span class="nav-number">7.9.</span> <span class="nav-text">profiling相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">7.10.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sudog%E7%9B%B8%E5%85%B3"><span class="nav-number">7.10.1.</span> <span class="nav-text">sudog相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">7.10.2.</span> <span class="nav-text">死锁检测</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">8.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">y2k38</p>
  <div class="site-description" itemprop="description">个人笔记</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-bootstrap-and-gmp-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="golang系列之-程序运行流程及GMP模型 | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          golang系列之-程序运行流程及GMP模型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-03-30 13:12:29 / 修改时间：17:09:17" itemprop="dateCreated datePublished" datetime="2025-03-30T13:12:29+08:00">2025-03-30</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:33</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文仅介绍程序运行流程以及GMP如何寻找g并运行，其他如抢占、死锁、信号处理、profiling等内容不打算深入。当前go版本：1.24</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>先讲几个概念</p>
<p><strong>进程、线程、协程</strong></p>
<ol>
<li>进程：程序的一个实例，也是操作系统的一个task，操作系统的资源分配最小单位</li>
<li>线程：一种概念，操作系统调度的最小单位，一个进程可以包含多个线程，线程之间共享内存、文件描述符等资源。不同操作系统的实现并不一致，linux下进程与线程的结构都是task_structure，也就是说他们是一样的，不同线程之间用指针指向同一份资源如内存空间实现共享。</li>
<li>协程：也称为用户态线程，由应用程序自行实现&#x2F;调度，一般情况下是协作式的，由开发者决定task何时让出cpu，go支持抢占式调度</li>
</ol>
<p><strong>线程与协程的映射模型</strong></p>
<ol>
<li>1:1模型，每个用户线程对应一个内核线程，如在c中pthread创建的线程，此时也可以理解为用户态线程就是内核态线程</li>
<li>1:N模型，一个内核线程对应多个用户线程，无法充分利用多核的并行性，现已淘汰</li>
<li>M:N模型，多个用户线程对应多个内核线程，实现较复杂，使用者较少，go是其中一个</li>
</ol>
<p><strong>GMP模型</strong></p>
<p>go早期的M:N模型遇到一些性能问题，如锁竞争激烈、线程创建&#x2F;销毁频繁、CPU缓存失效等，为了解决这些问题引入了P。在GMP模型中</p>
<ol>
<li>G-goroutine，用户态线程</li>
<li>M-machine，系统线程相关</li>
<li>P-processor，缓存、调度上下文等，其数量一般与CPU核心数量一致。P的出现使得调度变得本地化，避免全局锁竞争，提升了CPU缓存命中率等，最终使得go的并发调度更加高效</li>
</ol>
<h2 id="go程序的运行流程"><a href="#go程序的运行流程" class="headerlink" title="go程序的运行流程"></a>go程序的运行流程</h2><p>go程序启动时的入口是<code>_rt0_amd64</code>，该函数是汇编代码，具体如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/runtime/asm_amd64.s</span><br><span class="line">// 系统入口点</span><br><span class="line">TEXT _rt0_amd64(SB),NOSPLIT,$-8</span><br><span class="line">    MOVQ    0(SP), DI    // argc</span><br><span class="line">    LEAQ    8(SP), SI    // argv</span><br><span class="line">    JMP    runtime·rt0_go(SB)</span><br></pre></td></tr></table></figure>

<p><code>runtime·rt0_go</code>也是汇编代码，比较长，主要逻辑如下</p>
<ol>
<li>g0、m0双向绑定（g0、m0是全局变量，静态编译，因此指针已知，放在src&#x2F;runtime&#x2F;proc.go）</li>
<li>runtime·args      - 复制命令行参数（args函数放在src&#x2F;runtime&#x2F;runtime1.go）</li>
<li>runtime·osinit    - 系统初始化（osinit函数放在src&#x2F;runtime&#x2F;os_linux.go）</li>
<li>runtime·schedinit - 调度器初始化（schedinit函数放在src&#x2F;runtime&#x2F;proc.go）</li>
<li>runtime·mainPC    - 纪录runtime·main的地址（main函数放在src&#x2F;runtime&#x2F;proc.go，其内部调用main_main，也就是用户自己编写的main函数）</li>
<li>runtime·newproc   - 创建G用于运行runtime·main，放到p的runq里，等待调度</li>
<li>runtime·mstart    - 运行runtime·mstart（汇编函数，实际调用的是runtime·mstart0，放在src&#x2F;runtime&#x2F;proc.go，内部进行栈初始化、信号注册等，最后运行调度函数schedule）</li>
</ol>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="G-goroutine"><a href="#G-goroutine" class="headerlink" title="G - goroutine"></a>G - goroutine</h3><p>goroutine的数据结构如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="comment">// macOS下共440字节，虽然结构比较大，但GMP调度场景下使用的字段并不多</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 栈相关</span></span><br><span class="line">    stack             stack                       <span class="comment">// 最小为2KB，最大为1GB</span></span><br><span class="line">    stackguard0       <span class="type">uintptr</span>                     <span class="comment">// 用于正常函数调用时检查</span></span><br><span class="line">    stackguard1       <span class="type">uintptr</span>                     <span class="comment">// 用于调度恢复执行时检查</span></span><br><span class="line"></span><br><span class="line">    _panic            *_panic                     <span class="comment">// panic链</span></span><br><span class="line">    _defer            *_defer                     <span class="comment">// defer链</span></span><br><span class="line">    m                 *m                          <span class="comment">// 当前m</span></span><br><span class="line">    sched             gobuf                       <span class="comment">// 上下文如pc、sp等信息</span></span><br><span class="line">    syscallsp         <span class="type">uintptr</span>                     <span class="comment">// 系统调用时用</span></span><br><span class="line">    syscallpc         <span class="type">uintptr</span>                     <span class="comment">// 系统调用时用</span></span><br><span class="line">    syscallbp         <span class="type">uintptr</span>                     <span class="comment">// 系统调用时用</span></span><br><span class="line">    stktopsp          <span class="type">uintptr</span>                     <span class="comment">// 栈顶sp</span></span><br><span class="line"></span><br><span class="line">    param             unsafe.Pointer              <span class="comment">// 通用指针，存储sudog等</span></span><br><span class="line">    atomicstatus      atomic.Uint32               <span class="comment">// 状态，用的比较多，具体看后面列表</span></span><br><span class="line">    stackLock         <span class="type">uint32</span>                      <span class="comment">//</span></span><br><span class="line">    goid              <span class="type">uint64</span>                      <span class="comment">// 全局唯一id，从p获取，如果p没有，从sched获取</span></span><br><span class="line">    schedlink         guintptr                    <span class="comment">// next指针，下一个g，用于全局队列</span></span><br><span class="line">    waitsince         <span class="type">int64</span>                       <span class="comment">// 等待时刻</span></span><br><span class="line">    waitreason        waitReason                  <span class="comment">// 挂起原因</span></span><br><span class="line"></span><br><span class="line">    preempt           <span class="type">bool</span>                        <span class="comment">// 抢占标志</span></span><br><span class="line">    preemptStop       <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line">    preemptShrink     <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    asyncSafePoint    <span class="type">bool</span>                        <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    paniconfault      <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line">    gcscandone        <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line">    throwsplit        <span class="type">bool</span>                        <span class="comment">// 是否允许栈分裂/扩容</span></span><br><span class="line"></span><br><span class="line">    activeStackChans  <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    parkingOnChan     atomic.Bool                 <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    inMarkAssist      <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line">    coroexit          <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    raceignore        <span class="type">int8</span>                        <span class="comment">//</span></span><br><span class="line">    nocgocallback     <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line">    tracking          <span class="type">bool</span>                        <span class="comment">// trackingSeq%8 == 0</span></span><br><span class="line">    trackingSeq       <span class="type">uint8</span>                       <span class="comment">// 计数器，初始为一个随机数</span></span><br><span class="line">    trackingStamp     <span class="type">int64</span>                       <span class="comment">// 开始时刻（计算_Gwaiting、_Grunnable阶段耗时）</span></span><br><span class="line">    runnableTime      <span class="type">int64</span>                       <span class="comment">// _Grunnable总耗时</span></span><br><span class="line">    lockedm           muintptr                    <span class="comment">// m，锁定时用</span></span><br><span class="line">    fipsIndicator     <span class="type">uint8</span>                       <span class="comment">//</span></span><br><span class="line">    sig               <span class="type">uint32</span>                      <span class="comment">//</span></span><br><span class="line">    writebuf          []<span class="type">byte</span>                      <span class="comment">//</span></span><br><span class="line">    sigcode0          <span class="type">uintptr</span>                     <span class="comment">//</span></span><br><span class="line">    sigcode1          <span class="type">uintptr</span>                     <span class="comment">//</span></span><br><span class="line">    sigpc             <span class="type">uintptr</span>                     <span class="comment">//</span></span><br><span class="line">    parentGoid        <span class="type">uint64</span>                      <span class="comment">// 父g的goid</span></span><br><span class="line">    gopc              <span class="type">uintptr</span>                     <span class="comment">// 父g的pc</span></span><br><span class="line">    ancestors         *[]ancestorInfo             <span class="comment">// 父g的指针放到一个列表</span></span><br><span class="line">    startpc           <span class="type">uintptr</span>                     <span class="comment">// G的函数，=fn.fn</span></span><br><span class="line">    racectx           <span class="type">uintptr</span>                     <span class="comment">// 冲突检测相关</span></span><br><span class="line">    waiting           *sudog                      <span class="comment">// sudog指针，channel、select用</span></span><br><span class="line">    cgoCtxt           []<span class="type">uintptr</span>                   <span class="comment">//</span></span><br><span class="line">    labels            unsafe.Pointer              <span class="comment">// g为user类型时，父子共享</span></span><br><span class="line">    timer             *timer                      <span class="comment">// 定时器，time.Sleep用</span></span><br><span class="line">    sleepWhen         <span class="type">int64</span>                       <span class="comment">// 定时器，超时时间</span></span><br><span class="line">    selectDone        atomic.Uint32               <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    goroutineProfiled goroutineProfileStateHolder <span class="comment">// 新g需要标记不需要profile</span></span><br><span class="line"></span><br><span class="line">    coroarg           *coro                       <span class="comment">//</span></span><br><span class="line">    syncGroup         *synctestGroup              <span class="comment">// 测试相关，g为user类型时，父子共享</span></span><br><span class="line">    </span><br><span class="line">    trace             gTraceState                 <span class="comment">// trace相关数据</span></span><br><span class="line">    </span><br><span class="line">    gcAssistBytes     <span class="type">int64</span>                       <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g0，全局变量，只有第一个g0是编译期间生成的，其他g0在创建m绑定p时动态生成</span></span><br><span class="line"><span class="keyword">var</span> g0 g</span><br></pre></td></tr></table></figure>

<p><strong>类型</strong></p>
<p><code>user</code>：大部分的g都是user类型，执行用户代码<br><code>sys</code> ：大部分runtime开头的函数等都是sys类型，除了少部分如runtime.main外</p>
<p><strong>状态列表</strong></p>
<table>
<thead>
<tr>
<th align="left">status_name</th>
<th align="left">status_value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_Gidle</td>
<td align="left">0x00</td>
<td align="left">G已创建但未初始化</td>
</tr>
<tr>
<td align="left">_Grunnable</td>
<td align="left">0x01</td>
<td align="left">G放在runq，还未运行，未拥有stack</td>
</tr>
<tr>
<td align="left">_Grunning</td>
<td align="left">0x02</td>
<td align="left">G正在运行用户代码，拥有stack，已绑定M、P，不在runq</td>
</tr>
<tr>
<td align="left">_Gsyscall</td>
<td align="left">0x03</td>
<td align="left">G在执行系统调用（内核态），未运行用户代码，已绑定M，不在runq</td>
</tr>
<tr>
<td align="left">_Gwaiting</td>
<td align="left">0x04</td>
<td align="left">G阻塞中，未运行用户代码，未拥有stack，不在runq</td>
</tr>
<tr>
<td align="left">_Gmoribund_unused</td>
<td align="left">0x05</td>
<td align="left">此状态未被使用</td>
</tr>
<tr>
<td align="left">_Gdead</td>
<td align="left">0x06</td>
<td align="left">墓碑，G被M剥离并存储于free链表，或从free链表获取绑定中</td>
</tr>
<tr>
<td align="left">_Genqueue_unused</td>
<td align="left">0x07</td>
<td align="left">此状态未被使用</td>
</tr>
<tr>
<td align="left">_Gcopystack</td>
<td align="left">0x08</td>
<td align="left">迁移stack中，未运行用户代码，不在runq</td>
</tr>
<tr>
<td align="left">_Gpreempted</td>
<td align="left">0x09</td>
<td align="left">G被抢占，类似_Gwaiting</td>
</tr>
<tr>
<td align="left">_Gscan</td>
<td align="left">0x1000</td>
<td align="left">GC在扫描stack，未运行用户代码，拥有stack，可以组合上述其他标记</td>
</tr>
<tr>
<td align="left">_Gscanrunnable</td>
<td align="left">0x1001</td>
<td align="left">同_Gscan+_Grunnable</td>
</tr>
<tr>
<td align="left">_Gscanrunning</td>
<td align="left">0x1002</td>
<td align="left">同_Gscan+_Grunning</td>
</tr>
<tr>
<td align="left">_Gscansyscall</td>
<td align="left">0x1003</td>
<td align="left">同_Gscan+_Gsyscall</td>
</tr>
<tr>
<td align="left">_Gscanwaiting</td>
<td align="left">0x1004</td>
<td align="left">同_Gscan+_Gwaiting</td>
</tr>
<tr>
<td align="left">_Gscanpreempted</td>
<td align="left">0x1009</td>
<td align="left">同_Gscan+_Gpreempted</td>
</tr>
</tbody></table>
<p><strong>栈初始大小</strong></p>
<p>普通g的栈大小初始为2KB，非固定大小，可扩容，最大1GB。当然，初始栈大小也不是一成不变的，系统在GC时计算平均栈大小并更新变量。g0的栈大小因系统而异，如下</p>
<table>
<thead>
<tr>
<th align="left">OS</th>
<th align="left">是否系统分配 (<code>mStackIsSystemAllocated</code>)</th>
<th align="left"><code>g0</code> 栈大小</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Linux</td>
<td align="left">❌（Go 运行时自己分配）</td>
<td align="left">16KB</td>
</tr>
<tr>
<td align="left">macOS</td>
<td align="left">✅（系统分配）</td>
<td align="left">2MB</td>
</tr>
<tr>
<td align="left">iOS</td>
<td align="left">✅（系统分配）</td>
<td align="left">2MB</td>
</tr>
<tr>
<td align="left">Windows</td>
<td align="left">✅（系统分配）</td>
<td align="left">1MB</td>
</tr>
<tr>
<td align="left">Solaris</td>
<td align="left">✅（系统分配）</td>
<td align="left">8MB（可能）</td>
</tr>
<tr>
<td align="left">OpenBSD</td>
<td align="left">部分情况 ✅（mips64 除外）</td>
<td align="left">未知，可能 8MB</td>
</tr>
</tbody></table>
<h3 id="M-machine"><a href="#M-machine" class="headerlink" title="M - machine"></a>M - machine</h3><p>线程相关数据结构m如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// macOS下共1912字节</span></span><br><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0                   *g                            <span class="comment">// g0，调度用</span></span><br><span class="line">    morebuf              gobuf                         <span class="comment">//</span></span><br><span class="line">    divmod               <span class="type">uint32</span>                        <span class="comment">//</span></span><br><span class="line">    _                    <span class="type">uint32</span>                        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    procid               <span class="type">uint64</span>                        <span class="comment">// 线程ID，由系统提供</span></span><br><span class="line">    gsignal              *g                            <span class="comment">// g，信号处理用，32KB的栈</span></span><br><span class="line">    goSigStack           gsignalStack                  <span class="comment">//</span></span><br><span class="line">    sigmask              sigset                        <span class="comment">// 信号掩码</span></span><br><span class="line">    tls                  [tlsSlots]<span class="type">uintptr</span>             <span class="comment">//</span></span><br><span class="line">    mstartfn             <span class="function"><span class="keyword">func</span><span class="params">()</span></span>                        <span class="comment">// 线程启动时调用</span></span><br><span class="line">    curg                 *g                            <span class="comment">// 当前g，user/sys类型</span></span><br><span class="line">    caughtsig            guintptr                      <span class="comment">//</span></span><br><span class="line">    p                    puintptr                      <span class="comment">// 当前p</span></span><br><span class="line">    nextp                puintptr                      <span class="comment">// 获取的p先绑定在这个字段</span></span><br><span class="line">    oldp                 puintptr                      <span class="comment">// m、p取消绑定时纪录</span></span><br><span class="line">    id                   <span class="type">int64</span>                         <span class="comment">// 全局唯一ID，由mReserveID提供</span></span><br><span class="line">    mallocing            <span class="type">int32</span>                         <span class="comment">//</span></span><br><span class="line">    throwing             throwType                     <span class="comment">//</span></span><br><span class="line">    preemptoff           <span class="type">string</span>                        <span class="comment">// 阻止抢占的标志，调试、特殊场景用</span></span><br><span class="line">    locks                <span class="type">int32</span>                         <span class="comment">// 计数器，阻止抢占</span></span><br><span class="line">    dying                <span class="type">int32</span>                         <span class="comment">//</span></span><br><span class="line">    profilehz            <span class="type">int32</span>                         <span class="comment">//</span></span><br><span class="line">    spinning             <span class="type">bool</span>                          <span class="comment">// 自旋寻找工作中</span></span><br><span class="line">    blocked              <span class="type">bool</span>                          <span class="comment">// 阻塞状态，跟park字段搭配使用</span></span><br><span class="line">    newSigstack          <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    printlock            <span class="type">int8</span>                          <span class="comment">//</span></span><br><span class="line">    incgo                <span class="type">bool</span>                          <span class="comment">// 是否是c创建的</span></span><br><span class="line">    isextra              <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    isExtraInC           <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    isExtraInSig         <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    freeWait             atomic.Uint32                 <span class="comment">// 销毁状态</span></span><br><span class="line">    needextram           <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    g0StackAccurate      <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    traceback            <span class="type">uint8</span>                         <span class="comment">//</span></span><br><span class="line">    ncgocall             <span class="type">uint64</span>                        <span class="comment">//</span></span><br><span class="line">    ncgo                 <span class="type">int32</span>                         <span class="comment">//</span></span><br><span class="line">    cgoCallersUse        atomic.Uint32                 <span class="comment">//</span></span><br><span class="line">    cgoCallers           *cgoCallers                   <span class="comment">//</span></span><br><span class="line">    park                 note                          <span class="comment">// semaphore</span></span><br><span class="line">    alllink              *m                            <span class="comment">// next指针，用于allm链表</span></span><br><span class="line">    schedlink            muintptr                      <span class="comment">// next指针，用于空闲链表</span></span><br><span class="line">    lockedg              guintptr                      <span class="comment">// 被锁住的g</span></span><br><span class="line">    createstack          [<span class="number">32</span>]<span class="type">uintptr</span>                   <span class="comment">//</span></span><br><span class="line">    lockedExt            <span class="type">uint32</span>                        <span class="comment">//</span></span><br><span class="line">    lockedInt            <span class="type">uint32</span>                        <span class="comment">// 是否锁定m，cgo用</span></span><br><span class="line">    mWaitList            mWaitList                     <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    mLockProfile         mLockProfile                  <span class="comment">// profile相关</span></span><br><span class="line">    profStack            []<span class="type">uintptr</span>                     <span class="comment">// profile相关</span></span><br><span class="line"></span><br><span class="line">    waitunlockf          <span class="function"><span class="keyword">func</span><span class="params">(*g, unsafe.Pointer)</span></span> <span class="type">bool</span> <span class="comment">// 解锁函数</span></span><br><span class="line">    waitlock             unsafe.Pointer                <span class="comment">// 解锁函数参数</span></span><br><span class="line">    waitTraceSkip        <span class="type">int</span>                           <span class="comment">// skip数量</span></span><br><span class="line">    waitTraceBlockReason traceBlockReason              <span class="comment">// 挂起原因-trace用</span></span><br><span class="line">    </span><br><span class="line">    syscalltick          <span class="type">uint32</span>                        <span class="comment">//</span></span><br><span class="line">    freelink             *m                            <span class="comment">// next指针，freem链表</span></span><br><span class="line">    trace                mTraceState                   <span class="comment">// trace相关数据</span></span><br><span class="line">    </span><br><span class="line">    libcall              libcall                       <span class="comment">//</span></span><br><span class="line">    libcallpc            <span class="type">uintptr</span>                       <span class="comment">//</span></span><br><span class="line">    libcallsp            <span class="type">uintptr</span>                       <span class="comment">//</span></span><br><span class="line">    libcallg             guintptr                      <span class="comment">//</span></span><br><span class="line">    winsyscall           winlibcall                    <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    vdsoSP               <span class="type">uintptr</span>                       <span class="comment">//</span></span><br><span class="line">    vdsoPC               <span class="type">uintptr</span>                       <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    preemptGen           atomic.Uint32                 <span class="comment">// 计数器，统计抢占次数</span></span><br><span class="line">    </span><br><span class="line">    signalPending        atomic.Uint32                 <span class="comment">// 待执行抢占</span></span><br><span class="line">    </span><br><span class="line">    pcvalueCache         pcvalueCache                  <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    dlogPerM                                           <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    mOS                                                <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    chacha8              chacha8rand.State             <span class="comment">// 随机数种子</span></span><br><span class="line">    cheaprand            <span class="type">uint64</span>                        <span class="comment">// 随机数</span></span><br><span class="line">    </span><br><span class="line">    locksHeldLen         <span class="type">int</span>                           <span class="comment">//</span></span><br><span class="line">    locksHeld            [<span class="number">10</span>]heldLockInfo              <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对齐</span></span><br><span class="line">    _                    [goexperiment.SpinbitMutexInt * <span class="number">700</span> * (<span class="number">2</span> - goarch.PtrSize/<span class="number">4</span>)]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m0，全局变量。与g0不同，m0只有一个</span></span><br><span class="line"><span class="keyword">var</span> m0 m</span><br></pre></td></tr></table></figure>

<p><strong>抢占标志</strong></p>
<p>m结构体有3个字段用于抢占判断，他们的作用和差异如下</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
<th>如何影响抢占</th>
<th>主要用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>lockedInt</code></strong></td>
<td>是否锁定 M</td>
<td><code>lockedInt &gt; 0</code> 时，该 M 不能被调度出去</td>
<td><code>LockOSThread()</code>，用于绑定线程（如 CGo 调用）</td>
</tr>
<tr>
<td><strong><code>locks</code></strong></td>
<td>M 持有的锁计数</td>
<td><code>locks &gt; 0</code> 时，调度器不会抢占 Goroutine</td>
<td>运行时内部锁（GC 期间、关键代码）</td>
</tr>
<tr>
<td><strong><code>preemptoff</code></strong></td>
<td>阻止抢占的标志</td>
<td><code>preemptoff</code> 非空时，M 不能被抢占</td>
<td>调试、特殊场景防止调度</td>
</tr>
</tbody></table>
<h3 id="P-processor"><a href="#P-processor" class="headerlink" title="P - processor"></a>P - processor</h3><p>processor-局部化缓存、元数据等。数量一般与CPU核心数一致，除几个特殊的m，其他m都需要获取绑定一个p才能执行用户代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// macOS下共8952字节</span></span><br><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    id           <span class="type">int32</span>                     <span class="comment">// 数组索引，[0,gomaxprocs-1]</span></span><br><span class="line">    status       <span class="type">uint32</span>                    <span class="comment">// 状态</span></span><br><span class="line">    link         puintptr                  <span class="comment">// next指针</span></span><br><span class="line">    schedtick    <span class="type">uint32</span>                    <span class="comment">// 调度计数器</span></span><br><span class="line">    syscalltick  <span class="type">uint32</span>                    <span class="comment">// syscall计次数</span></span><br><span class="line">    sysmontick   sysmontick                <span class="comment">// sysmon调度次数</span></span><br><span class="line">    m            muintptr                  <span class="comment">// 当前m</span></span><br><span class="line">    mcache       *mcache                   <span class="comment">// mcache内存分配器</span></span><br><span class="line">    pcache       pageCache                 <span class="comment">// 页缓存</span></span><br><span class="line">    raceprocctx  <span class="type">uintptr</span>                   <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    deferpool    []*_defer                 <span class="comment">// defer列表，基于deferpoolbuf的切片</span></span><br><span class="line">    deferpoolbuf [<span class="number">32</span>]*_defer               <span class="comment">// defer列表，固定数组</span></span><br><span class="line">    </span><br><span class="line">    goidcache    <span class="type">uint64</span>                    <span class="comment">// 起始goid</span></span><br><span class="line">    goidcacheend <span class="type">uint64</span>                    <span class="comment">// 结束goid，用完后向sched.goidgen一次性申请16个id</span></span><br><span class="line">    </span><br><span class="line">    runqhead     <span class="type">uint32</span>                    <span class="comment">// 本地队列头部g索引</span></span><br><span class="line">    runqtail     <span class="type">uint32</span>                    <span class="comment">// 本地队列尾部g索引</span></span><br><span class="line">    runq         [<span class="number">256</span>]guintptr             <span class="comment">// 本地队列</span></span><br><span class="line">    runnext      guintptr                  <span class="comment">// 本地队列头部g，优化，可被p偷取</span></span><br><span class="line">    </span><br><span class="line">    gFree        <span class="keyword">struct</span> &#123;                  <span class="comment">// 本地g空闲链表</span></span><br><span class="line">        gList                              <span class="comment">// 链表头</span></span><br><span class="line">        n     <span class="type">int32</span>                        <span class="comment">// 数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sudogcache []*sudog                    <span class="comment">// sudog列表，基于sudogbuf的切片</span></span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog                 <span class="comment">// sudog列表，固定数组</span></span><br><span class="line">    </span><br><span class="line">    mspancache <span class="keyword">struct</span> &#123;                    <span class="comment">// mspan缓存</span></span><br><span class="line">        <span class="built_in">len</span> <span class="type">int</span>                            <span class="comment">// 数量</span></span><br><span class="line">        buf [<span class="number">128</span>]*mspan                    <span class="comment">// 指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pinnerCache           *pinner          <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    trace                 pTraceState      <span class="comment">// trace相关数据</span></span><br><span class="line">    </span><br><span class="line">    palloc                persistentAlloc  <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    gcAssistTime          <span class="type">int64</span>            <span class="comment">//</span></span><br><span class="line">    gcFractionalMarkTime  <span class="type">int64</span>            <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    limiterEvent          limiterEvent     <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    gcMarkWorkerMode      gcMarkWorkerMode <span class="comment">// GC标记工作模式</span></span><br><span class="line">    gcMarkWorkerStartTime <span class="type">int64</span>            <span class="comment">// GC标记开始时刻</span></span><br><span class="line">    </span><br><span class="line">    gcw                   gcWork           <span class="comment">// GC wbuf缓冲区（灰色队列）</span></span><br><span class="line">    </span><br><span class="line">    wbBuf                 wbBuf            <span class="comment">// 写屏障缓冲区</span></span><br><span class="line">    </span><br><span class="line">    runSafePointFn        <span class="type">uint32</span>           <span class="comment">// GC标志是否需要执行safePointFn</span></span><br><span class="line">    </span><br><span class="line">    statsSeq              atomic.Uint32    <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    timers                timers           <span class="comment">// 定时器列表，每次执行调度时判断是否有g超时</span></span><br><span class="line">    </span><br><span class="line">    maxStackScanDelta     <span class="type">int64</span>            <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    scannedStackSize      <span class="type">uint64</span>           <span class="comment">//</span></span><br><span class="line">    scannedStacks         <span class="type">uint64</span>           <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    preempt               <span class="type">bool</span>             <span class="comment">// 是否抢占</span></span><br><span class="line">    </span><br><span class="line">    gcStopTime            <span class="type">int64</span>            <span class="comment">// 停止时刻，检查到STW后纪录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>状态列表</strong></p>
<table>
<thead>
<tr>
<th align="left">status_name</th>
<th align="left">status_value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_Pidle</td>
<td align="left">0</td>
<td align="left">空闲，未运行用户代码，runq为空。默认状态</td>
</tr>
<tr>
<td align="left">_Prunning</td>
<td align="left">1</td>
<td align="left">运行中，P被M绑定，正在运行用户代码</td>
</tr>
<tr>
<td align="left">_Psyscall</td>
<td align="left">2</td>
<td align="left">正在执行系统调用，未运行用户代码，可被其他M偷取，类似_Pidle</td>
</tr>
<tr>
<td align="left">_Pgcstop</td>
<td align="left">3</td>
<td align="left">被M（STW）停止并拥有，当前M挂起。初始状态</td>
</tr>
<tr>
<td align="left">_Pdead</td>
<td align="left">4</td>
<td align="left">不在使用，剥离所有资源（GOMAXPROCS缩容）</td>
</tr>
</tbody></table>
<h3 id="schedt-调度器"><a href="#schedt-调度器" class="headerlink" title="schedt - 调度器"></a>schedt - 调度器</h3><p>schedt-调度器，纪录全局调度资源等，访问需要加锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// macOS下共6824字节</span></span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    goidgen      atomic.Uint64             <span class="comment">// goid全局计数器</span></span><br><span class="line">    lastpoll     atomic.Int64              <span class="comment">// 纪录上一次执行netpoll的时刻，0-正在轮询</span></span><br><span class="line">    pollUntil    atomic.Int64              <span class="comment">// netpoll轮询截止时刻</span></span><br><span class="line">    </span><br><span class="line">    lock         mutex                     <span class="comment">// 锁</span></span><br><span class="line">    </span><br><span class="line">    midle        muintptr                  <span class="comment">// 空闲m链表</span></span><br><span class="line">    nmidle       <span class="type">int32</span>                     <span class="comment">// 空闲m数量</span></span><br><span class="line">    nmidlelocked <span class="type">int32</span>                     <span class="comment">// 空闲的locked的m数量</span></span><br><span class="line">    mnext        <span class="type">int64</span>                     <span class="comment">// 累计m总量/自增id</span></span><br><span class="line">    maxmcount    <span class="type">int32</span>                     <span class="comment">// 最大可用线程数量，默认为10000</span></span><br><span class="line">    nmsys        <span class="type">int32</span>                     <span class="comment">// sys类型m数量</span></span><br><span class="line">    nmfreed      <span class="type">int64</span>                     <span class="comment">// 累计释放m数量</span></span><br><span class="line">    </span><br><span class="line">    ngsys        atomic.Int32              <span class="comment">// 系统G的数量</span></span><br><span class="line">    </span><br><span class="line">    pidle        puintptr                  <span class="comment">// 空闲p链表</span></span><br><span class="line">    npidle       atomic.Int32              <span class="comment">// 空闲p数量</span></span><br><span class="line">    nmspinning   atomic.Int32              <span class="comment">// 自旋的m的数量</span></span><br><span class="line">    needspinning atomic.Uint32             <span class="comment">// 需要某个m自旋放弃p</span></span><br><span class="line">    </span><br><span class="line">    runq         gQueue                    <span class="comment">// 状态为_Grunnable的g</span></span><br><span class="line">    runqsize     <span class="type">int32</span>                     <span class="comment">// 状态为_Grunnable的g数量</span></span><br><span class="line">    </span><br><span class="line">    disable      <span class="keyword">struct</span> &#123;                  <span class="comment">// </span></span><br><span class="line">        user     <span class="type">bool</span>                      <span class="comment">// 是否禁止user类型的g运行</span></span><br><span class="line">        runnable gQueue                    <span class="comment">// user字段为false时，user类型的g都阻塞在这里</span></span><br><span class="line">        n        <span class="type">int32</span>                     <span class="comment">// 总数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    gFree <span class="keyword">struct</span> &#123;                         <span class="comment">// 全局gFree链表</span></span><br><span class="line">        lock    mutex                      <span class="comment">// 锁</span></span><br><span class="line">        stack   gList                      <span class="comment">// 有栈的g</span></span><br><span class="line">        noStack gList                      <span class="comment">// 无栈的g</span></span><br><span class="line">        n       <span class="type">int32</span>                      <span class="comment">// 总数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sudoglock                mutex         <span class="comment">// sudog锁，用于sudogcache</span></span><br><span class="line">    sudogcache               *sudog        <span class="comment">// 全局sudog链表</span></span><br><span class="line">    </span><br><span class="line">    deferlock                mutex         <span class="comment">// 锁，保护deferpool</span></span><br><span class="line">    deferpool                *_defer       <span class="comment">// defer队列</span></span><br><span class="line">    </span><br><span class="line">    freem                    *m            <span class="comment">// free链表</span></span><br><span class="line">    </span><br><span class="line">    gcwaiting                atomic.Bool   <span class="comment">// STW，当前p释放到空闲队列</span></span><br><span class="line">    stopwait                 <span class="type">int32</span>         <span class="comment">// 待_Pgcstop的p数量</span></span><br><span class="line">    stopnote                 note          <span class="comment">// semaphore，存储执行GC的m</span></span><br><span class="line">    sysmonwait               atomic.Bool   <span class="comment">// true-sysmon挂起休眠了</span></span><br><span class="line">    sysmonnote               note          <span class="comment">// semaphore，sysmon挂起在这里</span></span><br><span class="line">    </span><br><span class="line">    safePointFn              <span class="function"><span class="keyword">func</span><span class="params">(*p)</span></span>      <span class="comment">// 到达安全点时执行的函数</span></span><br><span class="line">    safePointWait            <span class="type">int32</span>         <span class="comment">// 同p的数量，检查全部p是否都已执行safePointFn</span></span><br><span class="line">    safePointNote            note          <span class="comment">// semaphore，存储执行GC的m</span></span><br><span class="line">    </span><br><span class="line">    profilehz                <span class="type">int32</span>         <span class="comment">// profiler</span></span><br><span class="line">    </span><br><span class="line">    procresizetime           <span class="type">int64</span>         <span class="comment">// 调整p数量的时刻</span></span><br><span class="line">    totaltime                <span class="type">int64</span>         <span class="comment">// 调整p时，纪录所有核心的运行时长</span></span><br><span class="line">    </span><br><span class="line">    sysmonlock               mutex         <span class="comment">// 锁，用于sysmon</span></span><br><span class="line">    </span><br><span class="line">    timeToRun                timeHistogram <span class="comment">// 累计所有处于_Grunnable状态的g的时长</span></span><br><span class="line">    </span><br><span class="line">    idleTime                 atomic.Int64  <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    totalMutexWaitTime       atomic.Int64  <span class="comment">// 累计所有处于_Gwaiting状态的g的时长</span></span><br><span class="line">    </span><br><span class="line">    stwStoppingTimeGC        timeHistogram <span class="comment">//</span></span><br><span class="line">    stwStoppingTimeOther     timeHistogram <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    stwTotalTimeGC           timeHistogram <span class="comment">//</span></span><br><span class="line">    stwTotalTimeOther        timeHistogram <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    totalRuntimeLockWaitTime atomic.Int64  <span class="comment">// 纪录总等待耗时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="schedinit-调度器初始化"><a href="#schedinit-调度器初始化" class="headerlink" title="schedinit - 调度器初始化"></a>schedinit - 调度器初始化</h2><p>有点长，还是直接看注释吧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器锁初始化</span></span><br><span class="line">    lockInit(&amp;sched.lock, lockRankSched)</span><br><span class="line">    lockInit(&amp;sched.sysmonlock, lockRankSysmon)</span><br><span class="line">    lockInit(&amp;sched.deferlock, lockRankDefer)</span><br><span class="line">    lockInit(&amp;sched.sudoglock, lockRankSudog)</span><br><span class="line">    <span class="comment">// 全局变量锁初始化</span></span><br><span class="line">    lockInit(&amp;deadlock, lockRankDeadlock)</span><br><span class="line">    lockInit(&amp;paniclk, lockRankPanic)</span><br><span class="line">    lockInit(&amp;allglock, lockRankAllg)</span><br><span class="line">    lockInit(&amp;allpLock, lockRankAllp)</span><br><span class="line">    lockInit(&amp;reflectOffs.lock, lockRankReflectOffs)</span><br><span class="line">    lockInit(&amp;finlock, lockRankFin)</span><br><span class="line">    lockInit(&amp;cpuprof.lock, lockRankCpuprof)</span><br><span class="line">    <span class="comment">// allocm函数内使用</span></span><br><span class="line">    allocmLock.init(lockRankAllocmR, lockRankAllocmRInternal, lockRankAllocmW)</span><br><span class="line">    <span class="comment">// 执行系统调用exec、clone时使用</span></span><br><span class="line">    execLock.init(lockRankExecR, lockRankExecRInternal, lockRankExecW)</span><br><span class="line">    <span class="comment">// trace锁初始化</span></span><br><span class="line">    traceLockInit()</span><br><span class="line">    <span class="comment">// memstats锁初始化</span></span><br><span class="line">    lockInit(&amp;memstats.heapStats.noPLock, lockRankLeafRank)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证m数据结构的大小</span></span><br><span class="line">    lockVerifyMSize()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g0（m为m0）</span></span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制能创建的线程数量为10000</span></span><br><span class="line">    sched.maxmcount = <span class="number">10000</span></span><br><span class="line">    <span class="comment">// 文件描述符，用于panic时输出到指定文件</span></span><br><span class="line">    crashFD.Store(^<span class="type">uintptr</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止整个世界，空函数（staticlockranking默认为false）</span></span><br><span class="line">    worldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ticks纪录当前时刻和CPU时钟</span></span><br><span class="line">    ticks.init()</span><br><span class="line">    <span class="comment">// 插件、动态库元数据校验</span></span><br><span class="line">    moduledataverify()</span><br><span class="line">    <span class="comment">// 栈相关，全局stackpool和stackLarge初始化</span></span><br><span class="line">    stackinit()</span><br><span class="line">    <span class="comment">// malloc初始化</span></span><br><span class="line">    mallocinit()</span><br><span class="line">    <span class="comment">// 解析GODEBUG合并到默认值</span></span><br><span class="line">    godebug := getGodebugEarly()</span><br><span class="line">    <span class="comment">// 根据环境变量初始化CPU，要求在alginit前调用</span></span><br><span class="line">    cpuinit(godebug)</span><br><span class="line">    <span class="comment">// 全局随机状态初始化，要求在alginit、mcommoninit前调用</span></span><br><span class="line">    randinit()</span><br><span class="line">    <span class="comment">// 哈希计算相关初始化</span></span><br><span class="line">    alginit()</span><br><span class="line">    <span class="comment">// 到这里就能正常使用maps、hash、rand了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// m通用初始化</span></span><br><span class="line">    mcommoninit(gp.m, <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 插件、动态库初始化，到这里activeModules可用</span></span><br><span class="line">    modulesinit()</span><br><span class="line">    <span class="comment">// 初始化类型信息，用于reflect和GC（依赖activeModules）</span></span><br><span class="line">    typelinksinit()</span><br><span class="line">    <span class="comment">// 接口表初始化，使用activeModules（依赖activeModules）</span></span><br><span class="line">    itabsinit()</span><br><span class="line">    <span class="comment">// 栈对象初始化，要求在GC开启前完成</span></span><br><span class="line">    stkobjinit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前线程信号掩码到m.sigmask（平台相关）</span></span><br><span class="line">    sigsave(&amp;gp.m.sigmask)</span><br><span class="line">    initSigmask = gp.m.sigmask</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制命令行参数</span></span><br><span class="line">    goargs()</span><br><span class="line">    <span class="comment">// 复制环境变量</span></span><br><span class="line">    goenvs()</span><br><span class="line">    <span class="comment">// GOTRACEBACK相关环境变量解析（平台相关）</span></span><br><span class="line">    secure()</span><br><span class="line">    <span class="comment">// 检查stdin、stdout、stderr是否有效（平台相关）</span></span><br><span class="line">    checkfds()</span><br><span class="line">    <span class="comment">// debug、godebug解析设置</span></span><br><span class="line">    parsedebugvars()</span><br><span class="line">    <span class="comment">// GC初始化</span></span><br><span class="line">    gcinit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于崩溃时纪录栈信息</span></span><br><span class="line">    <span class="comment">// 16KB的栈</span></span><br><span class="line">    gcrash.stack = stackalloc(<span class="number">16384</span>)</span><br><span class="line">    <span class="comment">// stackguard0（用于正常函数调用时检查）</span></span><br><span class="line">    gcrash.stackguard0 = gcrash.stack.lo + <span class="number">1000</span></span><br><span class="line">    <span class="comment">// stackguard1（用于调度恢复执行时检查）</span></span><br><span class="line">    gcrash.stackguard1 = gcrash.stack.lo + <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认为false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> disableMemoryProfiling &#123;</span><br><span class="line">        <span class="comment">// 如果禁用heap profiling</span></span><br><span class="line">        <span class="comment">// parsedebugvars会覆盖MemProfileRate值，没关系，以disableMemoryProfiling设置为准</span></span><br><span class="line">        MemProfileRate = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存剖析调用栈初始化</span></span><br><span class="line">    <span class="comment">// mcommoninit在parsedebugvars前运行，需要重新初始化</span></span><br><span class="line">    mProfStackInit(gp.m)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// lastpoll纪录当前时刻</span></span><br><span class="line">    sched.lastpoll.Store(nanotime())</span><br><span class="line">    <span class="comment">// osinit时已纪录到全局变量ncpu</span></span><br><span class="line">    procs := ncpu</span><br><span class="line">    <span class="comment">// 以GOMAXPROCS为准</span></span><br><span class="line">    <span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        procs = n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据数量n扩容/缩容p</span></span><br><span class="line">    <span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 世界开始运行，空函数（staticlockranking默认为false）</span></span><br><span class="line">    worldStarted()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下情况一般不应该发生</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// go的版本号为空</span></span><br><span class="line">    <span class="keyword">if</span> buildVersion == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        buildVersion = <span class="string">&quot;unknown&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(modinfo) == <span class="number">1</span> &#123;</span><br><span class="line">        modinfo = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建g负责运行main函数"><a href="#创建g负责运行main函数" class="headerlink" title="创建g负责运行main函数"></a>创建g负责运行main函数</h2><h3 id="newproc-创建goroutine"><a href="#newproc-创建goroutine" class="headerlink" title="newproc - 创建goroutine"></a>newproc - 创建goroutine</h3><p>调用newproc创建新的g用于运行runtime.main，不会立即执行，而是放入p的本地队列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器将go关键字编译为newproc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(fn *funcval)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    pc := sys.GetCallerPC()</span><br><span class="line">    <span class="comment">// 切换到g0执行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 创建goroutine，此时状态已为_Grunnable或_Gwaiting</span></span><br><span class="line">        newg := newproc1(fn, gp, pc, <span class="literal">false</span>, waitReasonZero)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p</span></span><br><span class="line">        pp := getg().m.p.ptr()</span><br><span class="line">        <span class="comment">// 把g放到本地队列头部</span></span><br><span class="line">        runqput(pp, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// runtime.main已运行</span></span><br><span class="line">        <span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">            <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">            wakep()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, callergp *g, callerpc <span class="type">uintptr</span>, parked <span class="type">bool</span>, waitreason waitReason)</span></span> *g &#123;</span><br><span class="line">    <span class="comment">// 函数不能为nil</span></span><br><span class="line">    <span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m，禁止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// 从本地gFree获取一个g</span></span><br><span class="line">    newg := gfget(pp)</span><br><span class="line">    <span class="comment">// 获取失败</span></span><br><span class="line">    <span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 创建g、分配栈（初始为2KB，GC时更新为平均值）</span></span><br><span class="line">        newg = malg(stackMin)</span><br><span class="line">        <span class="comment">// 从_Gidle状态改为_Gdead，避免Gc扫描</span></span><br><span class="line">        casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">        <span class="comment">// 把g放到allgs切片</span></span><br><span class="line">        allgadd(newg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈检查</span></span><br><span class="line">    <span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;newproc1: newg missing stack&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态检查</span></span><br><span class="line">    <span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">        throw(<span class="string">&quot;newproc1: new g is not Gdead&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// totalSize=4*8+0=32</span></span><br><span class="line">    totalSize := <span class="type">uintptr</span>(<span class="number">4</span>*goarch.PtrSize + sys.MinFrameSize)</span><br><span class="line">    <span class="comment">// 内存对齐，totalSize=32</span></span><br><span class="line">    totalSize = alignUp(totalSize, sys.StackAlign)</span><br><span class="line">    <span class="comment">// sp=stack.hi-32</span></span><br><span class="line">    sp := newg.stack.hi - totalSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// usesLR默认为false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> usesLR &#123;</span><br><span class="line">        <span class="comment">// 调用者LR设为0</span></span><br><span class="line">        *(*<span class="type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 空函数，忽略</span></span><br><span class="line">        prepGoExitFrame(sp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arm64，先忽略</span></span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;arm64&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 调用者FP设为0</span></span><br><span class="line">        *(*<span class="type">uintptr</span>)(unsafe.Pointer(sp - goarch.PtrSize)) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sched重置清零</span></span><br><span class="line">    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 纪录/更新g的相关信息</span></span><br><span class="line"></span><br><span class="line">    newg.sched.sp = sp</span><br><span class="line">    newg.stktopsp = sp</span><br><span class="line">    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum</span><br><span class="line">    newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">    <span class="comment">// 调整fn、寄存器等信息</span></span><br><span class="line">    gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">    newg.parentGoid = callergp.goid</span><br><span class="line">    newg.gopc = callerpc</span><br><span class="line">    <span class="comment">// 为nil（tracebackancestors默认为0）</span></span><br><span class="line">    newg.ancestors = saveAncestors(callergp)</span><br><span class="line">    newg.startpc = fn.fn</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断g是否是sys类型，一般runtime.*的都是，除了少部分如runtime.main等</span></span><br><span class="line">    <span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// sys类型</span></span><br><span class="line">        <span class="comment">// 计数器+=1</span></span><br><span class="line">        sched.ngsys.Add(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// user类型</span></span><br><span class="line">        <span class="comment">// 测试相关，忽略</span></span><br><span class="line">        newg.syncGroup = callergp.syncGroup</span><br><span class="line">        <span class="comment">// g</span></span><br><span class="line">        <span class="keyword">if</span> mp.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">            newg.labels = mp.curg.labels</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PProf已启动</span></span><br><span class="line">        <span class="keyword">if</span> goroutineProfile.active &#123;</span><br><span class="line">            <span class="comment">// goroutineProfiled=2</span></span><br><span class="line">            newg.goroutineProfiled.Store(goroutineProfileSatisfied)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断g是否要进行跟踪统计</span></span><br><span class="line">    <span class="comment">// trackingSeq=随机数</span></span><br><span class="line">    newg.trackingSeq = <span class="type">uint8</span>(cheaprand())</span><br><span class="line">    <span class="comment">// trackingSeq%8 == 0（1/8的概率？）</span></span><br><span class="line">    <span class="keyword">if</span> newg.trackingSeq%gTrackingPeriod == <span class="number">0</span> &#123;</span><br><span class="line">        newg.tracking = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计到maxStackScan，有p的话，先暂存到p</span></span><br><span class="line">    gcController.addScannableStack(pp, <span class="type">int64</span>(newg.stack.hi-newg.stack.lo))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认_Grunnable，如果parked为true，则_Gwaiting</span></span><br><span class="line">    <span class="keyword">var</span> status <span class="type">uint32</span> = _Grunnable</span><br><span class="line">    <span class="keyword">if</span> parked &#123;</span><br><span class="line">        status = _Gwaiting</span><br><span class="line">        <span class="comment">// _Gwaiting时reason不能为空</span></span><br><span class="line">        newg.waitreason = waitreason</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// goid，每个p一次性从sched申请16个</span></span><br><span class="line">    <span class="keyword">if</span> pp.goidcache == pp.goidcacheend &#123;</span><br><span class="line">        <span class="comment">// 调度器goidgen+=16。如果goidgen为0，则goidcache=16</span></span><br><span class="line">        pp.goidcache = sched.goidgen.Add(_GoidCacheBatch)</span><br><span class="line">        <span class="comment">// 如果此时goidcache为16，操作后值为1</span></span><br><span class="line">        pp.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">        <span class="comment">// 结束goid</span></span><br><span class="line">        pp.goidcacheend = pp.goidcache + _GoidCacheBatch</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// goid</span></span><br><span class="line">    newg.goid = pp.goidcache</span><br><span class="line">    <span class="comment">// 从_Gdead状态改为_Grunnable或_Gwaiting</span></span><br><span class="line">    casgstatus(newg, _Gdead, status)</span><br><span class="line">    <span class="comment">// 当前p的起始goid向后挪动一位（被消耗一位）</span></span><br><span class="line">    pp.goidcache++</span><br><span class="line">    <span class="comment">// trace相关纪录数据等清空</span></span><br><span class="line">    newg.trace.reset()</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建g、分配栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">malg</span><span class="params">(stacksize <span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">    newg := <span class="built_in">new</span>(g)</span><br><span class="line">    <span class="keyword">if</span> stacksize &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// =round2(0+stacksize)</span></span><br><span class="line">        stacksize = round2(stackSystem + stacksize)</span><br><span class="line">        <span class="comment">// 创建栈</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 创建栈，暂不讨论</span></span><br><span class="line">            newg.stack = stackalloc(<span class="type">uint32</span>(stacksize))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// stackguard0（用于正常函数调用时检查）=stack.lo+928 （Ps. 2KB瞬间少了一半）</span></span><br><span class="line">        newg.stackguard0 = newg.stack.lo + stackGuard</span><br><span class="line">        <span class="comment">// stackguard1（用于调度恢复执行时检查）= ^uintptr(0)</span></span><br><span class="line">        newg.stackguard1 = ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// lo指向的位置设置为0</span></span><br><span class="line">        *(*<span class="type">uintptr</span>)(unsafe.Pointer(newg.stack.lo)) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runtime-main-程序入口"><a href="#runtime-main-程序入口" class="headerlink" title="runtime.main - 程序入口"></a>runtime.main - 程序入口</h3><p>main函数有两个，一个是跟底层运行时相关的runtime.main，另一个是用户编写的main.main。runtime.main内部负责运行时相关初始化，如执行所有包的init函数、开启GC、cgo初始化等，最后调用main.main</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当前g绑定的m</span></span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冲突检测相关，忽略</span></span><br><span class="line">    mp.g0.racectx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64位系统，栈最大为1GB</span></span><br><span class="line">    <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">        maxstacksize = <span class="number">1000000000</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maxstacksize = <span class="number">250000000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2GB</span></span><br><span class="line">    maxstackceiling = <span class="number">2</span> * maxstacksize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局变量，用以标志允许newproc创建运行M</span></span><br><span class="line">    mainStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了wasm，其他平台默认开启sysmon</span></span><br><span class="line">    <span class="keyword">if</span> haveSysmon &#123;</span><br><span class="line">        <span class="comment">// 汇编，切换到g0运行</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 清理freem链表，创建并初始化m，locked或cgo类型的m由模板线程延迟创建，其他类型则立即调用平台相关函数创建线程</span></span><br><span class="line">            <span class="comment">// sysmon负责轮询netpoll、抢占超时的g、回收阻塞在syscall的p</span></span><br><span class="line">            newm(sysmon, <span class="literal">nil</span>, <span class="number">-1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向绑定，防抢占</span></span><br><span class="line">    <span class="comment">// 当前g、m纪录到m.lockedg、g.lockedm字段</span></span><br><span class="line">    lockOSThread()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望当前m就是m0</span></span><br><span class="line">    <span class="keyword">if</span> mp != &amp;m0 &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime.main not on m0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻-单调时钟</span></span><br><span class="line">    runtimeInitTime = nanotime()</span><br><span class="line">    <span class="keyword">if</span> runtimeInitTime == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;nanotime returning zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启trace</span></span><br><span class="line">    <span class="keyword">if</span> debug.inittrace != <span class="number">0</span> &#123;</span><br><span class="line">        inittrace.id = getg().goid</span><br><span class="line">        inittrace.active = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行runtime相关的init函数，必须放在defer之前</span></span><br><span class="line">    doInit(runtime_inittasks)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面会设置为false，如果期间有任何panic，defer内unlock</span></span><br><span class="line">    needUnlock := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> needUnlock &#123;</span><br><span class="line">            <span class="comment">// 重置m.lockedg、g.lockedm字段</span></span><br><span class="line">            unlockOSThread()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行sweeper、scavenger（GC）</span></span><br><span class="line">    gcenable()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cgo使用，判断main是否完成相关初始化操作</span></span><br><span class="line">    main_init_done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cgo初始化</span></span><br><span class="line">    <span class="keyword">if</span> iscgo &#123;</span><br><span class="line">        <span class="keyword">if</span> _cgo_pthread_key_created == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;_cgo_pthread_key_created missing&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;_cgo_thread_start missing&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> GOOS != <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> _cgo_setenv == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;_cgo_setenv missing&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> _cgo_unsetenv == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;_cgo_unsetenv missing&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _cgo_notify_runtime_init_done == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;_cgo_notify_runtime_init_done missing&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> set_crosscall2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;set_crosscall2 missing&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        set_crosscall2()</span><br><span class="line"></span><br><span class="line">        startTemplateThread()</span><br><span class="line">        cgocall(_cgo_notify_runtime_init_done, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行模块相关的init函数</span></span><br><span class="line">    <span class="keyword">for</span> m := &amp;firstmoduledata; m != <span class="literal">nil</span>; m = m.next &#123;</span><br><span class="line">        doInit(m.inittasks)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭trace</span></span><br><span class="line">    inittrace.active = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cgo完成初始化</span></span><br><span class="line">    <span class="built_in">close</span>(main_init_done)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里没有panic，就不需要用defer来unlock了</span></span><br><span class="line">    needUnlock = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 重置m.lockedg、g.lockedm字段</span></span><br><span class="line">    unlockOSThread()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有main函数但不需要执行</span></span><br><span class="line">    <span class="comment">// 动态库（c-archive/c-shared）</span></span><br><span class="line">    <span class="keyword">if</span> isarchive || islibrary &#123;</span><br><span class="line">        <span class="comment">// wasm只有一个M</span></span><br><span class="line">        <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里阻塞，不应该返回</span></span><br><span class="line">            pause(sys.GetCallerSP() - <span class="number">16</span>)</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main.main函数，需要linker在运行时确定地址</span></span><br><span class="line">    fn := main_main</span><br><span class="line">    <span class="comment">// 执行main.main函数</span></span><br><span class="line">    fn()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有G发生panic，打印trace然后退出</span></span><br><span class="line">    <span class="comment">// runningPanicDefers会在panic+1，recovery时-1</span></span><br><span class="line">    <span class="keyword">if</span> runningPanicDefers.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 防止运行时间过长</span></span><br><span class="line">        <span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line">            <span class="keyword">if</span> runningPanicDefers.Load() == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同协程yield关键字，当前g让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">            Gosched()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遇到无法recover的panic时，panicking不为0</span></span><br><span class="line">    <span class="keyword">if</span> panicking.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 当前g让出CPU，g0执行调度运行其他g</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonPanicWait, traceBlockForever, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// panic了，运行hooks</span></span><br><span class="line">    runExitHooks(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编代码runtime·exit</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x *<span class="type">int32</span></span><br><span class="line">        *x = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime·mstart-运行调度函数"><a href="#runtime·mstart-运行调度函数" class="headerlink" title="runtime·mstart - 运行调度函数"></a>runtime·mstart - 运行调度函数</h2><p>runtime·mstart为汇编函数，函数内调用runtime·mstart0</p>
<h3 id="mstart0"><a href="#mstart0" class="headerlink" title="mstart0"></a>mstart0</h3><p>mstart0主要进行栈初始化、信号注册等，最后运行调度函数schedule</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// g0分配栈，m0进行信号处理初始化、执行mstartfn，寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart0</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否未分配，可能是由操作系统直接分配的栈</span></span><br><span class="line">    osStack := gp.stack.lo == <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> osStack &#123;</span><br><span class="line">        size := gp.stack.hi</span><br><span class="line">        <span class="comment">// 如果没有栈，设置大小为16KB</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 16384*1 =&gt; 16KB</span></span><br><span class="line">            size = <span class="number">16384</span> * sys.StackGuardMultiplier</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈顶</span></span><br><span class="line">        gp.stack.hi = <span class="type">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">        <span class="comment">// 栈底（预留1KB？）</span></span><br><span class="line">        gp.stack.lo = gp.stack.hi - size + <span class="number">1024</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// stackguard0（用于正常函数调用时检查）=stack.lo+928</span></span><br><span class="line">    gp.stackguard0 = gp.stack.lo + stackGuard</span><br><span class="line">    <span class="comment">// stackguard1（用于调度恢复执行时检查）=stack.lo+928</span></span><br><span class="line">    gp.stackguard1 = gp.stackguard0</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号处理初始化、执行mstartfn，寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    mstart1()</span><br><span class="line">    <span class="comment">// 这里执行后不会返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果栈由系统分配（linux为false，由go分配）</span></span><br><span class="line">    <span class="keyword">if</span> mStackIsSystemAllocated() &#123;</span><br><span class="line">        osStack = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m线程退出</span></span><br><span class="line">    mexit(osStack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理初始化、执行mstartfn，寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望当前g是g0</span></span><br><span class="line">    <span class="keyword">if</span> gp != gp.m.g0 &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad runtime·mstart&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寄存器相关</span></span><br><span class="line">    gp.sched.g = guintptr(unsafe.Pointer(gp))</span><br><span class="line">    gp.sched.pc = sys.GetCallerPC()</span><br><span class="line">    gp.sched.sp = sys.GetCallerSP()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编代码，amd64为空函数</span></span><br><span class="line">    asminit()</span><br><span class="line">    <span class="comment">// 信号处理初始化（平台相关）、纪录procid</span></span><br><span class="line">    minit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是m0</span></span><br><span class="line">    <span class="keyword">if</span> gp.m == &amp;m0 &#123;</span><br><span class="line">        <span class="comment">// 信号处理初始化（平台相关），如果是cgo，生成一定数量的extraM，</span></span><br><span class="line">        mstartm0()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dataindependenttiming默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debug.dataindependenttiming == <span class="number">1</span> &#123;</span><br><span class="line">        sys.EnableDIT()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fn := gp.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 执行mstartfn</span></span><br><span class="line">		<span class="comment">// 主要有sysmon/templateThread/用户自定义这几类函数</span></span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非m0（从代码看，只有m0才会运行该函数才对）</span></span><br><span class="line">    <span class="keyword">if</span> gp.m != &amp;m0 &#123;</span><br><span class="line">        <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">        acquirep(gp.m.nextp.ptr())</span><br><span class="line">        <span class="comment">// 重置nextp</span></span><br><span class="line">        gp.m.nextp = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="schedule-调度函数"><a href="#schedule-调度函数" class="headerlink" title="schedule - 调度函数"></a>schedule - 调度函数</h3><ol>
<li>寻找g<ol>
<li>如果lockedg有数据<ul>
<li>让出p并挂起休眠，直到lockedg状态变为可运行，被唤醒后绑定一个p返回</li>
<li>lockedg调整状态等数据，和m双向绑定，最后切换到lockedg的上下文执行（该函数永不返回）</li>
</ul>
</li>
<li>执行findRunnable寻找可运行的g</li>
<li>GC开始到标记结束这个过程只允许sys类型的g运行<ul>
<li>如果检查是user类型的g，回到开头重新findRunnable寻找</li>
</ul>
</li>
</ol>
</li>
<li>p获取、与m绑定<ol>
<li>如果当前m自旋中<ul>
<li>重置m.spinning，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</li>
</ul>
</li>
<li>如果g是GCworker或tracereader<ul>
<li>从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</li>
</ul>
</li>
<li>如果g.lockedm有数据<ul>
<li>m让出p给lockedm并唤醒，把当前m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</li>
<li>回到开头重新findRunnable寻找</li>
</ul>
</li>
</ol>
</li>
<li>g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m已加锁</span></span><br><span class="line">    <span class="keyword">if</span> mp.locks != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;schedule: holding locks&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.lockedg有数据</span></span><br><span class="line">    <span class="keyword">if</span> mp.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// m让出p并挂起休眠，直到lockedg状态变为可运行，被唤醒后绑定一个p返回</span></span><br><span class="line">        stoplockedm()</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lockedg调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line">        execute(mp.lockedg.ptr(), <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cgo</span></span><br><span class="line">    <span class="keyword">if</span> mp.incgo &#123;</span><br><span class="line">        throw(<span class="string">&quot;schedule: in cgo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// 非抢占</span></span><br><span class="line">    pp.preempt = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋中（runq应该为空） and (runnext有数据（这是访问优化） or runq不为空)</span></span><br><span class="line">    <span class="comment">// 需要在checkTimers之前判断，因为其会把g放到runq</span></span><br><span class="line">    <span class="keyword">if</span> mp.spinning &amp;&amp; (pp.runnext != <span class="number">0</span> || pp.runqhead != pp.runqtail) &#123;</span><br><span class="line">        throw(<span class="string">&quot;schedule: spinning with local work&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找可运行的g</span></span><br><span class="line">    gp, inheritTime, tryWakeP := findRunnable()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dontfreezetheworld默认为0。debug时为1，此时若panic则不会打断所有g运行</span></span><br><span class="line">    <span class="keyword">if</span> debug.dontfreezetheworld &gt; <span class="number">0</span> &amp;&amp; freezing.Load() &#123;</span><br><span class="line">        lock(&amp;deadlock)</span><br><span class="line">        lock(&amp;deadlock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m自旋中（runq应该为空）</span></span><br><span class="line">    <span class="keyword">if</span> mp.spinning &#123;</span><br><span class="line">        <span class="comment">// 重置m.spinning，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        resetspinning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC时只有sys类型的g允许运行</span></span><br><span class="line">    <span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="comment">// GC开始到标记结束这个过程只允许sys类型的g运行</span></span><br><span class="line">        <span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// GC运行中</span></span><br><span class="line">            <span class="comment">// 放进disable.runnable队列</span></span><br><span class="line">            sched.disable.runnable.pushBack(gp)</span><br><span class="line">            <span class="comment">// 计数器+1</span></span><br><span class="line">            sched.disable.n++</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有在g是GCworker或tracereader时才为true</span></span><br><span class="line">    <span class="keyword">if</span> tryWakeP &#123;</span><br><span class="line">        <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        wakep()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g.lockedm有数据</span></span><br><span class="line">    <span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 让出p给lockedm并唤醒，把当前m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">        startlockedm(gp)</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pprof相关</span></span><br><span class="line">    <span class="keyword">if</span> goroutineProfile.active &#123;</span><br><span class="line">		<span class="comment">// 记录Goroutine运行的采样数据</span></span><br><span class="line">        tryRecordGoroutineProfile(gp, <span class="literal">nil</span>, osyield)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m双向绑定</span></span><br><span class="line">    mp.curg = gp</span><br><span class="line">    gp.m = mp</span><br><span class="line">    <span class="comment">// 从_Grunnable状态改为_Grunning</span></span><br><span class="line">    casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">    <span class="comment">// 重置waitsince</span></span><br><span class="line">    gp.waitsince = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 非抢占</span></span><br><span class="line">    gp.preempt = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// stack.lo+928</span></span><br><span class="line">    gp.stackguard0 = gp.stack.lo + stackGuard</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否继承当前时间切片</span></span><br><span class="line">    <span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line">        <span class="comment">// 不继承，schedtick+=1</span></span><br><span class="line">        mp.p.ptr().schedtick++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m相关</span></span><br><span class="line">    hz := sched.profilehz</span><br><span class="line">    <span class="keyword">if</span> mp.profilehz != hz &#123;</span><br><span class="line">        <span class="comment">// 平台相关</span></span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">        setThreadCPUProfiler(hz)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，从 gp.sched 加载调度上下文，并执行</span></span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="findRunnable-寻找可运行的g"><a href="#findRunnable-寻找可运行的g" class="headerlink" title="findRunnable - 寻找可运行的g"></a>findRunnable - 寻找可运行的g</h3><p>逻辑比较复杂，大概如下</p>
<ol>
<li>如果遇到GC启动-STW，m释放p挂起休眠，被唤醒后重试</li>
<li>读取本地队列前尝试其他数据源<ol>
<li>在GC标志停止阶段，执行安全点函数<ul>
<li>如果所有的p都执行了安全点函数，则唤醒GC线程</li>
</ul>
</li>
<li>定时器p.timers检查<ul>
<li>清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行</li>
</ul>
</li>
<li>如果trace reader有g，返回该g</li>
<li>如果GC正在运行，从gcBgMarkWorkerPool获取一个g（dedicated&#x2F;fractional类型），符合条件则返回</li>
<li>每执行61次schedtick-调度，从全局队列获取一个g返回</li>
<li>符合条件则运行finalizer、cgo，不讨论</li>
</ol>
</li>
<li>本地队列不为空时，从本地队列拿一个g返回</li>
<li>全局队列不为空时，则拿走1&#x2F;gomaxprocs数量的g，返回第一个g</li>
<li>本地队列、全局队列都没有数据<ol>
<li>符合条件则执行netpoll轮询（非阻塞），把过期的g放入本地&#x2F;全局队列，返回第一个g</li>
<li>m自旋从其他p偷取g，成功返回第一个g，失败则回到开头重试</li>
<li>如果GC正在运行，从gcBgMarkWorkerPool获取一个g（idle类型），符合条件则返回</li>
<li>wasm相关，不讨论</li>
</ol>
</li>
<li>偷也没偷到，实在没事做，把p放回空闲队列，调度器加锁，double-check<ol>
<li>STW或GC标记停止阶段，返回开头重试</li>
<li>全局队列不为空，拿走1&#x2F;gomaxprocs数量的g，返回第一个g</li>
<li>检查到调度器通知一个m进入自旋，当前m选择自旋，返回开头重试</li>
<li>取消p与m的绑定，把p放回空闲队列<ul>
<li>如果m在自旋，取消自旋<ul>
<li>再次检查全局队列，如果全局队列不为空，拿走1&#x2F;gomaxprocs数量的g，返回第一个g</li>
<li>从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</li>
<li>尝试从空闲链表拿走一个p，成功则绑定m和p，返回开头重试</li>
<li>如果GC已启动且有空闲的标记g，获取p和g，绑定m和p，返回g</li>
</ul>
</li>
<li>符合条件则执行netpoll轮询（阻塞）<ul>
<li>从空闲链表拿一个p，把过期的g放入本地&#x2F;全局队列，有p则返回第一个g，无则回到开头重试</li>
</ul>
</li>
<li>如果netpoll已经被轮询，检查到有更早的过期时刻，则中断轮询</li>
</ul>
</li>
<li>把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回开头重试</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRunnable</span><span class="params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="type">bool</span>) &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// STW，当前p释放到空闲队列</span></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting.Load() &#123;</span><br><span class="line">        <span class="comment">// 更新p、调度器状态，把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">        gcstopm()</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC标记停止阶段需要执行safePointFn</span></span><br><span class="line">    <span class="keyword">if</span> pp.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 执行safePointFn，如果是最后一个p，则唤醒safePointNote</span></span><br><span class="line">        runSafePointFn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器p.timers检查</span></span><br><span class="line">    <span class="comment">// 清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行</span></span><br><span class="line">    now, pollUntil, _ := pp.timers.check(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trace相关</span></span><br><span class="line">    <span class="keyword">if</span> traceEnabled() || traceShuttingDown() &#123;</span><br><span class="line">        gp := traceReader()</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            trace := traceAcquire()</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">if</span> trace.ok() &#123;</span><br><span class="line">                trace.GoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">                traceRelease(trace)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 从gcBgMarkWorkerPool获取一个g，符合条件则返回</span></span><br><span class="line">        gp, tnow := gcController.findRunnableGCWorker(pp, now)</span><br><span class="line">        <span class="comment">// 拿到了</span></span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没拿到</span></span><br><span class="line">        now = tnow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从全局队列拿g</span></span><br><span class="line">    <span class="comment">// 每61个schedtick and 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> pp.schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 从全局队列获取一批p放到本地队列，返回第一个g</span></span><br><span class="line">        gp := globrunqget(pp, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 拿到了</span></span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没拿到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finalizer</span></span><br><span class="line">    <span class="keyword">if</span> fingStatus.Load()&amp;(fingWait|fingWake) == fingWait|fingWake &#123;</span><br><span class="line">        <span class="comment">// 尝试从fing拿走g</span></span><br><span class="line">        <span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 将g放到p.runq队列头部，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">            ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cgo，忽略</span></span><br><span class="line">    <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 汇编，执行cgo调用</span></span><br><span class="line">        asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地队列拿一个G</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，本地队列为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 从全局队列获取一批p放到本地队列，返回第一个g</span></span><br><span class="line">        gp := globrunqget(pp, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 拿到了</span></span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没拿到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，全局队列为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// netpoll相关</span></span><br><span class="line">    <span class="comment">// netpoll已初始化 and 挂起的g数量不为0 and 当前没有进行netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; netpollAnyWaiters() &amp;&amp; sched.lastpoll.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 平台相关</span></span><br><span class="line">        <span class="comment">// 执行epollWait检查，0-没有数据立即返回</span></span><br><span class="line">        <span class="keyword">if</span> list, delta := netpoll(<span class="number">0</span>); !list.empty() &#123;</span><br><span class="line">            <span class="comment">// G列表里拿一个</span></span><br><span class="line">            gp := list.pop()</span><br><span class="line">            <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">            netpollAdjustWaiters(delta)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，netpoll也没有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 满足条件的话，m自旋然后从其他p偷取g</span></span><br><span class="line">    <span class="comment">// m自旋中 or 双倍自旋m的数量没有超过忙碌中的p数量</span></span><br><span class="line">    <span class="keyword">if</span> mp.spinning || <span class="number">2</span>*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load() &#123;</span><br><span class="line">        <span class="comment">// m未自旋</span></span><br><span class="line">        <span class="keyword">if</span> !mp.spinning &#123;</span><br><span class="line">            <span class="comment">// 状态、计数器更新</span></span><br><span class="line">            <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">            mp.becomeSpinning()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从所有其他p偷取g</span></span><br><span class="line">        gp, inheritTime, tnow, w, newWork := stealWork(now)</span><br><span class="line">        <span class="comment">// 偷取成功</span></span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 偷取失败</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可能有新的timer或GC需要运行</span></span><br><span class="line">        <span class="keyword">if</span> newWork &#123;</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前时刻</span></span><br><span class="line">        now = tnow</span><br><span class="line">        <span class="comment">// w也是pollUntil</span></span><br><span class="line">        <span class="comment">// pollUntil = min(pollUntil, w)</span></span><br><span class="line">        <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">            pollUntil = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，没有找到G，没事做</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动 and 还有标记任务可以执行 and idleMarkWorkers计数器加1成功</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(pp) &amp;&amp; gcController.addIdleMarkWorker() &#123;</span><br><span class="line">        <span class="comment">// 从gcBgMarkWorkerPool获取一个g</span></span><br><span class="line">        node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">		<span class="comment">// 有数据</span></span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// gcMarkWorkerMode=3</span></span><br><span class="line">            pp.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">            <span class="comment">// g</span></span><br><span class="line">            gp := node.gp.ptr()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 恢复状态，idleMarkWorkers计数器减1</span></span><br><span class="line">        gcController.removeIdleMarkWorker()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// beforeIdle只在wasm有返回数据</span></span><br><span class="line">    gp, otherReady := beforeIdle(now, pollUntil)</span><br><span class="line">    <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> otherReady &#123;</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，真的没任何事情做，把P放到idle</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取快照allp、idlepMask、timerpMask</span></span><br><span class="line">    allpSnapshot := allp <span class="comment">// 所有p</span></span><br><span class="line">    idlepMaskSnapshot := idlepMask <span class="comment">// 标记哪些P是空闲的</span></span><br><span class="line">    timerpMaskSnapshot := timerpMask <span class="comment">// 标记哪些P有timer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 以下有一部分是加锁后的double-check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// STW，当前p释放到空闲队列 or GC标记停止阶段需要执行safePointFn</span></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting.Load() || pp.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 从全局队列获取一批p放到本地队列，返回第一个g</span></span><br><span class="line">        gp := globrunqget(pp, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m未自旋 and 调度器通知让其中一个m让出p</span></span><br><span class="line">    <span class="keyword">if</span> !mp.spinning &amp;&amp; sched.needspinning.Load() == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 状态、计数器更新</span></span><br><span class="line">        <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">        mp.becomeSpinning()</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">    <span class="keyword">if</span> releasep() != pp &#123;</span><br><span class="line">        throw(<span class="string">&quot;findrunnable: wrong p&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把p放进空闲链表</span></span><br><span class="line">    now = pidleput(pp, now)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录，用于恢复状态</span></span><br><span class="line">    wasSpinning := mp.spinning</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m自旋中</span></span><br><span class="line">    <span class="keyword">if</span> mp.spinning &#123;</span><br><span class="line">        <span class="comment">// 重置spinning</span></span><br><span class="line">        mp.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 复原，nmspinning-=1</span></span><br><span class="line">        <span class="keyword">if</span> sched.nmspinning.Add(<span class="number">-1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 小于0，异常</span></span><br><span class="line">            throw(<span class="string">&quot;findrunnable: negative nmspinning&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 全局队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">            pp, _ := pidlegetSpinning(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 拿到p！</span></span><br><span class="line">            <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 从全局队列获取一批p放到本地队列，返回第一个g</span></span><br><span class="line">                gp := globrunqget(pp, <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 状态异常</span></span><br><span class="line">                <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;global runq empty with non-zero runqsize&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">                acquirep(pp)</span><br><span class="line">                <span class="comment">// 状态、计数器更新</span></span><br><span class="line">                <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">                mp.becomeSpinning()</span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局队列为空 or 没有拿到p</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要有一个p是忙碌的，从剩余空闲p中拿走一个（可能拿不到）</span></span><br><span class="line">        pp := checkRunqsNoP(allpSnapshot, idlepMaskSnapshot)</span><br><span class="line">        <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">            acquirep(pp)</span><br><span class="line">            <span class="comment">// 状态、计数器更新</span></span><br><span class="line">            <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">            mp.becomeSpinning()</span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果GC已启动且有空闲的标记g，获取p和g</span></span><br><span class="line">        pp, gp := checkIdleGCNoP()</span><br><span class="line">        <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">            acquirep(pp)</span><br><span class="line">            <span class="comment">// 状态、计数器更新</span></span><br><span class="line">            <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">            mp.becomeSpinning()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// gcMarkWorkerMode=3</span></span><br><span class="line">            pp.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后</span></span><br><span class="line">        <span class="comment">// 找到所有p中的最小pollUntil</span></span><br><span class="line">        pollUntil = checkTimersNoP(allpSnapshot, timerpMaskSnapshot, pollUntil)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// netpoll相关</span></span><br><span class="line">    <span class="comment">// netpoll已初始化 and (挂起的g数量不为0 or 过期时刻不为0) and 当前没有执行netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; (netpollAnyWaiters() || pollUntil != <span class="number">0</span>) &amp;&amp; sched.lastpoll.Swap(<span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 纪录pollUntil</span></span><br><span class="line">        sched.pollUntil.Store(pollUntil)</span><br><span class="line">        <span class="comment">// netpoll不能有p</span></span><br><span class="line">        <span class="keyword">if</span> mp.p != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;findrunnable: netpoll with p&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自旋在上面已经判断过了</span></span><br><span class="line">        <span class="keyword">if</span> mp.spinning &#123;</span><br><span class="line">            throw(<span class="string">&quot;findrunnable: netpoll with spinning&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞时长</span></span><br><span class="line">        <span class="comment">// -1为永久阻塞</span></span><br><span class="line">        delay := <span class="type">int64</span>(<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// 过期时刻不为0</span></span><br><span class="line">        <span class="keyword">if</span> pollUntil != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 当前时刻</span></span><br><span class="line">            <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">                now = nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 过期时刻到当前时刻的时长/时差</span></span><br><span class="line">            delay = pollUntil - now</span><br><span class="line">            <span class="comment">// 已过期</span></span><br><span class="line">            <span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 0为非阻塞</span></span><br><span class="line">                delay = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// faketime，忽略</span></span><br><span class="line">        <span class="keyword">if</span> faketime != <span class="number">0</span> &#123;</span><br><span class="line">            delay = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// netpoll轮询，根据delay判断是否要阻塞，获得G列表及数量</span></span><br><span class="line">        list, delta := netpoll(delay)</span><br><span class="line">        <span class="comment">// 重新读取当前时刻</span></span><br><span class="line">        now = nanotime()</span><br><span class="line">        <span class="comment">// 已经从netpoll回来，pollUntil重置为0</span></span><br><span class="line">        sched.pollUntil.Store(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 纪录上一次执行netpoll的时刻</span></span><br><span class="line">        sched.lastpoll.Store(now)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// faketime，忽略</span></span><br><span class="line">        <span class="keyword">if</span> faketime != <span class="number">0</span> &amp;&amp; list.empty() &#123;</span><br><span class="line">            stopm()</span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 从空闲链表拿一个p</span></span><br><span class="line">        pp, _ := pidleget(now)</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 没拿到p</span></span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">            netpollAdjustWaiters(delta)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">            acquirep(pp)</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            <span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">                <span class="comment">// G列表里拿一个</span></span><br><span class="line">                gp := list.pop()</span><br><span class="line">                <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">                injectglist(&amp;list)</span><br><span class="line">                <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">                netpollAdjustWaiters(delta)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">                casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 先前为自旋状态</span></span><br><span class="line">            <span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">                <span class="comment">// 状态、计数器更新</span></span><br><span class="line">                <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">                mp.becomeSpinning()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> pollUntil != <span class="number">0</span> &amp;&amp; netpollinited() &#123; <span class="comment">// 说明正在执行netpoll轮询</span></span><br><span class="line">        pollerPollUntil := sched.pollUntil.Load()</span><br><span class="line">        <span class="comment">// 轮询完毕 or 有更早过期的事件</span></span><br><span class="line">        <span class="keyword">if</span> pollerPollUntil == <span class="number">0</span> || pollerPollUntil &gt; pollUntil &#123;</span><br><span class="line">            <span class="comment">// 中断netpoll轮询</span></span><br><span class="line">            netpollBreak()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">    stopm()</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试</span></span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里基本结束，下面是一些依赖的函数</p>
<h2 id="相关依赖函数"><a href="#相关依赖函数" class="headerlink" title="相关依赖函数"></a>相关依赖函数</h2><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>newproc、malg，不在重复</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p _panic</span><br><span class="line">    p.goexit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行defer</span></span><br><span class="line">    p.start(sys.GetCallerPC(), unsafe.Pointer(sys.GetCallerSP()))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fn, ok := p.nextDefer()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    goexit1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放回本地gFree，重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行goexit0函数</span></span><br><span class="line">    <span class="comment">// 将g放回本地gFree，重新寻找并运行可运行的g（永不返回）</span></span><br><span class="line">    mcall(goexit0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放回本地gFree，重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// g重置状态、取消与m的双向绑定后放到本地gFree，如果有locked的m，则切换到g0调度执行</span></span><br><span class="line">    gdestroy(gp)</span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g重置状态、取消与m的双向绑定后放到本地gFree，如果有locked的m，则切换到g0调度执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gdestroy</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// m</span></span><br><span class="line">    mp := getg().m</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Gdead</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计到maxStackScan，有p的话，先暂存到p</span></span><br><span class="line">    gcController.addScannableStack(pp, -<span class="type">int64</span>(gp.stack.hi-gp.stack.lo))</span><br><span class="line">    <span class="comment">// 判断g是否是sys类型，一般runtime.*的都是，除了少部分如runtime.main等</span></span><br><span class="line">    <span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// ngsys-=1</span></span><br><span class="line">        sched.ngsys.Add(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// g取消m绑定</span></span><br><span class="line">    gp.m = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 是否有lockedm</span></span><br><span class="line">    locked := gp.lockedm != <span class="number">0</span></span><br><span class="line">    <span class="comment">// locked字段重置</span></span><br><span class="line">    gp.lockedm = <span class="number">0</span></span><br><span class="line">    mp.lockedg = <span class="number">0</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    gp.preemptStop = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    gp.paniconfault = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    gp._defer = <span class="literal">nil</span></span><br><span class="line">    gp._panic = <span class="literal">nil</span></span><br><span class="line">    gp.writebuf = <span class="literal">nil</span></span><br><span class="line">    gp.waitreason = waitReasonZero</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    gp.labels = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 定时器</span></span><br><span class="line">    gp.timer = <span class="literal">nil</span></span><br><span class="line">    gp.syncGroup = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动 and </span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        assistWorkPerByte := gcController.assistWorkPerByte.Load()</span><br><span class="line">        scanCredit := <span class="type">int64</span>(assistWorkPerByte * <span class="type">float64</span>(gp.gcAssistBytes))</span><br><span class="line">        gcController.bgScanCredit.Add(scanCredit)</span><br><span class="line">        gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wasm</span></span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 把g放到本地gFree</span></span><br><span class="line">        gfput(pp, gp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有locked的m and lockedInt计数器不为0</span></span><br><span class="line">    <span class="keyword">if</span> locked &amp;&amp; mp.lockedInt != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: mp.lockedInt = &quot;</span>, mp.lockedInt, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> mp.isextra &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime.Goexit called in a thread that was not created by the Go runtime&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        throw(<span class="string">&quot;exited a goroutine internally locked to the OS thread&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把g放到本地gFree</span></span><br><span class="line">    gfput(pp, gp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有locked的m</span></span><br><span class="line">    <span class="keyword">if</span> locked &#123;</span><br><span class="line">        <span class="comment">// 非plan9，返回mstart释放p并退出线程</span></span><br><span class="line">        <span class="keyword">if</span> GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 汇编，从 g0.sched 加载调度上下文，并执行</span></span><br><span class="line">            gogo(&amp;mp.g0.sched)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// plan9，清零</span></span><br><span class="line">            mp.lockedExt = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gFree-空闲链表"><a href="#gFree-空闲链表" class="headerlink" title="gFree - 空闲链表"></a>gFree - 空闲链表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把g放到本地gFree，如果gFree数量超过64，只保留32个g，剩下的放到全局gFree</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gfput</span><span class="params">(pp *p, gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态，判断是否是_Gdead</span></span><br><span class="line">    <span class="keyword">if</span> readgstatus(gp) != _Gdead &#123;</span><br><span class="line">        throw(<span class="string">&quot;gfput: bad status (not Gdead)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈大小</span></span><br><span class="line">    stksize := gp.stack.hi - gp.stack.lo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过2KB</span></span><br><span class="line">    <span class="keyword">if</span> stksize != <span class="type">uintptr</span>(startingStackSize) &#123;</span><br><span class="line">        <span class="comment">// 释放栈</span></span><br><span class="line">        stackfree(gp.stack)</span><br><span class="line">        gp.stack.lo = <span class="number">0</span></span><br><span class="line">        gp.stack.hi = <span class="number">0</span></span><br><span class="line">        gp.stackguard0 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到本地gFree</span></span><br><span class="line">    pp.gFree.push(gp)</span><br><span class="line">    <span class="comment">// 计数器+=1</span></span><br><span class="line">    pp.gFree.n++</span><br><span class="line">    <span class="comment">// 如果本地gFree数量超过64</span></span><br><span class="line">    <span class="keyword">if</span> pp.gFree.n &gt;= <span class="number">64</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            inc      <span class="type">int32</span></span><br><span class="line">            stackQ   gQueue</span><br><span class="line">            noStackQ gQueue</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 保留最多32个数据</span></span><br><span class="line">        <span class="keyword">for</span> pp.gFree.n &gt;= <span class="number">32</span> &#123;</span><br><span class="line">            <span class="comment">// g</span></span><br><span class="line">            gp := pp.gFree.pop()</span><br><span class="line">            <span class="comment">// 计数器-=1</span></span><br><span class="line">            pp.gFree.n--</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 未分配，无栈</span></span><br><span class="line">                noStackQ.push(gp)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有栈</span></span><br><span class="line">                stackQ.push(gp)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计数器+=1</span></span><br><span class="line">            inc++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全局gFree加锁</span></span><br><span class="line">        lock(&amp;sched.gFree.lock)</span><br><span class="line">		<span class="comment">// 无栈</span></span><br><span class="line">        sched.gFree.noStack.pushAll(noStackQ)</span><br><span class="line">		<span class="comment">// 有栈</span></span><br><span class="line">        sched.gFree.stack.pushAll(stackQ)</span><br><span class="line">        sched.gFree.n += inc</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.gFree.lock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从本地gFree获取一个g，如果本地gFree为空，从全局gFree一次性拿最多32个到本地</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gfget</span><span class="params">(pp *p)</span></span> *g &#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 本地gFree列表为空 and 全局gFree列表不为空</span></span><br><span class="line">    <span class="keyword">if</span> pp.gFree.empty() &amp;&amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) &#123;</span><br><span class="line">        <span class="comment">// 全局gFree加锁</span></span><br><span class="line">        lock(&amp;sched.gFree.lock)</span><br><span class="line">        <span class="comment">// 填充32个数据</span></span><br><span class="line">        <span class="keyword">for</span> pp.gFree.n &lt; <span class="number">32</span> &#123;</span><br><span class="line">            <span class="comment">// 优先获取有栈的g</span></span><br><span class="line">            gp := sched.gFree.stack.pop()</span><br><span class="line">            <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 无栈的g</span></span><br><span class="line">                gp = sched.gFree.noStack.pop()</span><br><span class="line">                <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// 都没有数据</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计数器-=1</span></span><br><span class="line">            sched.gFree.n--</span><br><span class="line">            <span class="comment">// 放到本地gFree</span></span><br><span class="line">            pp.gFree.push(gp)</span><br><span class="line">            <span class="comment">// 计数器+=1</span></span><br><span class="line">            pp.gFree.n++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.gFree.lock)</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> retry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个g</span></span><br><span class="line">    gp := pp.gFree.pop()</span><br><span class="line">    <span class="comment">// 本地跟全局gFree都没有数据</span></span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器-=1</span></span><br><span class="line">    pp.gFree.n--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g有栈 and 栈大小超过2KB</span></span><br><span class="line">    <span class="keyword">if</span> gp.stack.lo != <span class="number">0</span> &amp;&amp; gp.stack.hi-gp.stack.lo != <span class="type">uintptr</span>(startingStackSize) &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 释放栈</span></span><br><span class="line">            stackfree(gp.stack)</span><br><span class="line">            gp.stack.lo = <span class="number">0</span></span><br><span class="line">            gp.stack.hi = <span class="number">0</span></span><br><span class="line">            gp.stackguard0 = <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g无栈</span></span><br><span class="line">    <span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 申请2KB的栈</span></span><br><span class="line">            gp.stack = stackalloc(startingStackSize)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// stackguard0（用于正常函数调用时检查）= stack.lo+928</span></span><br><span class="line">        gp.stackguard0 = gp.stack.lo + stackGuard</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把本地gFree数据迁移到全局gFree里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gfpurge</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        inc      <span class="type">int32</span></span><br><span class="line">        stackQ   gQueue</span><br><span class="line">        noStackQ gQueue</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 清空gFree</span></span><br><span class="line">    <span class="keyword">for</span> !pp.gFree.empty() &#123;</span><br><span class="line">        gp := pp.gFree.pop()</span><br><span class="line">        pp.gFree.n--</span><br><span class="line">        <span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 无栈</span></span><br><span class="line">            noStackQ.push(gp)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有栈</span></span><br><span class="line">            stackQ.push(gp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        inc++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局gFree加锁</span></span><br><span class="line">    lock(&amp;sched.gFree.lock)</span><br><span class="line">	<span class="comment">// 无栈</span></span><br><span class="line">    sched.gFree.noStack.pushAll(noStackQ)</span><br><span class="line">	<span class="comment">// 有栈</span></span><br><span class="line">    sched.gFree.stack.pushAll(stackQ)</span><br><span class="line">    sched.gFree.n += inc</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.gFree.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="user-sys类型判断"><a href="#user-sys类型判断" class="headerlink" title="user&#x2F;sys类型判断"></a>user&#x2F;sys类型判断</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC开始到标记结束这个过程只允许sys类型的g运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedEnabled</span><span class="params">(gp *g)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC时禁止user类型g</span></span><br><span class="line">    <span class="keyword">if</span> sched.disable.user &#123;</span><br><span class="line">        <span class="comment">// 判断g是否是sys类型，一般runtime.*的都是，除了少部分如runtime.main等</span></span><br><span class="line">        <span class="keyword">return</span> isSystemGoroutine(gp, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="status状态管理"><a href="#status状态管理" class="headerlink" title="status状态管理"></a>status状态管理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除_Gscan标志位，如果旧状态不符合要求则抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casfrom_Gscanstatus</span><span class="params">(gp *g, oldval, newval <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    success := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 旧值</span></span><br><span class="line">    <span class="keyword">switch</span> oldval &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 默认抛出异常</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: casfrom_Gscanstatus bad oldval gp=&quot;</span>, gp, <span class="string">&quot;, oldval=&quot;</span>, hex(oldval), <span class="string">&quot;, newval=&quot;</span>, hex(newval), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">&quot;casfrom_Gscanstatus:top gp-&gt;status is not in scan state&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _Gscanrunnable,</span><br><span class="line">        _Gscanwaiting,</span><br><span class="line">        _Gscanrunning,</span><br><span class="line">        _Gscansyscall,</span><br><span class="line">        _Gscanpreempted:</span><br><span class="line">        <span class="comment">// 加上_Gscan标志标志位</span></span><br><span class="line">        <span class="keyword">if</span> newval == oldval&amp;^_Gscan &#123;</span><br><span class="line">            success = gp.atomicstatus.CompareAndSwap(oldval, newval)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 失败，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> !success &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: casfrom_Gscanstatus failed gp=&quot;</span>, gp, <span class="string">&quot;, oldval=&quot;</span>, hex(oldval), <span class="string">&quot;, newval=&quot;</span>, hex(newval), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">&quot;casfrom_Gscanstatus: gp-&gt;status is not in scan state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同releasem（staticlockranking默认为false）</span></span><br><span class="line">    releaseLockRankAndM(lockRankGscan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非_Gscan状态转换为带_Gscan状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">castogscanstatus</span><span class="params">(gp *g, oldval, newval <span class="type">uint32</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> oldval &#123;</span><br><span class="line">    <span class="keyword">case</span> _Grunnable,</span><br><span class="line">        _Grunning,</span><br><span class="line">        _Gwaiting,</span><br><span class="line">        _Gsyscall:</span><br><span class="line">        <span class="keyword">if</span> newval == oldval|_Gscan &#123;</span><br><span class="line">            r := gp.atomicstatus.CompareAndSwap(oldval, newval)</span><br><span class="line">            <span class="keyword">if</span> r &#123;</span><br><span class="line">                <span class="comment">// 同acquirem（staticlockranking默认为false）</span></span><br><span class="line">                acquireLockRankAndM(lockRankGscan)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;runtime: castogscanstatus oldval=&quot;</span>, hex(oldval), <span class="string">&quot; newval=&quot;</span>, hex(newval), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    throw(<span class="string">&quot;castogscanstatus&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not reached&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casgstatus</span><span class="params">(gp *g, oldval, newval <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 有_Gscan标志位 or 新旧数值相同</span></span><br><span class="line">    <span class="keyword">if</span> (oldval&amp;_Gscan != <span class="number">0</span>) || (newval&amp;_Gscan != <span class="number">0</span>) || oldval == newval &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// Call on the systemstack to prevent print and throw from counting</span></span><br><span class="line">            <span class="comment">// against the nosplit stack reservation.</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: casgstatus: oldval=&quot;</span>, hex(oldval), <span class="string">&quot; newval=&quot;</span>, hex(newval), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;casgstatus: bad incoming values&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    lockWithRankMayAcquire(<span class="literal">nil</span>, lockRankGscan)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟时间</span></span><br><span class="line">    <span class="keyword">const</span> yieldDelay = <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">    <span class="keyword">var</span> nextYield <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断尝试，直到GC完成</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; !gp.atomicstatus.CompareAndSwap(oldval, newval); i++ &#123;</span><br><span class="line">        <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">        <span class="keyword">if</span> oldval == _Gwaiting &amp;&amp; gp.atomicstatus.Load() == _Grunnable &#123;</span><br><span class="line">			<span class="comment">// 异常</span></span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;casgstatus: waiting for Gwaiting but is Grunnable&quot;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次尝试</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 延迟5us</span></span><br><span class="line">            nextYield = nanotime() + yieldDelay</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还没到指定时刻</span></span><br><span class="line">        <span class="keyword">if</span> nanotime() &lt; nextYield &#123;</span><br><span class="line">            <span class="comment">// 等待atomicstatus复原</span></span><br><span class="line">            <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span> &amp;&amp; gp.atomicstatus.Load() != oldval; x++ &#123;</span><br><span class="line">                <span class="comment">// 自旋，短暂的忙等待（纳秒级）</span></span><br><span class="line">                procyield(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已到指定时刻</span></span><br><span class="line">            <span class="comment">// 主动让出CPU，让OS选择其他线程运行（微秒级到毫秒级）</span></span><br><span class="line">            osyield()</span><br><span class="line">            <span class="comment">// 延迟2.5us</span></span><br><span class="line">            nextYield = nanotime() + yieldDelay/<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成状态修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            gp.syncGroup.changegstatus(gp, oldval, newval)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原状态为_Grunning</span></span><br><span class="line">    <span class="keyword">if</span> oldval == _Grunning &#123;</span><br><span class="line">        <span class="comment">// casgstatusAlwaysTrack默认为false or trackingSeq/8 == 0</span></span><br><span class="line">        <span class="keyword">if</span> casgstatusAlwaysTrack || gp.trackingSeq%gTrackingPeriod == <span class="number">0</span> &#123;</span><br><span class="line">            gp.tracking = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器（初始值随机）+=1</span></span><br><span class="line">        gp.trackingSeq++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !gp.tracking &#123;</span><br><span class="line">		<span class="comment">// tracking为false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tracking为true</span></span><br><span class="line">    <span class="comment">// 统计g位与_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计运行时长、阻塞（mutex）时长</span></span><br><span class="line">    <span class="keyword">switch</span> oldval &#123;</span><br><span class="line">    <span class="keyword">case</span> _Grunnable: <span class="comment">// 原状态为_Grunnable</span></span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="comment">// 计算g处于_Grunnable状态的时长</span></span><br><span class="line">        gp.runnableTime += now - gp.trackingStamp</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        gp.trackingStamp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> _Gwaiting: <span class="comment">// 原状态为_Gwaiting</span></span><br><span class="line">        <span class="comment">// 如果不是mutex导致的等待，不统计</span></span><br><span class="line">        <span class="keyword">if</span> !gp.waitreason.isMutexWait() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="comment">// 累计所有处于_Gwaiting状态的g的时长</span></span><br><span class="line">        sched.totalMutexWaitTime.Add((now - gp.trackingStamp) * gTrackingPeriod)</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        gp.trackingStamp = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> newval &#123;</span><br><span class="line">    <span class="keyword">case</span> _Gwaiting: <span class="comment">// 新状态为_Gwaiting</span></span><br><span class="line">        <span class="comment">// 如果不是mutex导致的等待，不统计</span></span><br><span class="line">        <span class="keyword">if</span> !gp.waitreason.isMutexWait() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="comment">// trackingStamp纪录当前时刻</span></span><br><span class="line">        gp.trackingStamp = now</span><br><span class="line">    <span class="keyword">case</span> _Grunnable: <span class="comment">// 新状态为_Grunnable</span></span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="comment">// trackingStamp纪录当前时刻</span></span><br><span class="line">        gp.trackingStamp = now</span><br><span class="line">    <span class="keyword">case</span> _Grunning: <span class="comment">// 新状态为_Grunning</span></span><br><span class="line">        <span class="comment">// 取消tracking跟踪统计</span></span><br><span class="line">        gp.tracking = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 累计所有处于_Grunnable状态的g的时长</span></span><br><span class="line">        sched.timeToRun.record(gp.runnableTime)</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        gp.runnableTime = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为_Gwaiting状态并设置waitreason</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casGToWaiting</span><span class="params">(gp *g, old <span class="type">uint32</span>, reason waitReason)</span></span> &#123;</span><br><span class="line">    gp.waitreason = reason</span><br><span class="line">    <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">    casgstatus(gp, old, _Gwaiting)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为_Gwaiting状态并设置waitreason</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casGToWaitingForGC</span><span class="params">(gp *g, old <span class="type">uint32</span>, reason waitReason)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !reason.isWaitingForGC() &#123;</span><br><span class="line">        throw(<span class="string">&quot;casGToWaitingForGC with non-isWaitingForGC wait reason&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    casGToWaiting(gp, old, reason)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从_Grunning状态改为_Gscanpreempted</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casGToPreemptScan</span><span class="params">(gp *g, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> old != _Grunning || <span class="built_in">new</span> != _Gscan|_Gpreempted &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad g transition&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同acquirem（staticlockranking默认为false）</span></span><br><span class="line">    acquireLockRankAndM(lockRankGscan)</span><br><span class="line">    <span class="comment">// 不停尝试切换状态</span></span><br><span class="line">    <span class="keyword">for</span> !gp.atomicstatus.CompareAndSwap(_Grunning, _Gscan|_Gpreempted) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从_Gpreempted状态改为_Gwaiting</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casGFromPreempted</span><span class="params">(gp *g, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> old != _Gpreempted || <span class="built_in">new</span> != _Gwaiting &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad g transition&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waitreason = waitReasonPreempted</span><br><span class="line">    <span class="keyword">if</span> !gp.atomicstatus.CompareAndSwap(_Gpreempted, _Gwaiting) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg := gp.syncGroup; sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        sg.changegstatus(gp, _Gpreempted, _Gwaiting)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="allg-全局列表"><a href="#allg-全局列表" class="headerlink" title="allg-全局列表"></a>allg-全局列表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把g放到allg列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allgadd</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态，如果是默认状态</span></span><br><span class="line">    <span class="keyword">if</span> readgstatus(gp) == _Gidle &#123;</span><br><span class="line">        throw(<span class="string">&quot;allgadd: bad status Gidle&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;allglock)</span><br><span class="line">    <span class="comment">// 放到allgs末尾</span></span><br><span class="line">    allgs = <span class="built_in">append</span>(allgs, gp)</span><br><span class="line">    <span class="comment">// 指针指向了过期的g，更新</span></span><br><span class="line">    <span class="keyword">if</span> &amp;allgs[<span class="number">0</span>] != allgptr &#123;</span><br><span class="line">        atomicstorep(unsafe.Pointer(&amp;allgptr), unsafe.Pointer(&amp;allgs[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新allglen</span></span><br><span class="line">    atomic.Storeuintptr(&amp;allglen, <span class="type">uintptr</span>(<span class="built_in">len</span>(allgs)))</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;allglock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回allg</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allGsSnapshot</span><span class="params">()</span></span> []*g &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;allglock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allgs[:<span class="built_in">len</span>(allgs):<span class="built_in">len</span>(allgs)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="machine"><a href="#machine" class="headerlink" title="machine"></a>machine</h3><h4 id="结构体验证"><a href="#结构体验证" class="headerlink" title="结构体验证"></a>结构体验证</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证m数据结构的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockVerifyMSize</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// m大小为1912，最后的size应为2040+8=2048</span></span><br><span class="line">    size := roundupsize(unsafe.Sizeof(m&#123;&#125;), <span class="literal">false</span>) + mallocHeaderSize</span><br><span class="line">    <span class="comment">// 2048&amp;1023 =&gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> size&amp;mutexMMask != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;M structure uses sizeclass &quot;</span>, size, <span class="string">&quot;/&quot;</span>, hex(size), <span class="string">&quot; bytes; &quot;</span>,</span><br><span class="line">            <span class="string">&quot;incompatible with mutex flag mask &quot;</span>, hex(mutexMMask), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;runtime.m memory alignment too small for spinbit mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理freem链表，创建并初始化m，locked或cgo类型的m由模板线程延迟创建，其他类型则立即调用平台相关函数创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span></span>, pp *p, id <span class="type">int64</span>) &#123;</span><br><span class="line">    acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理freem链表，创建并初始化m</span></span><br><span class="line">    mp := allocm(pp, fn, id)</span><br><span class="line">    <span class="comment">// 将p存储到nextp</span></span><br><span class="line">    mp.nextp.set(pp)</span><br><span class="line">    <span class="comment">// 信号掩码设置</span></span><br><span class="line">    mp.sigmask = initSigmask</span><br><span class="line">    <span class="comment">// g、m不为nil and (有lockedm or cgo) and 非plan9</span></span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp != <span class="literal">nil</span> &amp;&amp; gp.m != <span class="literal">nil</span> &amp;&amp; (gp.m.lockedExt != <span class="number">0</span> || gp.m.incgo) &amp;&amp; GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock(&amp;newmHandoff.lock)</span><br><span class="line">        <span class="comment">// 未设置，异常</span></span><br><span class="line">        <span class="keyword">if</span> newmHandoff.haveTemplateThread == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;on a locked thread with no template thread&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// next指针，指向newm，m成为链表的头部</span></span><br><span class="line">        mp.schedlink = newmHandoff.newm</span><br><span class="line">        <span class="comment">// newm链表指针设置为m</span></span><br><span class="line">        newmHandoff.newm.set(mp)</span><br><span class="line">        <span class="comment">// 如果templateThread正在休眠</span></span><br><span class="line">        <span class="keyword">if</span> newmHandoff.waiting &#123;</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            newmHandoff.waiting = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 唤醒m（m放在wake.key）</span></span><br><span class="line">            notewakeup(&amp;newmHandoff.wake)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;newmHandoff.lock)</span><br><span class="line">        releasem(getg().m)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用平台相关函数创建线程</span></span><br><span class="line">    newm1(mp)</span><br><span class="line">    releasem(getg().m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用平台相关函数创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    <span class="comment">// cgo</span></span><br><span class="line">    <span class="keyword">if</span> iscgo &#123;</span><br><span class="line">        <span class="keyword">var</span> ts cgothreadstart</span><br><span class="line">        <span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;_cgo_thread_start missing&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ts.g.set(mp.g0)</span><br><span class="line">        ts.tls = (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;mp.tls[<span class="number">0</span>]))</span><br><span class="line">        ts.fn = unsafe.Pointer(abi.FuncPCABI0(mstart))</span><br><span class="line">        <span class="comment">// Prevent process clone</span></span><br><span class="line">        execLock.rlock()</span><br><span class="line">        asmcgocall(_cgo_thread_start, unsafe.Pointer(&amp;ts))</span><br><span class="line">        execLock.runlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    execLock.rlock()</span><br><span class="line">    <span class="comment">// 调用平台相关函数创建线程</span></span><br><span class="line">    newosproc(mp)</span><br><span class="line">    execLock.runlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用平台相关函数创建线程</span></span><br><span class="line"><span class="comment">// src/runtime/os_linux.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    <span class="comment">// g0栈顶</span></span><br><span class="line">    stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;newosproc stk=&quot;</span>, stk, <span class="string">&quot; m=&quot;</span>, mp, <span class="string">&quot; g=&quot;</span>, mp.g0, <span class="string">&quot; clone=&quot;</span>, abi.FuncPCABI0(clone), <span class="string">&quot; id=&quot;</span>, mp.id, <span class="string">&quot; ostk=&quot;</span>, &amp;mp, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧的sigset</span></span><br><span class="line">    <span class="keyword">var</span> oset sigset</span><br><span class="line">    <span class="comment">// 用sigset_all设置，旧的放到oset</span></span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">    ret := retryOnEAGAIN(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">        <span class="comment">// 成功返回tid，失败返回errno</span></span><br><span class="line">        r := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(abi.FuncPCABI0(mstart)))</span><br><span class="line">        <span class="comment">// 成功返回，不需要tid</span></span><br><span class="line">        <span class="keyword">if</span> r &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回errno</span></span><br><span class="line">        <span class="keyword">return</span> -r</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 还原</span></span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程失败</span></span><br><span class="line">    <span class="keyword">if</span> ret != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: failed to create new OS thread (have &quot;</span>, mcount(), <span class="string">&quot; already; errno=&quot;</span>, ret, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ret == _EAGAIN &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: may need to increase max user processes (ulimit -u)&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        throw(<span class="string">&quot;newosproc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理freem链表，创建并初始化m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocm</span><span class="params">(pp *p, fn <span class="keyword">func</span>()</span></span>, id <span class="type">int64</span>) *m &#123;</span><br><span class="line">    allocmLock.rlock()</span><br><span class="line"></span><br><span class="line">    acquirem()</span><br><span class="line"></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 当前m没有p</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">        acquirep(pp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待释放的m链表不为空，只保留仍在使用的m</span></span><br><span class="line">    <span class="keyword">if</span> sched.freem != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 仍在使用的m链表</span></span><br><span class="line">        <span class="keyword">var</span> newList *m</span><br><span class="line">        <span class="comment">// 遍历整个freem链表</span></span><br><span class="line">        <span class="keyword">for</span> freem := sched.freem; freem != <span class="literal">nil</span>; &#123;</span><br><span class="line">            <span class="comment">// m.freeWait</span></span><br><span class="line">            wait := freem.freeWait.Load()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把所有状态为freeMWait的m连接成一个新链表</span></span><br><span class="line">            <span class="comment">// m.freeWait == 2 =&gt; 仍在使用，退出前的初始状态，线程还没退出</span></span><br><span class="line">            <span class="keyword">if</span> wait == freeMWait &#123;</span><br><span class="line">                <span class="comment">// 获取下一个freem</span></span><br><span class="line">                next := freem.freelink</span><br><span class="line">                <span class="comment">// 修改next指针（指向prev）</span></span><br><span class="line">                freem.freelink = newList</span><br><span class="line">                <span class="comment">// prev指针指向freem</span></span><br><span class="line">                newList = freem</span><br><span class="line">                <span class="comment">// 指向下一个freem</span></span><br><span class="line">                freem = next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面是m.freeWait != 2 的节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// m.freeWait == 0 =&gt; exitThread，栈可回收</span></span><br><span class="line">            <span class="keyword">if</span> wait == freeMStack &#123;</span><br><span class="line">                systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">					<span class="comment">// 释放g0的栈</span></span><br><span class="line">                    stackfree(freem.g0.stack)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// m.freeWait == 1 =&gt; 线程退出最后一步</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一个freem</span></span><br><span class="line">            freem = freem.freelink</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换freem链表</span></span><br><span class="line">        sched.freem = newList</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建m</span></span><br><span class="line">    mp := <span class="built_in">new</span>(m)</span><br><span class="line">    <span class="comment">// 设置启动函数</span></span><br><span class="line">    mp.mstartfn = fn</span><br><span class="line">    <span class="comment">// m通用初始化</span></span><br><span class="line">    mcommoninit(mp, id)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个m分配一个g0</span></span><br><span class="line">    <span class="comment">// cgo or 栈由系统分配（linux为false，由go分配）</span></span><br><span class="line">    <span class="keyword">if</span> iscgo || mStackIsSystemAllocated() &#123;</span><br><span class="line">        <span class="comment">// 创建g、分配栈，无栈</span></span><br><span class="line">        mp.g0 = malg(<span class="number">-1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建g、分配栈，16KB的栈</span></span><br><span class="line">        mp.g0 = malg(<span class="number">16384</span> * sys.StackGuardMultiplier)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双向绑定</span></span><br><span class="line">    mp.g0.m = mp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟m当前p是同一个</span></span><br><span class="line">    <span class="keyword">if</span> pp == gp.m.p.ptr() &#123;</span><br><span class="line">        <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">        releasep()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    releasem(gp.m)</span><br><span class="line">    allocmLock.runlock()</span><br><span class="line">    <span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通用初始化"><a href="#通用初始化" class="headerlink" title="通用初始化"></a>通用初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m通用初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mcommoninit</span><span class="params">(mp *m, id <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果g不是g0</span></span><br><span class="line">    <span class="keyword">if</span> gp != gp.m.g0 &#123;</span><br><span class="line">        <span class="comment">// 获取当前调用栈信息，存入createstack数组</span></span><br><span class="line">        callers(<span class="number">1</span>, mp.createstack[:])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录m.id</span></span><br><span class="line">    <span class="keyword">if</span> id &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        mp.id = id</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有超过最大数量限制，则返回全局唯一id</span></span><br><span class="line">        mp.id = mReserveID()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化m的随机状态：m.chacha8、m.cheaprand</span></span><br><span class="line">    mrandinit(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.gsignal初始化（32KB栈的g，平台相关）</span></span><br><span class="line">    mpreinit(mp)</span><br><span class="line">    <span class="comment">// 初始化成功</span></span><br><span class="line">    <span class="keyword">if</span> mp.gsignal != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// stack.lo+928</span></span><br><span class="line">        mp.gsignal.stackguard1 = mp.gsignal.stack.lo + stackGuard</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next指针，跟allm串联起来成为新的allm</span></span><br><span class="line">    mp.alllink = allm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新allm指针</span></span><br><span class="line">    atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cgo相关</span></span><br><span class="line">    <span class="keyword">if</span> iscgo || GOOS == <span class="string">&quot;solaris&quot;</span> || GOOS == <span class="string">&quot;illumos&quot;</span> || GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">        mp.cgoCallers = <span class="built_in">new</span>(cgoCallers)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存剖析调用栈初始化</span></span><br><span class="line">    mProfStackInit(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号处理初始化"><a href="#信号处理初始化" class="headerlink" title="信号处理初始化"></a>信号处理初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m0信号处理初始化（平台相关），如果是cgo，生成一定数量的extraM</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstartm0</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// cgoHasExtraM默认为false</span></span><br><span class="line">    <span class="comment">// cgo或者是Windows</span></span><br><span class="line">    <span class="keyword">if</span> (iscgo || GOOS == <span class="string">&quot;windows&quot;</span>) &amp;&amp; !cgoHasExtraM &#123;</span><br><span class="line">        <span class="comment">// 设置为true</span></span><br><span class="line">        cgoHasExtraM = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 生成extraMWaiters数量的g、m并纪录在allg、extraM</span></span><br><span class="line">        newextram()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 信号处理初始化（平台相关）</span></span><br><span class="line">    initsig(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理初始化（平台相关）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initsig</span><span class="params">(preinit <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !preinit &#123;</span><br><span class="line">		<span class="comment">// preinit为false时</span></span><br><span class="line">        signalsOK = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态库（c-archive/c-shared） and </span></span><br><span class="line">    <span class="keyword">if</span> (isarchive || islibrary) &amp;&amp; !preinit &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 32个元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; _NSIG; i++ &#123;</span><br><span class="line">        t := &amp;sigtable[i]</span><br><span class="line">        <span class="comment">// 默认？ or 状态为_SigDefault（=16，第5位）</span></span><br><span class="line">        <span class="keyword">if</span> t.flags == <span class="number">0</span> || t.flags&amp;_SigDefault != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有其他G并行处理，不需要CAS</span></span><br><span class="line">        fwdSig[i] = getsig(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 安装go级别的函数</span></span><br><span class="line">        <span class="keyword">if</span> !sigInstallGoHandler(i) &#123;</span><br><span class="line">            <span class="comment">// 默认行为、忽略信号</span></span><br><span class="line">            <span class="keyword">if</span> fwdSig[i] != _SIG_DFL &amp;&amp; fwdSig[i] != _SIG_IGN &#123;</span><br><span class="line">                <span class="comment">// 注册备用信号栈</span></span><br><span class="line">                setsigstack(i)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> fwdSig[i] == _SIG_IGN &#123;</span><br><span class="line">                <span class="comment">// 初始化并检测哪些信号在进程启动时被忽略</span></span><br><span class="line">                sigInitIgnored(i)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组，32个元素</span></span><br><span class="line">        handlingSig[i] = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 安装信号</span></span><br><span class="line">        setsig(i, abi.FuncPCABIInternal(sighandler))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自增ID"><a href="#自增ID" class="headerlink" title="自增ID"></a>自增ID</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有超过最大数量限制，则返回全局唯一id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mReserveID</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否会溢出</span></span><br><span class="line">    <span class="keyword">if</span> sched.mnext+<span class="number">1</span> &lt; sched.mnext &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: thread ID overflow&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// id=当前mnext</span></span><br><span class="line">    id := sched.mnext</span><br><span class="line">    <span class="comment">// mnext+=1</span></span><br><span class="line">    sched.mnext++</span><br><span class="line">    <span class="comment">// 检查m的数量是否超过最大数量限制</span></span><br><span class="line">    checkmcount()</span><br><span class="line">    <span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数量限制检测"><a href="#数量限制检测" class="headerlink" title="数量限制检测"></a>数量限制检测</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查m的数量是否超过最大数量限制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkmcount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计总量 - 累计释放m数量 - 运行中的extraM数量 - 未运行的extraM数量</span></span><br><span class="line">    <span class="comment">// sched.mnext - sched.nmfreed - extraMInUse - extraMLength</span></span><br><span class="line">    count := mcount() - <span class="type">int32</span>(extraMInUse.Load()) - <span class="type">int32</span>(extraMLength.Load())</span><br><span class="line">    <span class="comment">// 超过最大数量限制</span></span><br><span class="line">    <span class="keyword">if</span> count &gt; sched.maxmcount &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: program exceeds &quot;</span>, sched.maxmcount, <span class="string">&quot;-thread limit\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;thread exhaustion&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="midle-全局空闲队列"><a href="#midle-全局空闲队列" class="headerlink" title="midle-全局空闲队列"></a>midle-全局空闲队列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把m放到midle空闲链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mput</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把m放到midle链表头部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// next指针指向midle</span></span><br><span class="line">    mp.schedlink = sched.midle</span><br><span class="line">    <span class="comment">// mp替换midle</span></span><br><span class="line">    sched.midle.set(mp)</span><br><span class="line">    <span class="comment">// 计数器+1</span></span><br><span class="line">    sched.nmidle++</span><br><span class="line">    <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">    checkdead()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从midle空闲链表中拿一个m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mget</span><span class="params">()</span></span> *m &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// midle链表头部</span></span><br><span class="line">    mp := sched.midle.ptr()</span><br><span class="line">    <span class="comment">// 有空闲m</span></span><br><span class="line">    <span class="keyword">if</span> mp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// schedlink即为next指针</span></span><br><span class="line">        sched.midle = mp.schedlink</span><br><span class="line">        <span class="comment">// 计数器-1</span></span><br><span class="line">        sched.nmidle--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="m启动-停止"><a href="#m启动-停止" class="headerlink" title="m启动&#x2F;停止"></a>m启动&#x2F;停止</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(pp *p, spinning, lockheld <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要加锁，返回时再根据lockheld同步锁状态</span></span><br><span class="line">    <span class="keyword">if</span> !lockheld &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p为nil</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// spinning为true时，p不能为nil</span></span><br><span class="line">        <span class="keyword">if</span> spinning &#123;</span><br><span class="line">            throw(<span class="string">&quot;startm: P required for spinning=true&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// spinning为false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从空闲链表拿一个p</span></span><br><span class="line">        pp, _ = pidleget(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 没有拿到</span></span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 返回前同步锁状态</span></span><br><span class="line">            <span class="keyword">if</span> !lockheld &#123;</span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">            &#125;</span><br><span class="line">            releasem(mp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，p不可能为nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从midle空闲链表中拿一个m</span></span><br><span class="line">    nmp := mget()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有拿到m</span></span><br><span class="line">    <span class="keyword">if</span> nmp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有超过最大数量限制，则返回全局唯一id，避免死锁</span></span><br><span class="line">        id := mReserveID()</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步spinning状态</span></span><br><span class="line">        <span class="keyword">if</span> spinning &#123;</span><br><span class="line">            <span class="comment">// 该函数将m.spinning置为true</span></span><br><span class="line">            fn = mspinning</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理freem链表，创建并初始化m，locked或cgo类型的m由模板线程延迟创建，其他类型则立即调用平台相关函数创建线程</span></span><br><span class="line">        newm(fn, pp, id)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回前同步锁状态</span></span><br><span class="line">        <span class="keyword">if</span> lockheld &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到空闲的m了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回前同步锁状态</span></span><br><span class="line">    <span class="keyword">if</span> !lockheld &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 空闲m不能有spinning状态</span></span><br><span class="line">    <span class="keyword">if</span> nmp.spinning &#123;</span><br><span class="line">        throw(<span class="string">&quot;startm: m is spinning&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nextp不应该有数据</span></span><br><span class="line">    <span class="keyword">if</span> nmp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;startm: m has p&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// spinning意味着本地队列为空，这里数据不一致</span></span><br><span class="line">    <span class="keyword">if</span> spinning &amp;&amp; !runqempty(pp) &#123;</span><br><span class="line">        throw(<span class="string">&quot;startm: p has runnable gs&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步spinning状态</span></span><br><span class="line">    nmp.spinning = spinning</span><br><span class="line">    <span class="comment">// 不直接绑定p，而是绑定nextp</span></span><br><span class="line">    nmp.nextp.set(pp)</span><br><span class="line">    <span class="comment">// 唤醒m（m放在m.park.key）</span></span><br><span class="line">    notewakeup(&amp;nmp.park)</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m已加锁</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;stopm holding locks&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m没有让出p</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;stopm holding p&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自旋中</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.spinning &#123;</span><br><span class="line">        throw(<span class="string">&quot;stopm spinning&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 把m放到midle空闲链表</span></span><br><span class="line">    mput(gp.m)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m挂起休眠，等待唤醒</span></span><br><span class="line">    mPark()</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">    acquirep(gp.m.nextp.ptr())</span><br><span class="line">    <span class="comment">// 重置nextp</span></span><br><span class="line">    gp.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m线程退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mexit</span><span class="params">(osStack <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m0</span></span><br><span class="line">    <span class="keyword">if</span> mp == &amp;m0 &#123;</span><br><span class="line">        <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">        handoffp(releasep())</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 累计释放m数量+=1</span></span><br><span class="line">        sched.nmfreed++</span><br><span class="line">        <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">        checkdead()</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// m挂起休眠，等待唤醒</span></span><br><span class="line">        mPark()</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">        throw(<span class="string">&quot;locked m0 woke up&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通m（按道理，只有m0才会运行该函数才对）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞所有信号（平台相关）</span></span><br><span class="line">    sigblock(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 信号处理（平台相关）</span></span><br><span class="line">    unminit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gsignal</span></span><br><span class="line">    <span class="keyword">if</span> mp.gsignal != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 释放栈</span></span><br><span class="line">        stackfree(mp.gsignal.stack)</span><br><span class="line">        <span class="comment">// g被释放</span></span><br><span class="line">        mp.gsignal = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 遍历allm</span></span><br><span class="line">    <span class="keyword">for</span> pprev := &amp;allm; *pprev != <span class="literal">nil</span>; pprev = &amp;(*pprev).alllink &#123;</span><br><span class="line">        <span class="comment">// 找到当前m</span></span><br><span class="line">        <span class="keyword">if</span> *pprev == mp &#123;</span><br><span class="line">            <span class="comment">// 链接下一个m</span></span><br><span class="line">            *pprev = mp.alllink</span><br><span class="line">            <span class="keyword">goto</span> found</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    throw(<span class="string">&quot;m not found in allm&quot;</span>)</span><br><span class="line">found:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.freeWait == 2 =&gt; 仍在使用，退出前的初始状态，线程还没退出</span></span><br><span class="line">    mp.freeWait.Store(freeMWait)</span><br><span class="line">    <span class="comment">// m放到freem链表</span></span><br><span class="line">    mp.freelink = sched.freem</span><br><span class="line">    <span class="comment">// 替换freem链表</span></span><br><span class="line">    sched.freem = mp</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.ncgocall累加到ncgocall</span></span><br><span class="line">    atomic.Xadd64(&amp;ncgocall, <span class="type">int64</span>(mp.ncgocall))</span><br><span class="line">    <span class="comment">// 纪录总等待耗时</span></span><br><span class="line">    sched.totalRuntimeLockWaitTime.Add(mp.mLockProfile.waitTime.Load())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">    handoffp(releasep())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 累计释放m数量+=1</span></span><br><span class="line">    sched.nmfreed++</span><br><span class="line">    <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">    checkdead()</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// macOS/iOS</span></span><br><span class="line">    <span class="keyword">if</span> GOOS == <span class="string">&quot;darwin&quot;</span> || GOOS == <span class="string">&quot;ios&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> mp.signalPending.Load() != <span class="number">0</span> &#123;</span><br><span class="line">            pendingPreemptSignals.Add(<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源（平台相关）</span></span><br><span class="line">    mdestroy(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否由系统分配</span></span><br><span class="line">    <span class="keyword">if</span> osStack &#123;</span><br><span class="line">        <span class="comment">// m.freeWait == 1 =&gt; 标记线程退出最后一步</span></span><br><span class="line">        mp.freeWait.Store(freeMRef)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回mstart，由系统释放g0栈并终止线程</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接退出（linux下为汇编函数runtime·exitThread）</span></span><br><span class="line">    exitThread(&amp;mp.freeWait)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自旋等待"><a href="#自旋等待" class="headerlink" title="自旋等待"></a>自旋等待</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置m.spinning，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetspinning</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 状态不一致</span></span><br><span class="line">    <span class="keyword">if</span> !gp.m.spinning &#123;</span><br><span class="line">        throw(<span class="string">&quot;resetspinning: not a spinning m&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置spinning</span></span><br><span class="line">    gp.m.spinning = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// nmspinning-=1</span></span><br><span class="line">    nmspinning := sched.nmspinning.Add(<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 数量小于0，异常</span></span><br><span class="line">    <span class="keyword">if</span> nmspinning &lt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;findrunnable: negative nmspinning&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    wakep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="processor"><a href="#processor" class="headerlink" title="processor"></a>processor</h3><h4 id="创建-容量调整"><a href="#创建-容量调整" class="headerlink" title="创建&#x2F;容量调整"></a>创建&#x2F;容量调整</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据数量n调整p容量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="type">int32</span>)</span></span> *p &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧值</span></span><br><span class="line">    old := gomaxprocs</span><br><span class="line">    <span class="keyword">if</span> old &lt; <span class="number">0</span> || nprocs &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;procresize: invalid arg&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 上一次调整的时刻</span></span><br><span class="line">    <span class="keyword">if</span> sched.procresizetime != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 所有核心的运行时长</span></span><br><span class="line">        sched.totaltime += <span class="type">int64</span>(old) * (now - sched.procresizetime)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新调整时刻</span></span><br><span class="line">    sched.procresizetime = now</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 32个p一组，每个p用一个bit表示状态</span></span><br><span class="line">    maskWords := (nprocs + <span class="number">31</span>) / <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整p</span></span><br><span class="line">    <span class="keyword">if</span> nprocs &gt; <span class="type">int32</span>(<span class="built_in">len</span>(allp)) &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock(&amp;allpLock)</span><br><span class="line">        <span class="comment">// 缩容</span></span><br><span class="line">        <span class="keyword">if</span> nprocs &lt;= <span class="type">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line">            allp = allp[:nprocs]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            <span class="comment">// 创建新的allp</span></span><br><span class="line">            nallp := <span class="built_in">make</span>([]*p, nprocs)</span><br><span class="line">            <span class="comment">// 复制旧的p</span></span><br><span class="line">            <span class="built_in">copy</span>(nallp, allp[:<span class="built_in">cap</span>(allp)])</span><br><span class="line">            <span class="comment">// 替换allp</span></span><br><span class="line">            allp = nallp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩容/不变</span></span><br><span class="line">        <span class="keyword">if</span> maskWords &lt;= <span class="type">int32</span>(<span class="built_in">cap</span>(idlepMask)) &#123;</span><br><span class="line">            idlepMask = idlepMask[:maskWords]</span><br><span class="line">            timerpMask = timerpMask[:maskWords]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 扩容，状态位数量=maskWords*32</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// idlepMask</span></span><br><span class="line">            nidlepMask := <span class="built_in">make</span>([]<span class="type">uint32</span>, maskWords)</span><br><span class="line">            <span class="built_in">copy</span>(nidlepMask, idlepMask)</span><br><span class="line">            idlepMask = nidlepMask</span><br><span class="line"></span><br><span class="line">            <span class="comment">// timerpMask</span></span><br><span class="line">            ntimerpMask := <span class="built_in">make</span>([]<span class="type">uint32</span>, maskWords)</span><br><span class="line">            <span class="built_in">copy</span>(ntimerpMask, timerpMask)</span><br><span class="line">            timerpMask = ntimerpMask</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;allpLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新创建的p要进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> i := old; i &lt; nprocs; i++ &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="comment">// 创建p</span></span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            pp = <span class="built_in">new</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        pp.init(i)</span><br><span class="line">        <span class="comment">// 纪录p指针</span></span><br><span class="line">        atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 当前p的id&lt;nprocs</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &amp;&amp; gp.m.p.ptr().id &lt; nprocs &#123;</span><br><span class="line">        <span class="comment">// 可以继续使用</span></span><br><span class="line">        gp.m.p.ptr().status = _Prunning</span><br><span class="line">		<span class="comment">// 清理p.mcache</span></span><br><span class="line">        gp.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁p前，先释放</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前p</span></span><br><span class="line">        <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 解除m绑定</span></span><br><span class="line">            gp.m.p.ptr().m = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// m解除p绑定</span></span><br><span class="line">        gp.m.p = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 拿第一个p</span></span><br><span class="line">        pp := allp[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 解除m绑定</span></span><br><span class="line">        pp.m = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 重置为默认状态_Pidle</span></span><br><span class="line">        pp.status = _Pidle</span><br><span class="line">        <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">        acquirep(pp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g.m.p还没绑定，暂时不需要mcache0</span></span><br><span class="line">    mcache0 = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩容后，allp销毁多余的p</span></span><br><span class="line">    <span class="keyword">for</span> i := nprocs; i &lt; old; i++ &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">		<span class="comment">// p销毁</span></span><br><span class="line">        pp.destroy()</span><br><span class="line">        <span class="comment">// 还不能回收，因为可能有正在执行syscall的m在引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">int32</span>(<span class="built_in">len</span>(allp)) != nprocs &#123;</span><br><span class="line">        lock(&amp;allpLock)</span><br><span class="line">        allp = allp[:nprocs]</span><br><span class="line">        idlepMask = idlepMask[:maskWords]</span><br><span class="line">        timerpMask = timerpMask[:maskWords]</span><br><span class="line">        unlock(&amp;allpLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非空闲的p，链表</span></span><br><span class="line">    <span class="keyword">var</span> runnablePs *p</span><br><span class="line">    <span class="comment">// 从后往前扫描</span></span><br><span class="line">    <span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="comment">// p当前使用着</span></span><br><span class="line">        <span class="keyword">if</span> gp.m.p.ptr() == pp &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置为默认状态_Pidle</span></span><br><span class="line">        pp.status = _Pidle</span><br><span class="line">        <span class="comment">// 本地队列为空</span></span><br><span class="line">        <span class="keyword">if</span> runqempty(pp) &#123;</span><br><span class="line">            <span class="comment">// 把p放进空闲链表</span></span><br><span class="line">            pidleput(pp, now)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从midle空闲链表中拿一个m，放到p.m</span></span><br><span class="line">            pp.m.set(mget())</span><br><span class="line">            <span class="comment">// next指针设置</span></span><br><span class="line">            pp.link.set(runnablePs)</span><br><span class="line">			<span class="comment">// 替换链表头</span></span><br><span class="line">            runnablePs = pp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偷取顺序重置</span></span><br><span class="line">    stealOrder.reset(<span class="type">uint32</span>(nprocs))</span><br><span class="line">    <span class="comment">// 编译器检查用，判断是否是int32类型</span></span><br><span class="line">    <span class="keyword">var</span> int32p *<span class="type">int32</span> = &amp;gomaxprocs</span><br><span class="line">    <span class="comment">// 更新gomaxprocs</span></span><br><span class="line">    atomic.Store((*<span class="type">uint32</span>)(unsafe.Pointer(int32p)), <span class="type">uint32</span>(nprocs))</span><br><span class="line">    <span class="comment">// p的数量有改动</span></span><br><span class="line">    <span class="keyword">if</span> old != nprocs &#123;</span><br><span class="line">        <span class="comment">// 重置capacity等字段，capacity=nprocs秒</span></span><br><span class="line">        gcCPULimiter.resetCapacity(now, nprocs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回非空闲的p</span></span><br><span class="line">    <span class="keyword">return</span> runnablePs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *p)</span></span> init(id <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 纪录p在allp内的索引</span></span><br><span class="line">    pp.id = id</span><br><span class="line">    <span class="comment">// 初始化，状态为_Pgcstop</span></span><br><span class="line">    pp.status = _Pgcstop</span><br><span class="line">    <span class="comment">// 0长度切片</span></span><br><span class="line">    pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 0长度切片</span></span><br><span class="line">    pp.deferpool = pp.deferpoolbuf[:<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 写屏障缓冲区</span></span><br><span class="line">    pp.wbBuf.reset()</span><br><span class="line">    <span class="comment">// mcache</span></span><br><span class="line">    <span class="keyword">if</span> pp.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是第一个p</span></span><br><span class="line">        <span class="keyword">if</span> id == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 全局变量未初始化</span></span><br><span class="line">            <span class="keyword">if</span> mcache0 == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;missing mcache?&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用全局变量</span></span><br><span class="line">            pp.mcache = mcache0</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 运行时创建</span></span><br><span class="line">			<span class="comment">// 从cachealloc分配器获取mcache</span></span><br><span class="line">            pp.mcache = allocmcache()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁初始化（定时器timers最小堆）</span></span><br><span class="line">    lockInit(&amp;pp.timers.mu, lockRankTimers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要p在使用，timerpMask就要标记该p</span></span><br><span class="line">    timerpMask.set(id)</span><br><span class="line">    <span class="comment">// p清理空闲标志，这个标记可以实时改</span></span><br><span class="line">    idlepMask.clear(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pidle-全局空闲链表"><a href="#pidle-全局空闲链表" class="headerlink" title="pidle-全局空闲链表"></a>pidle-全局空闲链表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把p放进空闲链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidleput</span><span class="params">(pp *p, now <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> !runqempty(pp) &#123;</span><br><span class="line">        throw(<span class="string">&quot;pidleput: P has non-empty run queue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// timers最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> pp.timers.<span class="built_in">len</span>.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 清除标记</span></span><br><span class="line">        timerpMask.clear(pp.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记为空闲状态</span></span><br><span class="line">    idlepMask.set(pp.id)</span><br><span class="line">    <span class="comment">// 设置next指针</span></span><br><span class="line">    pp.link = sched.pidle</span><br><span class="line">    <span class="comment">// 放到链表头部</span></span><br><span class="line">    sched.pidle.set(pp)</span><br><span class="line">    <span class="comment">// 空闲p数量+1</span></span><br><span class="line">    sched.npidle.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// stamp存储limiterEventIdle和now</span></span><br><span class="line">    <span class="keyword">if</span> !pp.limiterEvent.start(limiterEventIdle, now) &#123;</span><br><span class="line">        throw(<span class="string">&quot;must be able to track idle limiter event&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从空闲链表拿一个p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidleget</span><span class="params">(now <span class="type">int64</span>)</span></span> (*p, <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲p链表</span></span><br><span class="line">    pp := sched.pidle.ptr()</span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时刻</span></span><br><span class="line">        <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">            now = nanotime()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// timer可能随时都会加进来，非空闲状态都要设置</span></span><br><span class="line">        timerpMask.set(pp.id)</span><br><span class="line">        <span class="comment">// 取消空闲标记</span></span><br><span class="line">        idlepMask.clear(pp.id)</span><br><span class="line">        <span class="comment">// 把下一个pp放到pidle（这是一个链表）</span></span><br><span class="line">        sched.pidle = pp.link</span><br><span class="line">        <span class="comment">// 空闲p数量-1</span></span><br><span class="line">        sched.npidle.Add(<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// 重置stamp字段，纪录耗时</span></span><br><span class="line">        pp.limiterEvent.stop(limiterEventIdle, now)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pp, now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidlegetSpinning</span><span class="params">(now <span class="type">int64</span>)</span></span> (*p, <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲链表拿一个p</span></span><br><span class="line">    pp, now := pidleget(now)</span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 通知所有m，让其中一个m丢弃p，进入自旋等待</span></span><br><span class="line">        sched.needspinning.Store(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pp, now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p销毁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *p)</span></span> destroy() &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迁移本地队列</span></span><br><span class="line">    <span class="comment">// 本地队列不为空</span></span><br><span class="line">    <span class="keyword">for</span> pp.runqhead != pp.runqtail &#123;</span><br><span class="line">        <span class="comment">// tail索引</span></span><br><span class="line">        pp.runqtail--</span><br><span class="line">        <span class="comment">// g</span></span><br><span class="line">        gp := pp.runq[pp.runqtail%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">        <span class="comment">// 把g放到全局队列头部</span></span><br><span class="line">        globrunqputhead(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// runnext不为空</span></span><br><span class="line">    <span class="keyword">if</span> pp.runnext != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 把g放到全局队列头部</span></span><br><span class="line">        globrunqputhead(pp.runnext.ptr())</span><br><span class="line">        <span class="comment">// 重置runnext</span></span><br><span class="line">        pp.runnext = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迁移timers</span></span><br><span class="line">    <span class="comment">// 把最小堆里的timer全部迁移到当前p</span></span><br><span class="line">    getg().m.p.ptr().timers.take(&amp;pp.timers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">    <span class="comment">// GC运行中</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">        <span class="comment">// 扫描p.wbBuf，把标记好的数据放在p.gcw，最后清空p.wbBuf</span></span><br><span class="line">        wbBufFlush1(pp)</span><br><span class="line">        <span class="comment">// wbuf1、wbuf2根据容量选择放入work.empty或work.full队列</span></span><br><span class="line">        pp.gcw.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空sudog</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pp.sudogbuf &#123;</span><br><span class="line">        pp.sudogbuf[i] = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置为0长度切片</span></span><br><span class="line">    pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    pp.pinnerCache = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 清空defer</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> pp.deferpoolbuf &#123;</span><br><span class="line">        pp.deferpoolbuf[j] = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置为0长度切片</span></span><br><span class="line">    pp.deferpool = pp.deferpoolbuf[:<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// mcache</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 遍历mspancache</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pp.mspancache.<span class="built_in">len</span>; i++ &#123;</span><br><span class="line">			<span class="comment">// 放回spanalloc的空闲链表</span></span><br><span class="line">            mheap_.spanalloc.free(unsafe.Pointer(pp.mspancache.buf[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清0</span></span><br><span class="line">        pp.mspancache.<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">        lock(&amp;mheap_.lock)</span><br><span class="line">        <span class="comment">// 清空pcache</span></span><br><span class="line">        pp.pcache.flush(&amp;mheap_.pages)</span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// mcache相关字段清空并放回cachealloc分配器空闲链表</span></span><br><span class="line">    freemcache(pp.mcache)</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    pp.mcache = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 把本地gFree数据迁移到全局gFree里</span></span><br><span class="line">    gfpurge(pp)</span><br><span class="line">    <span class="comment">// 重置为0</span></span><br><span class="line">    pp.gcAssistTime = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 标记为_Pdead</span></span><br><span class="line">    pp.status = _Pdead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runq-本地goroutine队列"><a href="#runq-本地goroutine队列" class="headerlink" title="runq-本地goroutine队列"></a>runq-本地goroutine队列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把g放到本地队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqput</span><span class="params">(pp *p, gp *g, next <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// wasm（一般情况都有sysmon） and 放在队列首</span></span><br><span class="line">    <span class="keyword">if</span> !haveSysmon &amp;&amp; next &#123;</span><br><span class="line">        <span class="comment">// 放在队列尾</span></span><br><span class="line">        next = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般情况下raceenabled为false</span></span><br><span class="line">    <span class="comment">// raceenabled==true and 放在队列首 and 1/2的概率？</span></span><br><span class="line">    <span class="keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; randn(<span class="number">2</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 放在队列尾</span></span><br><span class="line">        next = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放在队列首</span></span><br><span class="line">    <span class="keyword">if</span> next &#123;</span><br><span class="line">    retryNext:</span><br><span class="line">        <span class="comment">// 纪录runnext</span></span><br><span class="line">        oldnext := pp.runnext</span><br><span class="line">        <span class="comment">// 尝试替换</span></span><br><span class="line">        <span class="keyword">if</span> !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;</span><br><span class="line">            <span class="comment">// 替换失败，重试</span></span><br><span class="line">            <span class="keyword">goto</span> retryNext</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换成功</span></span><br><span class="line">        <span class="comment">// 原runnext没有纪录，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> oldnext == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原runnext有G指针</span></span><br><span class="line">        <span class="comment">// 修改gp为原runnext，后面放在队列尾</span></span><br><span class="line">        gp = oldnext.ptr()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// head索引</span></span><br><span class="line">    h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire</span></span><br><span class="line">    <span class="comment">// tail索引</span></span><br><span class="line">    t := pp.runqtail</span><br><span class="line">    <span class="comment">// 没有超过runq的容量-256</span></span><br><span class="line">    <span class="keyword">if</span> t-h &lt; <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)) &#123;</span><br><span class="line">        <span class="comment">// 放在队列尾</span></span><br><span class="line">        pp.runq[t%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].set(gp)</span><br><span class="line">        <span class="comment">// 更新tail索引</span></span><br><span class="line">        atomic.StoreRel(&amp;pp.runqtail, t+<span class="number">1</span>) <span class="comment">// store-release</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过队列容量</span></span><br><span class="line">    <span class="comment">// 把一半的g放在调度器的全局队列</span></span><br><span class="line">    <span class="keyword">if</span> runqputslow(pp, gp, h, t) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 失败重试</span></span><br><span class="line">    <span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一半的g放在调度器的全局队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqputslow</span><span class="params">(pp *p, gp *g, h, t <span class="type">uint32</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// runq的一半+1个待入队的g</span></span><br><span class="line">    <span class="keyword">var</span> batch [<span class="built_in">len</span>(pp.runq)/<span class="number">2</span> + <span class="number">1</span>]*g</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总量</span></span><br><span class="line">    n := t - h</span><br><span class="line">    <span class="comment">// 一半</span></span><br><span class="line">    n = n / <span class="number">2</span></span><br><span class="line">    <span class="comment">// runq未满，异常</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)/<span class="number">2</span>) &#123;</span><br><span class="line">        throw(<span class="string">&quot;runqputslow: queue is not full&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿走一半的g</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        batch[i] = pp.runq[(h+i)%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新head索引</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <span class="comment">// cas-release</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 待入队的g放在尾部</span></span><br><span class="line">    batch[n] = gp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果raceenabled为true，忽略</span></span><br><span class="line">    <span class="keyword">if</span> randomizeScheduler &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">1</span>); i &lt;= n; i++ &#123;</span><br><span class="line">            j := cheaprandn(i + <span class="number">1</span>)</span><br><span class="line">            batch[i], batch[j] = batch[j], batch[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把这部份g链接起来作为一个链表</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        batch[i].schedlink.set(batch[i+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成gQueue类型</span></span><br><span class="line">    <span class="keyword">var</span> q gQueue</span><br><span class="line">    q.head.set(batch[<span class="number">0</span>])</span><br><span class="line">    q.tail.set(batch[n])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 把一批g放到全局队列</span></span><br><span class="line">    globrunqputbatch(&amp;q, <span class="type">int32</span>(n+<span class="number">1</span>))</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一批g放到本地队列尾部，如果本地队列满了放到全局队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqputbatch</span><span class="params">(pp *p, q *gQueue, qsize <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// head索引</span></span><br><span class="line">    h := atomic.LoadAcq(&amp;pp.runqhead)</span><br><span class="line">    <span class="comment">// tail索引</span></span><br><span class="line">    t := pp.runqtail</span><br><span class="line">    <span class="comment">// 已入队g数量</span></span><br><span class="line">    n := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 没有超过runq的容量-256</span></span><br><span class="line">    <span class="keyword">for</span> !q.empty() &amp;&amp; t-h &lt; <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)) &#123;</span><br><span class="line">        <span class="comment">// 待入队链表首个g</span></span><br><span class="line">        gp := q.pop()</span><br><span class="line">        <span class="comment">// 放入runq</span></span><br><span class="line">        pp.runq[t%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].set(gp)</span><br><span class="line">        <span class="comment">// 索引/计数器更新</span></span><br><span class="line">        t++</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列可能已满</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余待入队g数量</span></span><br><span class="line">    qsize -= <span class="type">int</span>(n)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果raceenabled为true，忽略</span></span><br><span class="line">    <span class="keyword">if</span> randomizeScheduler &#123;</span><br><span class="line">        off := <span class="function"><span class="keyword">func</span><span class="params">(o <span class="type">uint32</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (pp.runqtail + o) % <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">1</span>); i &lt; n; i++ &#123;</span><br><span class="line">            j := cheaprandn(i + <span class="number">1</span>)</span><br><span class="line">            pp.runq[off(i)], pp.runq[off(j)] = pp.runq[off(j)], pp.runq[off(i)]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新tail索引</span></span><br><span class="line">    atomic.StoreRel(&amp;pp.runqtail, t)</span><br><span class="line">    <span class="comment">// q队列不为空，也就是说还有g没有入队</span></span><br><span class="line">    <span class="keyword">if</span> !q.empty() &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 把一批g放到全局队列</span></span><br><span class="line">        globrunqputbatch(q, <span class="type">int32</span>(qsize))</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从p的runq拿一个g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqget</span><span class="params">(pp *p)</span></span> (gp *g, inheritTime <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// runnext有数据，直接返回</span></span><br><span class="line">    next := pp.runnext</span><br><span class="line">    <span class="comment">// runnext不为0 and 原子替换出runnext</span></span><br><span class="line">    <span class="keyword">if</span> next != <span class="number">0</span> &amp;&amp; pp.runnext.cas(next, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功拿到runnext</span></span><br><span class="line">        <span class="keyword">return</span> next.ptr(), <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// head索引</span></span><br><span class="line">        h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire</span></span><br><span class="line">        <span class="comment">// tail索引</span></span><br><span class="line">        t := pp.runqtail</span><br><span class="line">        <span class="comment">// 队列为空</span></span><br><span class="line">        <span class="keyword">if</span> t == h &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿队列第一个</span></span><br><span class="line">        gp := pp.runq[h%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">        <span class="comment">// 更新head索引</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+<span class="number">1</span>) &#123; <span class="comment">// cas-release</span></span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽走p本地队列所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqdrain</span><span class="params">(pp *p)</span></span> (drainQ gQueue, n <span class="type">uint32</span>) &#123;</span><br><span class="line">    <span class="comment">// 原runnext</span></span><br><span class="line">    oldNext := pp.runnext</span><br><span class="line">    <span class="comment">// double-check and 原子替换出runnext</span></span><br><span class="line">    <span class="keyword">if</span> oldNext != <span class="number">0</span> &amp;&amp; pp.runnext.cas(oldNext, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 放进队列</span></span><br><span class="line">        drainQ.pushBack(oldNext.ptr())</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// head索引</span></span><br><span class="line">    h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire</span></span><br><span class="line">    <span class="comment">// tail索引</span></span><br><span class="line">    t := pp.runqtail</span><br><span class="line">    <span class="comment">// 本地队列数据量</span></span><br><span class="line">    qn := t - h</span><br><span class="line">    <span class="comment">// 本地队列为空</span></span><br><span class="line">    <span class="keyword">if</span> qn == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据不一致</span></span><br><span class="line">    <span class="keyword">if</span> qn &gt; <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)) &#123;</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> retry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先更新索引，因为可能会跟runqsteal并行运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新head索引</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+qn) &#123; <span class="comment">// cas-release</span></span><br><span class="line">        <span class="comment">// 失败重试</span></span><br><span class="line">        <span class="keyword">goto</span> retry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有g放进drainQ队列</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; qn; i++ &#123;</span><br><span class="line">        gp := pp.runq[(h+i)%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">        drainQ.pushBack(gp)</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定p的本地队列偷走一半g</span></span><br><span class="line"><span class="comment">// pp是其他p</span></span><br><span class="line"><span class="comment">// batch是当前p的runq指针</span></span><br><span class="line"><span class="comment">// batchHead是当前p的runq的尾索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqgrab</span><span class="params">(pp *p, batch *[256]guintptr, batchHead <span class="type">uint32</span>, stealRunNextG <span class="type">bool</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// head索引</span></span><br><span class="line">        h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire</span></span><br><span class="line">        <span class="comment">// tail索引</span></span><br><span class="line">        t := atomic.LoadAcq(&amp;pp.runqtail) <span class="comment">// load-acquire</span></span><br><span class="line">        <span class="comment">// 总量</span></span><br><span class="line">        n := t - h</span><br><span class="line">        <span class="comment">// 一半</span></span><br><span class="line">        n = n - n/<span class="number">2</span></span><br><span class="line">        <span class="comment">// runq为空</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果需要把pp.runnext偷走</span></span><br><span class="line">            <span class="keyword">if</span> stealRunNextG &#123;</span><br><span class="line">                <span class="comment">// pp.runnext有数据</span></span><br><span class="line">                <span class="keyword">if</span> next := pp.runnext; next != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// p的状态为_Prunning</span></span><br><span class="line">                    <span class="keyword">if</span> pp.status == _Prunning &#123;</span><br><span class="line">                        <span class="comment">// 睡眠3us，确保当前g还在忙碌，没空执行runnext</span></span><br><span class="line">                        <span class="comment">// osHasLowResTimer一般为false</span></span><br><span class="line">                        <span class="keyword">if</span> !osHasLowResTimer &#123;</span><br><span class="line">                            usleep(<span class="number">3</span>)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 其他平台的定时器的颗粒度是1-15ms，太大了，不适合</span></span><br><span class="line">                            <span class="comment">// 主动让出CPU，让OS选择其他线程运行（微秒级到毫秒级）</span></span><br><span class="line">                            osyield()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原子替换出runnext</span></span><br><span class="line">                    <span class="keyword">if</span> !pp.runnext.cas(next, <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 替换失败，重试</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 只偷走runnext</span></span><br><span class="line">                    batch[batchHead%<span class="type">uint32</span>(<span class="built_in">len</span>(batch))] = next</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不需要偷走runnext，返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// runq不为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据前后不一致</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿走一半的g</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">            <span class="comment">// g</span></span><br><span class="line">            g := pp.runq[(h+i)%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))]</span><br><span class="line">            <span class="comment">// 放到当前p.runq</span></span><br><span class="line">            batch[(batchHead+i)%<span class="type">uint32</span>(<span class="built_in">len</span>(batch))] = g</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新head索引</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <span class="comment">// cas-release</span></span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从p2的runq偷走一半的g放到p的runq，最后返回一个g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqsteal</span><span class="params">(pp, p2 *p, stealRunNextG <span class="type">bool</span>)</span></span> *g &#123;</span><br><span class="line">    <span class="comment">// tail索引</span></span><br><span class="line">    t := pp.runqtail</span><br><span class="line">    <span class="comment">// 从p2的本地队列偷走一半的g</span></span><br><span class="line">    n := runqgrab(p2, &amp;pp.runq, t, stealRunNextG)</span><br><span class="line">    <span class="comment">// 没偷到</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [0,n)</span></span><br><span class="line">    n--</span><br><span class="line">    <span class="comment">// 拿最后一个g</span></span><br><span class="line">    gp := pp.runq[(t+n)%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">    <span class="comment">// 总共才偷到一个g</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偷到多个g的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// head索引</span></span><br><span class="line">    h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire</span></span><br><span class="line">    <span class="comment">// 超过队列容量，异常</span></span><br><span class="line">    <span class="keyword">if</span> t-h+n &gt;= <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)) &#123;</span><br><span class="line">        throw(<span class="string">&quot;runqsteal: runq overflow&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新tail索引</span></span><br><span class="line">    atomic.StoreRel(&amp;pp.runqtail, t+n) <span class="comment">// store-release</span></span><br><span class="line">    <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调度器相关"><a href="#调度器相关" class="headerlink" title="调度器相关"></a>调度器相关</h3><h4 id="g-m挂起、唤醒"><a href="#g-m挂起、唤醒" class="headerlink" title="g&#x2F;m挂起、唤醒"></a>g&#x2F;m挂起、唤醒</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同协程yield关键字，当前g让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 该函数只在wasm有效</span></span><br><span class="line">    checkTimeouts()</span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行gosched_m函数</span></span><br><span class="line">    <span class="comment">// 当前g、m解除绑定，g交给其他空闲m执行，当前m重新寻找并运行可运行的g</span></span><br><span class="line">    mcall(gosched_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前g、m解除绑定，g交给其他空闲m执行，当前m重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gosched_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 非抢占</span></span><br><span class="line">    <span class="comment">// 当前g、m解除绑定，g交给其他空闲m执行，当前m重新寻找并运行可运行的g</span></span><br><span class="line">    goschedImpl(gp, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前g、m解除绑定，g交给其他空闲m执行，当前m重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g, preempted <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态</span></span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="comment">// 异常，_Grunning位未设置</span></span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">&quot;bad g status&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Grunnable</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 把g放到全局队列尾部</span></span><br><span class="line">    globrunqput(gp)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtime已执行初始化，允许newproc创建运行M</span></span><br><span class="line">    <span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">        <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        wakep()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前g让出CPU，g0执行调度运行其他g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span></span> <span class="type">bool</span>, lock unsafe.Pointer, reason waitReason, traceReason traceBlockReason, traceskip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 非time.Sleep</span></span><br><span class="line">    <span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">        <span class="comment">// 该函数只在wasm有效</span></span><br><span class="line">        checkTimeouts()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    gp := mp.curg</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态</span></span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="comment">// 异常，_Grunning位未设置</span></span><br><span class="line">    <span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">        throw(<span class="string">&quot;gopark: bad g status&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 纪录解锁函数、参数等信息</span></span><br><span class="line">    mp.waitlock = lock</span><br><span class="line">    mp.waitunlockf = unlockf</span><br><span class="line">    gp.waitreason = reason</span><br><span class="line">    mp.waitTraceBlockReason = traceReason</span><br><span class="line">    mp.waitTraceSkip = traceskip</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行park_m函数</span></span><br><span class="line">    mcall(park_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放到本地队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goready</span><span class="params">(gp *g, traceskip <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 将g放到p.runq队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        <span class="comment">// 放到队列头部</span></span><br><span class="line">        ready(gp, traceskip, <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放到p.runq队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ready</span><span class="params">(gp *g, traceskip <span class="type">int</span>, next <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态</span></span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 预期状态是_Gwaiting，异常</span></span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Gwaiting &#123;</span><br><span class="line">        <span class="comment">// 打印g状态</span></span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">&quot;bad g-&gt;status in ready&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把g放到本地队列，根据next判断放在首尾</span></span><br><span class="line">    runqput(mp.p.ptr(), gp, next)</span><br><span class="line">    <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    wakep()</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放回本地队列尾部，重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goyield</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 该函数只在wasm有效</span></span><br><span class="line">    checkTimeouts()</span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行goyield_m函数</span></span><br><span class="line">    <span class="comment">// 将g放回本地队列尾部，重新寻找并运行可运行的g</span></span><br><span class="line">    mcall(goyield_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放回本地队列尾部，重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goyield_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Grunnable</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line">    <span class="comment">// 把g放到本地队列尾部</span></span><br><span class="line">    runqput(pp, gp, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m挂起休眠，等待唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mPark</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// semaphore，只有g0可以执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起休眠（m放在m.park.key），标记blocked为true</span></span><br><span class="line">    notesleep(&amp;gp.m.park)</span><br><span class="line">    <span class="comment">// 被notewakeup唤醒，标记blocked为false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将m.park.key重置为0</span></span><br><span class="line">    noteclear(&amp;gp.m.park)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除绑定、修改状态、运行调度函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    sg := gp.syncGroup</span><br><span class="line">    <span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        sg.incActive()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Gwaiting</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁函数</span></span><br><span class="line">    <span class="keyword">if</span> fn := mp.waitunlockf; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 执行是否成功</span></span><br><span class="line">        ok := fn(gp, mp.waitlock)</span><br><span class="line">        <span class="comment">// 移除函数及其参数数据</span></span><br><span class="line">        mp.waitunlockf = <span class="literal">nil</span></span><br><span class="line">        mp.waitlock = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="comment">// 测试，忽略</span></span><br><span class="line">            <span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">                sg.decActive()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line">            execute(gp, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        sg.decActive()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g、m解除绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dropg</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    setMNoWB(&amp;gp.m.curg.m, <span class="literal">nil</span>)</span><br><span class="line">    setGNoWB(&amp;gp.m.curg, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取p"><a href="#获取p" class="headerlink" title="获取p"></a>获取p</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 期望nmspinning为0，且nmspinning+=1成功</span></span><br><span class="line">    <span class="keyword">if</span> sched.nmspinning.Load() != <span class="number">0</span> || !sched.nmspinning.CompareAndSwap(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时nmspinning=1</span></span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pp *p</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">    pp, _ = pidlegetSpinning(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 没拿到</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 复原，nmspinning-=1</span></span><br><span class="line">        <span class="keyword">if</span> sched.nmspinning.Add(<span class="number">-1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 小于0，异常</span></span><br><span class="line">            throw(<span class="string">&quot;wakep: negative nmspinning&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">    startm(pp, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有一个p是忙碌的，从剩余空闲p中拿走一个（可能拿不到）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkRunqsNoP</span><span class="params">(allpSnapshot []*p, idlepMaskSnapshot pMask)</span></span> *p &#123;</span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> id, p2 := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">        <span class="comment">// p2忙碌中 and p2的本地队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> !idlepMaskSnapshot.read(<span class="type">uint32</span>(id)) &amp;&amp; !runqempty(p2) &#123;</span><br><span class="line">            <span class="comment">// 调度器加锁</span></span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">            pp, _ := pidlegetSpinning(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 没拿到p</span></span><br><span class="line">            <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 剩下的p也不用找了</span></span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了</span></span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">return</span> pp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的p都处于默认空闲状态或者runq为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到所有p中的最小pollUntil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkTimersNoP</span><span class="params">(allpSnapshot []*p, timerpMaskSnapshot pMask, pollUntil <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> id, p2 := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">        <span class="comment">// p2可能有timer</span></span><br><span class="line">        <span class="keyword">if</span> timerpMaskSnapshot.read(<span class="type">uint32</span>(id)) &#123;</span><br><span class="line">            <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">            w := p2.timers.wakeTime()</span><br><span class="line">            <span class="comment">// w也是pollUntil</span></span><br><span class="line">            <span class="comment">// pollUntil = min(pollUntil, w)</span></span><br><span class="line">            <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">                pollUntil = w</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有p中的最小值</span></span><br><span class="line">    <span class="keyword">return</span> pollUntil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果GC已启动且有空闲的标记g，获取p和g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkIdleGCNoP</span><span class="params">()</span></span> (*p, *g) &#123;</span><br><span class="line">    <span class="comment">// GC未启动/停止 or 计数器已超限</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;gcBlackenEnabled) == <span class="number">0</span> || !gcController.needIdleMarkWorker() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有标记任务可以执行</span></span><br><span class="line">    <span class="keyword">if</span> !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">    pp, now := pidlegetSpinning(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 没拿到</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC未启动/停止 or idleMarkWorkers计数器加1成功</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> || !gcController.addIdleMarkWorker() &#123;</span><br><span class="line">        <span class="comment">// 把p放进空闲链表</span></span><br><span class="line">        pidleput(pp, now)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 把p放进空闲链表</span></span><br><span class="line">        pidleput(pp, now)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 恢复状态，idleMarkWorkers计数器减1</span></span><br><span class="line">        gcController.removeIdleMarkWorker()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pp, node.gp.ptr()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="偷取任务"><a href="#偷取任务" class="headerlink" title="偷取任务"></a>偷取任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试从所有其他p偷取g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stealWork</span><span class="params">(now <span class="type">int64</span>)</span></span> (gp *g, inheritTime <span class="type">bool</span>, rnow, pollUntil <span class="type">int64</span>, newWork <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有执行过timer</span></span><br><span class="line">    ranTimer := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多尝试4次</span></span><br><span class="line">    <span class="keyword">const</span> stealTries = <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; stealTries; i++ &#123;</span><br><span class="line">        <span class="comment">// 如果是最后一次，偷取timer或者runnext</span></span><br><span class="line">        stealTimersOrRunNextG := i == stealTries<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机选一个p</span></span><br><span class="line">        <span class="keyword">for</span> enum := stealOrder.start(cheaprand()); !enum.done(); enum.next() &#123;</span><br><span class="line">            <span class="comment">// STW，当前p释放到空闲队列</span></span><br><span class="line">            <span class="keyword">if</span> sched.gcwaiting.Load() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, now, pollUntil, <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p2</span></span><br><span class="line">            p2 := allp[enum.position()]</span><br><span class="line">            <span class="comment">// 同一个p</span></span><br><span class="line">            <span class="keyword">if</span> pp == p2 &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果需要偷取timer或者runnext and p可能有timer</span></span><br><span class="line">            <span class="keyword">if</span> stealTimersOrRunNextG &amp;&amp; timerpMask.read(enum.position()) &#123;</span><br><span class="line">                <span class="comment">// 定时器p.timers检查</span></span><br><span class="line">                <span class="comment">// 清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行</span></span><br><span class="line">                tnow, w, ran := p2.timers.check(now)</span><br><span class="line">                <span class="comment">// 当前时刻</span></span><br><span class="line">                now = tnow</span><br><span class="line">                <span class="comment">// w也是pollUntil</span></span><br><span class="line">                <span class="comment">// pollUntil = min(pollUntil, w)</span></span><br><span class="line">                <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">                    pollUntil = w</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果有执行过timer，有g被放到runq</span></span><br><span class="line">                <span class="keyword">if</span> ran &#123;</span><br><span class="line">                    <span class="comment">// 从p2的runq拿一个g</span></span><br><span class="line">                    <span class="keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="comment">// 成功</span></span><br><span class="line">                        <span class="comment">// 这里的ranTimer是不是应该改为true？</span></span><br><span class="line">                        <span class="keyword">return</span> gp, inheritTime, now, pollUntil, ranTimer</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 没拿到</span></span><br><span class="line">                    <span class="comment">// 标记，表示有执行过timer</span></span><br><span class="line">                    ranTimer = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非空闲状态，如果p2处于默认的空闲状态，则不处理</span></span><br><span class="line">            <span class="keyword">if</span> !idlepMask.read(enum.position()) &#123;</span><br><span class="line">                <span class="comment">// 从p2的runq偷走一半的g放到p的runq，最后返回一个g</span></span><br><span class="line">                <span class="keyword">if</span> gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// 偷到了</span></span><br><span class="line">                    <span class="keyword">return</span> gp, <span class="literal">false</span>, now, pollUntil, ranTimer</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, now, pollUntil, ranTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runq-全局队列"><a href="#runq-全局队列" class="headerlink" title="runq-全局队列"></a>runq-全局队列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把g放到全局队列尾部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqput</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到全局队列末尾</span></span><br><span class="line">    sched.runq.pushBack(gp)</span><br><span class="line">    <span class="comment">// 计数器+1</span></span><br><span class="line">    sched.runqsize++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把g放到全局队列头部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqputhead</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到全局队列头部</span></span><br><span class="line">    sched.runq.push(gp)</span><br><span class="line">    <span class="comment">// 计数器+1</span></span><br><span class="line">    sched.runqsize++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一批g放到全局队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqputbatch</span><span class="params">(batch *gQueue, n <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把q2链表放到q链表末尾</span></span><br><span class="line">    sched.runq.pushBackAll(*batch)</span><br><span class="line">    <span class="comment">// 计数器+n</span></span><br><span class="line">    sched.runqsize += n</span><br><span class="line">    <span class="comment">// 数据清理</span></span><br><span class="line">    *batch = gQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从全局队列获取一批p放到本地队列，返回第一个g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqget</span><span class="params">(pp *p, max <span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局队列为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按p数量均分</span></span><br><span class="line">    n := sched.runqsize/gomaxprocs + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 边界处理</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; sched.runqsize &#123;</span><br><span class="line">        n = sched.runqsize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最多max个g</span></span><br><span class="line">    <span class="keyword">if</span> max &gt; <span class="number">0</span> &amp;&amp; n &gt; max &#123;</span><br><span class="line">        n = max</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最多128个g</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="type">int32</span>(<span class="built_in">len</span>(pp.runq))/<span class="number">2</span> &#123;</span><br><span class="line">        n = <span class="type">int32</span>(<span class="built_in">len</span>(pp.runq)) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器-n</span></span><br><span class="line">    sched.runqsize -= n</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿链表第一个g</span></span><br><span class="line">    gp := sched.runq.pop()</span><br><span class="line">    <span class="comment">// 总量-1</span></span><br><span class="line">    n--</span><br><span class="line">    <span class="comment">// 如果剩余总量不为0</span></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">        <span class="comment">// 一次拿一个g</span></span><br><span class="line">        gp1 := sched.runq.pop()</span><br><span class="line">        <span class="comment">// 把g放到本地队列尾部</span></span><br><span class="line">        runqput(pp, gp1, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回第一个g</span></span><br><span class="line">    <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectglist</span><span class="params">(glist *gList)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 为空，不处理</span></span><br><span class="line">    <span class="keyword">if</span> glist.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个g</span></span><br><span class="line">    head := glist.head.ptr()</span><br><span class="line">    <span class="keyword">var</span> tail *g</span><br><span class="line">    qsize := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到队列的尾部、计算数据量、g状态修改</span></span><br><span class="line">    <span class="keyword">for</span> gp := head; gp != <span class="literal">nil</span>; gp = gp.schedlink.ptr() &#123;</span><br><span class="line">        tail = gp</span><br><span class="line">        qsize++</span><br><span class="line">        <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gList转换为gQueue</span></span><br><span class="line">    <span class="keyword">var</span> q gQueue</span><br><span class="line">    q.head.set(head)</span><br><span class="line">    q.tail.set(tail)</span><br><span class="line">    *glist = gList&#123;&#125;</span><br><span class="line"></span><br><span class="line">    startIdle := <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            mp := acquirem()</span><br><span class="line">            <span class="comment">// 调度器加锁</span></span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">            pp, _ := pidlegetSpinning(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 没拿到p</span></span><br><span class="line">            <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁，返回</span></span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                releasem(mp)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">            startm(pp, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            releasem(mp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有p</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 把一批g放到全局队列</span></span><br><span class="line">        globrunqputbatch(&amp;q, <span class="type">int32</span>(qsize))</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 尝试唤醒m处理</span></span><br><span class="line">        startIdle(qsize)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲p数量</span></span><br><span class="line">    npidle := <span class="type">int</span>(sched.npidle.Load())</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        globq gQueue</span><br><span class="line">        n     <span class="type">int</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 拿一批最多与空闲p数量相等的g</span></span><br><span class="line">    <span class="keyword">for</span> n = <span class="number">0</span>; n &lt; npidle &amp;&amp; !q.empty(); n++ &#123;</span><br><span class="line">        g := q.pop()</span><br><span class="line">        globq.pushBack(g)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有空闲p</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 把上面这批g放到全局队列</span></span><br><span class="line">        globrunqputbatch(&amp;globq, <span class="type">int32</span>(n))</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 尝试唤醒m处理</span></span><br><span class="line">        startIdle(n)</span><br><span class="line">        <span class="comment">// 剩余g数量</span></span><br><span class="line">        qsize -= n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// q队列不为空，也就是说还有g没有入队</span></span><br><span class="line">    <span class="keyword">if</span> !q.empty() &#123;</span><br><span class="line">        <span class="comment">// 把一批g放到本地队列尾部，如果本地队列满了放到全局队列</span></span><br><span class="line">        runqputbatch(pp, &amp;q, qsize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    wakep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="g-m绑定、解绑"><a href="#g-m绑定、解绑" class="headerlink" title="g&#x2F;m绑定、解绑"></a>g&#x2F;m绑定、解绑</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计数器m.lockedInt+=1</span></span><br><span class="line">    getg().m.lockedInt++</span><br><span class="line">    dolockOSThread()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dolockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放在lockedg、lockedm，双向绑定</span></span><br><span class="line">    gp.m.lockedg.set(gp)</span><br><span class="line">    gp.lockedm.set(gp.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unlockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.lockedInt == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        systemstack(badunlockosthread)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器m.lockedInt-=1</span></span><br><span class="line">    gp.m.lockedInt--</span><br><span class="line">    <span class="comment">// 重置lockedg、lockedm</span></span><br><span class="line">    dounlockOSThread()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dounlockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 计数器m.lockedInt不为0，不处理</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.lockedInt != <span class="number">0</span> || gp.m.lockedExt != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    gp.m.lockedg = <span class="number">0</span></span><br><span class="line">    gp.lockedm = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让出p给lockedm并唤醒，把当前m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startlockedm</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// m</span></span><br><span class="line">    mp := gp.lockedm.ptr()</span><br><span class="line">    <span class="comment">// m跟当前g的m不一样</span></span><br><span class="line">    <span class="keyword">if</span> mp == getg().m &#123;</span><br><span class="line">        throw(<span class="string">&quot;startlockedm: locked to me&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nextp有数据</span></span><br><span class="line">    <span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;startlockedm: m has p&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 空闲的locked的m数量-=1</span></span><br><span class="line">    incidlelocked(<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">    pp := releasep()</span><br><span class="line">    <span class="comment">// nextp设置为p</span></span><br><span class="line">    mp.nextp.set(pp)</span><br><span class="line">    <span class="comment">// 唤醒m（m放在m.park.key）</span></span><br><span class="line">    notewakeup(&amp;mp.park)</span><br><span class="line">    <span class="comment">// 把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">    stopm()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m让出p并挂起休眠，直到lockedg状态变为可运行，被唤醒后绑定一个p返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stoplockedm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.lockedg为0（不为0才会走到这里） or g.lockedm不是当前m</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.lockedg == <span class="number">0</span> || gp.m.lockedg.ptr().lockedm.ptr() != gp.m &#123;</span><br><span class="line">        throw(<span class="string">&quot;stoplockedm: inconsistent locking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p不为空，把这个p给其他m</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">        pp := releasep()</span><br><span class="line">        <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">        handoffp(pp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复原，空闲的locked的m数量+=1，检查是否存在死锁</span></span><br><span class="line">    incidlelocked(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// m挂起休眠，等待唤醒</span></span><br><span class="line">    mPark()</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取locked的g.atomicstatus状态</span></span><br><span class="line">    status := readgstatus(gp.m.lockedg.ptr())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果状态不是_Grunnable，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunnable &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime:stoplockedm: lockedg (atomicstatus=&quot;</span>, status, <span class="string">&quot;) is not Grunnable or Gscanrunnable\n&quot;</span>)</span><br><span class="line">        dumpgstatus(gp.m.lockedg.ptr())</span><br><span class="line">        throw(<span class="string">&quot;stoplockedm: not runnable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">    acquirep(gp.m.nextp.ptr())</span><br><span class="line">    <span class="comment">// 重置nextp</span></span><br><span class="line">    gp.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲的locked的m数量调整</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incidlelocked</span><span class="params">(v <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.nmidlelocked += v</span><br><span class="line">    <span class="comment">// v为-1时加锁，为1时是解锁</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">        checkdead()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="m-p绑定、解绑"><a href="#m-p绑定、解绑" class="headerlink" title="m&#x2F;p绑定、解绑"></a>m&#x2F;p绑定、解绑</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquirep</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 绑定m和p</span></span><br><span class="line">    wirep(pp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启写屏障</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理p.mcache</span></span><br><span class="line">    pp.mcache.prepareForSweep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定m和p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wirep</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m已经跟其他p绑定</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;wirep: already in go&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p也有其他m绑定着 or p的状态不是默认的_Pidle</span></span><br><span class="line">    <span class="keyword">if</span> pp.m != <span class="number">0</span> || pp.status != _Pidle &#123;</span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            id := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> pp.m != <span class="number">0</span> &#123;</span><br><span class="line">                id = pp.m.ptr().id</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;wirep: p-&gt;m=&quot;</span>, pp.m, <span class="string">&quot;(&quot;</span>, id, <span class="string">&quot;) p-&gt;status=&quot;</span>, pp.status, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;wirep: invalid p state&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.p绑定p</span></span><br><span class="line">    gp.m.p.set(pp)</span><br><span class="line">    <span class="comment">// p.m绑定m</span></span><br><span class="line">    pp.m.set(gp.m)</span><br><span class="line">    <span class="comment">// 从_Pidle状态改为_Prunning</span></span><br><span class="line">    pp.status = _Prunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消p与m的绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releasep</span><span class="params">()</span></span> *p &#123;</span><br><span class="line">    <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">    <span class="keyword">return</span> releasepNoTrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消p与m的绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releasepNoTrace</span><span class="params">()</span></span> *p &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g.m.p不为0才会走到这里</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;releasep: invalid arg&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line">    <span class="comment">// p.m不是当前m or p.status不是_Prunning</span></span><br><span class="line">    <span class="keyword">if</span> pp.m.ptr() != gp.m || pp.status != _Prunning &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;releasep: m=&quot;</span>, gp.m, <span class="string">&quot; m-&gt;p=&quot;</span>, gp.m.p.ptr(), <span class="string">&quot; p-&gt;m=&quot;</span>, hex(pp.m), <span class="string">&quot; p-&gt;status=&quot;</span>, pp.status, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;releasep: invalid p state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m.p取消绑定</span></span><br><span class="line">    gp.m.p = <span class="number">0</span></span><br><span class="line">    <span class="comment">// p.m取消绑定</span></span><br><span class="line">    pp.m = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 重置为默认状态_Pidle</span></span><br><span class="line">    pp.status = _Pidle</span><br><span class="line">    <span class="keyword">return</span> pp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoffp</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 本地队列不为空 or 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> !runqempty(pp) || sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">        startm(pp, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动 and 还有标记任务可以执行</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(pp) &#123;</span><br><span class="line">        <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">        startm(pp, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有任务可以执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋等待的m</span></span><br><span class="line">    <span class="keyword">if</span> sched.nmspinning.Load()+sched.npidle.Load() == <span class="number">0</span> &amp;&amp; sched.nmspinning.CompareAndSwap(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 重置，其他m不需要自旋让出p</span></span><br><span class="line">        sched.needspinning.Store(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">        startm(pp, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// STW，当前p释放到空闲队列</span></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting.Load() &#123;</span><br><span class="line">        <span class="comment">// 状态改为_Pgcstop</span></span><br><span class="line">        pp.status = _Pgcstop</span><br><span class="line">        <span class="comment">// p的停止时间</span></span><br><span class="line">        pp.gcStopTime = nanotime()</span><br><span class="line">        <span class="comment">// 待_Pgcstop的p数量-1</span></span><br><span class="line">        sched.stopwait--</span><br><span class="line">        <span class="comment">// 所有p已_Pgcstop</span></span><br><span class="line">        <span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 唤醒m（m放在stopnote.key）执行GC</span></span><br><span class="line">            notewakeup(&amp;sched.stopnote)</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// GC标志需要执行safePointFn and 重置runSafePointFn成功</span></span><br><span class="line">    <span class="keyword">if</span> pp.runSafePointFn != <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;pp.runSafePointFn, <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行safePointFn</span></span><br><span class="line">        sched.safePointFn(pp)</span><br><span class="line">        <span class="comment">// 计数器safePointWait-=1（safePointWait=gomaxprocs-1）</span></span><br><span class="line">        sched.safePointWait--</span><br><span class="line">        <span class="comment">// 如果是最后一个p（其他p都已经执行了safePointFn）</span></span><br><span class="line">        <span class="keyword">if</span> sched.safePointWait == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 唤醒m（m放在safePointNote.key）</span></span><br><span class="line">            notewakeup(&amp;sched.safePointNote)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">        startm(pp, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p是最后一放入空闲队列的（其他p都在空闲队列） and 当前没有进行netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> sched.npidle.Load() == gomaxprocs<span class="number">-1</span> &amp;&amp; sched.lastpoll.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">        startm(pp, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p不是最后一个放进空闲队列的 or 正在执行netpoll轮询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">    when := pp.timers.wakeTime()</span><br><span class="line">    <span class="comment">// 把p放进空闲链表</span></span><br><span class="line">    pidleput(pp, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> when != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果正在轮询netpoll且有更早过期的事件，中断netpoll轮询。如果没有轮询netpoll，则从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        wakeNetPoller(when)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="netpoll"><a href="#netpoll" class="headerlink" title="netpoll"></a>netpoll</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果正在轮询netpoll且有更早过期的事件，中断netpoll轮询。如果没有轮询netpoll，则从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakeNetPoller</span><span class="params">(when <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 正在轮询netpoll中</span></span><br><span class="line">    <span class="keyword">if</span> sched.lastpoll.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        pollerPollUntil := sched.pollUntil.Load()</span><br><span class="line">        <span class="comment">// 轮询完毕 or 有更早过期的事件</span></span><br><span class="line">        <span class="keyword">if</span> pollerPollUntil == <span class="number">0</span> || pollerPollUntil &gt; when &#123;</span><br><span class="line">            <span class="comment">// 中断netpoll轮询</span></span><br><span class="line">            netpollBreak()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非plan9</span></span><br><span class="line">        <span class="keyword">if</span> GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">            wakep()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行safePointFn，如果是最后一个p，则唤醒safePointNote</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runSafePointFn</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置runSafePointFn</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;p.runSafePointFn, <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行safePointFn</span></span><br><span class="line">    sched.safePointFn(p)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 计数器safePointWait-=1（safePointWait=gomaxprocs-1）</span></span><br><span class="line">    sched.safePointWait--</span><br><span class="line">    <span class="comment">// 如果是最后一个p（其他p都已经执行了safePointFn）</span></span><br><span class="line">    <span class="keyword">if</span> sched.safePointWait == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒m（m放在safePointNote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.safePointNote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="寄存器数据保存"><a href="#寄存器数据保存" class="headerlink" title="寄存器数据保存"></a>寄存器数据保存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存到sched字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">(pc, sp, bp <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是g0或者是gsignal</span></span><br><span class="line">    <span class="keyword">if</span> gp == gp.m.g0 || gp == gp.m.gsignal &#123;</span><br><span class="line">        throw(<span class="string">&quot;save on system g not allowed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存到sched字段</span></span><br><span class="line">    gp.sched.pc = pc</span><br><span class="line">    gp.sched.sp = sp</span><br><span class="line">    gp.sched.lr = <span class="number">0</span></span><br><span class="line">    gp.sched.ret = <span class="number">0</span></span><br><span class="line">    gp.sched.bp = bp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保ctxt为0</span></span><br><span class="line">    <span class="keyword">if</span> gp.sched.ctxt != <span class="literal">nil</span> &#123;</span><br><span class="line">        badctxt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抢占相关"><a href="#抢占相关" class="headerlink" title="抢占相关"></a>抢占相关</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历p，抢占超时的g、回收阻塞在syscall的p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="type">int64</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="comment">// 强制回收p的数量</span></span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allp加锁</span></span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历allp，因为会临时解锁，不能用range</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">        <span class="comment">// p</span></span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="comment">// 扩容中</span></span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 不处理当前p</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sysmon纪录的的当前p的调度次数</span></span><br><span class="line">        pd := &amp;pp.sysmontick</span><br><span class="line">        <span class="comment">// 下面只判断_Prunning、_Psyscall两种状态</span></span><br><span class="line">        s := pp.status</span><br><span class="line">        <span class="comment">// m是否进入syscall</span></span><br><span class="line">        sysretake := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s == _Prunning || s == _Psyscall &#123;</span><br><span class="line">            <span class="comment">// p的调度次数</span></span><br><span class="line">            t := <span class="type">int64</span>(pp.schedtick)</span><br><span class="line">            <span class="comment">// p的调度次数跟sysmon纪录的的调度次数不一致</span></span><br><span class="line">            <span class="keyword">if</span> <span class="type">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">                <span class="comment">// 同步调度次数</span></span><br><span class="line">                pd.schedtick = <span class="type">uint32</span>(t)</span><br><span class="line">                pd.schedwhen = now</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;</span><br><span class="line">                <span class="comment">// 调度次数一致，但超时了（10ms）</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置g、p抢占标志、发送抢占信号给m</span></span><br><span class="line">                preemptone(pp)</span><br><span class="line">                <span class="comment">// m进入syscall，preemptone失效</span></span><br><span class="line">                sysretake = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// syscall时重试</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line">            <span class="comment">// p的syscall次数</span></span><br><span class="line">            t := <span class="type">int64</span>(pp.syscalltick)</span><br><span class="line">            <span class="comment">// m没有进入syscall and p与sysmon纪录的syscall次数不一致</span></span><br><span class="line">            <span class="keyword">if</span> !sysretake &amp;&amp; <span class="type">int64</span>(pd.syscalltick) != t &#123;</span><br><span class="line">                <span class="comment">// 同步syscall次数</span></span><br><span class="line">                pd.syscalltick = <span class="type">uint32</span>(t)</span><br><span class="line">                pd.syscallwhen = now</span><br><span class="line">                <span class="comment">// 不处理当前p</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// m进入syscall or p与sysmon纪录的syscall次数一致</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 本地队列为空 and 自旋m数量+空闲p数量&gt;0 and syscall次数一致但没有超时（10ms）</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(pp) &amp;&amp; sched.nmspinning.Load()+sched.npidle.Load() &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="comment">// 不处理当前p</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// allp解锁，以便接下来调度器加锁</span></span><br><span class="line">            unlock(&amp;allpLock)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 空闲的locked的m数量-=1，假装是locked的m在运行</span></span><br><span class="line">            incidlelocked(<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">// 强制回收p</span></span><br><span class="line">            <span class="comment">// p状态改为_Pidle</span></span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;pp.status, s, _Pidle) &#123;</span><br><span class="line">                <span class="comment">// 强制回收p的数量+1</span></span><br><span class="line">                n++</span><br><span class="line">                <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">                pp.syscalltick++</span><br><span class="line">                <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">                handoffp(pp)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 复原，空闲的locked的m数量+=1，检查是否存在死锁</span></span><br><span class="line">            incidlelocked(<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 重新加锁</span></span><br><span class="line">            lock(&amp;allpLock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint32</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐个设置p的抢占标志，发送信号给线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptall</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    res := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// p的状态非_Prunning</span></span><br><span class="line">        <span class="keyword">if</span> pp.status != _Prunning &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置g、p抢占标志、发送抢占信号给m</span></span><br><span class="line">        <span class="keyword">if</span> preemptone(pp) &#123;</span><br><span class="line">            res = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有一个成功即为true</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置g、p抢占标志、发送抢占信号给m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptone</span><span class="params">(pp *p)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    mp := pp.m.ptr()</span><br><span class="line">    <span class="comment">// m为nil or m为当前m</span></span><br><span class="line">    <span class="keyword">if</span> mp == <span class="literal">nil</span> || mp == getg().m &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    gp := mp.curg</span><br><span class="line">    <span class="comment">// g为nil or m为g0</span></span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> || gp == mp.g0 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g设置标志位（可能设置错了g，也可能不执行）</span></span><br><span class="line">    gp.preempt = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// stackguard0（用于正常函数调用时检查）设置为0xfffffade</span></span><br><span class="line">    gp.stackguard0 = stackPreempt</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preemptMSupported默认为true and asyncpreemptoff默认为0（为1时禁用基于信号的异步抢占）</span></span><br><span class="line">    <span class="keyword">if</span> preemptMSupported &amp;&amp; debug.asyncpreemptoff == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// p设置标志位</span></span><br><span class="line">        pp.preempt = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 发送抢占信号给m（平台相关）</span></span><br><span class="line">        preemptM(mp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g状态修改、解除与m的绑定，重新寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptPark</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态</span></span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="comment">// 异常，_Grunning位未设置</span></span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">&quot;bad g status&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// asyncSafePoint</span></span><br><span class="line">    <span class="keyword">if</span> gp.asyncSafePoint &#123;</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        f := findfunc(gp.sched.pc)</span><br><span class="line">        <span class="keyword">if</span> !f.valid() &#123;</span><br><span class="line">            throw(<span class="string">&quot;preempt at unknown pc&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> f.flag&amp;abi.FuncFlagSPWrite != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: unexpected SPWRITE function&quot;</span>, funcname(f), <span class="string">&quot;in async preempt&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;preempt SPWRITE&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Gscanpreempted</span></span><br><span class="line">    casGToPreemptScan(gp, _Grunning, _Gscan|_Gpreempted)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Gscanpreempted状态改为_Gpreempted</span></span><br><span class="line">    casfrom_Gscanstatus(gp, _Gscan|_Gpreempted, _Gpreempted)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改g状态、纪录寄存器状态，唤醒sysmon、GC等线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reentersyscall</span><span class="params">(pc, sp, bp <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m加锁</span></span><br><span class="line">    gp.m.locks++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stackguard0（用于正常函数调用时检查）设置为0xfffffade</span></span><br><span class="line">    gp.stackguard0 = stackPreempt</span><br><span class="line">    <span class="comment">// 禁止栈分裂/扩容，否则抛出异常</span></span><br><span class="line">    gp.throwsplit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储到g.sched</span></span><br><span class="line">    save(pc, sp, bp)</span><br><span class="line">    <span class="comment">// 同步到syscall相关字段</span></span><br><span class="line">    gp.syscallsp = sp</span><br><span class="line">    gp.syscallpc = pc</span><br><span class="line">    gp.syscallbp = bp</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Gsyscall</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gsyscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// staticLockRanking默认为false</span></span><br><span class="line">    <span class="keyword">if</span> staticLockRanking &#123;</span><br><span class="line">        save(pc, sp, bp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过边界，异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallsp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallsp &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscall inconsistent sp &quot;</span>, hex(gp.syscallsp), <span class="string">&quot; [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscall&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过边界，异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallbp != <span class="number">0</span> &amp;&amp; gp.syscallbp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallbp &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscall inconsistent bp &quot;</span>, hex(gp.syscallbp), <span class="string">&quot; [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscall&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sysmon挂起休眠了</span></span><br><span class="line">    <span class="keyword">if</span> sched.sysmonwait.Load() &#123;</span><br><span class="line">        <span class="comment">// entersyscall_sysmon</span></span><br><span class="line">        <span class="comment">// 有工作了，唤醒sysmon</span></span><br><span class="line">        systemstack(entersyscall_sysmon)</span><br><span class="line">        <span class="comment">// 存储到g.sched</span></span><br><span class="line">        save(pc, sp, bp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC标志需要执行safePointFn</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 执行runSafePointFn函数</span></span><br><span class="line">        <span class="comment">// 执行safePointFn，如果是最后一个p，则唤醒safePointNote</span></span><br><span class="line">        systemstack(runSafePointFn)</span><br><span class="line">        <span class="comment">// 存储到g.sched</span></span><br><span class="line">        save(pc, sp, bp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录p的syscall次数到m</span></span><br><span class="line">    gp.m.syscalltick = gp.m.p.ptr().syscalltick</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line">    <span class="comment">// p取消m绑定</span></span><br><span class="line">    pp.m = <span class="number">0</span></span><br><span class="line">    <span class="comment">// m纪录p到oldp</span></span><br><span class="line">    gp.m.oldp.set(pp)</span><br><span class="line">    <span class="comment">// m取消p绑定</span></span><br><span class="line">    gp.m.p = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 状态改为_Psyscall</span></span><br><span class="line">    atomic.Store(&amp;pp.status, _Psyscall)</span><br><span class="line">    <span class="comment">// STW，当前p释放到空闲队列</span></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting.Load() &#123;</span><br><span class="line">        <span class="comment">// 执行entersyscall_gcwait</span></span><br><span class="line">        <span class="comment">// p停止，唤醒m执行GC</span></span><br><span class="line">        systemstack(entersyscall_gcwait)</span><br><span class="line">        <span class="comment">// 存储到g.sched</span></span><br><span class="line">        save(pc, sp, bp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    gp.m.locks--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改g状态、纪录寄存器状态，唤醒sysmon、GC等线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fp := getcallerfp()</span><br><span class="line">	<span class="comment">// 修改g状态、纪录寄存器状态，唤醒sysmon、GC等线程</span></span><br><span class="line">    reentersyscall(sys.GetCallerPC(), sys.GetCallerSP(), fp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有工作了，唤醒sysmon</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscall_sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// sysmon空闲等待中</span></span><br><span class="line">    <span class="keyword">if</span> sched.sysmonwait.Load() &#123;</span><br><span class="line">        <span class="comment">// 取消等待标记</span></span><br><span class="line">        sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 唤醒sysmon（m放在sysmonnote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p停止，唤醒m执行GC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscall_gcwait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// syscall前使用的p</span></span><br><span class="line">    pp := gp.m.oldp.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// GC and p从_Psyscall状态改为_Pgcstop</span></span><br><span class="line">    <span class="keyword">if</span> sched.stopwait &gt; <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;pp.status, _Psyscall, _Pgcstop) &#123;</span><br><span class="line">        <span class="comment">// p的停止时间</span></span><br><span class="line">        pp.gcStopTime = nanotime()</span><br><span class="line">        <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">        pp.syscalltick++</span><br><span class="line">        <span class="comment">// 待_Pgcstop的p数量-1，如果所有p已_Pgcstop</span></span><br><span class="line">        <span class="keyword">if</span> sched.stopwait--; sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 唤醒m（m放在stopnote.key）执行GC</span></span><br><span class="line">            notewakeup(&amp;sched.stopnote)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改g状态、纪录寄存器状态，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscallblock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m加锁</span></span><br><span class="line">    gp.m.locks++</span><br><span class="line">    <span class="comment">// 禁止栈分裂/扩容，否则抛出异常</span></span><br><span class="line">    gp.throwsplit = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// stackguard0（用于正常函数调用时检查）设置为0xfffffade</span></span><br><span class="line">    gp.stackguard0 = stackPreempt</span><br><span class="line">    <span class="comment">// 纪录p的syscall次数到m</span></span><br><span class="line">    gp.m.syscalltick = gp.m.p.ptr().syscalltick</span><br><span class="line">    <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">    gp.m.p.ptr().syscalltick++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    pc := sys.GetCallerPC()</span><br><span class="line">    sp := sys.GetCallerSP()</span><br><span class="line">    bp := getcallerfp()</span><br><span class="line">    <span class="comment">// 存储到g.sched</span></span><br><span class="line">    save(pc, sp, bp)</span><br><span class="line">    <span class="comment">// 同步到syscall相关字段</span></span><br><span class="line">    gp.syscallsp = gp.sched.sp</span><br><span class="line">    gp.syscallpc = gp.sched.pc</span><br><span class="line">    gp.syscallbp = gp.sched.bp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过边界，异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallsp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallsp &#123;</span><br><span class="line">        sp1 := sp</span><br><span class="line">        sp2 := gp.sched.sp</span><br><span class="line">        sp3 := gp.syscallsp</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscallblock inconsistent sp &quot;</span>, hex(sp1), <span class="string">&quot; &quot;</span>, hex(sp2), <span class="string">&quot; &quot;</span>, hex(sp3), <span class="string">&quot; [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscallblock&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Gsyscall</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gsyscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过边界，异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallsp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallsp &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscallblock inconsistent sp &quot;</span>, hex(sp), <span class="string">&quot; &quot;</span>, hex(gp.sched.sp), <span class="string">&quot; &quot;</span>, hex(gp.syscallsp), <span class="string">&quot; [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscallblock&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过边界，异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallbp != <span class="number">0</span> &amp;&amp; gp.syscallbp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallbp &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscallblock inconsistent bp &quot;</span>, hex(bp), <span class="string">&quot; &quot;</span>, hex(gp.sched.bp), <span class="string">&quot; &quot;</span>, hex(gp.syscallbp), <span class="string">&quot; [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscallblock&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行entersyscallblock_handoff</span></span><br><span class="line">    <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">    systemstack(entersyscallblock_handoff)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储到g.sched</span></span><br><span class="line">    save(sys.GetCallerPC(), sys.GetCallerSP(), getcallerfp())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m解锁</span></span><br><span class="line">    gp.m.locks--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscallblock_handoff</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">    handoffp(releasep())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m尝试绑定syscall前使用的p，或者从空闲p列表拿一个绑定，绑定成功返回，失败则把m放到空闲队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m加锁</span></span><br><span class="line">    gp.m.locks++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sys.GetCallerSP() &gt; gp.syscallsp &#123;</span><br><span class="line">        throw(<span class="string">&quot;exitsyscall: syscall frame is no longer valid&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    gp.waitsince = <span class="number">0</span></span><br><span class="line">    <span class="comment">// syscall前使用的p</span></span><br><span class="line">    oldp := gp.m.oldp.ptr()</span><br><span class="line">    <span class="comment">// 重置该字段</span></span><br><span class="line">    gp.m.oldp = <span class="number">0</span></span><br><span class="line">    <span class="comment">// m尝试绑定syscall前使用的p，或者从空闲p列表拿一个绑定</span></span><br><span class="line">    <span class="keyword">if</span> exitsyscallfast(oldp) &#123;</span><br><span class="line">        <span class="comment">// pprof相关</span></span><br><span class="line">        <span class="keyword">if</span> goroutineProfile.active &#123;</span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="comment">// 在写屏障路径上记录g的profile相关信息</span></span><br><span class="line">                tryRecordGoroutineProfileWB(gp)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">        gp.m.p.ptr().syscalltick++</span><br><span class="line">        <span class="comment">// 从_Gsyscall状态改为_Grunning</span></span><br><span class="line">        casgstatus(gp, _Gsyscall, _Grunning)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC未运行</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        gp.syscallsp = <span class="number">0</span></span><br><span class="line">        <span class="comment">// m解锁</span></span><br><span class="line">        gp.m.locks--</span><br><span class="line">        <span class="comment">// g被抢占</span></span><br><span class="line">        <span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">            <span class="comment">// stackguard0（用于正常函数调用时检查）设置为0xfffffade</span></span><br><span class="line">            gp.stackguard0 = stackPreempt</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非抢占</span></span><br><span class="line">            <span class="comment">// stack.lo+928</span></span><br><span class="line">            gp.stackguard0 = gp.stack.lo + stackGuard</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 允许栈分裂/扩容</span></span><br><span class="line">        gp.throwsplit = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC时只有sys类型的g允许运行</span></span><br><span class="line">        <span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">            <span class="comment">// 同协程yield关键字，当前g让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">            Gosched()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿不到p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// m解锁</span></span><br><span class="line">    gp.m.locks--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行exitsyscall0函数</span></span><br><span class="line">    <span class="comment">// 能拿到p则绑定执行g，拿不到时，如果有locked的m则让出CPU等待locked的g可运行，否则把当前m放到空闲m列表</span></span><br><span class="line">    mcall(exitsyscall0)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    gp.syscallsp = <span class="number">0</span></span><br><span class="line">    <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">    gp.m.p.ptr().syscalltick++</span><br><span class="line">    <span class="comment">// 允许栈分裂/扩容</span></span><br><span class="line">    gp.throwsplit = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试绑定m和oldp，或者从空闲p列表拿一个绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscallfast</span><span class="params">(oldp *p)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// freezeStopWait表示发生panic</span></span><br><span class="line">    <span class="keyword">if</span> sched.stopwait == freezeStopWait &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试将oldp的状态从_Psyscall改为_Pidle</span></span><br><span class="line">    <span class="keyword">if</span> oldp != <span class="literal">nil</span> &amp;&amp; oldp.status == _Psyscall &amp;&amp; atomic.Cas(&amp;oldp.status, _Psyscall, _Pidle) &#123;</span><br><span class="line">        <span class="comment">// 绑定m和oldp</span></span><br><span class="line">        wirep(oldp)</span><br><span class="line">        <span class="comment">// 同步m与p的syscall次数</span></span><br><span class="line">        exitsyscallfast_reacquired(trace)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oldp为nil or oldp状态非_Psyscall or 状态修改失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲p链表有数据</span></span><br><span class="line">    <span class="keyword">if</span> sched.pidle != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 从空闲链表拿一个p并绑定m</span></span><br><span class="line">            ok = exitsyscallfast_pidle()</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 拿到了</span></span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没拿到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步m与p的syscall次数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscallfast_reacquired</span><span class="params">(trace traceLocker)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// m与p的syscall次数不一致</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.syscalltick != gp.m.p.ptr().syscalltick &#123;</span><br><span class="line">        <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">        gp.m.p.ptr().syscalltick++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从空闲链表拿一个p并绑定m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscallfast_pidle</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">    pp, _ := pidleget(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 拿到p and sysmon挂起休眠了</span></span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &amp;&amp; sched.sysmonwait.Load() &#123;</span><br><span class="line">        <span class="comment">// 取消等待标记</span></span><br><span class="line">        sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 唤醒sysmon（m放在sysmonnote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到p</span></span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">        acquirep(pp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于runtime，能拿到p则绑定执行g，拿不到时，如果有locked的m则让出CPU等待locked的g可运行，否则把当前m放到空闲m列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从_Gsyscall状态改为_Grunnable</span></span><br><span class="line">    casgstatus(gp, _Gsyscall, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pp *p</span><br><span class="line">    <span class="comment">// GC开始到标记结束这个过程只允许sys类型的g运行</span></span><br><span class="line">    <span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">        <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">        pp, _ = pidleget(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> locked <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有拿到p</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 把g放到全局队列尾部</span></span><br><span class="line">        globrunqput(gp)</span><br><span class="line">        <span class="comment">// 是否有locked的m</span></span><br><span class="line">        locked = gp.lockedm != <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> sched.sysmonwait.Load() &#123;</span><br><span class="line">        <span class="comment">// 拿到p，sysmon挂起休眠了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消等待标记</span></span><br><span class="line">        sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 唤醒sysmon（m放在sysmonnote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到p</span></span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">        acquirep(pp)</span><br><span class="line">        <span class="comment">// g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line">        execute(gp, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有拿到p</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lockedm不为空</span></span><br><span class="line">    <span class="keyword">if</span> locked &#123;</span><br><span class="line">        <span class="comment">// m让出p并挂起休眠，直到lockedg状态变为可运行，被唤醒后绑定一个p返回</span></span><br><span class="line">        stoplockedm()</span><br><span class="line">        <span class="comment">// g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line">        execute(gp, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lockedm为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">    stopm()</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main相关"><a href="#main相关" class="headerlink" title="main相关"></a>main相关</h3><h4 id="init初始化函数"><a href="#init初始化函数" class="headerlink" title="init初始化函数"></a>init初始化函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行init函数，可以是runtime相关或module相关</span></span><br><span class="line"><span class="comment">// var runtime_inittasks []*initTask</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doInit</span><span class="params">(ts []*initTask)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        doInit1(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行单个init函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doInit1</span><span class="params">(t *initTask)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t.state &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 完成</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 执行中</span></span><br><span class="line">        throw(<span class="string">&quot;recursive call during initialization - linker skew&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:<span class="comment">// 0-未开始</span></span><br><span class="line">        <span class="comment">// 设置为执行中</span></span><br><span class="line">        t.state = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            start  <span class="type">int64</span>        <span class="comment">// 开始时刻-单调时钟</span></span><br><span class="line">            before tracestat    <span class="comment">// 原状态</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inittrace-全局变量</span></span><br><span class="line">        <span class="keyword">if</span> inittrace.active &#123;</span><br><span class="line">            start = nanotime()</span><br><span class="line">            before = inittrace</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init函数数量</span></span><br><span class="line">        <span class="keyword">if</span> t.nfns == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;inittask with no functions&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定位到第一个init函数的位置</span></span><br><span class="line">        firstFunc := add(unsafe.Pointer(t), <span class="number">8</span>)</span><br><span class="line">        <span class="comment">// 执行所有init函数</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; t.nfns; i++ &#123;</span><br><span class="line">            p := add(firstFunc, <span class="type">uintptr</span>(i)*goarch.PtrSize)</span><br><span class="line">            f := *(*<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)(unsafe.Pointer(&amp;p))</span><br><span class="line">            f()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收尾</span></span><br><span class="line">        <span class="keyword">if</span> inittrace.active &#123;</span><br><span class="line">            <span class="comment">// 纪录结束时刻</span></span><br><span class="line">            end := nanotime()</span><br><span class="line">            <span class="comment">// 当前状态</span></span><br><span class="line">            after := inittrace</span><br><span class="line"></span><br><span class="line">            f := *(*<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)(unsafe.Pointer(&amp;firstFunc))</span><br><span class="line">            pkg := funcpkgpath(findfunc(abi.FuncPCABIInternal(f)))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印耗时等信息</span></span><br><span class="line">            <span class="keyword">var</span> sbuf [<span class="number">24</span>]<span class="type">byte</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;init &quot;</span>, pkg, <span class="string">&quot; @&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">string</span>(fmtNSAsMS(sbuf[:], <span class="type">uint64</span>(start-runtimeInitTime))), <span class="string">&quot; ms, &quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">string</span>(fmtNSAsMS(sbuf[:], <span class="type">uint64</span>(end-start))), <span class="string">&quot; ms clock, &quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">string</span>(itoa(sbuf[:], after.bytes-before.bytes)), <span class="string">&quot; bytes, &quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">string</span>(itoa(sbuf[:], after.allocs-before.allocs)), <span class="string">&quot; allocs&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记完成</span></span><br><span class="line">        t.state = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h3><h4 id="启动sweeper、scavenger"><a href="#启动sweeper、scavenger" class="headerlink" title="启动sweeper、scavenger"></a>启动sweeper、scavenger</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动sweeper、scavenger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcenable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// sweeper</span></span><br><span class="line">    <span class="keyword">go</span> bgsweep(c)</span><br><span class="line">    <span class="comment">// scavenger</span></span><br><span class="line">    <span class="keyword">go</span> bgscavenge(c)</span><br><span class="line">    &lt;-c</span><br><span class="line">    &lt;-c</span><br><span class="line">    <span class="comment">// 运行时已完成初始化，可以执行GC</span></span><br><span class="line">    memstats.enablegc = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GC调度"><a href="#GC调度" class="headerlink" title="GC调度"></a>GC调度</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地/全局队列为空时，执行netpoll轮询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pollWork</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// 本地队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> !runqempty(p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// netpoll已初始化 and 挂起的g数量不为0 and 当前没有进行netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; netpollAnyWaiters() &amp;&amp; sched.lastpoll.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 平台相关</span></span><br><span class="line">        <span class="comment">// 执行epollWait检查，0-没有数据立即返回</span></span><br><span class="line">        <span class="keyword">if</span> list, delta := netpoll(<span class="number">0</span>); !list.empty() &#123;</span><br><span class="line">            <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">            netpollAdjustWaiters(delta)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sysmon相关"><a href="#sysmon相关" class="headerlink" title="sysmon相关"></a>sysmon相关</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空闲时轮询netpoll，其他时候，抢占超时的g、回收阻塞在syscall的p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// sys类型的m数量+=1</span></span><br><span class="line">    sched.nmsys++</span><br><span class="line">    <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">    checkdead()</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    lasttrace := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    idle := <span class="number">0</span></span><br><span class="line">    delay := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 永久循环</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> idle == <span class="number">0</span> &#123;          <span class="comment">// 休眠20us</span></span><br><span class="line">            delay = <span class="number">20</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123;   <span class="comment">// 50次20us后，双倍休眠时间</span></span><br><span class="line">            delay *= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123;    <span class="comment">// 最多休眠10ms</span></span><br><span class="line">            delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始前，先休眠一段时间</span></span><br><span class="line">        usleep(delay)</span><br><span class="line"></span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="comment">// schedtrace默认为0 and (STW，当前p释放到空闲队列 or 所有的p都空闲)</span></span><br><span class="line">        <span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting.Load() || sched.npidle.Load() == gomaxprocs) &#123;</span><br><span class="line">            <span class="comment">// 调度器加锁</span></span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            <span class="comment">// STW，当前p释放到空闲队列 or 所有的p都空闲</span></span><br><span class="line">            <span class="keyword">if</span> sched.gcwaiting.Load() || sched.npidle.Load() == gomaxprocs &#123;</span><br><span class="line">                syscallWake := <span class="literal">false</span></span><br><span class="line">                <span class="comment">// 遍历所有P，找到全局最小的when</span></span><br><span class="line">                next := timeSleepUntil()</span><br><span class="line">                <span class="comment">// 还未到超时时刻</span></span><br><span class="line">                <span class="keyword">if</span> next &gt; now &#123;</span><br><span class="line">                    <span class="comment">// 标记空闲等待中</span></span><br><span class="line">                    sched.sysmonwait.Store(<span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 休眠前先解锁</span></span><br><span class="line">                    unlock(&amp;sched.lock)</span><br><span class="line">                    <span class="comment">// sleep = forcegcperiod/2 = 1min</span></span><br><span class="line">                    sleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">                    <span class="comment">// 下一个超时时刻在1min内</span></span><br><span class="line">                    <span class="keyword">if</span> next-now &lt; sleep &#123;</span><br><span class="line">                        sleep = next - now</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 非Windows下为true，sleep &gt;= 0</span></span><br><span class="line">                    shouldRelax := sleep &gt;= osRelaxMinNS</span><br><span class="line">                    <span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">                        <span class="comment">// 非Windows下为空函数</span></span><br><span class="line">                        osRelax(<span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 挂起休眠指定时间（m放在sysmonnote.key），标记blocked为true</span></span><br><span class="line">                    syscallWake = notetsleep(&amp;sched.sysmonnote, sleep)</span><br><span class="line">                    <span class="comment">// 被唤醒/超时</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">                        <span class="comment">// 非Windows下为空函数</span></span><br><span class="line">                        osRelax(<span class="literal">false</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 唤醒后重新加锁</span></span><br><span class="line">                    lock(&amp;sched.lock)</span><br><span class="line">                    <span class="comment">// 取消等待标记</span></span><br><span class="line">                    sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">                    <span class="comment">// 将sysmonnote.key重置为0</span></span><br><span class="line">                    noteclear(&amp;sched.sysmonnote)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 成功唤醒</span></span><br><span class="line">                <span class="keyword">if</span> syscallWake &#123;</span><br><span class="line">                    idle = <span class="number">0</span></span><br><span class="line">                    delay = <span class="number">20</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从这里到末尾都要加锁访问</span></span><br><span class="line">        lock(&amp;sched.sysmonlock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前时刻</span></span><br><span class="line">        now = nanotime()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cgo</span></span><br><span class="line">        <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">            asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上一次执行netpoll的时刻</span></span><br><span class="line">        lastpoll := sched.lastpoll.Load()</span><br><span class="line">        <span class="comment">// netpoll已初始化 and 当前没有进行netpoll轮询 and lastpoll距离现在没有超过10ms</span></span><br><span class="line">        <span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">            <span class="comment">// lastpoll更新为当前时刻</span></span><br><span class="line">            sched.lastpoll.CompareAndSwap(lastpoll, now)</span><br><span class="line">            <span class="comment">// 执行epollWait检查，0-没有数据立即返回</span></span><br><span class="line">            list, delta := netpoll(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            <span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">                <span class="comment">// 空闲的locked的m数量-=1，假装是locked的m在运行</span></span><br><span class="line">                incidlelocked(<span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">                injectglist(&amp;list)</span><br><span class="line">                <span class="comment">// 复原，空闲的locked的m数量+=1，检查是否存在死锁</span></span><br><span class="line">                incidlelocked(<span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">                netpollAdjustWaiters(delta)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// netbsd相关</span></span><br><span class="line">        <span class="keyword">if</span> GOOS == <span class="string">&quot;netbsd&quot;</span> &amp;&amp; needSysmonWorkaround &#123;</span><br><span class="line">            <span class="keyword">if</span> next := timeSleepUntil(); next &lt; now &#123;</span><br><span class="line">                startm(<span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为1时sysmon将会唤醒scavenger</span></span><br><span class="line">        <span class="keyword">if</span> scavenger.sysmonWake.Load() != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 重置scavenger状态，修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            scavenger.wake()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历p，抢占超时的g、回收阻塞在syscall的p</span></span><br><span class="line">        <span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 有回收p</span></span><br><span class="line">            idle = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无回收p</span></span><br><span class="line">            idle++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; forcegc.idle.Load() &#123;</span><br><span class="line">            <span class="comment">// forcegc加锁</span></span><br><span class="line">            lock(&amp;forcegc.lock)</span><br><span class="line">            <span class="comment">// 重置idle</span></span><br><span class="line">            forcegc.idle.Store(<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">var</span> list gList</span><br><span class="line">            <span class="comment">// 把g放到链表</span></span><br><span class="line">            list.push(forcegc.g)</span><br><span class="line">            <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;forcegc.lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// schedtrace默认为0，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="type">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">            lasttrace = now</span><br><span class="line">            schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.sysmonlock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cgo相关"><a href="#cgo相关" class="headerlink" title="cgo相关"></a>cgo相关</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建模板线程，每次唤醒时创建所有locked和cgo类型的m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTemplateThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// wasm只有一个线程</span></span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 原子设置haveTemplateThread为1</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;newmHandoff.haveTemplateThread, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置失败，有其他线程已经执行了</span></span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理freem链表，创建并初始化m，locked或cgo类型的m由模板线程延迟创建，其他类型则立即调用平台相关函数创建线程</span></span><br><span class="line">    <span class="comment">// templateThread：每次唤醒时创建所有locked和cgo类型的m</span></span><br><span class="line">    newm(templateThread, <span class="literal">nil</span>, <span class="number">-1</span>)</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次唤醒时创建所有locked和cgo类型的m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">templateThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// sys类型的m数量+=1</span></span><br><span class="line">    sched.nmsys++</span><br><span class="line">    <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">    checkdead()</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 永久循环</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        lock(&amp;newmHandoff.lock)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// m队列不为空</span></span><br><span class="line">        <span class="keyword">for</span> newmHandoff.newm != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 拿到整个m链表</span></span><br><span class="line">            newm := newmHandoff.newm.ptr()</span><br><span class="line">            <span class="comment">// 清除指针</span></span><br><span class="line">            newmHandoff.newm = <span class="number">0</span></span><br><span class="line">            unlock(&amp;newmHandoff.lock)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历整个m链表并创建线程运行m</span></span><br><span class="line">            <span class="keyword">for</span> newm != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 下一个m，也是新链表的头部</span></span><br><span class="line">                next := newm.schedlink.ptr()</span><br><span class="line">                <span class="comment">// m清除next指针</span></span><br><span class="line">                newm.schedlink = <span class="number">0</span></span><br><span class="line">                <span class="comment">// 调用平台相关函数创建线程运行m</span></span><br><span class="line">                newm1(newm)</span><br><span class="line">                <span class="comment">// 指向下一个m</span></span><br><span class="line">                newm = next</span><br><span class="line">            &#125;</span><br><span class="line">            lock(&amp;newmHandoff.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前m等待唤醒，下面会进行sleep</span></span><br><span class="line">        newmHandoff.waiting = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 将wake.key重置为0</span></span><br><span class="line">        noteclear(&amp;newmHandoff.wake)</span><br><span class="line"></span><br><span class="line">        unlock(&amp;newmHandoff.lock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挂起休眠（m放在wake.key），标记blocked为true</span></span><br><span class="line">        notesleep(&amp;newmHandoff.wake)</span><br><span class="line">        <span class="comment">// 被notewakeup唤醒，标记blocked为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="profiling相关"><a href="#profiling相关" class="headerlink" title="profiling相关"></a>profiling相关</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存剖析调用栈初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mProfStackInit</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 为0不处理，profstackdepth默认128，最大值1024</span></span><br><span class="line">    <span class="keyword">if</span> debug.profstackdepth == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// make([]uintptr, 1+6+debug.profstackdepth)</span></span><br><span class="line">    mp.profStack = makeProfStackFP()</span><br><span class="line">    <span class="comment">// make([]uintptr, 1+6+debug.profstackdepth)</span></span><br><span class="line">    mp.mLockProfile.stack = makeProfStackFP()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="sudog相关"><a href="#sudog相关" class="headerlink" title="sudog相关"></a>sudog相关</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从sudogcache获取一个sudog</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireSudog</span><span class="params">()</span></span> *sudog &#123;</span><br><span class="line">    <span class="comment">// sema -&gt; acquireSudog -&gt; new(sudog) -&gt; malloc -&gt; GC -&gt; sema</span></span><br><span class="line">    <span class="comment">// 有环，需要使用acquirem避免GC</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// sudog列表为空，从调度器拿</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.sudoglock)</span><br><span class="line">        <span class="comment">// 数据量没有超过容量一半 and 调度器的sudog列表不为空</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &lt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &amp;&amp; sched.sudogcache != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 从调度器的sudog链表拿走放到p里</span></span><br><span class="line">            s := sched.sudogcache</span><br><span class="line">            sched.sudogcache = s.next</span><br><span class="line">            s.next = <span class="literal">nil</span></span><br><span class="line">            pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.sudoglock)</span><br><span class="line">        <span class="comment">// 调度器的sudog列表也是空的</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 使用new创建一个sudog放到p里</span></span><br><span class="line">            pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, <span class="built_in">new</span>(sudog))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿走列表里最后一个sudog</span></span><br><span class="line">    n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">    s := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">    pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">    pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;acquireSudog: found s.elem != nil in cache&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把sudog放回cache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseSudog</span><span class="params">(s *sudog)</span></span> &#123;</span><br><span class="line">    <span class="comment">// guard</span></span><br><span class="line">    <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-nil elem&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.isSelect &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-false isSelect&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.next != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-nil next&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-nil prev&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.waitlink != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-nil waitlink&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.c != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-nil c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp.param != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: releaseSudog with non-nil gp.param&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// 本地队列满了，把一半的数量放到全局队列</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="built_in">cap</span>(pp.sudogcache) &#123;</span><br><span class="line">        <span class="comment">// 链表头部和尾部指针</span></span><br><span class="line">        <span class="keyword">var</span> first, last *sudog</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &gt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &#123;</span><br><span class="line">            <span class="comment">// 拿走列表里最后一个sudog</span></span><br><span class="line">            n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">            p := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">            pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">            pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// 如果是第一个数据</span></span><br><span class="line">            <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">                first = p</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 上一个sudog指向当前sudog</span></span><br><span class="line">                last.next = p</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指向当前sudog</span></span><br><span class="line">            last = p</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.sudoglock)</span><br><span class="line">        <span class="comment">// 链接全局sudog链表头部</span></span><br><span class="line">        last.next = sched.sudogcache</span><br><span class="line">        <span class="comment">// 替换（GC时清空全局sudog缓存）</span></span><br><span class="line">        sched.sudogcache = first</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.sudoglock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放到本地链表</span></span><br><span class="line">    pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在死锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkdead</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态库（c-archive/c-shared） and 非wasm平台</span></span><br><span class="line">    <span class="keyword">if</span> (islibrary || isarchive) &amp;&amp; GOARCH != <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic</span></span><br><span class="line">    <span class="keyword">if</span> panicking.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> run0 <span class="type">int32</span></span><br><span class="line">    <span class="comment">// 没有运行cgo and 有额外的m（Windows）</span></span><br><span class="line">    <span class="keyword">if</span> !iscgo &amp;&amp; cgoHasExtraM &amp;&amp; extraMLength.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        run0 = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户m数量 = 累计总量 - 累计释放m数量 - 空闲m数量 - locked的m数量 - sys类型m数量</span></span><br><span class="line">    <span class="comment">// = sched.mnext - sched.nmfreed - sched.nmidle - sched.nmidlelocked - sched.nmsys</span></span><br><span class="line">    run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面条件一般情况下都满足</span></span><br><span class="line">    <span class="keyword">if</span> run &gt; run0 &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run为0或1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> run &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: checkdead: nmidle=&quot;</span>, sched.nmidle, <span class="string">&quot; nmidlelocked=&quot;</span>, sched.nmidlelocked, <span class="string">&quot; mcount=&quot;</span>, mcount(), <span class="string">&quot; nmsys=&quot;</span>, sched.nmsys, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        throw(<span class="string">&quot;checkdead: inconsistent counts&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grunning := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 每个g都执行一遍该函数，期间allglock会被锁住</span></span><br><span class="line">    forEachG(<span class="function"><span class="keyword">func</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 是否是runtime相关的函数，除了部份如runtime.main</span></span><br><span class="line">        <span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取g.atomicstatus状态</span></span><br><span class="line">        s := readgstatus(gp)</span><br><span class="line">        <span class="keyword">switch</span> s &amp;^ _Gscan &#123;</span><br><span class="line">        <span class="keyword">case</span> _Gwaiting,</span><br><span class="line">            _Gpreempted: <span class="comment">// _Gwaiting、_Gpreempted</span></span><br><span class="line">            grunning++</span><br><span class="line">        <span class="keyword">case</span> _Grunnable,</span><br><span class="line">            _Grunning,</span><br><span class="line">            _Gsyscall: <span class="comment">// _Grunnable、_Grunning、_Gsyscall</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: checkdead: find g &quot;</span>, gp.goid, <span class="string">&quot; in status &quot;</span>, s, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            throw(<span class="string">&quot;checkdead: runnable g&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 如果runtime·Goexit()</span></span><br><span class="line">    <span class="keyword">if</span> grunning == <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        fatal(<span class="string">&quot;no goroutines (main called runtime.Goexit) - deadlock!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// faketime，忽略</span></span><br><span class="line">    <span class="keyword">if</span> faketime != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> when := timeSleepUntil(); when &lt; maxWhen &#123;</span><br><span class="line">            faketime = when</span><br><span class="line"></span><br><span class="line">            pp, _ := pidleget(faketime)</span><br><span class="line">            <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                throw(<span class="string">&quot;checkdead: no p for timer&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            mp := mget()</span><br><span class="line">            <span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                throw(<span class="string">&quot;checkdead: no m for timer&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            sched.nmspinning.Add(<span class="number">1</span>)</span><br><span class="line">            mp.spinning = <span class="literal">true</span></span><br><span class="line">            mp.nextp.set(pp)</span><br><span class="line">            notewakeup(&amp;mp.park)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有goroutine运行，检查p</span></span><br><span class="line">    <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// 有timer</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pp.timers.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    fatal(<span class="string">&quot;all goroutines are asleep - deadlock!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">6.5 调度器</a><br><a target="_blank" rel="noopener" href="https://xargin.com/go-bootstrap/">Go 系列文章2：Go 程序的启动流程</a><br><a target="_blank" rel="noopener" href="https://blog.nindalf.com/posts/how-goroutines-work/">How Goroutines Work</a><br><a target="_blank" rel="noopener" href="https://medium.com/@ninucium/golang-concurrency-patterns-for-select-done-errgroup-and-worker-pool-645bec0bd3c9">Golang Concurrency Patterns: For-Select-Done, Errgroup and Worker Pool</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=-K11rY57K7k">Dmitry Vyukov — Go scheduler: Implementing language with lightweight concurrency</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=5zXAHh5tJqQ">GopherCon 2018: Bryan C. Mills - Rethinking Classical Concurrency Patterns</a><br><a target="_blank" rel="noopener" href="https://medium.com/@ankur_anand/illustrated-tales-of-go-runtime-scheduler-74809ef6d19b">Illustrated Tales of Go Runtime Scheduler.</a><br><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a">Go: Goroutine, OS Thread and CPU Management</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=YHRO5WQGh0k">GopherCon 2018: Kavya Joshi - The Scheduler Saga</a><br><a target="_blank" rel="noopener" href="https://agrim123.github.io/posts/goroutines.html">Goroutines: M, P, G orchestration</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zkweb/p/7815600.html">Golang源码探索(二) 协程的实现原理 </a><br><a target="_blank" rel="noopener" href="https://tontinton.com/posts/scheduling-internals/">Scheduling Internals.</a><br><a target="_blank" rel="noopener" href="https://xargin.com/go-scheduler/">Go 系列文章4 : 调度器</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/golang-series-timer-and-ticker/" rel="prev" title="golang系列之-定时器Timer和Ticker">
                  <i class="fa fa-angle-left"></i> golang系列之-定时器Timer和Ticker
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">y2k38</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">106k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:26</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Y2k38/y2k38.github.io","repo_id":"R_kgDOMZGvZA","category":"Announcements","category_id":"DIC_kwDOMZGvZM4CirXX","mapping":"pathname","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"preferred_color_scheme","lang":"zh-CN","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
