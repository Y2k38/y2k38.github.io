<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx配置HTTPS访问</title>
    <url>/2019/09/02/configure-nginx-with-https/</url>
    <content><![CDATA[<p>简单介绍如何生成https服务所需要的证书、私钥以及部署，文档分别描述了开发时使用的self-signed证书以及线上使用的let’s encrypt免费证书的生成方法</p>
<h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><h3 id="创建证书以及私钥"><a href="#创建证书以及私钥" class="headerlink" title="创建证书以及私钥"></a>创建证书以及私钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>req:</strong> 指定X.509证书签名请求(CSR)管理</p>
</li>
<li><p><strong>-x509:</strong> 生成self-sigend证书</p>
</li>
<li><p><strong>-nodes:</strong> 不使用密码</p>
</li>
<li><p><strong>-days 365:</strong> 证书有效期</p>
</li>
<li><p><strong>-newkey rsa:2048:</strong> 生成证书的同时生成私钥，rsa加密算法，2048位</p>
</li>
<li><p><strong>-keyout:</strong> 私钥的存储路径</p>
</li>
<li><p><strong>-out:</strong> 证书的存储路径</p>
</li>
</ul>
<p>信息填写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Country Name (2 letter code) [AU]:US</span><br><span class="line">State or Province Name (full name) [Some-State]:New York</span><br><span class="line">Locality Name (eg, city) []:New York City</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:Bouncy Castles, Inc.</span><br><span class="line">Organizational Unit Name (eg, section) []:Ministry of Water Slides</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []: example.com (or server_IP_address)</span><br><span class="line">Email Address []:admin@your_domain.com</span><br></pre></td></tr></table></figure>

<h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/nginx/sites-enabled/example.com</span><br></pre></td></tr></table></figure>

<p>添加证书以及私钥</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/ssl/certs/nginx-selfsigned.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/ssl/private/nginx-selfsigned.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /var/www/example.com/html;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启nginx，完成</p>
<h2 id="正式证书"><a href="#正式证书" class="headerlink" title="正式证书"></a>正式证书</h2><h3 id="let’t-encrypt安装"><a href="#let’t-encrypt安装" class="headerlink" title="let’t encrypt安装"></a>let’t encrypt安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> git <span class="built_in">clone</span> https://github.com/letsencrypt/letsencrypt /usr/local/letsencrypt</span><br></pre></td></tr></table></figure>

<h3 id="生成证书以及私钥"><a href="#生成证书以及私钥" class="headerlink" title="生成证书以及私钥"></a>生成证书以及私钥</h3><p><strong>生成指定域名证书及密钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> -H /data/app/letsencrypt/letsencrypt-auto certonly --standalone -d www.example.com</span><br></pre></td></tr></table></figure>

<p>letsencrypt需要记录服务器ip，选择“Y”。打开新的命令行窗口，在指定的目录<code>.well-known</code>下创建文件并将指定的内容写入后，在原命令行窗口点击<code>enter</code>键结束</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Saving debug <span class="built_in">log</span> to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line">Plugins selected: Authenticator standalone, Installer None</span><br><span class="line">Obtaining a new certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">http-01 challenge <span class="keyword">for</span> www.example.com</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class="line">certificate. If you<span class="string">&#x27;re running certbot in manual mode on a machine that is not</span></span><br><span class="line"><span class="string">your server, please ensure you&#x27;</span>re okay with that.</span><br><span class="line"></span><br><span class="line">Are you OK with your IP being logged?</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es/(N)o: Y</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Create a file containing just this data:</span><br><span class="line"></span><br><span class="line">BxYgbmNBP0glztPgaevZwzwMSPy2Asd8LRzlyQNnax9.sAK0-w3-GGiCDaAreDXX1rxwm0qQfBfhb-4765BnzRZ</span><br><span class="line"></span><br><span class="line">And make it available on your web server at this URL:</span><br><span class="line"></span><br><span class="line">http://www.example.com/.well-known/acme-challenge/BxYgbmNBP0glztPgaevZwzwMSPy2Asd8LRzlyQNnax9</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Press Enter to Continue           <span class="comment"># 文件创建后再确认</span></span><br><span class="line">Waiting <span class="keyword">for</span> verification...</span><br><span class="line">Cleaning up challenges</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/www.example.com/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/www.example.com/privkey.pem</span><br><span class="line">   Your cert will expire on 2019-11-04. To obtain a new or tweaked</span><br><span class="line">   version of this certificate <span class="keyword">in</span> the future, simply run</span><br><span class="line">   letsencrypt-auto again. To non-interactively renew *all* of your</span><br><span class="line">   certificates, run <span class="string">&quot;letsencrypt-auto renew&quot;</span></span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let<span class="string">&#x27;s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">   Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure>

<p><strong>生成wildcard domain证书及密钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果嫌单个域名太麻烦，想配置wildcard证书，使用下面的命令</span></span><br><span class="line"><span class="built_in">sudo</span> -H /data/app/letsencrypt/letsencrypt-auto certonly --manual --preferred-challenges=dns -d *.example.com</span><br></pre></td></tr></table></figure>

<p>按提示添加dns记录后再点击<code>enter</code>结束</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Saving debug <span class="built_in">log</span> to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line">Plugins selected: Authenticator manual, Installer None</span><br><span class="line">Obtaining a new certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">dns-01 challenge <span class="keyword">for</span> example.com</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class="line">certificate. If you<span class="string">&#x27;re running certbot in manual mode on a machine that is not</span></span><br><span class="line"><span class="string">your server, please ensure you&#x27;</span>re okay with that.</span><br><span class="line"></span><br><span class="line">Are you OK with your IP being logged?</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es/(N)o: Y</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Please deploy a DNS TXT record under the name</span><br><span class="line">_acme-challenge.example.com with the following value:</span><br><span class="line"></span><br><span class="line">AhAGaqohVH8JMAS-jHkS5L_i2J4JCnglUJvY5n2S9qI</span><br><span class="line"></span><br><span class="line">Before continuing, verify the record is deployed.</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Press Enter to Continue           <span class="comment"># 需添加dns记录</span></span><br><span class="line">Waiting <span class="keyword">for</span> verification...</span><br><span class="line">Cleaning up challenges</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/example.com/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/example.com/privkey.pem</span><br><span class="line">   Your cert will expire on 2019-11-04. To obtain a new or tweaked</span><br><span class="line">   version of this certificate <span class="keyword">in</span> the future, simply run</span><br><span class="line">   letsencrypt-auto again. To non-interactively renew *all* of your</span><br><span class="line">   certificates, run <span class="string">&quot;letsencrypt-auto renew&quot;</span></span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let<span class="string">&#x27;s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">   Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure>

<h3 id="配置nginx-1"><a href="#配置nginx-1" class="headerlink" title="配置nginx"></a>配置nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/nginx/sites-enabled/example.com</span><br></pre></td></tr></table></figure>

<p>添加证书以及私钥</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /var/www/example.com/html;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启nginx，完成</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04">How To Create a Self-Signed SSL Certificate for Nginx in Ubuntu 18.04</a><br><a href="https://www.linode.com/docs/security/ssl/install-lets-encrypt-to-create-ssl-certificates/">Install Let’s Encrypt to Create SSL Certificates</a><br><a href="https://gist.github.com/cecilemuller/a26737699a7e70a7093d4dc115915de8">How to setup Let’s Encrypt for Nginx on Ubuntu 18.04 (including IPv6, HTTP&#x2F;2 and A+ SLL rating)</a><br><a href="https://certbot.eff.org/docs/using.html">Certbot User Guide</a><br><a href="http://manpages.ubuntu.com/manpages/xenial/man1/letsencrypt.1.html">letsencrypt man</a></p>
]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>ssl</tag>
        <tag>https</tag>
        <tag>self-signed</tag>
        <tag>let&#39;s enctypt</tag>
      </tags>
  </entry>
  <entry>
    <title>安装docker并部署registry服务</title>
    <url>/2024/07/20/deploy-docker-and-registry-service/</url>
    <content><![CDATA[<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>当前仅展示apt方式安装，离线安装方式不展示</p>
<h3 id="清理历史残留"><a href="#清理历史残留" class="headerlink" title="清理历史残留"></a>清理历史残留</h3><p>如果系统有预装docker或者先前安装过，先卸载干净在安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 第一次安装时输出为空</span></span><br><span class="line"><span class="keyword">for</span> pkg <span class="keyword">in</span> docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; <span class="keyword">do</span> <span class="built_in">sudo</span> apt remove <span class="variable">$pkg</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果以前有安装过docker，相关数据可以删除掉</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h3 id="apt安装"><a href="#apt安装" class="headerlink" title="apt安装"></a>apt安装</h3><h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><p>由于docker被gfw屏蔽，访问时需要使用vpn，这里使用先前搭建的<a href="/posts/deploy-shadowsocks-service">ss服务</a></p>
<p>新建<code>apt.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/apt/apt.conf</span><br></pre></td></tr></table></figure>

<p>添加proxy配置，默认源地址配置直连，如此后续配置docker源后，使用<code>apt update</code>便可直接访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquire::http::Proxy &quot;http://127.0.0.1:8118&quot;;</span><br><span class="line">Acquire::http::Proxy &#123;</span><br><span class="line">    archive.ubuntu.com DIRECT;</span><br><span class="line">    security.ubuntu.com DIRECT;</span><br><span class="line">    cn.archive.ubuntu.com DIRECT;</span><br><span class="line">    mirrors.tuna.tsinghua.edu.cn DIRECT;</span><br><span class="line">&#125;</span><br><span class="line">Acquire::https::Proxy &quot;http://127.0.0.1:8118&quot;;</span><br><span class="line">Acquire::https::Proxy &#123;</span><br><span class="line">    archive.ubuntu.com DIRECT;</span><br><span class="line">    security.ubuntu.com DIRECT;</span><br><span class="line">    cn.archive.ubuntu.com DIRECT;</span><br><span class="line">    mirrors.tuna.tsinghua.edu.cn DIRECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置源并安装"><a href="#配置源并安装" class="headerlink" title="配置源并安装"></a>配置源并安装</h4><p>按照docker官方教材安装docker，其中，下载<code>docker.asc</code>的命令做了一些修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add Docker&#x27;s official GPG key:</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install ca-certificates curl</span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br><span class="line"><span class="comment"># 配置proxy</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118;<span class="built_in">export</span> https_proxy=http://127.0.0.1:8118;</span><br><span class="line"><span class="comment"># 下载后在使用sudo搬到指定目录</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o docker.asc &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">mv</span> docker.asc /etc/apt/keyrings/docker.asc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.asc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the repository to Apt sources:</span></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是k8s部署，只需要containerd就够了</span></span><br><span class="line"><span class="built_in">sudo</span> apt install containerd.io docker-ce docker-ce-cli docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>

<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>将当前用户加入<code>docker</code>用户组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<h2 id="部署registry"><a href="#部署registry" class="headerlink" title="部署registry"></a>部署registry</h2><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>因为gfw的原因，docker hub的访问会时不时抽风，在使用docker pull前可以先配置代理，当前步骤可跳过</p>
<p>创建配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/systemd/system/docker.service.d/http-proxy.conf</span><br></pre></td></tr></table></figure>

<p>配置proxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://127.0.0.1:8118&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=http://127.0.0.1:8118&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=localhost,127.0.0.1,registry.noname.io&quot;</span><br></pre></td></tr></table></figure>

<p>重启并验证docker环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl show --property=Environment docker</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># Environment=HTTP_PROXY=http://127.0.0.1:8118 HTTPS_PROXY=http://127.0.0.1:8118 NO_PROXY=localhost,127.0.0.1,registry.noname.io</span></span><br></pre></td></tr></table></figure>

<h3 id="生成ssl证书"><a href="#生成ssl证书" class="headerlink" title="生成ssl证书"></a>生成ssl证书</h3><p>可以直接使用http，但后续k8s镜像的下载必须使用https，没有那么多耐心再去折腾，在这里先解决了，一劳永逸</p>
<p><code>/data/docker/</code>是我用于专门存放与registry相关的数据，包括certs以及后续docker push上来的镜像数据</p>
<p>下面命令关键的域名registry.noname.io要填好</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">  -newkey rsa:4096 -nodes -sha256 -keyout /data/docker/certs/noname.io.key \</span><br><span class="line">  -addext <span class="string">&quot;subjectAltName = DNS:registry.noname.io&quot;</span> \</span><br><span class="line">  -x509 -days 365 -out /data/docker/certs/noname.io.crt</span><br></pre></td></tr></table></figure>

<p>由此，https所需要的证书也就准备好了</p>
<h3 id="创建registry服务"><a href="#创建registry服务" class="headerlink" title="创建registry服务"></a>创建registry服务</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>将<code>/data/docker/certs</code>挂载到container的<code>/data/certs</code>目录</li>
<li><code>/data/docker/registry</code>挂载到container的<code>/var/lib/registry</code>目录，后续删除重建container时就保留下了image数据</li>
</ol>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>如果只是创建一个简单的可运行registry，直接运行docker run</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart always --name registry \</span><br><span class="line">  -v /data/docker/registry:/var/lib/registry \</span><br><span class="line">  -v /data/docker/certs:/data/certs \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_CERTIFICATE=/data/certs/noname.io.crt \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_KEY=/data/certs/noname.io.key \</span><br><span class="line">  registry:2.8.3</span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>如果涉及比较复杂的配置，像权限管理、接入s3文件系统、缓存配置、中继配置等，则使用配置文件方式比较好</p>
<p>创建registry配置文件，参考配置文件：<a href="https://github.com/distribution/distribution/blob/master/cmd/registry/config-example.yml">example YAML file</a>，修改后如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">:5000</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="attr">certificate:</span> <span class="string">/data/certs/noname.io.crt</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">/data/certs/noname.io.key</span></span><br></pre></td></tr></table></figure>

<p>运行docker run</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart always --name registry \</span><br><span class="line">  -v /data/docker/registry:/var/lib/registry \</span><br><span class="line">  -v /data/docker/certs:/data/certs \</span><br><span class="line">  -v /data/docker/config/config.yml:/etc/docker/registry/config.yml \</span><br><span class="line">  registry:2.8.3</span><br></pre></td></tr></table></figure>

<h3 id="修改系统配置"><a href="#修改系统配置" class="headerlink" title="修改系统配置"></a>修改系统配置</h3><h4 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/hosts</span><br></pre></td></tr></table></figure>

<p>添加私有registry的域名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">127.0.0.1 registry.noname.io</span><br></pre></td></tr></table></figure>

<h4 id="修改docker配置"><a href="#修改docker配置" class="headerlink" title="修改docker配置"></a>修改docker配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p><code>insecure-registries</code>需要添加registry的域名端口</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;exec-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;native.cgroupdriver=systemd&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;registry.noname.io:5000&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>如果要开放局域网内的访问，配置防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 5000/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure>

<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><p>访问registry接口，此时因为registry还没有任何image数据，输出为空</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://registry.noname.io:5000/v2/_catalog | jq .</span><br></pre></td></tr></table></figure>

<p>推送镜像测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag alpine:3.20.1 registry.noname.io:5000/alpine:3.20.1</span><br><span class="line">docker push registry.noname.io:5000/alpine:3.20.1</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu</a><br><a href="https://distribution.github.io/distribution/">Distribution Registry</a><br><a href="https://medium.com/@haminhsang1903/private-docker-registry-with-https-and-a-nginx-reverse-proxy-using-docker-compose-6c1335c5e820">Private Docker registry with HTTPS and a Nginx reverse proxy using Docker Compose</a></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title>安装kvm虚拟机</title>
    <url>/2024/07/19/deploy-kvm-and-cockpit/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般情况下，日常开发我只使用vagrant跟virtualbox，但后面想搭建一个k8s环境学习，需要一个免费、高性能、便于管理的虚拟机管理软件</p>
<p>综合考虑了下现在市面上的虚拟机管理软件</p>
<ol>
<li>virtualbox 的磁盘性能太差，nat网络所有虚拟机都是同一个IP：10.0.2.15，其他方面也不考虑了</li>
<li>parallel desktop 太贵太黑心</li>
<li>vmware 价格也不便宜还很吃电脑资源</li>
<li>hyper-v 管理界面太难用，同时无法固定虚拟机IP</li>
</ol>
<p>最终我选择组装一台台式机，安装了ubuntu系统，并在上面安装使用kvm虚拟机</p>
<p>cpu是amd 7700，8核心16线程；32GB内存；暂时不需要用到显卡；PC在路由器做了MAC跟IP的绑定，方便使用ssh</p>
<p>由于virt-manager太难用，最后选择cockpit作为kvm虚拟机管理软件</p>
<h2 id="kvm安装"><a href="#kvm安装" class="headerlink" title="kvm安装"></a>kvm安装</h2><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><p>确认cpu开启虚拟化功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般是cpu的核心数量</span></span><br><span class="line">egrep -c <span class="string">&#x27;(vmx|svm)&#x27;</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<h3 id="安装kvm"><a href="#安装kvm" class="headerlink" title="安装kvm"></a>安装kvm</h3><p>安装kvm以及依赖软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install qemu-system-x86 libvirt-daemon-system virtinst \</span><br><span class="line">  virt-manager virt-viewer ovmf swtpm qemu-utils guestfs-tools \</span><br><span class="line">  libosinfo-bin tuned</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> libvirtd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line"><span class="built_in">sudo</span> virt-host-validate qemu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有使用window的需要，可以下载virtio</span></span><br><span class="line">wget https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.240-1/virtio-win-0.1.240.iso</span><br></pre></td></tr></table></figure>

<h3 id="安装后工作"><a href="#安装后工作" class="headerlink" title="安装后工作"></a>安装后工作</h3><p>将用户添加到kvm跟libvirt组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG kvm <span class="variable">$USER</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG libvirt <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<h2 id="cockpit安装"><a href="#cockpit安装" class="headerlink" title="cockpit安装"></a>cockpit安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install cockpit cockpit-machines</span><br></pre></td></tr></table></figure>

<p>防火墙配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 9090/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure>

<p>浏览器打开访问web管理页面 <a href="https://192.168.0.105:9090/">https://192.168.0.105:9090</a></p>
<p><img src="/images/kvm_with_cockpit.png" alt="kvm with cockpit preview"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.tecmint.com/install-qemu-kvm-ubuntu-create-virtual-machines/">How to Install QEMU&#x2F;KVM on Ubuntu to Create Virtual Machines</a><br><a href="https://www.tecmint.com/manage-kvm-virtual-machines-using-cockpit-web-console/">Managing KVM Virtual Machines with Cockpit Web Console in Linux</a><br><a href="https://github.com/bryansteiner/gpu-passthrough-tutorial">gpu-passthrough-tutorial</a></p>
]]></content>
      <tags>
        <tag>kvm</tag>
        <tag>cockpit</tag>
      </tags>
  </entry>
  <entry>
    <title>生成火焰图分析php代码</title>
    <url>/2020/01/23/how-to-generate-php-flamegraphs/</url>
    <content><![CDATA[<p>flamegraph是一款可视化工具，用户分析程序堆栈调用，x轴堆栈轨迹，y轴堆栈深度，x轴长度越长，占用更多cpu时间。下面简单介绍如何使用xdebug以及flamegraph生成火焰图</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>配置xdebug参数</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">xdebug.trace_output_name</span> = xdebug.trace.%t.%s</span><br><span class="line"><span class="attr">xdebug.trace_enable_trigger</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.trace_output_dir</span> = /tmp</span><br><span class="line"><span class="attr">xdebug.trace_enable_trigger_value</span> = <span class="string">&quot;&lt;secret key&gt;&quot;</span></span><br><span class="line"><span class="attr">xdebug.trace_format</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>下载flamegraph，<code>git clone https://github.com/brendangregg/FlameGraph.git</code>，放置在任意位置</p>
<h2 id="flamegraph"><a href="#flamegraph" class="headerlink" title="flamegraph"></a>flamegraph</h2><p>获取堆栈数据</p>
<p>请求页面&#x2F;接口url，在url后面增加<code>?XDEBUG_TRACE=&lt;secret key&gt;</code>，获取php堆栈数据 <code>curl http://youdomain.com?XDEBUG_TRACE=&lt;secret key&gt;</code>，如果是命令行命令，则在php命令后使用参数<code>php -d xdebug.auto_trace=1</code></p>
<p>转换堆栈数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./stackcollapse-xdebug.php /tmp/xdebug.trace.1579703170._data_www_yii2_web_index_php.xt &gt; out.folded</span><br></pre></td></tr></table></figure>

<p>生成火焰图</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./flamegraph.pl out.folded &gt; out.svg</span><br></pre></td></tr></table></figure>

<p>示例</p>
<p><img src="/images/yii2-flamegraph-example.svg" alt="yii2 flamegraph example"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://daniellockyer.com/php-flame-graphs/">How to generate PHP Flamegraphs</a><br><a href="https://github.com/brendangregg/FlameGraph">Flame Graphs visualize profiled code</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>flamegraph</tag>
        <tag>debug</tag>
        <tag>profiling</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建shadowsocks服务</title>
    <url>/2024/07/19/deploy-shadowsocks-service/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于国内恶劣的网络环境，作为一名频繁访问外网的Web开发者，不得不自建一个VPN服务，以下简单介绍Shadowsocks的搭建过程。</p>
<p>单纯的ss流量会迅速被gfw识别到并屏蔽，因此使用ss时需要增加obfs用以混淆欺骗gfw，可以极大程度减小被屏蔽的风险。当然，如果你用的是比较出名的服务器供应商，如bandwagon的服务器，那么被屏蔽的机会也很大。</p>
<p>服务端使用的一键安装脚本twist由于开发者已经放弃维护长时间，目前只有参考作用，如果你有耐心，也可以自己修改后再使用，也就跟下面的服务端搭建教程一样。搞完是真的累，太渣了，太需要提高自己的编程水平，写一个一体化的软件包才行</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="twist脚本"><a href="#twist脚本" class="headerlink" title="twist脚本"></a>twist脚本</h3><p>服务端使用的是twist脚本，里面集成了Shadowsocks+simple-obfs+fail2ban以及相关依赖包，使用shell编写，感兴趣的可以看看源代码，下载地址如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/forestbat/Twist</span><br></pre></td></tr></table></figure>

<p>下载后，脚本添加执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x twist</span><br></pre></td></tr></table></figure>

<p>切换到root账户，twist执行需要</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure>

<h3 id="修改twist"><a href="#修改twist" class="headerlink" title="修改twist"></a>修改twist</h3><p>twist文件里面有一些软件需要删掉&#x2F;更换，有些则需要手动安装，先手动执行一遍twist脚本<code>./twist install</code>，确认有哪些错误，然后选择执行下面的命令</p>
<ol>
<li>修改<code>dependenciesinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不同的系统不一样，不要全改</span></span><br><span class="line"><span class="comment"># 1. 新增依赖包，如libcork-dev</span></span><br><span class="line"><span class="comment"># 2. 名称更换，如python-pip改为python3-pip</span></span><br><span class="line">apt install python3-dev python3-pip python3-setuptools python3-m2crypto libcork-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将pip改为pip3，可能需要使用pip安装m2crypto</span></span><br><span class="line">pip3 install qrcode</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改<code>sslibevinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># github的包命名改了，解压后变成了libsodium-stable</span></span><br><span class="line">tar zxf libsodium-<span class="variable">$&#123;libsodiumver&#125;</span>.tar.gz &amp;&amp; <span class="built_in">mv</span> libsodium-stable libsodium-<span class="variable">$&#123;libsodiumver&#125;</span></span><br></pre></td></tr></table></figure>

<p>或者删掉libsodium这段，直接手动编译安装，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/jedisct1/libsodium/releases/download/1.0.19-RELEASE/libsodium-1.0.19.tar.gz</span><br><span class="line">tar zxf libsodium-1.0.19.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libsodium-1.0.19</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改<code>sslibevinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 tar zxf $&#123;ssobfsver&#125;.tar.gz 这一行后面修改添加代码，因为obfs也有很长时间没有更新，导致在新的编译器下报错</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ssobfstag</span>&quot;</span> == <span class="string">&quot;v0.0.5&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment"># patch</span></span><br><span class="line">sed -i -e <span class="string">&quot;249s/$/ else &#123;result = OBFS_ERROR;&#125;/&quot;</span> /tmp/<span class="variable">$&#123;ssobfsver&#125;</span>/src/obfs_http.c</span><br><span class="line">sed -i -e <span class="string">&#x27;246d&#x27;</span> /tmp/<span class="variable">$&#123;ssobfsver&#125;</span>/src/obfs_http.c</span><br><span class="line"><span class="comment"># patch end</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改<code>sslibevinstallerr</code>、<code>sslibevinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sslibevinstallerr函数如下</span></span><br><span class="line"><span class="comment"># 删掉mbedtls相关包，与libsodium类似，因为命名问题我直接绑定版本了</span></span><br><span class="line"><span class="built_in">rm</span> -rf libsodium-<span class="variable">$&#123;libsodiumver&#125;</span>.tar.gz libsodium-<span class="variable">$&#123;libsodiumver&#125;</span> <span class="variable">$&#123;mbedtlsver&#125;</span>.tar.gz <span class="variable">$&#123;mbedtlsver&#125;</span> <span class="variable">$&#123;sslibevver&#125;</span>.tar.gz <span class="variable">$sslibevver</span> <span class="variable">$&#123;ssobfsver&#125;</span>.tar.gz <span class="variable">$ssobfsver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sslibevinstall函数如下</span></span><br><span class="line"><span class="comment"># 搜索与mbedtlstag有关的代码段，修改绑定版本v2.28.1</span></span><br><span class="line"><span class="comment"># ldconfig</span></span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$mbedtlstag</span>&quot;</span> ] &amp;&amp; mbedtlstag=<span class="string">&quot;v2.28.1&quot;</span></span><br><span class="line">mbedtlsver=<span class="string">&quot;mbedtls-<span class="subst">$(echo $&#123;mbedtlstag&#125; | sed -e &#x27;s/^[a-zA-Z]//g&#x27;)</span>&quot;</span></span><br><span class="line">wget -t 3 -T 30 -nv -O <span class="variable">$&#123;mbedtlsver&#125;</span>.tar.gz https://github.com/Mbed-TLS/mbedtls/archive/refs/tags/<span class="variable">$&#123;mbedtlstag&#125;</span>.tar.gz</span><br><span class="line">[ <span class="string">&quot;$?&quot;</span> != <span class="string">&quot;0&quot;</span> ] &amp;&amp; sslibevinstallerr <span class="string">&quot;mbedtls-<span class="subst">$(echo $&#123;mbedtlstag&#125; | sed -e &#x27;s/^[a-zA-Z]//g&#x27;)</span>&quot;</span></span><br><span class="line">[ -d <span class="variable">$&#123;mbedtlsver&#125;</span> ] &amp;&amp; <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;mbedtlsver&#125;</span>&quot;</span></span><br><span class="line">tar zxf <span class="variable">$&#123;mbedtlsver&#125;</span>.tar.gz</span><br><span class="line"><span class="built_in">pushd</span> <span class="variable">$mbedtlsver</span></span><br><span class="line">make SHARED=1 CFLAGS=-fPIC <span class="string">&quot;-j<span class="subst">$((MAKECORES+1)</span>)&quot;</span> &amp;&amp; make DESTDIR=/usr install || sslibevinstallerr <span class="string">&quot;mbedtls-<span class="variable">$&#123;mbedtlstag&#125;</span> | sed -e &#x27;s/^[a-zA-Z]//g&#x27;&quot;</span> err</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line">ldconfig</span><br><span class="line"><span class="built_in">rm</span> -rf libsodium-<span class="variable">$&#123;libsodiumver&#125;</span>.tar.gz libsodium-<span class="variable">$&#123;libsodiumver&#125;</span> mbedtls-<span class="variable">$&#123;mbedtlsver&#125;</span>.tgz mbedtls-<span class="variable">$&#123;mbedtlsver&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="安装完毕"><a href="#安装完毕" class="headerlink" title="安装完毕"></a>安装完毕</h3><p>执行修改后的twist脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./twist install</span><br></pre></td></tr></table></figure>

<p>如果twist安装成功，此时命令行下将会展示ss服务的二维码以及url，手机端可以用小火箭扫描，桌面端可以复制url导入</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># obfs混淆ss流量；privoxy将http流量转换为socks5流量</span></span><br><span class="line"><span class="built_in">sudo</span> apt install shadowsocks-libev simple-obfs privoxy</span><br></pre></td></tr></table></figure>

<h3 id="ss配置"><a href="#ss配置" class="headerlink" title="ss配置"></a>ss配置</h3><p>修改ss配置，配置文件可以是<code>/etc/shadowsocks-libev/config.json</code>，也可以是<code>/etc/shadowsocks-libev/config-obfs.json</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure>

<p>按下方模板配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;server_ip&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span><span class="string">&quot;tcp_and_udp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span><span class="number">443</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span><span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;server_password&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">86400</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;xchacha20-ietf-poly1305&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugin&quot;</span><span class="punctuation">:</span><span class="string">&quot;obfs-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugin_opts&quot;</span><span class="punctuation">:</span><span class="string">&quot;obfs=tls;obfs-host=mzstatic.com;obfs-uri=/&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>执行下面的命令，确认软件可正常运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看输出确认无异常报错</span></span><br><span class="line"><span class="built_in">sudo</span> ss-local -c /etc/shadowsocks-libev/config.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1080端口</span></span><br><span class="line"><span class="built_in">sudo</span> netstat -tnlp | grep 1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发现ss服务未能正常启动，查看status信息</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status shadowsocks-libev.service</span><br></pre></td></tr></table></figure>

<p>修改<code>systemd</code>配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /usr/lib/systemd/system/shadowsocks-libev.service</span><br></pre></td></tr></table></figure>

<p>将<code>ss-server</code>改为<code>ss-local</code>，因为我们修改的是<code>shadowsocks-libev.service</code>，配置文件就是<code>config.json</code>，这里就不需要再修改什么</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  This file is part of shadowsocks-libev.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Shadowsocks-libev is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment">#  it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment">#  the Free Software Foundation; either version 3 of the License, or</span></span><br><span class="line"><span class="comment">#  (at your option) any later version.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  This file is default for Debian packaging. See also</span></span><br><span class="line"><span class="comment">#  /etc/default/shadowsocks-libev for environment variables.</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Shadowsocks-libev Default Client Service</span><br><span class="line"><span class="attr">Documentation</span>=man:shadowsocks-libev(<span class="number">8</span>)</span><br><span class="line"><span class="attr">After</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"><span class="attr">Wants</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">CapabilityBoundingSet</span>=CAP_NET_BIND_SERVICE</span><br><span class="line"><span class="attr">AmbientCapabilities</span>=CAP_NET_BIND_SERVICE</span><br><span class="line"><span class="attr">DynamicUser</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">EnvironmentFile</span>=/etc/default/shadowsocks-libev</span><br><span class="line"><span class="attr">LimitNOFILE</span>=<span class="number">32768</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/ss-local -c <span class="variable">$CONFFILE</span> <span class="variable">$DAEMON_ARGS</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p>重启ss服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart shadowsocks-libev</span><br></pre></td></tr></table></figure>

<h3 id="privoxy配置"><a href="#privoxy配置" class="headerlink" title="privoxy配置"></a>privoxy配置</h3><p>修改配置文件<code>/etc/privoxy/config</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/privoxy/config</span><br></pre></td></tr></table></figure>

<p>修改<code>listen-address</code>，因为有时我会将地址共享出来给局域网其他设备使用，所以我一般会将<code>127.0.0.1</code>改为<code>0.0.0.0</code>。在末尾添加<code>forward-socks5</code>指令，将所有<code>http</code>流量转发到<code>1080</code>端口</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">listen-address  0.0.0.0:8118</span><br><span class="line">forward-socks5   /               127.0.0.1:1080  .</span><br></pre></td></tr></table></figure>

<p>重启privoxy服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart privoxy</span><br></pre></td></tr></table></figure>

<p>防火墙开放8118端口访问（可选，如果没有打算给局域网内的其他机器使用就不要打开）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 8118/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure>

<h3 id="最后验证"><a href="#最后验证" class="headerlink" title="最后验证"></a>最后验证</h3><p>配置环境变量<code>http_proxy</code>以及<code>https_proxy</code>，访问外网地址，只要有html数据流输出即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118;<span class="built_in">export</span> https_proxy=http://127.0.0.1:8118;</span><br><span class="line"></span><br><span class="line">curl -i https://www.google.com/</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/forestbat/Twist">Twist脚本github地址</a><br><a href="https://winamp.top/228.html">Debian11下编译安装Shadowsocks-libev</a><br><a href="http://docs.lvrui.io/2016/12/12/Linux%E4%B8%AD%E4%BD%BF%E7%94%A8ShadowSocks-Privoxy%E4%BB%A3%E7%90%86/">Linux中使用ShadowSocks+Privoxy代理</a></p>
]]></content>
      <tags>
        <tag>shadowsocks</tag>
        <tag>obfs</tag>
        <tag>privoxy</tag>
      </tags>
  </entry>
  <entry>
    <title>如何配置wireguard服务端及客户端</title>
    <url>/2020/04/05/how-to-setup-wireguard-vpn-server/</url>
    <content><![CDATA[<p>从19年开始，ss流量已经能被gfw识别并屏蔽，原本打算切换到v2ray，但配置混淆需要域名反而会暴露出更多信息，此外，网上一篇文章指出v2ray开发者失联的同时一项v2ray流量识别的专利被注册，因此决定放弃v2ray并转向另一个被linus盛赞的wireguard。</p>
<p>wireguard是非常简单、现代化、快速的vpn，使用最新的加密技术，udp传输，支持ip漫游等。wireguard没有服务端、客户端的区分，每一台设备都是一个<code>peer</code>。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>添加wireguard的PPA源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:wireguard/wireguard</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install wireguard</span><br></pre></td></tr></table></figure>

<p>wireguard作为linux内核模块方式加载，内核更新wireguard也会自动重新编译，重启系统或使用<code>modprobe</code>开启模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe wireguard</span><br></pre></td></tr></table></figure>

<p>检查wireguard模块是否成功加载，成功输出与下面类似</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant@bionic:~$ lsmod | grep wireguard</span><br><span class="line">wireguard             221184  0</span><br><span class="line">ip6_udp_tunnel         16384  1 wireguard</span><br><span class="line">udp_tunnel             16384  1 wireguard</span><br></pre></td></tr></table></figure>

<h2 id="生成keys"><a href="#生成keys" class="headerlink" title="生成keys"></a>生成keys</h2><p>wireguard提供了两个命令行工具<code>wg</code>以及<code>wg-quick</code>，使用<code>wg</code>生成公钥和私钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> 077</span><br><span class="line">wg genkey | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/wireguard/privatekey | wg pubkey | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/wireguard/publickey</span><br></pre></td></tr></table></figure>

<p>类似ssh，需要为每台设备生成一对publickey&#x2F;privatekey</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>我们需要生成一个虚拟网卡，名称可以按个人喜好选择，这里选择用<code>wg0</code>，IP网段使用<code>10.10.0.1/24</code>，确保该网段没有被你的家庭或公司网络使用，编辑文件<code>/etc/wireguard/wg0.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">PrivateKey = &lt;your server private key here&gt;</span><br><span class="line">Address = 10.10.0.1/24</span><br><span class="line">Address = fd86:ea04:1111::1/64</span><br><span class="line">SaveConfig = true</span><br><span class="line">PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE; ip6tables -A FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o enp0s3 -j MASQUERADE; ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o enp0s3 -j MASQUERADE</span><br><span class="line">ListenPort = 51820</span><br></pre></td></tr></table></figure>

<p><code>PrivateKey</code>填上一步生成的私钥，填入你选择的<code>Address</code>，这里配置了两个IP4&#x2F;6的地址，<code>enp0s3</code>是你服务器主要的网络设备，使用<code>ifconfig</code>或<code>ip a</code>查看你的主设备名，<code>ListenPort</code>默认为51820，建议修改</p>
<p>要注意的是<code>SaveConfig</code>设置，wireguard配置后不需要<code>restart</code>或<code>reload</code>，使用<code>wg</code>命令添加<code>peer</code>即可立即生效。但是，这些操作都是直接写入到内存中而不是磁盘，因此如果你重启系统或服务，那么你就会失去添加的配置，所以这里设置为<code>true</code>，自动保存配置。但这个配置有时候也会让人非常困扰，你可能添加配置后重启服务，然后你发现添加的配置不见了，需要先停止服务再添加配置最后重启。</p>
<p>添加网络配置，使得内核可以正确路由我们的NAT流量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&#x27;cat &lt;&lt; EOF &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward=1</span></span><br><span class="line"><span class="string">net.ipv6.conf.all.forwarding=1</span></span><br><span class="line"><span class="string">EOF&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl -p</span><br></pre></td></tr></table></figure>

<p>运行命令，开启wg0设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wg-quick up wg0</span><br></pre></td></tr></table></figure>

<p>如果一切顺利，那么运行下面命令你将看到类似的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant@bionic:~$ <span class="built_in">sudo</span> wg</span><br><span class="line">interface: wg0</span><br><span class="line">  public key: Td4IBZg2s2bMSjewD0h4oBhlbaJteygxjT83xeM7uTY=</span><br><span class="line">  private key: (hidden)</span><br><span class="line">  listening port: 51820</span><br></pre></td></tr></table></figure>

<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>客户端配置与服务端类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">Address = 10.10.0.2/32</span><br><span class="line">Address = fd86:ea04:1111::2/128</span><br><span class="line">SaveConfig = true</span><br><span class="line">PrivateKey = &lt;your client private key here&gt;</span><br><span class="line">DNS = 8.8.8.8</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = &lt;your server public key here&gt;</span><br><span class="line">Endpoint = &lt;your server public ip&gt;:51820</span><br><span class="line">AllowedIPs = 0.0.0.0/0, ::/0</span><br></pre></td></tr></table></figure>

<p>填写服务器的publickey、ip、端口，配置<code>0.0.0.0/0, ::/0</code>将所有流量传输到服务端</p>
<p>在服务端添加客户端配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wg <span class="built_in">set</span> wg0 peer &lt;client-public-key&gt; allowed-ips 10.10.0.2/32,fd86:ea04:1111::2/128</span><br></pre></td></tr></table></figure>

<p>以上的操作针对的是linux系统，官方推出了可用的iOS&#x2F;MacOS&#x2F;Android&#x2F;Windows图形界面软件，其中有一个选项要注意的是<code>On-Demand</code>，有<code>Ethernet</code>和<code>Wi-Fi</code>选项，如果勾选，那么会在选中网络中会自动开启vpn</p>
<h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><p>如果你的系统使用systemd,如ubuntu，设置wireguard开机启动命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> wg-quick@wg0</span><br></pre></td></tr></table></figure>

<h2 id="开放防火墙"><a href="#开放防火墙" class="headerlink" title="开放防火墙"></a>开放防火墙</h2><h3 id="UFW"><a href="#UFW" class="headerlink" title="UFW"></a>UFW</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 51820/udp</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.wireguard.com/">WireGuard: fast, modern, secure VPN tunnel</a><br><a href="https://securityespresso.org/tutorials/2019/03/22/vpn-server-using-wireguard-on-ubuntu/">How to setup your own VPN server using WireGuard on Ubuntu</a><br><a href="https://medium.com/@aveek/setting-up-pihole-wireguard-vpn-server-and-client-ubuntu-server-fc88f3f38a0a">Setting Up PiHole, Wireguard VPN server and Client (Ubuntu Server)</a></p>
]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>wireguard</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ubuntu系统monospace字体显示异常的问题</title>
    <url>/2019/11/24/linux-monofonts-render-incorrectly/</url>
    <content><![CDATA[<p>很长的一段时间，被xubuntu下的一个monospace字体显示问题困扰着，在网上找了很多方法也没有解决问题，在一次误打误撞的情况下解决了，简单把自己问题的过程记录下来，希望给一些小伙伴们帮助</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>xubuntu下monospace在浏览器以及vscode下显示异常，具体如下图所示</p>
<p>浏览器chrome&#x2F;firefox下的monospace</p>
<p><img src="/images/monofont_display_incorrect_in_browser.png" alt="monofont display incorrect in browser"></p>
<p>vscode下的monospace</p>
<p><img src="/images/monofont_display_incorrect_in_vscode.png" alt="monofont display incorrect in vscode"></p>
<p>网上搜索结果大部分指示，是由于libfreetype6 2.8.1-2ubuntu2的一个bug导致，需要升级到最新的libfreetype2.9或者降级到libfreetype2.8.0，按照搜索的文档进行libfreetype的升级&#x2F;降级后，显示效果依旧，问题没有得到解决</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>在我放弃治疗后过了一段时间，突然想起，一直以来都忽略了验证linux的字体信息。首先，获取显示异常的字体font-family，如下图</p>
<p><img src="/images/browser_get_font_family.png" alt="browser get font family"></p>
<p>使用fc-match验证字体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fc-match monospace</span><br><span class="line">DejaVuSansMono.ttf: <span class="string">&quot;DejaVu Sans Mono&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match consolas</span><br><span class="line">DejaVuSansMono.ttf: <span class="string">&quot;DejaVu Sans Mono&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match Menlo</span><br><span class="line">DejaVuSans.ttf: <span class="string">&quot;DejaVu Sans&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match <span class="string">&quot;PingFang SC&quot;</span></span><br><span class="line">DejaVuSans.ttf: <span class="string">&quot;DejaVu Sans&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match <span class="string">&quot;Microsoft YaHei&quot;</span></span><br><span class="line">NotoSansCJK-Regular.ttc: <span class="string">&quot;Noto Sans CJK SC&quot;</span> <span class="string">&quot;Regular&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到Menlo、”PingFang SC”、”Microsoft YaHei”的实际字体跟monospace并不一致，抱着死马当活马医的心态，编辑字体配置文件<code>~/.config/fontconfig/fonts.conf</code>，内容如下，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;fonts.dtd&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>Menlo<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prefer</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>DejaVu Sans Mono<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>退出，重新登录，发现这个困扰了很久的问题终于解决，如下图</p>
<p><img src="/images/monofont_the_correct_view.png" alt="monofont the correct view"></p>
<p>vscode可以通过更改font-family恢复正常的显示效果</p>
<p><strong>注意</strong></p>
<p>ubuntu&#x2F;xubuntu、中文&#x2F;英文的系统默认的字体会有些许差异，以上的操作可能不一定生效，可以新增<code>~/.config/fontconfig/conf.d/00-menlo.conf</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;fonts.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span> <span class="attr">binding</span>=<span class="string">&quot;same&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Menlo<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">accept</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>DejaVu Sans Mono<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">accept</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/adobe/brackets/issues/14290">[Ubuntu 18.04 LTS] Font not rendering properly</a><br><a href="https://stackoverflow.com/questions/50114376/ubuntu-18-04-lts-font-not-rendering-properly">Ubuntu 18.04 LTS Font not rendering properly</a><br><a href="https://superuser.com/questions/930572/why-doesnt-fc-match-respect-my-match-and-edit-rule-for-courier-when-it-does-for">Why doesn’t fc-match respect my match and edit rule for Courier when it does for Consolas?</a></p>
]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>browser</tag>
        <tag>vscode</tag>
        <tag>monospace</tag>
        <tag>fonts</tag>
      </tags>
  </entry>
  <entry>
    <title>使用github pages搭建个人博客</title>
    <url>/2019/09/02/personal-blog-using-github-pages/</url>
    <content><![CDATA[<p>简单介绍如何使用github pages服务以及hexo搭建一个免费的个人博客</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个空的仓库，名字固定格式为“username.github.io”，这个名字也是博客的访问的域名</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli           <span class="comment"># 安装hexo命令行工具</span></span><br><span class="line">hexo init blog                    <span class="comment"># 创建blog项目</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next <span class="comment"># 安装next主题，可选</span></span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git --save <span class="comment"># 安装github发布工具</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><p>修改_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础配置</span></span><br><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Y2k38&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">y2k38&#x27;s</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">y2k38</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># URL </span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://y2k38.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 博客主题配置</span></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment"># 可选，若没有安装next主题，则忽略</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># github部署配置</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/Y2k38/y2k38.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment"># 注意，分支固定位master</span></span><br></pre></td></tr></table></figure>

<h3 id="发布github"><a href="#发布github" class="headerlink" title="发布github"></a>发布github</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>完成</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="添加gitalk评论系统"><a href="#添加gitalk评论系统" class="headerlink" title="添加gitalk评论系统"></a>添加gitalk评论系统</h3><blockquote>
<p>[Deprecated] github要求校验方式改为personal access token，待gitalk作者及theme-next作者更新</p>
</blockquote>
<p>新建OAuth application获取id、secret，<a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p>
<p><img src="/images/register_a_new_OAuth_application.png" alt="new oauth app"></p>
<p>配置next主题 <code>themes/next/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># Demo: https://gitalk.github.io</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/gitalk/gitalk, https://github.com/emn178/js-md5</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">y2k38</span> <span class="comment"># GitHub repo owner</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">y2k38.github.io</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">xxxxxxxxxxxxxxxx</span> <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">yyyyyyyyyyyyyyyy</span> <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">Y2k38</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://pages.github.com/">GitHub Pages</a><br><a href="https://gist.github.com/btfak/18938572f5df000ebe06fbd1872e4e39">How to use Hexo and deploy to GitHub Pages</a><br><a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line">Creating a personal access token for the command line</a></p>
]]></content>
      <tags>
        <tag>github pages</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - 类</title>
    <url>/2020/11/26/php-extension-writing-classes/</url>
    <content><![CDATA[<p>以下简单介绍如何在C语言层面使用PHP类</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>创建一个PHP对象，对象类似关联数组，对象之上可关联任意多个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(makeObject) &#123;</span><br><span class="line">    object_init(return_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加属性</span></span><br><span class="line">    zend_update_property_string(<span class="literal">NULL</span>, return_value, <span class="string">&quot;prop1&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;prop1&quot;</span>), <span class="string">&quot;val1&quot;</span>);</span><br><span class="line">    zend_update_property_long(<span class="literal">NULL</span>, return_value, <span class="string">&quot;prop2&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;prop2&quot;</span>), <span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数并打印结果<code>var_dump(makeObject());</code>，输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">object(stdClass)#1 (2) &#123;</span><br><span class="line">    [<span class="string">&quot;prop1&quot;</span>]=&gt;</span><br><span class="line">    string(3) <span class="string">&quot;val1&quot;</span></span><br><span class="line">    [<span class="string">&quot;prop2&quot;</span>]=&gt;</span><br><span class="line">    int(123)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>创建一个类模板</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class定义存储于zend_class_entry</span></span><br><span class="line">zend_class_entry *test_ce_myclass;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_methods[] = &#123;</span><br><span class="line">    <span class="comment">// 类方法使用宏指令PHP_ME</span></span><br><span class="line">    <span class="comment">// public function hello()</span></span><br><span class="line">    PHP_ME(MyClass, hello, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC)</span><br><span class="line">    <span class="comment">// 与函数定义相同</span></span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主菜，注册并加载类</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_init_myclass</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    zend_class_entry ce;</span><br><span class="line">    INIT_CLASS_ENTRY(ce, <span class="string">&quot;MyClass&quot;</span>, test_methods);</span><br><span class="line">    <span class="comment">// 注册MyClass类</span></span><br><span class="line">    test_ce_myclass = zend_register_internal_class(&amp;ce);</span><br><span class="line">    <span class="comment">// 添加属性/常量等</span></span><br><span class="line">    <span class="comment">// public $success = true;</span></span><br><span class="line">    zend_declare_property_bool(test_ce_myclass, <span class="string">&quot;success&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;success&quot;</span>)<span class="number">-1</span>, <span class="number">1</span>, ZEND_ACC_PUBLIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法hello</span></span><br><span class="line">PHP_METHOD(MyClass, hello)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_STRING(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，函数<code>test_init_myclass</code>的最后一个参数<code>ZEND_ACC_PUBLIC</code>为访问控制标记之一公共访问，常用的访问控制标记还有以下几个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZEND_ACC_STATIC</span><br><span class="line">ZEND_ACC_PUBLIC</span><br><span class="line">ZEND_ACC_PROTECTED</span><br><span class="line">ZEND_ACC_PRIVATE</span><br><span class="line">ZEND_ACC_CTOR</span><br><span class="line">ZEND_ACC_DTOR</span><br><span class="line">ZEND_ACC_DEPRECATED</span><br></pre></td></tr></table></figure>

<p>一个class定义注册相关逻辑已经完成，要在PHP中使用类MyClass还需要在模块初始化<code>MINIT</code>中添加运行<code>test_init_myclass</code>以加载类MyClass</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    test_init_myclass();</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译<code>test</code>模块并开启后，运行<code>var_dump(new MyClass());</code>，将得到以下类似输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">object(MyClass)#1 (1) &#123;</span><br><span class="line">    [<span class="string">&quot;success&quot;</span>]=&gt;</span><br><span class="line">    bool(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以直接在C层面初始化并生成一个实例化类对象，增加一个工厂方法<code>factory</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_methods[] = &#123;</span><br><span class="line">    PHP_ME(MyClass, hello, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC)</span><br><span class="line">    PHP_ME(MyClass, factory, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)</span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PHP_METHOD(MyClass, factory)</span><br><span class="line">&#123;</span><br><span class="line">    object_init_ex(return_value, test_ce_myclass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们可以使用<code>MyClass::factory()</code>获取一个新的MyClass对象</p>
<p>如果需要对MyClass进行一些操作，像在PHP使用构造方法，在test_methods里添加<code>__construct</code>，如此，PHP在<code>new MyClass()</code>将自动调用构造方法<code>__construct</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_methods[] = &#123;</span><br><span class="line">    <span class="comment">// ZEND_ACC_CTOR</span></span><br><span class="line">    PHP_ME(MyClass, __construct, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)</span><br><span class="line">    PHP_ME(MyClass, hello, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC)</span><br><span class="line">    PHP_ME(MyClass, factory, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)</span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PHP_METHOD(MyClass, __construct)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h2><p>上面，虽然对象在new时会自动调用<code>__construct</code>函数进行初始化，但<code>factory</code>不会自动调用构造函数，仅返回包含默认值的新对象，为此，我们需要在<code>factory</code>内调用构造方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zend_interfaces.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">PHP_METHOD(MyClass, factory)</span><br><span class="line">&#123;</span><br><span class="line">    zval *myzval;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ZVAL(myzval)</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    object_init_ex(return_value, test_ce_myclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zend_call_method，其他的还有</span></span><br><span class="line">    <span class="comment">// zend_call_method_with_0_params</span></span><br><span class="line">    <span class="comment">// zend_call_method_with_1_params</span></span><br><span class="line">    <span class="comment">// zend_call_method_with_2_params</span></span><br><span class="line">    <span class="comment">// ZEND_API zval* zend_call_method(zval *object_pp, zend_class_entry *obj_ce, zend_function **fn_proxy, const char *function_name, size_t function_name_len, zval *retval, int param_count, zval* arg1, zval* arg2);</span></span><br><span class="line">    zend_call_method(return_value, test_ce_myclass, <span class="literal">NULL</span>, <span class="string">&quot;__construct&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;__construct&quot;</span>)<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">1</span>, myzval, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>先前我们已经了解函数返回值<code>return_value</code>的使用，现在，我们来看如何在方法内访问<code>$this</code>，PHP提供<code>getThis()</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_METHOD(MyClass, __construct)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *msg;</span><br><span class="line">    <span class="type">size_t</span> msg_len;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_STRING(msg, msg_len)</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    zend_update_property_string(test_ce_myclass, getThis(), <span class="string">&quot;msg&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;msg&quot;</span>)<span class="number">-1</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关联结构体"><a href="#关联结构体" class="headerlink" title="关联结构体"></a>关联结构体</h2><p>我们构建一个结构体，这个结构体在PHP是无法访问的，但可以在扩展内访问对该结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还不是特别了解</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">test_struct</span> &#123;</span></span><br><span class="line">    zend_object <span class="built_in">std</span>;</span><br><span class="line">    <span class="type">int</span> unknown_id;</span><br><span class="line">    <span class="type">char</span> *unknown_str;</span><br><span class="line">&#125; test_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_object *<span class="title function_">create_test_struct</span><span class="params">(zend_class_entry *class_type)</span> &#123;</span><br><span class="line">    test_struct *intern;</span><br><span class="line"></span><br><span class="line">    intern = ecalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(test_struct) + zend_object_properties_size(class_type));</span><br><span class="line"></span><br><span class="line">    zend_object_std_init(&amp;intern-&gt;<span class="built_in">std</span>, class_type);</span><br><span class="line">    object_properties_init(&amp;intern-&gt;<span class="built_in">std</span>, class_type);</span><br><span class="line"></span><br><span class="line">    intern-&gt;<span class="built_in">std</span>.handlers = zend_get_std_object_handlers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;intern-&gt;<span class="built_in">std</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_test_struct</span><span class="params">(<span class="type">void</span> *object)</span> &#123;</span><br><span class="line">    test_struct *secrets = (test_struct*)object;</span><br><span class="line">    <span class="keyword">if</span> (secrets-&gt;unknown_str) &#123;</span><br><span class="line">        efree(secrets-&gt;unknown_str);</span><br><span class="line">    &#125;</span><br><span class="line">    efree(secrets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问结构体<code>test_struct</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_METHOD(MyClass, attachStruct) &#123;</span><br><span class="line">    test_struct *secrets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    secrets = (test_struct*)getThis();</span><br><span class="line"></span><br><span class="line">    RETURN_LONG(secrets-&gt;unknown_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>PHP的异常继承自<code>Exception</code>，所以下面除了新增一个异常类，还涉及了类的继承</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zend_exceptions.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">zend_class_entry *test_ce_exception;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_init_exception</span><span class="params">()</span> &#123;</span><br><span class="line">    zend_class_entry ce;</span><br><span class="line">    <span class="comment">// 设置第三个参数为NULL，继承Exception所有方法，无自定义行为</span></span><br><span class="line">    INIT_CLASS_ENTRY(ce, <span class="string">&quot;MyException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    test_ce_exception = zend_register_internal_class_ex(&amp;ce, (zend_class_entry*)zend_exception_get_default());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    test_init_myclass();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    test_init_exception();</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法&#x2F;函数中抛出异常</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_METHOD(MyClass, throwExcept) &#123;</span><br><span class="line">    zend_throw_exception(test_ce_exception, <span class="string">&quot;custom exception throw&quot;</span>, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/Y2k38/php_ext_tutorial">php_ext_tutorial</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/bigbes/bigbes.github.io/wiki/PHP-Extensions-Made-Eldrich:-Classes">PHP Extensions Made Eldrich: Classes</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - Part 1</title>
    <url>/2019/09/03/php-extension-writing-part1/</url>
    <content><![CDATA[<p>在网上找到几篇基于PHP5的扩展开发的文章，有些古老，与PHP7不完全兼容，自己做了些简单的翻译、修改。</p>
<p>建议开发者先阅读<a href="http://www.phpinternalsbook.com/">PHP Internals Book</a>这份在线文档，里面对PHP做了比较全面的讲解。由于PHP扩展开发的资料比较少，也鲜有PHP开发者触及到这块，编写扩展时如果遇到问题，最好是先查找PHP源代码是否有相关的使用案例，再通过网上论坛、QQ等方式寻求帮助。</p>
<p>本文是PHP扩展开发系列的第一篇，主要介绍如何开发一个简单的PHP扩展、如何获取ini配置参数、如何配置全局变量</p>
<p>前期准备：</p>
<p>PHP编译选项加入<code>--enable-debug</code>以及<code>--enable-maintainer-zts</code>。<code>--enable-debug</code>生成额外的调试符号，并将优化等级设置为<code>-O0</code>，报告内存泄露等错误，使使用gdb进行debug时更为准确；<code>--enable-maintainer-zts</code>启用线程安全，开启<code>ZTS</code>宏定义，配置PHP为TSRM机制，用于编写调试多线程代码</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="扩展目录结构"><a href="#扩展目录结构" class="headerlink" title="扩展目录结构"></a>扩展目录结构</h3><p>你可能会使用PHP源代码自带的脚本<code>ext/ext_skel.php</code>生成扩展骨架，但这里选择极简方式创建一个扩展，最基本的扩展只需要三个文件：配置文件<code>config.m4</code>，头文件<code>php_test.h</code>，源文件<code>test.c</code></p>
<p><code>test</code>扩展目录结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php-7.4.1</span><br><span class="line">└── ext</span><br><span class="line">    └── <span class="built_in">test</span></span><br><span class="line">        ├── config.m4</span><br><span class="line">        ├── php_test.h</span><br><span class="line">        └── test.c</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnl 用于生成configure及其他文件</span><br><span class="line">dnl `dnl`开头的行为注释内容</span><br><span class="line">dnl 若扩展依赖外部库，使用--with，否则默认使用--enable</span><br><span class="line">PHP_ARG_ENABLE(test, whether to enable test support,</span><br><span class="line">[  --enable-test          Enable test support], no)</span><br><span class="line"></span><br><span class="line">if test &quot;$PHP_TEST&quot; != &quot;no&quot;; then</span><br><span class="line">  AC_DEFINE(HAVE_TEST, 1, [ Have test support ])</span><br><span class="line">  PHP_NEW_EXTENSION(test, test.c, $ext_shared)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>头文件默认格式为<code>php_extname.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PHP_TEST_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PHP_TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PHP扩展结构zend_module_entry */</span></span><br><span class="line"><span class="keyword">extern</span> zend_module_entry test_module_entry;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> phpext_test_ptr &amp;test_module_entry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* version扩展版本号 */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PHP_TEST_VERSION <span class="string">&quot;0.1.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义函数声明PHP_FUNCTION(your_function_name) */</span></span><br><span class="line">PHP_FUNCTION(test);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ZTS) &amp;&amp; defined(COMPILE_DL_TEST)</span></span><br><span class="line">ZEND_TSRMLS_CACHE_EXTERN()</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_CONFIG_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php_test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义函数注册，最终*test_functions注册到模块声明test_module_entry */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_functions[] = &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 注册`test`函数，格式为PHP_FE(func_name, arg_info)，arg_info声明参数信息，如是否是引用等，这里先忽略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PHP_FE(test, <span class="literal">NULL</span>)</span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块注册 */</span></span><br><span class="line">zend_module_entry test_module_entry = &#123;</span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,                    <span class="comment">/* 扩展名称 */</span></span><br><span class="line">    test_functions,            <span class="comment">/* 自定义函数注册 */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_MINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_RINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_RSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_MINFO */</span></span><br><span class="line">    PHP_TEST_VERSION,          <span class="comment">/* version */</span></span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数test */</span></span><br><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_STRING(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_DL_TEST</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ZTS</span></span><br><span class="line">ZEND_TSRMLS_CACHE_DEFINE()</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">ZEND_GET_MODULE(test)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line"><span class="comment"># 除非config.m4有改动，否则只执行以下命令</span></span><br><span class="line">make &amp;&amp; <span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在<code>php.ini</code>添加<code>extension=test.so</code>，执行脚本获取输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;echo test();&quot;</span> <span class="comment"># 输出：Hello World</span></span><br></pre></td></tr></table></figure>

<h2 id="INI参数"><a href="#INI参数" class="headerlink" title="INI参数"></a>INI参数</h2><p>Zend Engine提供了两种方式访问ini参数，以下是第一种较为简单的方式，第二种方式与全局变量搭配使用，后面介绍</p>
<p>我们在PHP的声明周期MINIT阶段注册ini参数，在<code>php_test.h</code>添加MINIT原型声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test模块初始化</span></span><br><span class="line">PHP_MINIT_FUNCTION(test);</span><br><span class="line"><span class="comment">// test模块关闭清理函数</span></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(test);</span><br></pre></td></tr></table></figure>

<p><code>test.c</code>做以下调整，注册MINIT，init参数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php_ini.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">zend_module_entry test_module_entry = &#123;</span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    test_functions,</span><br><span class="line">    PHP_MINIT(test),      <span class="comment">/* 注册MINIT */</span></span><br><span class="line">    PHP_MSHUTDOWN(test),  <span class="comment">/* 注册MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    PHP_TEST_VERSION,</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ini参数获取代码块</span></span><br><span class="line">PHP_INI_BEGIN()</span><br><span class="line">    <span class="comment">// ini参数test.foo声明</span></span><br><span class="line">    PHP_INI_ENTRY(<span class="string">&quot;test.foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, PHP_INI_ALL, <span class="literal">NULL</span>)</span><br><span class="line">PHP_INI_END();</span><br><span class="line"><span class="comment">// 以上宏等同于声明zend_ini_entry_def[]变量</span></span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    REGISTER_INI_ENTRIES();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    UNREGISTER_INI_ENTRIES();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_STRING(INI_STR(<span class="string">&quot;test.foo&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ini参数声明放置在<code>PHP_INI_BEGIN</code>、<code>PHP_INI_END</code>，参数声明使用宏<code>PHP_INI_ENTRY</code>，具体格式为<code>PHP_INI_ENTRY(param_name, default_val, access_mode_modifier, validator)</code></p>
<p><code>access_mode_modifier</code>决定ini参数可在什么地方被修改，主要有</p>
<ul>
<li>PHP_INI_ALL: 值可通过php.ini、.htaccess、ini_set修改</li>
<li>PHP_INI_SYSTEM: 只可通过php.ini修改</li>
<li>PHP_INI_PERDIR: 只可通过.htaccess修改</li>
</ul>
<p><code>validator</code>校验这里先忽略</p>
<p>ini参数值获取方式如下</p>
<table>
<thead>
<tr>
<th align="left">当前值local value</th>
<th align="left">默认值master value</th>
<th align="left">返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INI_STR</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">char *</td>
</tr>
<tr>
<td align="left">INI_INT</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">zend_long</td>
</tr>
<tr>
<td align="left">INI_FLT</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">INI_BOOL</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">zend_bool</td>
</tr>
</tbody></table>
<p>配置PHP，在<code>php.ini</code>添加<code>test.foo=helloworld</code>，执行脚本获取输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;echo test();&quot;</span> <span class="comment"># 输出：helloworld</span></span><br></pre></td></tr></table></figure>

<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>上面部分的ini参数获取代码有几个问题，第一，每次读取ini参数值时，都需要系统扫描ini设置表，并转换成相应的类型；第二，没有校验用户输入，这样用户使用<code>ini_set</code>可以设置任意数据</p>
<p>我们可以配置ini参数到全局变量，避免每次扫描ini设置表，在这之前，先看看如何使用全局变量编写一个计数器</p>
<p>头文件<code>php_test.h</code>添加全局变量声明，并定义一个宏来访问我们的全局变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;TSRM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line">ZEND_BEGIN_MODULE_GLOBALS(test)</span><br><span class="line">    <span class="type">long</span> counter;</span><br><span class="line">ZEND_END_MODULE_GLOBALS(test)</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 上面代码等同</span></span><br><span class="line"><span class="comment"> * typedef struct _zend_pib_globals &#123;</span></span><br><span class="line"><span class="comment"> *     long counter;</span></span><br><span class="line"><span class="comment"> * &#125; zend_test_globals;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 TEST_G - 全局变量访问 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TEST_G(v) TSRMG(test_globals_id, zend_test_globals *, v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TEST_G(v) (test_globals.v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请求初始化 */</span></span><br><span class="line">PHP_MINIT_FUNCTION(test);</span><br></pre></td></tr></table></figure>

<p>源文件初始化全局变量，MINIT只会在进程或线程创建时执行一次，而一个进程可以服务多个请求，我们需要计数器在每个请求开始时清零，需要RINIT函数清零counter</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化zend_test_globals */</span></span><br><span class="line">ZEND_DECLARE_MODULE_GLOBALS(test)</span><br><span class="line"><span class="comment">/* 等同于 zend_test_globals test_globals; */</span></span><br><span class="line"></span><br><span class="line">zend_module_entry test_module_entry = &#123;</span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    test_functions,</span><br><span class="line">    PHP_MINIT(test),</span><br><span class="line">    PHP_MSHUTDOWN(test),</span><br><span class="line">    PHP_RINIT(test),     <span class="comment">/* 注册请求初始化函数 */</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    PHP_TEST_VERSION,</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量初始化，仅在进程/线程创建时初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_init_globals</span><span class="params">(zend_test_globals *test_globals)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求初始化</span></span><br><span class="line">PHP_RINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 因一个进程可服务多个请求，我们需要每个请求都有独立的counter */</span></span><br><span class="line">    TEST_G(counter) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化</span></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 全局变量表注册 */</span></span><br><span class="line">    ZEND_INIT_MODULE_GLOBALS(test, php_test_init_globals, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    REGISTER_INI_ENTRIES();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行PHP脚本获取输出验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;test(); echo test();&quot;</span> <span class="comment"># 输出：2</span></span><br></pre></td></tr></table></figure>

<h2 id="INI注册全局变量"><a href="#INI注册全局变量" class="headerlink" title="INI注册全局变量"></a>INI注册全局变量</h2><p>有了上面的认识，在这里，将ini参数<code>test.direction</code>注册到全局变量，并添加validator校验</p>
<p>头文件添加参数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZEND_BEGIN_MODULE_GLOBALS(test)</span><br><span class="line">    <span class="type">long</span> counter;</span><br><span class="line">    zend_bool direction;</span><br><span class="line">ZEND_END_MODULE_GLOBALS(test)</span><br></pre></td></tr></table></figure>

<p>源文件修改为以下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_INI_BEGIN()</span><br><span class="line">    PHP_INI_ENTRY(<span class="string">&quot;test.foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, PHP_INI_ALL, <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">// STD_PHP_INI_ENTRY(name, default_value, modifiable, on_modify, property_name, struct_type, struct_ptr)</span></span><br><span class="line">    STD_PHP_INI_ENTRY(<span class="string">&quot;test.direction&quot;</span>, <span class="string">&quot;1&quot;</span>, PHP_INI_ALL, OnUpdateBool, direction, zend_test_globals, test_globals)</span><br><span class="line">PHP_INI_END();</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_init_globals</span><span class="params">(zend_test_globals *test_globals)</span> &#123;</span><br><span class="line">    <span class="comment">/* direction初始化，0|1 */</span></span><br><span class="line">    test_globals-&gt;direction = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TEST_G(direction)) &#123;</span><br><span class="line">        TEST_G(counter)++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TEST_G(counter)--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RETURN_LONG(TEST_G(counter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>STD_PHP_INI_ENTRY</code>可以使用更多参数，这里我们将参数写入全局变量<code>test_globals</code>。关联第四个参数<code>on_modify</code>校验输入值，如果成功，写入到全局变量，默认为<code>onUpdateLongGEZero</code>，其他的宏还有<code>OnUpdateLong</code>、<code>OnUpdateBool</code>、<code>OnUpdateReal</code>、<code>OnUpdateString</code>、<code>OnUpdateStringUnempty</code></p>
<p>配置PHP，在<code>php.ini</code>添加<code>test.direction=0</code>，执行脚本获取输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;echo test();&quot;</span> <span class="comment"># 输出：-1</span></span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/Y2k38/php_ext_tutorial">php_ext_tutorial</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://stackoverflow.com/questions/3632160/how-to-make-a-php-extension">How to make a PHP extension</a><br><a href="https://wiki.php.net/phpng-upgrading">Upgrading PHP extensions from PHP5 to NG</a><br><del><a href="https://devzone.zend.com/303/extension-writing-part-i-introduction-to-php-and-zend/">Extension Writing Part I: Introduction to PHP and Zend (已失效)</a></del><br><a href="https://github.com/bigbes/bigbes.github.io/wiki/Extension-Writing-Part-I:-Introduction-to-PHP-and-Zend">Extension Writing Part I: Introduction to PHP and Zend</a><br><a href="http://www.phpinternalsbook.com/">PHP Internals Book</a><br><a href="https://wiki.php.net/internals/references">References about Maintaining and Extending PHP</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
        <tag>helloworld</tag>
        <tag>ini variable</tag>
        <tag>global variable</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - Part 2</title>
    <url>/2020/02/01/php-extension-writing-part2/</url>
    <content><![CDATA[<p>PHP扩展开发第二章，主要介绍函数参数获取、zval数据类型、数组及数组遍历以及$GLOBALS全局变量访问</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>扩展自定义函数不需要声明形参，Zend Engine会给每个函数传递一个参数列表<code>zend_execute_data *execute_data</code>，函数参数通过宏块<code>ZEND_PARSE_PARAMETERS_START</code>、<code>ZEND_PARSE_PARAMETERS_END</code>获取，当然，旧的方法<code>zend_parse_parameters</code>也可以使用，只是会更麻烦点</p>
<p>下面示例函数将接收参数name以及打印的次数t_param并打印name</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数1</span></span><br><span class="line">    zend_string *name;</span><br><span class="line">    <span class="comment">// 参数2</span></span><br><span class="line">    zend_long t_param = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> times = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低可接收1个参数，最多2个</span></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name)</span><br><span class="line">        Z_PARAM_OPTIONAL</span><br><span class="line">        <span class="title function_">Z_PARAM_LONG</span><span class="params">(t_param)</span></span><br><span class="line">    <span class="title function_">ZEND_PARSE_PARAMETERS_END</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有传递默认值</span></span><br><span class="line">    <span class="keyword">if</span> (ZEND_NUM_ARGS() == <span class="number">2</span>) &#123;</span><br><span class="line">        times = (<span class="type">int</span>) (t_param &lt; <span class="number">1</span> ? <span class="number">1</span> : t_param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        php_printf(<span class="string">&quot;Hello %s&quot;</span>, ZSTR_VAL(name));</span><br><span class="line">    &#125;</span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用的有数据类型以及参数获取方法有下</p>
<table>
<thead>
<tr>
<th align="left">Variable Type</th>
<th align="left">Macro</th>
</tr>
</thead>
<tbody><tr>
<td align="left">zend_bool</td>
<td align="left">Z_PARAM_BOOL</td>
</tr>
<tr>
<td align="left">zend_long</td>
<td align="left">Z_PARAM_LONG</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Z_PARAM_DOUBLE</td>
</tr>
<tr>
<td align="left">zend_string *</td>
<td align="left">Z_PARAM_STR</td>
</tr>
<tr>
<td align="left">char *</td>
<td align="left">Z_PARAM_STRING</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_RESOURCE</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_ARRAY</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_OBJECT</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_ZVAL</td>
</tr>
</tbody></table>
<h2 id="ZVAL结构"><a href="#ZVAL结构" class="headerlink" title="ZVAL结构"></a>ZVAL结构</h2><p>PHP7的zval相对PHP5做了比较大的改动，zval、zend_string、zend_array重构，bool类型分成了true、false两种类型直接存储在(zval).u1.type_info等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// php7 zval变量结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">zend_value</span> &#123;</span></span><br><span class="line">    zend_long         lval;                <span class="comment">/* long value */</span></span><br><span class="line">    <span class="type">double</span>            dval;                <span class="comment">/* double value */</span></span><br><span class="line">    zend_refcounted  *counted;</span><br><span class="line">    zend_string      *str;</span><br><span class="line">    zend_array       *arr;</span><br><span class="line">    zend_object      *obj;</span><br><span class="line">    zend_resource    *res;</span><br><span class="line">    zend_reference   *ref;</span><br><span class="line">    zend_ast_ref     *ast;</span><br><span class="line">    zval             *zv;</span><br><span class="line">    <span class="type">void</span>             *ptr;</span><br><span class="line">    zend_class_entry *ce;</span><br><span class="line">    zend_function    *func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> w1;</span><br><span class="line">        <span class="type">uint32_t</span> w2;</span><br><span class="line">    &#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">    zend_value        value;            <span class="comment">/* value */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_3(</span><br><span class="line">                zend_uchar    type,            <span class="comment">/* active type */</span></span><br><span class="line">                zend_uchar    type_flags,</span><br><span class="line">                <span class="keyword">union</span> &#123;</span><br><span class="line">                    <span class="type">uint16_t</span>  extra;        <span class="comment">/* not further specified */</span></span><br><span class="line">                &#125; u)</span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="type">uint32_t</span> type_info;</span><br><span class="line">    &#125; u1;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line">        <span class="type">uint32_t</span>     cache_slot;           <span class="comment">/* cache slot (for RECV_INIT) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     opline_num;           <span class="comment">/* opline number (for FAST_CALL) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">        <span class="type">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">        <span class="type">uint32_t</span>     access_flags;         <span class="comment">/* class constant access flags */</span></span><br><span class="line">        <span class="type">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line">        <span class="type">uint32_t</span>     constant_flags;       <span class="comment">/* constant flags */</span></span><br><span class="line">        <span class="type">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>zval类型判断，一般情况下，如果参数与<code>Z_PARAM_*</code>的类型不一致，Zend Engine会进行转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收任意类型参数，最后输出其类型</span></span><br><span class="line">PHP_FUNCTION(test_type)</span><br><span class="line">&#123;</span><br><span class="line">    zval *uservar;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ZVAL(uservar);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (Z_TYPE_P(uservar)) &#123;</span><br><span class="line">        <span class="keyword">case</span> IS_NULL:</span><br><span class="line">            php_printf(<span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_TRUE:</span><br><span class="line">            php_printf(<span class="string">&quot;Boolean: TRUE&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_FALSE:</span><br><span class="line">            php_printf(<span class="string">&quot;Boolean: FALSE&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_LONG:</span><br><span class="line">            php_printf(<span class="string">&quot;Long: %ld&quot;</span>, Z_LVAL_P(uservar));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_DOUBLE:</span><br><span class="line">            php_printf(<span class="string">&quot;Double: %f&quot;</span>, Z_DVAL_P(uservar));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_STRING:</span><br><span class="line">            php_printf(<span class="string">&quot;String: &quot;</span>);</span><br><span class="line">            PHPWRITE(Z_STRVAL_P(uservar), Z_STRLEN_P (uservar));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_RESOURCE:</span><br><span class="line">            php_printf(<span class="string">&quot;Resource&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">            php_printf(<span class="string">&quot;Array&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">            php_printf(<span class="string">&quot;Object&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            php_printf(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印数组内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_again)</span><br><span class="line">&#123;</span><br><span class="line">    zval *zname;</span><br><span class="line">    </span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ZVAL(zname);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将改变原有参数类型</span></span><br><span class="line">    convert_to_string(zname);</span><br><span class="line">    php_printf(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">    PHPWRITE(Z_STRVAL_P(zname), Z_STRLEN_P(zname));</span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_to_*</code>会将参数转换成指定的类型，即改变原始参数类型、数据，在php代码中，原本以传参的形式传递的变量值会被修改。要解决这个问题，可以使用临时变量，也可以使用<code>convert_to_*_ex</code>，该类函数在转换类型前会先调用<code>SEPARATE_ZVAL_IF_NOT_REF</code>，避免修改原始变量</p>
<h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><p>PHP的数组用途非常广泛，类对象属性的存储也依赖数组，数组的底层实现结构为HashTable</p>
<p>下面函数创建一个数据并返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_array)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// $arr = [];</span></span><br><span class="line">    array_init(return_value);</span><br><span class="line">    <span class="comment">// $arr[3] = 123;</span></span><br><span class="line">    add_index_long(return_value, <span class="number">3</span>, <span class="number">123</span>);</span><br><span class="line">    <span class="comment">// $arr[] = &quot;example&quot;;</span></span><br><span class="line">    add_next_index_string(return_value, <span class="string">&quot;example&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *mystr = estrdup(<span class="string">&quot;five&quot;</span>);</span><br><span class="line">    add_next_index_string(return_value, mystr);</span><br><span class="line">    efree(mystr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $arr[&quot;pi&quot;] = 3.1415926;</span></span><br><span class="line">    add_assoc_double(return_value, <span class="string">&quot;pi&quot;</span>, <span class="number">3.1415926</span>);</span><br><span class="line">    </span><br><span class="line">    zval subarr;</span><br><span class="line">    array_init(&amp;subarr);</span><br><span class="line">    add_next_index_string(&amp;subarr, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    add_assoc_zval(return_value, <span class="string">&quot;subarr&quot;</span>, &amp;subarr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>add_next_index_*</code>添加元素进数组，由系统分配一个递增的数字key</li>
<li><code>add_index_*</code>添加元素进数组，由用户指定一个数字类型的key</li>
<li><code>add_assoc_*</code>添加元素进数组，由用户指定的字符串类型key</li>
</ul>
<p>注意：<code>add_assoc_*</code>非二进制安全</p>
<p>扩展函数返回值不使用<code>return</code>语句，配置<code>zval *return_value</code>即可，该变量由宏<code>PHP_FUNCTION</code>提供，返回值<code>RETURN_TRUE</code>也是通过设置<code>return_value</code>完成返回值赋值，默认设置为<code>IS_NULL</code>类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历并打印数组字符串值</span></span><br><span class="line">PHP_FUNCTION(test_array_strings)</span><br><span class="line">&#123;</span><br><span class="line">    zval *arr, *data;</span><br><span class="line">    HashTable *arr_hash;</span><br><span class="line">    HashPosition pointer;</span><br><span class="line">    <span class="type">int</span> array_count;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ARRAY(arr);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    arr_hash = Z_ARRVAL_P(arr);</span><br><span class="line">    array_count = zend_hash_num_elements(arr_hash);</span><br><span class="line"></span><br><span class="line">    php_printf(<span class="string">&quot;The array passed contains %d elements\n&quot;</span>, array_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 可使用宏ZEND_HASH_FOREACH_VAL、ZEND_HASH_FOREACH_END</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">        zend_hash_internal_pointer_reset_ex(arr_hash, &amp;pointer);</span><br><span class="line">        data = zend_hash_get_current_data_ex(arr_hash, &amp;pointer);</span><br><span class="line">        zend_hash_move_forward_ex(arr_hash, &amp;pointer)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// example 1</span></span><br><span class="line">        <span class="comment">// 如果是字符串就打印</span></span><br><span class="line">        <span class="comment">// if (Z_TYPE_P(data) == IS_STRING) &#123;</span></span><br><span class="line">        <span class="comment">//     PHPWRITE(Z_STRVAL_P(data), Z_STRLEN_P(data));</span></span><br><span class="line">        <span class="comment">//     php_printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// example 2</span></span><br><span class="line">        <span class="comment">// 将参数转为字符串打印</span></span><br><span class="line">        <span class="comment">// zval tmp;</span></span><br><span class="line">        <span class="comment">// tmp = *data;</span></span><br><span class="line">        <span class="comment">// zval_copy_ctor(&amp;tmp);</span></span><br><span class="line">        <span class="comment">// convert_to_string(&amp;tmp);</span></span><br><span class="line">        <span class="comment">// PHPWRITE(Z_STRVAL(tmp), Z_STRLEN(tmp));</span></span><br><span class="line">        <span class="comment">// php_printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// zval_dtor(&amp;tmp);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// example 3</span></span><br><span class="line">        <span class="comment">// 打印数组key以及value</span></span><br><span class="line">        <span class="type">int</span> keytype;</span><br><span class="line">        zend_string * str_index;</span><br><span class="line">        zend_ulong num_index;</span><br><span class="line"></span><br><span class="line">        keytype = zend_hash_get_current_key_ex(arr_hash, &amp;str_index, &amp;num_index, &amp;pointer);</span><br><span class="line">        <span class="keyword">if</span> (HASH_KEY_IS_STRING == keytype) &#123;</span><br><span class="line">            <span class="comment">// 字符串类型key</span></span><br><span class="line">            PHPWRITE(ZSTR_VAL(str_index), ZSTR_LEN(str_index));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HASH_KEY_IS_LONG == keytype) &#123;</span><br><span class="line">            <span class="comment">// 数字key</span></span><br><span class="line">            php_printf(<span class="string">&quot;%ld&quot;</span>, num_index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        php_printf(<span class="string">&quot; =&gt; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        zval tmp;</span><br><span class="line">        tmp = *data;</span><br><span class="line">        zval_copy_ctor(&amp;tmp);</span><br><span class="line">        convert_to_string(&amp;tmp);</span><br><span class="line">        PHPWRITE(Z_STRVAL(tmp), Z_STRLEN(tmp));</span><br><span class="line">        php_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        zval_dtor(&amp;tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zend_hash_get_current_key_ex</code>返回的类型有</p>
<ul>
<li><code>HASH_KEY_IS_LONG</code>：整型key</li>
<li><code>HASH_KEY_IS_STRING</code>：字符串型key</li>
<li><code>HASH_KEY_NON_EXISTENT</code>：遍历完整个数组，没有更多元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印数组val</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_array_walk</span><span class="params">(zval *pDest)</span></span><br><span class="line">&#123;</span><br><span class="line">    zval tmp;</span><br><span class="line"></span><br><span class="line">    tmp = *pDest;</span><br><span class="line">    zval_copy_ctor(&amp;tmp);</span><br><span class="line">    convert_to_string(&amp;tmp);</span><br><span class="line">    PHPWRITE(Z_STRVAL(tmp), Z_STRLEN(tmp));</span><br><span class="line">    php_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    zval_dtor(&amp;tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印prefix以及数组val</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_array_walk_arg</span><span class="params">(zval *pDest, <span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_printf(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span> *)argument);</span><br><span class="line">    test_array_walk(pDest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印prefix、数组val以及suffix</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_array_walk_args</span><span class="params">(zval *pDest, <span class="type">int</span> num_args, va_list args, zend_hash_key *hash_key)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_printf(<span class="string">&quot;%s&quot;</span>, va_arg(args, <span class="type">char</span> *));</span><br><span class="line">    test_array_walk(pDest);</span><br><span class="line">    php_printf(<span class="string">&quot;%s\n&quot;</span>, va_arg(args, <span class="type">char</span> *));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line">PHP_FUNCTION(test_array_walk)</span><br><span class="line">&#123;</span><br><span class="line">    zval *arr;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ARRAY(arr);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的遍历数组处理</span></span><br><span class="line">    zend_hash_apply(Z_ARRVAL_P(arr), (<span class="type">apply_func_t</span>) test_array_walk);</span><br><span class="line">    <span class="comment">// 遍历数组，带一个参数</span></span><br><span class="line">    zend_hash_apply_with_argument(Z_ARRVAL_P(arr), (<span class="type">apply_func_arg_t</span>) test_array_walk_arg, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历数组，带多个参数</span></span><br><span class="line">    zend_hash_apply_with_arguments(Z_ARRVAL_P(arr), (<span class="type">apply_func_args_t</span>) test_array_walk_args, <span class="number">2</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;Welcome to my extension!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>test_array_walk</code>类似<code>array_map</code>，<code>test_array_walk</code>简单遍历数组，<code>test_array_walk_arg</code>遍历数组，可接收一个任意类型的额外参数，下面代码中用作数组元素的前缀，<code>test_array_walk_args</code>遍历数组，可接收任意多个参数，下面代码中用作数组元素的前缀、后缀</p>
<p>返回值类型：</p>
<ul>
<li><code>ZEND_HASH_APPLY_KEEP</code>：维持原有元素，继续遍历数组剩余元素</li>
<li><code>ZEND_HASH_APPLY_REMOVE</code>：删除原有元素，继续遍历数组剩余元素</li>
<li><code>ZEND_HASH_APPLY_STOP</code>：维持原有元素，停止遍历数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回数组指定key的value</span></span><br><span class="line">PHP_FUNCTION(test_array_value)</span><br><span class="line">&#123;</span><br><span class="line">    zval *arr, *offset, *val;</span><br><span class="line">    <span class="type">char</span> * tmp;</span><br><span class="line">    zend_string *str_index = <span class="literal">NULL</span>;</span><br><span class="line">    zend_ulong num_index;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_ARRAY(arr);</span><br><span class="line">        Z_PARAM_ZVAL(offset);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对非integer/string的key进行转换</span></span><br><span class="line">    <span class="keyword">switch</span> (Z_TYPE_P(offset)) &#123;</span><br><span class="line">        <span class="keyword">case</span> IS_NULL:</span><br><span class="line">        <span class="keyword">case</span> IS_FALSE:</span><br><span class="line">            num_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_TRUE:</span><br><span class="line">            num_index = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_DOUBLE:</span><br><span class="line">            num_index = (<span class="type">long</span>) Z_DVAL_P(offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_LONG:</span><br><span class="line">        <span class="keyword">case</span> IS_RESOURCE:</span><br><span class="line">            num_index = Z_LVAL_P(offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_STRING:</span><br><span class="line">            str_index = zval_get_string(offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">            tmp = <span class="string">&quot;Array&quot;</span>;</span><br><span class="line">            str_index = zend_string_init(tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">            tmp = <span class="string">&quot;Object&quot;</span>;</span><br><span class="line">            str_index = zend_string_init(tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            tmp = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">            str_index = zend_string_init(tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str_index &amp;&amp; (val = zend_hash_find(Z_ARRVAL_P(arr), str_index)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!str_index &amp;&amp; (val = zend_hash_index_find(Z_ARRVAL_P(arr), num_index)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *return_value = *val;</span><br><span class="line">    zval_copy_ctor(return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PHP7中zval在栈分配，函数执行完清理，需要深入复制一份给return_value</p>
<h2 id="Symbol-Tables"><a href="#Symbol-Tables" class="headerlink" title="Symbol Tables"></a>Symbol Tables</h2><p>全局变量$GLOBALS的底层存储结构也是HashTable，存储在一个全局结构体Executor Globals(_zend_executor_globals)里，通过EG(symbol_table)访问相关数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问全局变量$GLOBALS</span></span><br><span class="line">PHP_FUNCTION(test_get_global_var)</span><br><span class="line">&#123;</span><br><span class="line">    zval *val;</span><br><span class="line">    zend_string *varname;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_STR(varname);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局变量符号表：EG(symbol_table)</span></span><br><span class="line">    <span class="keyword">if</span> ((val = zend_hash_find(&amp;EG(symbol_table), varname)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_NOTICE, <span class="string">&quot;Undefined variable: %s&quot;</span>, ZSTR_VAL(varname));</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *return_value = *val;</span><br><span class="line">    zval_copy_ctor(return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/Y2k38/php_ext_tutorial">php_ext_tutorial</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><del><a href="https://devzone.zend.com/317/extension-writing-part-ii-parameters-arrays-and-zvals/">Extension Writing Part II: Parameters, Arrays, and ZVALs (Unable To Access)</a></del><br><del><a href="https://devzone.zend.com/318/extension-writing-part-ii-parameters-arrays-and-zvals-continued/">Extension Writing Part II: Parameters, Arrays, and ZVALs [continued] (Unable To Access)</a></del><br><a href="https://github.com/bigbes/bigbes.github.io/wiki/Extension-Writing-Part-II:-Parameters,-Arrays,-and-ZVALs">Extension Writing Part II: Parameters, Arrays, and ZVALs</a><br><a href="https://wiki.php.net/phpng-upgrading">Upgrading PHP extensions from PHP5 to NG</a><br><a href="http://www.phpinternalsbook.com/">PHP Internals Book</a><br><a href="https://wiki.php.net/internals/references">References about Maintaining and Extending PHP</a><br><a href="https://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html">Internal value representation in PHP 7 - Part 1 </a><br><a href="https://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html">Internal value representation in PHP 7 - Part 2</a><br><a href="https://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html">PHP’s new hashtable implementation</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
        <tag>parameters</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - Part 3</title>
    <url>/2020/02/09/php-extension-writing-part3/</url>
    <content><![CDATA[<p>本文将简单介绍资源类型、资源的创建、访问、销毁操作。不再建议使用资源类型，使用类更为合适</p>
<h2 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h2><p><code>zval</code>可以表示大部分的PHP数据类型，但有一样不能很好的表示其结构：指针。由于不透明的结构、无法使用传统运算符进行操作等，使得指针在PHP的表示变得困难。因此PHP用一个特殊的标记表示指针：资源，为了使资源标记具有意义，必须先注册到zend engine才能使用。</p>
<p>在头文件定义结构体<code>php_test_person</code>以及资源名称，放置在<code>#define</code>语句后，<code>PHP_MINIT_FUNCTION(test);</code>之前</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    zend_string *name;</span><br><span class="line">    zend_long age;</span><br><span class="line">&#125; php_test_person;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHP_TEST_PERSON_RES_NAME <span class="string">&quot;Person Data&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>源文件定义<code>le_*</code>全局变量，MINIT阶段注册，用于获取资源类型、字面意义名称、析构函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> le_test_person;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    le_test_person = zend_register_list_destructors_ex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化资源"><a href="#初始化资源" class="headerlink" title="初始化资源"></a>初始化资源</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_new)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person * person;</span><br><span class="line">    zend_string * name;</span><br><span class="line">    zend_long age;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name);</span><br><span class="line">        Z_PARAM_LONG(age);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_WARNING, <span class="string">&quot;Nonsense age (%ld) given, person resource not created.&quot;</span>, age);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    person = emalloc(<span class="keyword">sizeof</span>(php_test_person));</span><br><span class="line">    person-&gt;name = zend_string_copy(name); <span class="comment">// estrndup + zend_string =&gt; zend_string_copy</span></span><br><span class="line">    person-&gt;age = age;</span><br><span class="line"></span><br><span class="line">    RETURN_RES(zend_register_resource(person, le_test_person));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数接收参数name以及age，参数进行校验通过后，申请一段内存空间并写入数据，<code>return_value</code>返回该资源。PHP不需要知道资源的具体内部表示，只需要获取该资源存储的指针以及资源类型</p>
<h2 id="函数接收资源参数"><a href="#函数接收资源参数" class="headerlink" title="函数接收资源参数"></a>函数接收资源参数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_greet)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person *person;</span><br><span class="line">    zval *zperson;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_RESOURCE(zperson);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    person = (php_test_person *) zend_fetch_resource_ex(zperson, PHP_TEST_PERSON_RES_NAME, le_test_person);</span><br><span class="line"></span><br><span class="line">    php_printf(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">    PHPWRITE(ZSTR_VAL(person-&gt;name), ZSTR_LEN(person-&gt;name));</span><br><span class="line">    php_printf(<span class="string">&quot;!\nAccording to my records, you are %ld years old.\n&quot;</span>, person-&gt;age);</span><br><span class="line"></span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ZEND_FETCH_RESOURCE</code>在PHP7中已被删除，目前获取资源的函数是<code>zend_fetch_resource</code>、<code>zend_fetch_resource_ex</code>。<code>zend_fetch_resource_ex</code>函数需要一个zval、字面意义名称、资源类型，返回一个指针。函数内部切记不要<code>free</code>该指针</p>
<h2 id="销毁资源"><a href="#销毁资源" class="headerlink" title="销毁资源"></a>销毁资源</h2><p>在PHP中使用<code>fopen</code>打开文件并获得一个资源句柄<code>$fp</code>，接下来<code>unset($fp)</code>时文件被关闭，即使没有使用<code>fclose</code>函数。其中的奥秘在<code>zend_register_list_destructors_ex</code>，该函数第一个参数为常规资源的析构函数，第二个为持久化资源的析构函数，当离开资源变量所在作用域时，自动调用清理&#x2F;析构函数，释放内存、关闭连接或执行其他清理操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">le_test_person = zend_register_list_destructors_ex(php_test_person_dtor, <span class="literal">NULL</span>, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_person_dtor</span><span class="params">(zend_resource *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_test_person *person = (php_test_person *) res-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (person) &#123;</span><br><span class="line">        <span class="keyword">if</span> (person-&gt;name) &#123;</span><br><span class="line">            zend_string_release(person-&gt;name); <span class="comment">// efree zend_string =&gt; zend_string_release</span></span><br><span class="line">        &#125;</span><br><span class="line">        efree(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强制销毁资源"><a href="#强制销毁资源" class="headerlink" title="强制销毁资源"></a>强制销毁资源</h2><p>使用<code>zend_list_delete</code>销毁资源，该函数可销毁任何资源类型变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_delete)</span><br><span class="line">&#123;</span><br><span class="line">    zval * zperson;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_RESOURCE(zperson);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    zend_list_delete(Z_RES_P(zperson));</span><br><span class="line"></span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="持久化资源"><a href="#持久化资源" class="headerlink" title="持久化资源"></a>持久化资源</h2><p>持久化资源与常规资源不同的地方在析构函数声明注册的位置，数据内存申请使用<code>pemalloc</code>代替<code>emalloc</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> le_test_person_persist;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    le_test_person = zend_register_list_destructors_ex(php_test_person_dtor, <span class="literal">NULL</span>, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line">    le_test_person_persist = zend_register_list_destructors_ex(<span class="literal">NULL</span>, php_test_person_persist_dtor, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，<code>php_test_person_dtor</code>会在请求结束后调用，<code>php_test_person_persist_dtor</code>在扩展shutdown阶段调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_person_persist_dtor</span><span class="params">(zend_resource *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_test_person *person = (php_test_person *) res-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (person) &#123;</span><br><span class="line">        <span class="keyword">if</span> (person-&gt;name) &#123;</span><br><span class="line">            zend_string_release(person-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">        pefree(person, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_pnew)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person * person;</span><br><span class="line">    zend_string * name;</span><br><span class="line">    zend_long age;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name);</span><br><span class="line">        Z_PARAM_LONG(age);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_WARNING, <span class="string">&quot;Nonsense age (%ld) given, person resource not created.&quot;</span>, age);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    person = pemalloc(<span class="keyword">sizeof</span>(php_test_person), <span class="number">1</span>);</span><br><span class="line">    person-&gt;name = zend_string_dup(name, <span class="number">1</span>);</span><br><span class="line">    person-&gt;age = age;</span><br><span class="line"></span><br><span class="line">    RETURN_RES(zend_register_resource(person, le_test_person_persist));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>test_person_pnew</code>与<code>test_person_new</code>仅在数据初始化、资源类型方面有差异</p>
<h2 id="查找已存在的持久化资源"><a href="#查找已存在的持久化资源" class="headerlink" title="查找已存在的持久化资源"></a>查找已存在的持久化资源</h2><p>为了可以重用持久化资源，需要将其保存在一个安全的地方，zend engine提供了一个executor global通过<code>EG(persistent_list)</code>访问，该变量类型为<code>HashTable</code></p>
<p>重新修改t<code>est_person_pnew</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_pnew2)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person * person;</span><br><span class="line">    <span class="type">char</span> * key_raw;</span><br><span class="line">    <span class="type">size_t</span> key_len;</span><br><span class="line">    zend_string * name, * key;</span><br><span class="line">    zend_long age;</span><br><span class="line">    zval * zperson = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name);</span><br><span class="line">        Z_PARAM_LONG(age);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_WARNING, <span class="string">&quot;Nonsense age (%ld) given, person resource not created.&quot;</span>, age);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key_len = spprintf(&amp;key_raw, <span class="number">0</span>, <span class="string">&quot;test_person_%s_%ld\n&quot;</span>, ZSTR_VAL(name), age);</span><br><span class="line">    key = zend_string_init(key_raw, key_len, <span class="number">1</span>);</span><br><span class="line">    efree(key_raw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((zperson = zend_hash_find(&amp;EG(persistent_list), key)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        person = (php_test_person *) zend_fetch_resource_ex(zperson, PHP_TEST_PERSON_RES_NAME, le_test_person_persist);</span><br><span class="line"></span><br><span class="line">        ZVAL_RES(return_value, zend_register_persistent_resource_ex(key, person, le_test_person_persist));</span><br><span class="line">        zend_string_release(key);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    person = pemalloc(<span class="keyword">sizeof</span>(php_test_person), <span class="number">1</span>);</span><br><span class="line">    person-&gt;name = zend_string_copy(name);</span><br><span class="line">    person-&gt;age = age;</span><br><span class="line"></span><br><span class="line">    ZVAL_RES(return_value, zend_register_persistent_resource_ex(key, person, le_test_person_persist));</span><br><span class="line">    zend_string_release(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>test_person_pnew2</code>先确定<code>EG(persistent_list)</code>是否已经存在，已存在则直接使用，不存在则申请内存初始化资源</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><del><a href="https://devzone.zend.com/446/extension-writing-part-iii-resources/">Extension Writing Part III: Resources</a></del><br><a href="https://github.com/bigbes/bigbes.github.io/wiki/Extension-Writing-Part-III:-Resources">Extension Writing Part III: Resources</a><br><a href="https://wiki.php.net/phpng-upgrading">Upgrading PHP extensions from PHP5 to NG</a><br><a href="http://www.phpinternalsbook.com/">PHP Internals Book</a><br><a href="https://wiki.php.net/internals/references">References about Maintaining and Extending PHP</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
        <tag>resource</tag>
        <tag>pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql安装配置</title>
    <url>/2024/08/11/postgres-setup-example/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h3><p>系统是ubuntu 24.04 LTS，开机启动使用了systemd，所以先安装相关依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install libsystemd-dev</span><br></pre></td></tr></table></figure>

<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>官网推荐使用pre-packaged方式，稳定可靠，适合生产环境。不过我想用最新版，就直接用源码编译安装了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入源代码目录</span></span><br><span class="line"><span class="built_in">cd</span> postgresql-16.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定安装目录、设置支持systemd</span></span><br><span class="line">./configure --prefix=/usr/local/postgresql-16.4 --with-systemd --with-ssl=openssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 软连接，方便升级用</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/local/postgresql-16.4 /usr/local/pgsql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="built_in">sudo</span> adduser postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库数据存储目录，与app目录分离</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/lib/pgsql/data</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R postgres /var/lib/pgsql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到postgres用户</span></span><br><span class="line">su - postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库目录、启动实例</span></span><br><span class="line">/usr/local/pgsql/bin/initdb -D /var/lib/pgsql/data</span><br><span class="line">/usr/local/pgsql/bin/pg_ctl -D /var/lib/pgsql/data -l logfile start</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">/usr/local/pgsql/bin/psql</span><br><span class="line"><span class="comment"># 关闭实例</span></span><br><span class="line"><span class="comment"># /usr/local/pgsql/bin/pg_ctl -D /var/lib/pgsql/data/ -l logfile stop</span></span><br></pre></td></tr></table></figure>

<p>到这里，postgresql完成安装、初始化</p>
<h3 id="systemd配置"><a href="#systemd配置" class="headerlink" title="systemd配置"></a>systemd配置</h3><p>开机启动配置systemd，添加配置文件<code>/etc/systemd/system/postgresql.service</code>，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=PostgreSQL database server</span><br><span class="line">Documentation=man:postgres(1)</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">User=postgres</span><br><span class="line">ExecStart=/usr/local/pgsql/bin/postgres -D /var/lib/pgsql/data</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=mixed</span><br><span class="line">KillSignal=SIGINT</span><br><span class="line">TimeoutSec=infinity</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>使用systemd启动postgresql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl start postgresql</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> postgresql</span><br></pre></td></tr></table></figure>

<h2 id="pgsql配置"><a href="#pgsql配置" class="headerlink" title="pgsql配置"></a>pgsql配置</h2><p>以上完成pg安装，本地可以直接访问使用。接下来是配置数据库提供对外访问能力，如配置tcp监听地址、添加用户、配置权限等</p>
<p>进入pg的data数据存储目录，修改相关配置文件</p>
<h3 id="tcp配置"><a href="#tcp配置" class="headerlink" title="tcp配置"></a>tcp配置</h3><p>修改<code>postgresql.conf</code>文件，配置监听地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认localhost，改为&#x27;*&#x27;</span><br><span class="line">listen_addresses = &#x27;*&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="auth配置"><a href="#auth配置" class="headerlink" title="auth配置"></a>auth配置</h3><p>PS: pg的授权配置没有像mysql一样开箱即用，先简单配置下吧</p>
<p>修改<code>pg_hba.conf</code>文件，开放数据库&#x2F;用户对外访问权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class="line">host    blogdb          all             0.0.0.0/0               scram-sha-256</span><br><span class="line">host    blogdb          all             ::0/0                   scram-sha-256</span><br></pre></td></tr></table></figure>

<p>重启postgresql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start postgresql</span><br></pre></td></tr></table></figure>

<p>修改超级用户密码或者创建新角色并授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 修改postgres密码</span></span><br><span class="line"><span class="comment">-- alter user postgres password &#x27;your_password&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建新角色并授权</span></span><br><span class="line">\c blogdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> ROLE blog_read_only <span class="keyword">WITH</span> LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ROLE blog_read_write <span class="keyword">WITH</span> LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ROLE blog_admin <span class="keyword">WITH</span> LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> blog_read_only;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> blog_read_write;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> blog_admin;</span><br></pre></td></tr></table></figure>

<h2 id="curd-example"><a href="#curd-example" class="headerlink" title="curd example"></a>curd example</h2><p>完成了pg的安装配置，接下来就是写一个demo测试了，首先，找一个数据表导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取countries.csv数据</span></span><br><span class="line">curl <span class="string">&#x27;https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv&#x27;</span> \</span><br><span class="line">    --output ./countries.csv</span><br></pre></td></tr></table></figure>

<p>创建数据库blogdb，并导入countries.csv</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database blogdb;</span><br><span class="line">\c blogdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> countries (</span><br><span class="line">  id <span class="type">integer</span> <span class="keyword">primary</span> key generated always <span class="keyword">as</span> <span class="keyword">identity</span>,</span><br><span class="line">  name text <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">  alpha_2 <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  alpha_3 <span class="type">char</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  numeric_3 <span class="type">char</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  iso_3166_2 text <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  region text,</span><br><span class="line">  sub_region text,</span><br><span class="line">  intermediate_region text,</span><br><span class="line">  region_code <span class="type">char</span>(<span class="number">3</span>),</span><br><span class="line">  sub_region_code <span class="type">char</span>(<span class="number">3</span>),</span><br><span class="line">  intermediate_region_code <span class="type">char</span>(<span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">copy</span> countries (</span><br><span class="line">  name,</span><br><span class="line">  alpha_2,</span><br><span class="line">  alpha_3,</span><br><span class="line">  numeric_3,</span><br><span class="line">  iso_3166_2,</span><br><span class="line">  region,</span><br><span class="line">  sub_region,</span><br><span class="line">  intermediate_region,</span><br><span class="line">  region_code,</span><br><span class="line">  sub_region_code,</span><br><span class="line">  intermediate_region_code</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> <span class="string">&#x27;/var/lib/pgsql/data/countries.csv&#x27;</span></span><br><span class="line">delimiter <span class="string">&#x27;,&#x27;</span> csv header;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check that the data got loaded into the table ok.</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> countries limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Should say 249.</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> countries;</span><br></pre></td></tr></table></figure>

<p>使用golang写一个简单的app，查询countries数据，到这里完成!</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/jackc/pgx/v5&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	conn, err := pgx.Connect(ctx, <span class="string">&quot;postgres://postgres:your_password@192.168.33.10:5432/blogdb?sslmode=disable&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close(ctx)</span><br><span class="line"></span><br><span class="line">	rows, err := conn.Query(ctx, <span class="string">&quot;SELECT id, name FROM countries LIMIT 10&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		<span class="keyword">var</span> id <span class="type">int</span></span><br><span class="line">		<span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">		err = rows.Scan(&amp;id, &amp;name)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(id, <span class="string">&quot;-&quot;</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="开启ssl"><a href="#开启ssl" class="headerlink" title="开启ssl"></a>开启ssl</h3><p>如果想要在本地提前体验ssl加密配置的过程，那么按照下面的流程，先生成self-signed证书、私钥，最后修改配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入数据存储目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/pgsql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成self-signed ssl相关证书、私钥</span></span><br><span class="line">openssl req -new -x509 -days 365 -nodes -text -out server.crt \</span><br><span class="line">  -keyout server.key -subj <span class="string">&quot;/CN=dbhost.yourdomain.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除other、group的访问权限</span></span><br><span class="line"><span class="built_in">chmod</span> og-rwx server.key</span><br></pre></td></tr></table></figure>

<p>修改<code>postgresql.conf</code>文件，取消下面三行注释，需要保证证书放置在data目录，生产环境如果使用授权ca证书，修改的命令就不是ssl_cert_file以及ssl_key_file，按官网描述修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssl = on</span><br><span class="line">ssl_cert_file = &#x27;server.crt&#x27;</span><br><span class="line">ssl_key_file = &#x27;server.key&#x27;</span><br></pre></td></tr></table></figure>

<p>最后，demo里dsn移除<code>sslmode=disable</code>，然后重新运行验证</p>
]]></content>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kubeadm部署k8s集群</title>
    <url>/2024/08/16/use-kubeadm-to-deploy-k8s-cluster/</url>
    <content><![CDATA[<p>部署计划：先创建一台虚拟机vm1，安装docker以及k8s组件，然后克隆两台新的vm2&#x2F;vm3，组合成一个小型的k8s集群</p>
<h2 id="虚拟机准备"><a href="#虚拟机准备" class="headerlink" title="虚拟机准备"></a>虚拟机准备</h2><h3 id="创建vm1"><a href="#创建vm1" class="headerlink" title="创建vm1"></a>创建vm1</h3><p>创建虚拟机vm1，以下就不展示繁琐的系统安装过程了</p>
<p><img src="/images/kvm_create_vm1.png" alt="kvm create vm1"></p>
<h3 id="配置vm1"><a href="#配置vm1" class="headerlink" title="配置vm1"></a>配置vm1</h3><p>根据教程：<a href="/2024/07/20/deploy-docker-and-registry-service/">安装docker并部署registry服务</a>安装好containerd，再执行下面的配置</p>
<h4 id="系统配置修改"><a href="#系统配置修改" class="headerlink" title="系统配置修改"></a>系统配置修改</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux 模块</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> modprobe overlay</span><br><span class="line"><span class="built_in">sudo</span> modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># lsmod | grep overlay</span></span><br><span class="line"><span class="comment"># lsmod | grep br_netfilter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络配置</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> sysctl --system</span><br><span class="line"></span><br><span class="line"><span class="comment"># sudo sysctl -a | grep net.ipv4.ip_forward</span></span><br></pre></td></tr></table></figure>

<h4 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h4><p>关闭swap并移除文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看swap文件位置</span></span><br><span class="line"><span class="built_in">sudo</span> swapon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭swap</span></span><br><span class="line"><span class="built_in">sudo</span> swapoff /swap.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除swap文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /swap.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动项注释</span></span><br><span class="line"><span class="built_in">sudo</span> vi /etc/fstab</span><br><span class="line"><span class="comment"># 删除或注释下面行</span></span><br><span class="line"><span class="comment">#/swap.img      none    swap    sw      0       0</span></span><br></pre></td></tr></table></figure>

<h4 id="registry证书导入"><a href="#registry证书导入" class="headerlink" title="registry证书导入"></a>registry证书导入</h4><p>私有registry使用self-signed证书，kubeadm拉取时会报错，故将证书添加到vm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 物理机拷贝证书到vm1</span></span><br><span class="line">scp noname.io.crt noname@192.168.122.11:/home/noname/</span><br><span class="line"></span><br><span class="line"><span class="comment"># vm1 复制到系统目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> noname.io.crt /usr/local/share/ca-certificates/</span><br><span class="line"><span class="built_in">sudo</span> update-ca-certificates</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker <span class="comment"># 可选</span></span><br></pre></td></tr></table></figure>

<h4 id="containerd设置"><a href="#containerd设置" class="headerlink" title="containerd设置"></a>containerd设置</h4><p>修改<code>/etc/containerd/config.toml</code>，设置cgroup driver为systemd，同时可以修改pause版本，version是必须的，否则不生效，缩进非必要，可以删除</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="section">[plugins]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span></span><br><span class="line">    <span class="attr">runtime_type</span> = <span class="string">&quot;io.containerd.runc.v2&quot;</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span></span><br><span class="line">      <span class="attr">SystemdCgroup</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span></span><br><span class="line">    <span class="attr">sandbox_image</span> = <span class="string">&quot;registry.noname.io:5000/pause:3.10&quot;</span> <span class="comment"># 默认是3.8，这里可以不修改</span></span><br></pre></td></tr></table></figure>

<p>重启containerd服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>

<p>执行命令输出生效中的配置，验证配置是否跟预期一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd config dump | grep SystemdCgroup</span><br></pre></td></tr></table></figure>

<h4 id="docker配置（可选）"><a href="#docker配置（可选）" class="headerlink" title="docker配置（可选）"></a>docker配置（可选）</h4><p>k8s与docker分手后，vm只需要一个containerd就够了，但如果你同时也安装了docker，也可以修改<code>/etc/docker/daemon.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;exec-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;native.cgroupdriver=systemd&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;registry.noname.io:5000&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启docker服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="镜像准备（可选）"><a href="#镜像准备（可选）" class="headerlink" title="镜像准备（可选）"></a>镜像准备（可选）</h4><p>为了避免kubeadm init长时间卡在镜像拉取上，可以先在物理机上通过proxy拉取到本地，再推送到私有registry，最后配置从私有registry拉取image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># k8s需要的镜像，可以通过kubeadm config images list打印</span></span><br><span class="line">docker pull registry.k8s.io/kube-apiserver:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/kube-controller-manager:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/kube-scheduler:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/kube-proxy:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/coredns/coredns:v1.11.1</span><br><span class="line">docker pull registry.k8s.io/pause:3.10</span><br><span class="line">docker pull registry.k8s.io/etcd:3.5.15-0</span><br><span class="line"><span class="comment"># cilium依赖的镜像</span></span><br><span class="line">docker pull quay.io/cilium/cilium:v1.15.6</span><br><span class="line">docker pull quay.io/cilium/operator-generic:v1.15.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新打tag</span></span><br><span class="line">docker tag registry.k8s.io/kube-apiserver:v1.31.0 registry.noname.io:5000/kube-apiserver:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/kube-controller-manager:v1.31.0 registry.noname.io:5000/kube-controller-manager:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/kube-scheduler:v1.31.0 registry.noname.io:5000/kube-scheduler:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/kube-proxy:v1.31.0 registry.noname.io:5000/kube-proxy:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/coredns/coredns:v1.11.1 registry.noname.io:5000/coredns:v1.11.1</span><br><span class="line">docker tag registry.k8s.io/pause:3.10 registry.noname.io:5000/pause:3.10</span><br><span class="line">docker tag registry.k8s.io/etcd:3.5.15-0 registry.noname.io:5000/etcd:3.5.15-0</span><br><span class="line">docker tag quay.io/cilium/cilium:v1.15.6 registry.noname.io:5000/cilium/cilium:v1.15.6</span><br><span class="line">docker tag quay.io/cilium/operator-generic:v1.15.6 registry.noname.io:5000/cilium/operator-generic:v1.15.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送至私有registry</span></span><br><span class="line">docker push registry.noname.io:5000/kube-apiserver:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/kube-controller-manager:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/kube-scheduler:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/kube-proxy:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/coredns:v1.11.1</span><br><span class="line">docker push registry.noname.io:5000/pause:3.10</span><br><span class="line">docker push registry.noname.io:5000/etcd:3.5.15-0</span><br><span class="line">docker push registry.noname.io:5000/cilium/cilium:v1.15.6</span><br><span class="line">docker push registry.noname.io:5000/cilium/operator-generic:v1.15.6</span><br></pre></td></tr></table></figure>

<p>在虚拟机vm1中使用critool导入镜像，示例如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以先 alias</span></span><br><span class="line"><span class="comment"># alias crictl=&quot;crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看containerd镜像</span></span><br><span class="line"><span class="built_in">sudo</span> crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像到containerd</span></span><br><span class="line"><span class="built_in">sudo</span> crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock pull registry.noname.io:5000/quay.io/cilium/operator-generic:v1.15.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新打tag</span></span><br><span class="line"><span class="built_in">sudo</span> ctr --namespace=k8s.io image tag registry.noname.io:5000/quay.io/cilium/operator-generic:v1.15.6 quay.io/cilium/operator-generic:v1.15.6</span><br></pre></td></tr></table></figure>

<h2 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h2><h3 id="apt方式安装（推荐）"><a href="#apt方式安装（推荐）" class="headerlink" title="apt方式安装（推荐）"></a>apt方式安装（推荐）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">sudo</span> apt update -y &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y apt-transport-https ca-certificates curl gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先创建好目录，如果没有的话</span></span><br><span class="line"><span class="comment"># sudo mkdir -p -m 755 /etc/apt/keyrings</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># curl这里需要使用http_proxy/https_proxy</span></span><br><span class="line">curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.31/deb/Release.key | <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认会覆盖已存在的/etc/apt/sources.list.d/kubernetes.list</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.31/deb/ /&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一 安装最新版，同时会安装ebtables cri-tools kubernetes-cni组件</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二 指定版本</span></span><br><span class="line"><span class="comment"># sudo apt-get install -y kubelet=1.31.0* kubeadm=1.31.0* kubectl=1.31.0*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时检查下xzip ethtool socat conntrack net-tools这几个组件是否安装</span></span><br><span class="line"><span class="comment"># sudo apt-get install -y xzip ethtool socat conntrack net-tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定版本</span></span><br><span class="line"><span class="built_in">sudo</span> apt-mark hold kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure>

<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>由于手动安装错误未能及时解决，先记录步骤，后续改进</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制软件到vm</span></span><br><span class="line"><span class="comment"># cd Downloads/</span></span><br><span class="line">scp kube* kubelet.service 10-kubeadm.conf noname@192.168.122.11:/home/noname/   <span class="comment"># kubernetes相关</span></span><br><span class="line">scp crictl-v1.30.1-linux-amd64.tar.gz noname@192.168.122.11:/home/noname/       <span class="comment"># cri-tools</span></span><br><span class="line">scp cni-plugins-linux-amd64-v1.5.1.tgz noname@192.168.122.11:/home/noname/      <span class="comment"># kubernetes-cni</span></span><br><span class="line">scp cilium-linux-v0.16.13.tar.gz noname@192.168.122.11:/home/noname/            <span class="comment"># cilium</span></span><br><span class="line">scp helm-v3.15.3-linux-amd64.tar.gz noname@192.168.122.11:/home/noname/         <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubernetes-cni</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /opt/cni/bin &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">chown</span> -R root:root /opt/cni</span><br><span class="line"><span class="built_in">sudo</span> tar -C /opt/cni/bin -xzf cni-plugins-linux-amd64-v1.5.1.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># cri-tools</span></span><br><span class="line"><span class="built_in">sudo</span> tar -C /usr/local/bin -xzf crictl-v1.31.1-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># cilium</span></span><br><span class="line"><span class="built_in">sudo</span> tar -C /usr/local/bin -xzf cilium-linux-v0.16.13.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># helm</span></span><br><span class="line">tar zxf helm-v3.15.3-linux-amd64.tar.gz &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">mv</span> linux-amd64/helm /usr/local/bin/ &amp;&amp; <span class="built_in">rm</span> -rf linux-amd64/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将kubeadm等组件放置到指定目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> kube* /usr/local/bin/ &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/kube*</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/lib/kubelet</span><br><span class="line"><span class="comment"># 修改配置文件中的bin目录并放置到指定位置</span></span><br><span class="line"><span class="built_in">cat</span> kubelet.service | sed <span class="string">&quot;s:/usr/bin:/usr/local/bin:g&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /usr/lib/systemd/system/kubelet.service</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line"><span class="comment"># 同上</span></span><br><span class="line"><span class="built_in">cat</span> 10-kubeadm.conf | sed <span class="string">&quot;s:/usr/bin:/usr/local/bin:g&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure>

<h2 id="克隆vm1"><a href="#克隆vm1" class="headerlink" title="克隆vm1"></a>克隆vm1</h2><p>以上初步准备安装好了k8s，现在还不能执行初始化部署，复制两个新的vm，避免每台机器都重复执行上面的操作，偷懒</p>
<p>新的vm需要确保跟旧的vm1不能有相同的MAC地址、hostname、product_uuid</p>
<h3 id="hostname重命名"><a href="#hostname重命名" class="headerlink" title="hostname重命名"></a>hostname重命名</h3><p>修改hostname</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> hostnamectl hostname vm1</span><br><span class="line"><span class="comment"># sudo hostnamectl hostname vm2</span></span><br><span class="line"><span class="comment"># sudo hostnamectl hostname vm3</span></span><br></pre></td></tr></table></figure>

<h3 id="重新生成machine-id"><a href="#重新生成machine-id" class="headerlink" title="重新生成machine-id"></a>重新生成machine-id</h3><p>dhcp获取IP时，依赖的是machine-id，如果三台机器的machine-id都一样，你会发现所有vm的IP地址都是一样的，会出现冲突，比如ssh突然断线</p>
<p>先关闭其他机器如vm1，使用同样ssh命令如<code>ssh noname@192.168.122.11</code>连接到新的vm2&#x2F;vm3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要确保/etc/machine-id与/var/lib/dbus/machine-id一致，软连接来的，只要改一个</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/machine-id</span><br><span class="line"><span class="built_in">sudo</span> dbus-uuidgen --ensure=/etc/machine-id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次确认下，确定三台机器的product_uuid都不一样</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/class/dmi/id/product_uuid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启机器</span></span><br><span class="line"><span class="built_in">sudo</span> reboot now</span><br></pre></td></tr></table></figure>

<h3 id="cockpit绑定MAC以及IP"><a href="#cockpit绑定MAC以及IP" class="headerlink" title="cockpit绑定MAC以及IP"></a>cockpit绑定MAC以及IP</h3><p>点击添加【静态主机条目】，绑定mac地址与ip地址，避免重启一次机器就变一次IP</p>
<p><img src="/images/bind_ip_and_mac.png" alt="bind ip and mac"></p>
<h3 id="hosts修改"><a href="#hosts修改" class="headerlink" title="hosts修改"></a>hosts修改</h3><p>往hosts添加三台vm的host映射，移除<code>127.0.0.1 vm1</code>字样的的记录</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">192.168.0.105 registry.noname.io</span><br><span class="line"></span><br><span class="line">192.168.122.11 vm1</span><br><span class="line">192.168.122.126 vm2</span><br><span class="line">192.168.122.235 vm3</span><br></pre></td></tr></table></figure>

<h2 id="部署k8s"><a href="#部署k8s" class="headerlink" title="部署k8s"></a>部署k8s</h2><p>好了，到这里就可以开始使用kubeadm初始化部署k8s集群了</p>
<h3 id="执行kubeadm-init"><a href="#执行kubeadm-init" class="headerlink" title="执行kubeadm init"></a>执行kubeadm init</h3><p>方法一，直接运行下面命令，比较适合简单的集群配置，不涉及太多配置修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm init --skip-phases addon/kube-proxy --apiserver-advertise-address 192.168.122.11 --node-name vm1 --image-repository registry.noname.io:5000</span><br></pre></td></tr></table></figure>

<p>方法二，通过命令导出默认配置内容，修改相关配置，最后指定config文件运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导出默认配置</span></span><br><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm_config.yaml</span><br></pre></td></tr></table></figure>

<p>把advertiseAddress、name、skipPhases、imageRepository等需要修改的地方全改了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">bootstrapTokens:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">system:bootstrappers:kubeadm:default-node-token</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">abcdef.0123456789abcdef</span></span><br><span class="line">  <span class="attr">ttl:</span> <span class="string">24h0m0s</span></span><br><span class="line">  <span class="attr">usages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">signing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">authentication</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line">  <span class="attr">advertiseAddress:</span> <span class="number">192.168</span><span class="number">.122</span><span class="number">.11</span></span><br><span class="line">  <span class="attr">bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line">  <span class="attr">criSocket:</span> <span class="string">unix:///var/run/containerd/containerd.sock</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vm1</span></span><br><span class="line">  <span class="attr">taints:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">skipPhases:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">addon/kube-proxy</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">timeoutForControlPlane:</span> <span class="string">4m0s</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">clusterName:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">controllerManager:</span> &#123;&#125;</span><br><span class="line"><span class="attr">dns:</span> &#123;&#125;</span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.noname.io:5000</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="number">1.31</span><span class="number">.0</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">dnsDomain:</span> <span class="string">cluster.local</span></span><br><span class="line">  <span class="attr">serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span></span><br><span class="line"><span class="attr">scheduler:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>dry-run验证kubeadm_config.yaml文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm init --config kubeadm_config.yaml --dry-run</span><br></pre></td></tr></table></figure>

<p>执行初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm init --config kubeadm_config.yaml</span><br></pre></td></tr></table></figure>

<p>正常情况下，只要没有中途退出报错，走到这里就是安装成功的第一步了。如果出现异常可以在初始化命令后面加<code>-v 5</code>打印更具体的报错信息，我也把遇到过的报错情况放到了最后的bug处理，接下来就是验证集群是否在正常工作了</p>
<p>PS：kubeadm提示可以在执行init命令前可以先拉取image，我试了一下<code>kubeadm config images pull</code>，发现init还是会去拉取image，上面就不在记录这个步骤</p>
<h3 id="集群状态验证"><a href="#集群状态验证" class="headerlink" title="集群状态验证"></a>集群状态验证</h3><p>配置bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<p>执行命令，验证集群的工作状态。<strong>注意</strong>：安装过程中如果有使用proxy会导致kubectl连接不上api server，导致超时，需要删除环境变量<code>unset http_proxy</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看6443端口的监听情况</span></span><br><span class="line"><span class="built_in">sudo</span> netstat -tnlp | grep 6443</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出集群状态</span></span><br><span class="line">kubectl cluster-info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有节点信息</span></span><br><span class="line">kubectl get nodes -o wide</span><br><span class="line">kubectl describe nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于现在还没有安装cilium cni，此时coredns应处于pending状态</span></span><br><span class="line">kubectl get pods -A -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有pod反复崩溃重启，查看相关日志</span></span><br><span class="line">kubectl logs &lt;pod名称&gt; -n &lt;namespace&gt; -p</span><br><span class="line">kubectl describe &lt;pod名称&gt; -n &lt;namespace&gt; -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过crictl查看container，操作类似docker</span></span><br><span class="line"><span class="built_in">sudo</span> crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock ps -a</span><br></pre></td></tr></table></figure>

<h3 id="安装cilium"><a href="#安装cilium" class="headerlink" title="安装cilium"></a>安装cilium</h3><p>下载cilium，安装到&#x2F;usr&#x2F;local&#x2F;bin&#x2F;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可能需要proxy</span></span><br><span class="line">curl -L --fail --remote-name-all https://github.com/cilium/cilium-cli/releases/download/v0.16.15/cilium-linux-amd64.tar.gz&#123;,.<span class="built_in">sha256sum</span>&#125;</span><br><span class="line"><span class="built_in">sha256sum</span> --check cilium-linux-amd64.tar.gz.sha256sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略目录操作了</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> cilium /usr/local/bin/</span><br></pre></td></tr></table></figure>

<p>cilium查看组件安装情况以及报错信息，这里可以根据输出拉取相关image推送到私有registry，cni目录需要保证所有者是root</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看cilium状态、错误</span></span><br><span class="line">cilium status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保/opt/cni目录的所有者是root</span></span><br><span class="line"><span class="comment"># sudo chown -R root:root /opt/cni</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群安装cilium</span></span><br><span class="line">cilium install</span><br><span class="line"><span class="comment"># 指定版本安装</span></span><br><span class="line"><span class="comment"># cilium install v1.15.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod是否准备就绪-running</span></span><br><span class="line">kubectl get pods -A -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点状态应变为-Ready</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<p>到这里集群的初始化就完成了，congratulations</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="单节点k8s"><a href="#单节点k8s" class="headerlink" title="单节点k8s"></a>单节点k8s</h4><p>如果你不想要组集群了，想使用单个节点，那么移除taint即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/control-plane-</span><br><span class="line"><span class="comment"># 这个taint未必存在</span></span><br><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>

<h4 id="配置proxy拉取镜像"><a href="#配置proxy拉取镜像" class="headerlink" title="配置proxy拉取镜像"></a>配置proxy拉取镜像</h4><p>如果你不想使用私有的registry，那么可以使用proxy，containerd的配置如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl set-environment HTTP_PROXY=192.168.0.105:8118</span><br><span class="line"><span class="built_in">sudo</span> systemctl set-environment HTTPS_PROXY=192.168.0.105:8118</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>

<p>然后，不论是直接执行<code>kubeadm init</code>还是<code>kubeadm config images pull</code>，拉取镜像都会通过proxy拉取</p>
<h4 id="Dashboard-UI"><a href="#Dashboard-UI" class="headerlink" title="Dashboard UI"></a>Dashboard UI</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>方法一：使用helm安装（官方推荐）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 kubernetes-dashboard 仓库</span></span><br><span class="line">helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/</span><br><span class="line"><span class="comment"># 使用 kubernetes-dashboard Chart 部署名为 `kubernetes-dashboard` 的 Helm Release</span></span><br><span class="line">helm upgrade --install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard --create-namespace --namespace kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>方法二：下载配置文件导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以下载后传送到vm</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>

<p>执行<code>kubectl get pods -A</code>，你会在kubernetes-dashboard命名空间下看到两个pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS      AGE     IP                NODE   NOMINATED NODE   READINESS GATES</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper-6b96ff7878-ct999   1/1     Running   0             6m57s   10.0.1.215        vm2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard-8696f5f494-8cx4d        1/1     Running   0             6m57s   10.0.1.62         vm2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>如果无法拉取image，可以在物理机下载后推送到私有registry</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull kubernetesui/dashboard:v2.7.0</span><br><span class="line">docker pull kubernetesui/metrics-scraper:v1.0.8</span><br></pre></td></tr></table></figure>

<h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>新建文件<code>dashboard-user.yaml</code>，创建用户、绑定角色，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: dashboard-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: dashboard-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: dashboard-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f dashboard-user.yaml</span><br></pre></td></tr></table></figure>

<h5 id="访问dashboard"><a href="#访问dashboard" class="headerlink" title="访问dashboard"></a>访问dashboard</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br><span class="line"><span class="comment"># 新版本限制死了只能在执行了kubectl proxy的机器上打开，没什么意义</span></span><br><span class="line"><span class="comment"># kubectl proxy --address 0.0.0.0 --accept-hosts &#x27;.*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取登陆的token</span></span><br><span class="line">kubectl -n kubernetes-dashboard create token dashboard-user</span><br><span class="line"></span><br><span class="line"><span class="comment"># 物理机建立ssh port forwarding</span></span><br><span class="line">ssh -L 8001:127.0.0.1:8001 noname@192.168.122.11</span><br></pre></td></tr></table></figure>

<p>在物理机浏览器打开dashboard页面：<a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a> ，输入token即可进入dashboard界面</p>
<h3 id="部署vm2-vm3"><a href="#部署vm2-vm3" class="headerlink" title="部署vm2&#x2F;vm3"></a>部署vm2&#x2F;vm3</h3><p>打印vm1的k8s token信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>

<p>在vm2&#x2F;vm3执行命令，加入集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm <span class="built_in">join</span> 192.168.122.11:6443 --token 1kf3mx.6omg1ycbi6xul19q \</span><br><span class="line">  --discovery-token-ca-cert-hash sha256:9a412686425ed09f8156ec63cb52e798a61cf8de85069be0e36ec023f806ea4f</span><br></pre></td></tr></table></figure>

<p>在vm1验证集群状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>刚开始时，安装k8s不是使用apt，而是手动下载kubeadm等组件手动安装，但是遇到了CrashLoopBackOff、kubelet-check超时等错误，集群一直拉不起来，无奈删掉所有，重新按照apt的方式安装了，结果是一路畅通，后续再手动试试，我要跟这个问题死磕到底</p>
<h3 id="bug处理"><a href="#bug处理" class="headerlink" title="bug处理"></a>bug处理</h3><ol>
<li>CrashLoopBackOff</li>
</ol>
<p>待查明原因</p>
<ol start="2">
<li>cilium安装报错<code>cp: cannot create regular file &#39;/hostbin/cilium-mount&#39;: Permission denied</code></li>
</ol>
<p>这是因为这个目录是我手动创建的，在执行apt安装前就存在，目录的owner不是root，需要确保虚拟机&#x2F;opt&#x2F;cni目录的所有者是root，执行<code>sudo chown -R root:root /opt/cni</code>解决，详细看：<a href="https://github.com/cilium/cilium/issues/23838">https://github.com/cilium/cilium/issues/23838</a></p>
<ol start="3">
<li>kubeadm join报错<code>&#39;/run/systemd/resolve/resolv.conf&#39;: No such file or directory</code></li>
</ol>
<p>从服务器我换了一个debian，毕竟线上服务器通常都不是同一类系统，而这次报错的服务器bookworm就没有安装<code>systemd-resolved</code>，下载安装即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install systemd-resolved</span><br></pre></td></tr></table></figure>

<p>上面debian的修改会引入另一个问题，就是vm无法连通外网了，发现是dhcp有异常，进而导致<code>ImagePullBackOff</code>，也不知道为什么不能直接读取本地的image，需要使用<code>systemd-networkd</code>才行，详细看问题描述<a href="https://garajau.com.br/2022/01/configure-networkd-debian">Configuring systemd-networkd on Debian</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line"><span class="built_in">mv</span> /etc/network/interfaces /etc/network/interfaces.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增systemd-dhcp配置</span></span><br><span class="line"><span class="built_in">sudo</span> vi /etc/systemd/network/dhcp.network</span><br></pre></td></tr></table></figure>

<p>dhcp.network文件内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">[Match]</span><br><span class="line">Name=en*</span><br><span class="line">   </span><br><span class="line">[Network]</span><br><span class="line">DHCP=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>设置开机启动并重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> systemd-networkd</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart systemd-networkd</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>nginx-deployment报错<code>ImagePullBackOff</code></li>
</ol>
<p>这个问题很奇怪，除了前面提到的网络问题，还可能是hash值不匹配</p>
<p>当时我改了<a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/controllers/nginx-deployment.yaml">nginx-deployment.yaml</a>里的镜像，而且确认本地已经拉取过来了，但部署时就一直报错，最后我在物理机重新拉取镜像时发现hash值居然对不上，最后重新打tag推送才解决</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">安装 kubeadm</a><br><a href="https://blog.radwell.codes/2022/07/single-node-kubernetes-cluster-via-kubeadm-on-ubuntu-22-04/">Simple Single-node Kubernetes Cluster via kubeadm on Ubuntu 22.04</a><br><a href="https://www.linuxtechi.com/install-kubernetes-cluster-on-debian/">How to Install Kubernetes Cluster on Debian 12 | 11</a><br><a href="https://izsk.me/2023/06/03/cilium-on-kubernetes-install/">cilium在kubernetes中的生产实践二(cilium部署)</a><br><a href="https://www.tutorialworks.com/difference-docker-containerd-runc-crio-oci/#:~:text=runc%20provides%20all%20of%20the,create%20and%20run%20container%20processes.">The differences between Docker, containerd, CRI-O and runc</a><br><a href="https://spacelift.io/blog/kubernetes-dashboard">Kubernetes Dashboard: Tutorial, Best Practices &amp; Alternatives</a><br><a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md">Creating sample user</a><br><a href="https://unix.stackexchange.com/questions/402999/is-it-ok-to-change-etc-machine-id">Is it OK to change &#x2F;etc&#x2F;machine-id?</a></p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
        <tag>kubeadm</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次xdebug异常</title>
    <url>/2019/09/05/vagrant-xdebug-not-working/</url>
    <content><![CDATA[<p>工欲善其事必先利其器，xdebug是php开发的一个杀手级利器，vagrant是一款非常便捷的虚拟机管理工具，两者搭配有时会出现一些奇怪的问题，近期在重新配置开发环境时，出现xdebug连不上的异常情况，花了些时间才找到问题并解决，记录下解决问题的过程，希望能帮助到一些小伙伴</p>
<h2 id="问题及解决过程"><a href="#问题及解决过程" class="headerlink" title="问题及解决过程"></a>问题及解决过程</h2><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>xdebug配置后，客户端多次请求，vscode均无任何反应。检查服务端、客户端配置，确认没有差错；监测网络数据，只有初次请求数据，无结果返回</p>
<h3 id="客户端-服务器配置信息"><a href="#客户端-服务器配置信息" class="headerlink" title="客户端&#x2F;服务器配置信息"></a>客户端&#x2F;服务器配置信息</h3><p>服务器是vagrant + ubuntu 18.04 + PHP 7.4，客户端是Windows 10，编辑器是vscode</p>
<p>初始xdebug配置如下</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[xdebug]</span></span><br><span class="line"><span class="attr">xdebug.remote_enable</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.remote_autostart</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.remote_port</span> = <span class="number">9001</span></span><br><span class="line"><span class="attr">xdebug.remote_handler</span> = <span class="string">&quot;dbgp&quot;</span></span><br><span class="line"><span class="attr">xdebug.remote_mode</span> = req</span><br><span class="line"><span class="attr">xdebug.remote_connect_back</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.overload_var_dump</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>vscode配置launch.json如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Listen for XDebug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;php&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">9001</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pathMappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;/data/example&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\data\\example&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="开启xdebug日志监测"><a href="#开启xdebug日志监测" class="headerlink" title="开启xdebug日志监测"></a>开启xdebug日志监测</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">xdebug.remote_log</span>=/tmp/xdebug.log</span><br></pre></td></tr></table></figure>

<p>再次请求，获取日志数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[140114918627520] Log opened at 2019-09-04 11:49:00</span><br><span class="line">[140114918627520] I: Checking remote connect back address.</span><br><span class="line">[140114918627520] I: Checking header &#x27;HTTP_X_FORWARDED_FOR&#x27;.</span><br><span class="line">[140114918627520] I: Checking header &#x27;REMOTE_ADDR&#x27;.</span><br><span class="line">[140114918627520] I: Remote address found, connecting to 192.168.33.1:9001.</span><br><span class="line">[140114918627520] E: Time-out connecting to client (Waited: 200 ms). :-(</span><br><span class="line">[140114918627520] Log closed at 2019-09-04 11:49:00</span><br></pre></td></tr></table></figure>

<p>日志显示服务端有正常向客户端9001端口发起连接，但客户端无响应导致超时，检查客户端防火墙无异常</p>
<p>最后，在谷歌上找到一个类似的问题，发现问题与vagrant有关，具体问题描述见参考文档链接</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 移除 xdebug.remote_connect_back = 1</span></span><br><span class="line"><span class="comment">; 添加</span></span><br><span class="line"><span class="attr">xdebug.remote_host</span>=<span class="number">10.0</span>.<span class="number">2.2</span></span><br></pre></td></tr></table></figure>

<p>重启php-fpm，再次测试，vscode可连接xdebug，问题解决</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://danemacmillan.com/how-to-configure-xdebug-in-phpstorm-through-vagrant/">How to configure Xdebug in PhpStorm through Vagrant</a><br><a href="https://stackoverflow.com/questions/24831707/xdebug-time-out-connecting-to-client-using-phpstorm-7-1-3-vagrant-virtualbo">xdebug Time-out connecting to client</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>vagrant</tag>
        <tag>php7.4</tag>
        <tag>xdebug</tag>
      </tags>
  </entry>
</search>
