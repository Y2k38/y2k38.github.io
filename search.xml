<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>安装docker并部署registry服务</title>
    <url>/deploy-docker-and-registry-service/</url>
    <content><![CDATA[<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>当前仅展示apt方式安装，离线安装方式不展示</p>
<h3 id="清理历史残留"><a href="#清理历史残留" class="headerlink" title="清理历史残留"></a>清理历史残留</h3><p>如果系统有预装docker或者先前安装过，先卸载干净在安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 第一次安装时输出为空</span></span><br><span class="line"><span class="keyword">for</span> pkg <span class="keyword">in</span> docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; <span class="keyword">do</span> <span class="built_in">sudo</span> apt remove <span class="variable">$pkg</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果以前有安装过docker，相关数据可以删除掉</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h3 id="apt安装"><a href="#apt安装" class="headerlink" title="apt安装"></a>apt安装</h3><h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><p>由于docker被gfw屏蔽，访问时需要使用vpn，这里使用先前搭建的<a href="/deploy-shadowsocks-service">ss服务</a></p>
<p>新建<code>apt.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/apt/apt.conf</span><br></pre></td></tr></table></figure>

<p>添加proxy配置，默认源地址配置直连，如此后续配置docker源后，使用<code>apt update</code>便可直接访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquire::http::Proxy &quot;http://127.0.0.1:8118&quot;;</span><br><span class="line">Acquire::http::Proxy &#123;</span><br><span class="line">    archive.ubuntu.com DIRECT;</span><br><span class="line">    security.ubuntu.com DIRECT;</span><br><span class="line">    cn.archive.ubuntu.com DIRECT;</span><br><span class="line">    mirrors.tuna.tsinghua.edu.cn DIRECT;</span><br><span class="line">&#125;</span><br><span class="line">Acquire::https::Proxy &quot;http://127.0.0.1:8118&quot;;</span><br><span class="line">Acquire::https::Proxy &#123;</span><br><span class="line">    archive.ubuntu.com DIRECT;</span><br><span class="line">    security.ubuntu.com DIRECT;</span><br><span class="line">    cn.archive.ubuntu.com DIRECT;</span><br><span class="line">    mirrors.tuna.tsinghua.edu.cn DIRECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="配置源并安装"><a href="#配置源并安装" class="headerlink" title="配置源并安装"></a>配置源并安装</h4><p>按照docker官方教材安装docker，其中，下载<code>docker.asc</code>的命令做了一些修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add Docker&#x27;s official GPG key:</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install ca-certificates curl</span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br><span class="line"><span class="comment"># 配置proxy</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118;<span class="built_in">export</span> https_proxy=http://127.0.0.1:8118;</span><br><span class="line"><span class="comment"># 下载后在使用sudo搬到指定目录</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o docker.asc &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">mv</span> docker.asc /etc/apt/keyrings/docker.asc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.asc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the repository to Apt sources:</span></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是k8s部署，只需要containerd就够了</span></span><br><span class="line"><span class="built_in">sudo</span> apt install containerd.io docker-ce docker-ce-cli docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>

<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>将当前用户加入<code>docker</code>用户组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<h2 id="部署registry"><a href="#部署registry" class="headerlink" title="部署registry"></a>部署registry</h2><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>因为gfw的原因，docker hub的访问会时不时抽风，在使用docker pull前可以先配置代理，当前步骤可跳过</p>
<p>创建配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/systemd/system/docker.service.d/http-proxy.conf</span><br></pre></td></tr></table></figure>

<p>配置proxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://127.0.0.1:8118&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=http://127.0.0.1:8118&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=localhost,127.0.0.1,registry.noname.io&quot;</span><br></pre></td></tr></table></figure>

<p>重启并验证docker环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl show --property=Environment docker</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># Environment=HTTP_PROXY=http://127.0.0.1:8118 HTTPS_PROXY=http://127.0.0.1:8118 NO_PROXY=localhost,127.0.0.1,registry.noname.io</span></span><br></pre></td></tr></table></figure>

<h3 id="生成ssl证书"><a href="#生成ssl证书" class="headerlink" title="生成ssl证书"></a>生成ssl证书</h3><p>可以直接使用http，但后续k8s镜像的下载必须使用https，没有那么多耐心再去折腾，在这里先解决了，一劳永逸</p>
<p><code>/data/docker/</code>是我用于专门存放与registry相关的数据，包括certs以及后续docker push上来的镜像数据</p>
<p>下面命令关键的域名registry.noname.io要填好</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">  -newkey rsa:4096 -nodes -sha256 -keyout /data/docker/certs/noname.io.key \</span><br><span class="line">  -addext <span class="string">&quot;subjectAltName = DNS:registry.noname.io&quot;</span> \</span><br><span class="line">  -x509 -days 365 -out /data/docker/certs/noname.io.crt</span><br></pre></td></tr></table></figure>

<p>由此，https所需要的证书也就准备好了</p>
<h3 id="创建registry服务"><a href="#创建registry服务" class="headerlink" title="创建registry服务"></a>创建registry服务</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>将<code>/data/docker/certs</code>挂载到container的<code>/data/certs</code>目录</li>
<li><code>/data/docker/registry</code>挂载到container的<code>/var/lib/registry</code>目录，后续删除重建container时就保留下了image数据</li>
</ol>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>如果只是创建一个简单的可运行registry，直接运行docker run</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart always --name registry \</span><br><span class="line">  -v /data/docker/registry:/var/lib/registry \</span><br><span class="line">  -v /data/docker/certs:/data/certs \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_CERTIFICATE=/data/certs/noname.io.crt \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_KEY=/data/certs/noname.io.key \</span><br><span class="line">  registry:2.8.3</span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>如果涉及比较复杂的配置，像权限管理、接入s3文件系统、缓存配置、中继配置等，则使用配置文件方式比较好</p>
<p>创建registry配置文件，参考配置文件：<a href="https://github.com/distribution/distribution/blob/master/cmd/registry/config-example.yml">example YAML file</a>，修改后如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">:5000</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="attr">certificate:</span> <span class="string">/data/certs/noname.io.crt</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">/data/certs/noname.io.key</span></span><br></pre></td></tr></table></figure>

<p>运行docker run</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart always --name registry \</span><br><span class="line">  -v /data/docker/registry:/var/lib/registry \</span><br><span class="line">  -v /data/docker/certs:/data/certs \</span><br><span class="line">  -v /data/docker/config/config.yml:/etc/docker/registry/config.yml \</span><br><span class="line">  registry:2.8.3</span><br></pre></td></tr></table></figure>

<h3 id="修改系统配置"><a href="#修改系统配置" class="headerlink" title="修改系统配置"></a>修改系统配置</h3><h4 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/hosts</span><br></pre></td></tr></table></figure>

<p>添加私有registry的域名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">127.0.0.1 registry.noname.io</span><br></pre></td></tr></table></figure>

<h4 id="修改docker配置"><a href="#修改docker配置" class="headerlink" title="修改docker配置"></a>修改docker配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p><code>insecure-registries</code>需要添加registry的域名端口</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;exec-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;native.cgroupdriver=systemd&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;registry.noname.io:5000&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>如果要开放局域网内的访问，配置防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 5000/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure>

<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><p>访问registry接口，此时因为registry还没有任何image数据，输出为空</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://registry.noname.io:5000/v2/_catalog | jq .</span><br></pre></td></tr></table></figure>

<p>推送镜像测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag alpine:3.20.1 registry.noname.io:5000/alpine:3.20.1</span><br><span class="line">docker push registry.noname.io:5000/alpine:3.20.1</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu</a><br><a href="https://distribution.github.io/distribution/">Distribution Registry</a><br><a href="https://medium.com/@haminhsang1903/private-docker-registry-with-https-and-a-nginx-reverse-proxy-using-docker-compose-6c1335c5e820">Private Docker registry with HTTPS and a Nginx reverse proxy using Docker Compose</a></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置HTTPS访问</title>
    <url>/configure-nginx-with-https/</url>
    <content><![CDATA[<p>简单介绍如何生成https服务所需要的证书、私钥以及部署，文档分别描述了开发时使用的self-signed证书以及线上使用的let’s encrypt免费证书的生成方法</p>
<h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><h3 id="创建证书以及私钥"><a href="#创建证书以及私钥" class="headerlink" title="创建证书以及私钥"></a>创建证书以及私钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>req:</strong> 指定X.509证书签名请求(CSR)管理</p>
</li>
<li><p><strong>-x509:</strong> 生成self-sigend证书</p>
</li>
<li><p><strong>-nodes:</strong> 不使用密码</p>
</li>
<li><p><strong>-days 365:</strong> 证书有效期</p>
</li>
<li><p><strong>-newkey rsa:2048:</strong> 生成证书的同时生成私钥，rsa加密算法，2048位</p>
</li>
<li><p><strong>-keyout:</strong> 私钥的存储路径</p>
</li>
<li><p><strong>-out:</strong> 证书的存储路径</p>
</li>
</ul>
<p>信息填写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Country Name (2 letter code) [AU]:US</span><br><span class="line">State or Province Name (full name) [Some-State]:New York</span><br><span class="line">Locality Name (eg, city) []:New York City</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:Bouncy Castles, Inc.</span><br><span class="line">Organizational Unit Name (eg, section) []:Ministry of Water Slides</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []: example.com (or server_IP_address)</span><br><span class="line">Email Address []:admin@your_domain.com</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/nginx/sites-enabled/example.com</span><br></pre></td></tr></table></figure>

<p>添加证书以及私钥</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/ssl/certs/nginx-selfsigned.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/ssl/private/nginx-selfsigned.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /var/www/example.com/html;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启nginx，完成</p>
<h2 id="正式证书"><a href="#正式证书" class="headerlink" title="正式证书"></a>正式证书</h2><h3 id="let’t-encrypt安装"><a href="#let’t-encrypt安装" class="headerlink" title="let’t encrypt安装"></a>let’t encrypt安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> git <span class="built_in">clone</span> https://github.com/letsencrypt/letsencrypt /usr/local/letsencrypt</span><br></pre></td></tr></table></figure>

<h3 id="生成证书以及私钥"><a href="#生成证书以及私钥" class="headerlink" title="生成证书以及私钥"></a>生成证书以及私钥</h3><p><strong>生成指定域名证书及密钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> -H /data/app/letsencrypt/letsencrypt-auto certonly --standalone -d www.example.com</span><br></pre></td></tr></table></figure>

<p>letsencrypt需要记录服务器ip，选择“Y”。打开新的命令行窗口，在指定的目录<code>.well-known</code>下创建文件并将指定的内容写入后，在原命令行窗口点击<code>enter</code>键结束</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Saving debug <span class="built_in">log</span> to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line">Plugins selected: Authenticator standalone, Installer None</span><br><span class="line">Obtaining a new certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">http-01 challenge <span class="keyword">for</span> www.example.com</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class="line">certificate. If you<span class="string">&#x27;re running certbot in manual mode on a machine that is not</span></span><br><span class="line"><span class="string">your server, please ensure you&#x27;</span>re okay with that.</span><br><span class="line"></span><br><span class="line">Are you OK with your IP being logged?</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es/(N)o: Y</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Create a file containing just this data:</span><br><span class="line"></span><br><span class="line">BxYgbmNBP0glztPgaevZwzwMSPy2Asd8LRzlyQNnax9.sAK0-w3-GGiCDaAreDXX1rxwm0qQfBfhb-4765BnzRZ</span><br><span class="line"></span><br><span class="line">And make it available on your web server at this URL:</span><br><span class="line"></span><br><span class="line">http://www.example.com/.well-known/acme-challenge/BxYgbmNBP0glztPgaevZwzwMSPy2Asd8LRzlyQNnax9</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Press Enter to Continue           <span class="comment"># 文件创建后再确认</span></span><br><span class="line">Waiting <span class="keyword">for</span> verification...</span><br><span class="line">Cleaning up challenges</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/www.example.com/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/www.example.com/privkey.pem</span><br><span class="line">   Your cert will expire on 2019-11-04. To obtain a new or tweaked</span><br><span class="line">   version of this certificate <span class="keyword">in</span> the future, simply run</span><br><span class="line">   letsencrypt-auto again. To non-interactively renew *all* of your</span><br><span class="line">   certificates, run <span class="string">&quot;letsencrypt-auto renew&quot;</span></span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let<span class="string">&#x27;s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">   Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure>

<p><strong>生成wildcard domain证书及密钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果嫌单个域名太麻烦，想配置wildcard证书，使用下面的命令</span></span><br><span class="line"><span class="built_in">sudo</span> -H /data/app/letsencrypt/letsencrypt-auto certonly --manual --preferred-challenges=dns -d *.example.com</span><br></pre></td></tr></table></figure>

<p>按提示添加dns记录后再点击<code>enter</code>结束</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Saving debug <span class="built_in">log</span> to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line">Plugins selected: Authenticator manual, Installer None</span><br><span class="line">Obtaining a new certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">dns-01 challenge <span class="keyword">for</span> example.com</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class="line">certificate. If you<span class="string">&#x27;re running certbot in manual mode on a machine that is not</span></span><br><span class="line"><span class="string">your server, please ensure you&#x27;</span>re okay with that.</span><br><span class="line"></span><br><span class="line">Are you OK with your IP being logged?</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es/(N)o: Y</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Please deploy a DNS TXT record under the name</span><br><span class="line">_acme-challenge.example.com with the following value:</span><br><span class="line"></span><br><span class="line">AhAGaqohVH8JMAS-jHkS5L_i2J4JCnglUJvY5n2S9qI</span><br><span class="line"></span><br><span class="line">Before continuing, verify the record is deployed.</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Press Enter to Continue           <span class="comment"># 需添加dns记录</span></span><br><span class="line">Waiting <span class="keyword">for</span> verification...</span><br><span class="line">Cleaning up challenges</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/example.com/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/example.com/privkey.pem</span><br><span class="line">   Your cert will expire on 2019-11-04. To obtain a new or tweaked</span><br><span class="line">   version of this certificate <span class="keyword">in</span> the future, simply run</span><br><span class="line">   letsencrypt-auto again. To non-interactively renew *all* of your</span><br><span class="line">   certificates, run <span class="string">&quot;letsencrypt-auto renew&quot;</span></span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let<span class="string">&#x27;s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">   Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure>

<h3 id="配置nginx-1"><a href="#配置nginx-1" class="headerlink" title="配置nginx"></a>配置nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/nginx/sites-enabled/example.com</span><br></pre></td></tr></table></figure>

<p>添加证书以及私钥</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /var/www/example.com/html;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启nginx，完成</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04">How To Create a Self-Signed SSL Certificate for Nginx in Ubuntu 18.04</a><br><a href="https://www.linode.com/docs/security/ssl/install-lets-encrypt-to-create-ssl-certificates/">Install Let’s Encrypt to Create SSL Certificates</a><br><a href="https://gist.github.com/cecilemuller/a26737699a7e70a7093d4dc115915de8">How to setup Let’s Encrypt for Nginx on Ubuntu 18.04 (including IPv6, HTTP&#x2F;2 and A+ SLL rating)</a><br><a href="https://certbot.eff.org/docs/using.html">Certbot User Guide</a><br><a href="http://manpages.ubuntu.com/manpages/xenial/man1/letsencrypt.1.html">letsencrypt man</a></p>
]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>ssl</tag>
        <tag>https</tag>
        <tag>let&#39;s enctypt</tag>
      </tags>
  </entry>
  <entry>
    <title>安装kvm虚拟机</title>
    <url>/deploy-kvm-and-cockpit/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般情况下，日常开发我只使用vagrant跟virtualbox，但后面想搭建一个k8s环境学习，需要一个免费、高性能、便于管理的虚拟机管理软件</p>
<p>综合考虑了下现在市面上的虚拟机管理软件</p>
<ol>
<li>virtualbox 的磁盘性能太差，nat网络所有虚拟机都是同一个IP：10.0.2.15，其他方面也不考虑了</li>
<li>parallel desktop 太贵太黑心</li>
<li>vmware 价格也不便宜还很吃电脑资源</li>
<li>hyper-v 管理界面太难用，同时无法固定虚拟机IP</li>
</ol>
<p>最终我选择组装一台台式机，安装了ubuntu系统，并在上面安装使用kvm虚拟机</p>
<p>cpu是amd 7700，8核心16线程；32GB内存；暂时不需要用到显卡；PC在路由器做了MAC跟IP的绑定，方便使用ssh</p>
<p>由于virt-manager太难用，最后选择cockpit作为kvm虚拟机管理软件</p>
<h2 id="kvm安装"><a href="#kvm安装" class="headerlink" title="kvm安装"></a>kvm安装</h2><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><p>确认cpu开启虚拟化功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般是cpu的核心数量</span></span><br><span class="line">egrep -c <span class="string">&#x27;(vmx|svm)&#x27;</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<h3 id="安装kvm"><a href="#安装kvm" class="headerlink" title="安装kvm"></a>安装kvm</h3><p>安装kvm以及依赖软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install qemu-system-x86 libvirt-daemon-system virtinst \</span><br><span class="line">  virt-manager virt-viewer ovmf swtpm qemu-utils guestfs-tools \</span><br><span class="line">  libosinfo-bin tuned</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> libvirtd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line"><span class="built_in">sudo</span> virt-host-validate qemu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有使用window的需要，可以下载virtio</span></span><br><span class="line">wget https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.240-1/virtio-win-0.1.240.iso</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="安装后工作"><a href="#安装后工作" class="headerlink" title="安装后工作"></a>安装后工作</h3><p>将用户添加到kvm跟libvirt组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG kvm <span class="variable">$USER</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG libvirt <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<h2 id="cockpit安装"><a href="#cockpit安装" class="headerlink" title="cockpit安装"></a>cockpit安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install cockpit cockpit-machines</span><br></pre></td></tr></table></figure>

<p>防火墙配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 9090/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure>

<p>浏览器打开访问web管理页面 <a href="https://192.168.0.105:9090/">https://192.168.0.105:9090</a></p>
<p><img src="/images/kvm_with_cockpit.png" alt="kvm with cockpit preview"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.tecmint.com/install-qemu-kvm-ubuntu-create-virtual-machines/">How to Install QEMU&#x2F;KVM on Ubuntu to Create Virtual Machines</a><br><a href="https://www.tecmint.com/manage-kvm-virtual-machines-using-cockpit-web-console/">Managing KVM Virtual Machines with Cockpit Web Console in Linux</a><br><a href="https://github.com/bryansteiner/gpu-passthrough-tutorial">gpu-passthrough-tutorial</a></p>
]]></content>
      <tags>
        <tag>kvm</tag>
        <tag>cockpit</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建shadowsocks服务</title>
    <url>/deploy-shadowsocks-service/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于国内恶劣的网络环境，作为一名频繁访问外网的Web开发者，不得不自建一个VPN服务，以下简单介绍Shadowsocks的搭建过程。</p>
<p>单纯的ss流量会迅速被gfw识别到并屏蔽，因此使用ss时需要增加obfs用以混淆欺骗gfw，可以极大程度减小被屏蔽的风险。当然，如果你用的是比较出名的服务器供应商，如bandwagon的服务器，那么被屏蔽的机会也很大。</p>
<p>服务端使用的一键安装脚本twist由于开发者已经放弃维护长时间，目前只有参考作用，如果你有耐心，也可以自己修改后再使用，也就跟下面的服务端搭建教程一样。搞完是真的累，太渣了，太需要提高自己的编程水平，写一个一体化的软件包才行</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="twist脚本"><a href="#twist脚本" class="headerlink" title="twist脚本"></a>twist脚本</h3><p>服务端使用的是twist脚本，里面集成了Shadowsocks+simple-obfs+fail2ban以及相关依赖包，使用shell编写，感兴趣的可以看看源代码，下载地址如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/forestbat/Twist</span><br></pre></td></tr></table></figure>

<p>下载后，脚本添加执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x twist</span><br></pre></td></tr></table></figure>

<p>切换到root账户，twist执行需要</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="修改twist"><a href="#修改twist" class="headerlink" title="修改twist"></a>修改twist</h3><p>twist文件里面有一些软件需要删掉&#x2F;更换，有些则需要手动安装，先手动执行一遍twist脚本<code>./twist install</code>，确认有哪些错误，然后选择执行下面的命令</p>
<ol>
<li>修改<code>dependenciesinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不同的系统不一样，不要全改</span></span><br><span class="line"><span class="comment"># 1. 新增依赖包，如libcork-dev</span></span><br><span class="line"><span class="comment"># 2. 名称更换，如python-pip改为python3-pip</span></span><br><span class="line">apt install python3-dev python3-pip python3-setuptools python3-m2crypto libcork-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将pip改为pip3，可能需要使用pip安装m2crypto</span></span><br><span class="line">pip3 install qrcode</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改<code>sslibevinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># github的包命名改了，解压后变成了libsodium-stable</span></span><br><span class="line">tar zxf libsodium-<span class="variable">$&#123;libsodiumver&#125;</span>.tar.gz &amp;&amp; <span class="built_in">mv</span> libsodium-stable libsodium-<span class="variable">$&#123;libsodiumver&#125;</span></span><br></pre></td></tr></table></figure>

<p>或者删掉libsodium这段，直接手动编译安装，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/jedisct1/libsodium/releases/download/1.0.19-RELEASE/libsodium-1.0.19.tar.gz</span><br><span class="line">tar zxf libsodium-1.0.19.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libsodium-1.0.19</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改<code>sslibevinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 tar zxf $&#123;ssobfsver&#125;.tar.gz 这一行后面修改添加代码，因为obfs也有很长时间没有更新，导致在新的编译器下报错</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ssobfstag</span>&quot;</span> == <span class="string">&quot;v0.0.5&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment"># patch</span></span><br><span class="line">sed -i -e <span class="string">&quot;249s/$/ else &#123;result = OBFS_ERROR;&#125;/&quot;</span> /tmp/<span class="variable">$&#123;ssobfsver&#125;</span>/src/obfs_http.c</span><br><span class="line">sed -i -e <span class="string">&#x27;246d&#x27;</span> /tmp/<span class="variable">$&#123;ssobfsver&#125;</span>/src/obfs_http.c</span><br><span class="line"><span class="comment"># patch end</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改<code>sslibevinstallerr</code>、<code>sslibevinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sslibevinstallerr函数如下</span></span><br><span class="line"><span class="comment"># 删掉mbedtls相关包，与libsodium类似，因为命名问题我直接绑定版本了</span></span><br><span class="line"><span class="built_in">rm</span> -rf libsodium-<span class="variable">$&#123;libsodiumver&#125;</span>.tar.gz libsodium-<span class="variable">$&#123;libsodiumver&#125;</span> <span class="variable">$&#123;mbedtlsver&#125;</span>.tar.gz <span class="variable">$&#123;mbedtlsver&#125;</span> <span class="variable">$&#123;sslibevver&#125;</span>.tar.gz <span class="variable">$sslibevver</span> <span class="variable">$&#123;ssobfsver&#125;</span>.tar.gz <span class="variable">$ssobfsver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sslibevinstall函数如下</span></span><br><span class="line"><span class="comment"># 搜索与mbedtlstag有关的代码段，修改绑定版本v2.28.1</span></span><br><span class="line"><span class="comment"># ldconfig</span></span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$mbedtlstag</span>&quot;</span> ] &amp;&amp; mbedtlstag=<span class="string">&quot;v2.28.1&quot;</span></span><br><span class="line">mbedtlsver=<span class="string">&quot;mbedtls-<span class="subst">$(echo $&#123;mbedtlstag&#125; | sed -e &#x27;s/^[a-zA-Z]//g&#x27;)</span>&quot;</span></span><br><span class="line">wget -t 3 -T 30 -nv -O <span class="variable">$&#123;mbedtlsver&#125;</span>.tar.gz https://github.com/Mbed-TLS/mbedtls/archive/refs/tags/<span class="variable">$&#123;mbedtlstag&#125;</span>.tar.gz</span><br><span class="line">[ <span class="string">&quot;$?&quot;</span> != <span class="string">&quot;0&quot;</span> ] &amp;&amp; sslibevinstallerr <span class="string">&quot;mbedtls-<span class="subst">$(echo $&#123;mbedtlstag&#125; | sed -e &#x27;s/^[a-zA-Z]//g&#x27;)</span>&quot;</span></span><br><span class="line">[ -d <span class="variable">$&#123;mbedtlsver&#125;</span> ] &amp;&amp; <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;mbedtlsver&#125;</span>&quot;</span></span><br><span class="line">tar zxf <span class="variable">$&#123;mbedtlsver&#125;</span>.tar.gz</span><br><span class="line"><span class="built_in">pushd</span> <span class="variable">$mbedtlsver</span></span><br><span class="line">make SHARED=1 CFLAGS=-fPIC <span class="string">&quot;-j<span class="subst">$((MAKECORES+1)</span>)&quot;</span> &amp;&amp; make DESTDIR=/usr install || sslibevinstallerr <span class="string">&quot;mbedtls-<span class="variable">$&#123;mbedtlstag&#125;</span> | sed -e &#x27;s/^[a-zA-Z]//g&#x27;&quot;</span> err</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line">ldconfig</span><br><span class="line"><span class="built_in">rm</span> -rf libsodium-<span class="variable">$&#123;libsodiumver&#125;</span>.tar.gz libsodium-<span class="variable">$&#123;libsodiumver&#125;</span> mbedtls-<span class="variable">$&#123;mbedtlsver&#125;</span>.tgz mbedtls-<span class="variable">$&#123;mbedtlsver&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="安装完毕"><a href="#安装完毕" class="headerlink" title="安装完毕"></a>安装完毕</h3><p>执行修改后的twist脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./twist install</span><br></pre></td></tr></table></figure>

<p>如果twist安装成功，此时命令行下将会展示ss服务的二维码以及url，手机端可以用小火箭扫描，桌面端可以复制url导入</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># obfs混淆ss流量；privoxy将http流量转换为socks5流量</span></span><br><span class="line"><span class="built_in">sudo</span> apt install shadowsocks-libev simple-obfs privoxy</span><br></pre></td></tr></table></figure>

<h3 id="ss配置"><a href="#ss配置" class="headerlink" title="ss配置"></a>ss配置</h3><p>修改ss配置，配置文件可以是<code>/etc/shadowsocks-libev/config.json</code>，也可以是<code>/etc/shadowsocks-libev/config-obfs.json</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure>

<p>按下方模板配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;server_ip&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span><span class="string">&quot;tcp_and_udp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span><span class="number">443</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span><span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;server_password&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">86400</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;xchacha20-ietf-poly1305&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugin&quot;</span><span class="punctuation">:</span><span class="string">&quot;obfs-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugin_opts&quot;</span><span class="punctuation">:</span><span class="string">&quot;obfs=tls;obfs-host=mzstatic.com;obfs-uri=/&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>执行下面的命令，确认软件可正常运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看输出确认无异常报错</span></span><br><span class="line"><span class="built_in">sudo</span> ss-local -c /etc/shadowsocks-libev/config.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1080端口</span></span><br><span class="line"><span class="built_in">sudo</span> netstat -tnlp | grep 1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发现ss服务未能正常启动，查看status信息</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status shadowsocks-libev.service</span><br></pre></td></tr></table></figure>

<p>修改<code>systemd</code>配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /usr/lib/systemd/system/shadowsocks-libev.service</span><br></pre></td></tr></table></figure>

<p>将<code>ss-server</code>改为<code>ss-local</code>，因为我们修改的是<code>shadowsocks-libev.service</code>，配置文件就是<code>config.json</code>，这里就不需要再修改什么</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  This file is part of shadowsocks-libev.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Shadowsocks-libev is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment">#  it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment">#  the Free Software Foundation; either version 3 of the License, or</span></span><br><span class="line"><span class="comment">#  (at your option) any later version.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  This file is default for Debian packaging. See also</span></span><br><span class="line"><span class="comment">#  /etc/default/shadowsocks-libev for environment variables.</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Shadowsocks-libev Default Client Service</span><br><span class="line"><span class="attr">Documentation</span>=man:shadowsocks-libev(<span class="number">8</span>)</span><br><span class="line"><span class="attr">After</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"><span class="attr">Wants</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">CapabilityBoundingSet</span>=CAP_NET_BIND_SERVICE</span><br><span class="line"><span class="attr">AmbientCapabilities</span>=CAP_NET_BIND_SERVICE</span><br><span class="line"><span class="attr">DynamicUser</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">EnvironmentFile</span>=/etc/default/shadowsocks-libev</span><br><span class="line"><span class="attr">LimitNOFILE</span>=<span class="number">32768</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/ss-local -c <span class="variable">$CONFFILE</span> <span class="variable">$DAEMON_ARGS</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p>重启ss服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart shadowsocks-libev</span><br></pre></td></tr></table></figure>

<h3 id="privoxy配置"><a href="#privoxy配置" class="headerlink" title="privoxy配置"></a>privoxy配置</h3><p>修改配置文件<code>/etc/privoxy/config</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/privoxy/config</span><br></pre></td></tr></table></figure>

<p>修改<code>listen-address</code>，因为有时我会将地址共享出来给局域网其他设备使用，所以我一般会将<code>127.0.0.1</code>改为<code>0.0.0.0</code>。在末尾添加<code>forward-socks5</code>指令，将所有<code>http</code>流量转发到<code>1080</code>端口</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">listen-address  0.0.0.0:8118</span><br><span class="line">forward-socks5   /               127.0.0.1:1080  .</span><br></pre></td></tr></table></figure>

<p>重启privoxy服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart privoxy</span><br></pre></td></tr></table></figure>

<p>防火墙开放8118端口访问（可选，如果没有打算给局域网内的其他机器使用就不要打开）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 8118/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure>

<h3 id="最后验证"><a href="#最后验证" class="headerlink" title="最后验证"></a>最后验证</h3><p>配置环境变量<code>http_proxy</code>以及<code>https_proxy</code>，访问外网地址，只要有html数据流输出即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118;<span class="built_in">export</span> https_proxy=http://127.0.0.1:8118;</span><br><span class="line"></span><br><span class="line">curl -i https://www.google.com/</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/forestbat/Twist">Twist脚本github地址</a><br><a href="https://winamp.top/228.html">Debian11下编译安装Shadowsocks-libev</a><br><a href="http://docs.lvrui.io/2016/12/12/Linux%E4%B8%AD%E4%BD%BF%E7%94%A8ShadowSocks-Privoxy%E4%BB%A3%E7%90%86/">Linux中使用ShadowSocks+Privoxy代理</a></p>
]]></content>
      <tags>
        <tag>shadowsocks</tag>
        <tag>obfs</tag>
        <tag>privoxy</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-channel</title>
    <url>/golang-series-channel/</url>
    <content><![CDATA[<p>channel-管道，是go语言中一种常见的goroutine的通信方式</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>示例1. 两个goroutine之间使用channel传递数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新goroutine</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    message &lt;- <span class="string">&quot;Hello from goroutine!&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前goroutine</span></span><br><span class="line">msg := &lt;-message</span><br><span class="line">fmt.Println(msg)</span><br></pre></td></tr></table></figure>

<p>示例2. 使用select同时监听多个goroutine的响应数据，实际上，业务代码中一般都是跟定时器搭配使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">    ch1 &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    ch2 &lt;- <span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received from ch1:&quot;</span>, msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received from ch2:&quot;</span>, msg2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// len，元素个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// cap，循环队列的长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指针，指向一个循环队列</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// 元素大小</span></span><br><span class="line">    synctest <span class="type">bool</span>           <span class="comment">// true if created in a synctest bubble</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 是否已关闭</span></span><br><span class="line">    timer    *timer         <span class="comment">// 定时器，双向绑定timer</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>           <span class="comment">// 写索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>           <span class="comment">// 读索引</span></span><br><span class="line">    recvq    waitq          <span class="comment">// 读队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// 写队列</span></span><br><span class="line">    lock     mutex          <span class="comment">// 锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向队列，sudog内部有prev和next指针</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog            <span class="comment">// head</span></span><br><span class="line">    last  *sudog            <span class="comment">// tail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h2><p>创建channel，具体逻辑如下</p>
<ol>
<li>guard，让错误尽早返回</li>
<li>计算创建channel所需的内存大小（header+buf）</li>
<li>创建channel、初始化字段数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">    elem := t.Elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保元素大小没有超过2^16=64KB</span></span><br><span class="line">    <span class="keyword">if</span> elem.Size_ &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.Align_ &gt; maxAlign &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果channel有buf缓冲区</span></span><br><span class="line">    <span class="comment">// 计算buf总大小=type_size*size</span></span><br><span class="line">    mem, overflow := math.MulUintptr(elem.Size_, <span class="type">uintptr</span>(size))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建channel</span></span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:          <span class="comment">// size=0或者type_size=0，无buf</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> !elem.Pointers():  <span class="comment">// 元素非指针类型，一次性为header和buf申请内存</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>:                <span class="comment">// 指针类型，分别为header和buf申请内存</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.elemsize = <span class="type">uint16</span>(elem.Size_)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">    <span class="comment">// synctest，忽略</span></span><br><span class="line">    <span class="keyword">if</span> getg().syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.synctest = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁优先级设置，见src/runtime/lockrank.go</span></span><br><span class="line">    lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.Size_, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取buf可写入的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanbuf</span><span class="params">(c *hchan, i <span class="type">uint</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="keyword">return</span> add(c.buf, <span class="type">uintptr</span>(i)*<span class="type">uintptr</span>(c.elemsize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">full</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 容量为0</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 有G在等待读数据</span></span><br><span class="line">        <span class="keyword">return</span> c.recvq.first == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容量不为0，确认队列是否已满</span></span><br><span class="line">    <span class="keyword">return</span> c.qcount == c.dataqsiz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 容量为0</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atomic.Loadp(unsafe.Pointer(&amp;c.sendq.first)) == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步timer（&lt;=go1.22)</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line">        c.timer.maybeRunChan()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容量不为0，确认队列是否为空</span></span><br><span class="line">    <span class="keyword">return</span> atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>如何发送数据到channel？当使用代码<code>c &lt;- x</code>时，系统将编译为对chansend1的调用；当使用select发送数据时，编译为对selectnbsend的调用；而这两个函数最终会调用chansend</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `c &lt;- x`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chansend(c, elem, <span class="literal">true</span>, sys.GetCallerPC())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select代码块</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//    select &#123;</span></span><br><span class="line"><span class="comment">//    case c &lt;- v:</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    default:</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 编译为如下代码</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    if selectnbsend(c, v) &#123;</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, sys.GetCallerPC())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chansend代码如下，具体逻辑为</p>
<ol>
<li>select场景，非阻塞<ul>
<li>如果channel  已关闭，异常</li>
<li>如果channel  未初始化或buf已满，发送失败，返回</li>
</ul>
</li>
<li>c &lt;- v场景，阻塞<ul>
<li>如果channel  未初始化或已关闭，异常</li>
</ul>
</li>
<li>共同逻辑<ul>
<li>加锁double-check，如果channel  已关闭，异常</li>
<li>如果已经有读G在等待，说明buf为空，把数据给队列的第一个读G并唤醒，返回</li>
<li>buf未满，写入下一个空位置，更新索引、计数器，返回</li>
<li>buf已满，非阻塞返回写入失败，阻塞则把当前G封装到sudog放进写队列，挂起等待</li>
<li>被唤醒后<ul>
<li>如果是因为channel  被关闭导致的唤醒，异常</li>
<li>数据已被读G拿走，清理收尾</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传递数据到channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 非阻塞-select</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;chansend: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞-select and channel未关闭 and buf已满</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 写入</span></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已关闭，异常</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经有读G在等待，说明buf为空，把数据给队列的第一个G并唤醒</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下场景：0 &lt;= buf_len &lt;= cap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf未满</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// 获取buf下一个可写入的地址</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        <span class="comment">// 写索引</span></span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素个数</span></span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf已满</span></span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="comment">// 加上上面的channel未关闭、buf已满，可以当作是double-check</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，挂起等待</span></span><br><span class="line">    <span class="comment">// Ps. 下面这交叉写看的好乱</span></span><br><span class="line">    gp := getg()                    <span class="comment">// 当前G</span></span><br><span class="line">    mysg := acquireSudog()          <span class="comment">// sudog</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span>            <span class="comment">// 纪录G在channel上阻塞的耗时</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    mysg.elem = ep                  <span class="comment">// x元素指针（c &lt;- x)</span></span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span>             <span class="comment">// ？</span></span><br><span class="line">    mysg.g = gp                     <span class="comment">// 把当前G放到sudog的g，双向绑定</span></span><br><span class="line">    mysg.isSelect = <span class="literal">false</span>           <span class="comment">// 非select操作</span></span><br><span class="line">    mysg.c = c                      <span class="comment">// channel</span></span><br><span class="line">    gp.waiting = mysg               <span class="comment">// 把sudog放到当前G的waiting，双向绑定</span></span><br><span class="line">    gp.param = <span class="literal">nil</span>                  <span class="comment">// 重置sudog指针</span></span><br><span class="line">    c.sendq.enqueue(mysg)           <span class="comment">// 把sudog放进队列</span></span><br><span class="line">    gp.parkingOnChan.Store(<span class="literal">true</span>)    <span class="comment">// 是否阻塞在channel</span></span><br><span class="line">    reason := waitReasonChanSend</span><br><span class="line">    <span class="keyword">if</span> c.synctest &#123;</span><br><span class="line">        reason = waitReasonSynctestChanSend</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起</span></span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), reason, traceBlockChanSend, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保x元素还活着</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向绑定异常</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span>                <span class="comment">// 当前G移除sudog绑定</span></span><br><span class="line">    gp.activeStackChans = <span class="literal">false</span>     <span class="comment">// 是否在等待channel操作</span></span><br><span class="line">    closed := !mysg.success         <span class="comment">// 关闭channel时设置为false，其他情况为true</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 纪录阻塞事件</span></span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span>                    <span class="comment">// 移除channel绑定</span></span><br><span class="line">    releaseSudog(mysg)              <span class="comment">// 删除sudog</span></span><br><span class="line">    <span class="comment">// 因为channel被关闭而导致的唤醒</span></span><br><span class="line">    <span class="keyword">if</span> closed &#123;、</span><br><span class="line">        <span class="comment">// 状态不匹配</span></span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已关闭channel不可写入</span></span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送元素value给读G并将其唤醒，buf为空才会走到这里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// synctest，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; sg.g.syncGroup != getg().syncGroup &#123;</span><br><span class="line">        unlockf()</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sg =&gt; 从recvq拿到的，ep =&gt; x元素指针（c &lt;- x)</span></span><br><span class="line">    <span class="comment">// y元素指针（y := &lt;- c)，如果是丢弃数值则不处理 =&gt; &lt;- c</span></span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep)</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读G</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    <span class="comment">// 纪录读sudog写到param</span></span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    sg.success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒读G</span></span><br><span class="line">    goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// sg =&gt; 从recvq获取的</span></span><br><span class="line">    <span class="comment">// 元素指针</span></span><br><span class="line">    dst := sg.elem</span><br><span class="line">    typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.Size_)</span><br><span class="line">    <span class="comment">// 复制数据</span></span><br><span class="line">    memmove(dst, src, t.Size_)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine被挂起休眠之前调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanparkcommit</span><span class="params">(gp *g, chanLock unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    gp.activeStackChans = <span class="literal">true</span>      <span class="comment">// 是否在等待channel操作</span></span><br><span class="line">    gp.parkingOnChan.Store(<span class="literal">false</span>)   <span class="comment">// 是否阻塞在channel</span></span><br><span class="line">    unlock((*mutex)(chanLock))      <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把sudog放进队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *waitq)</span></span> enqueue(sgp *sudog) &#123;</span><br><span class="line">    sgp.next = <span class="literal">nil</span></span><br><span class="line">    x := q.last</span><br><span class="line">    <span class="comment">// 队列为空</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        sgp.prev = <span class="literal">nil</span></span><br><span class="line">        q.first = sgp</span><br><span class="line">        q.last = sgp</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    sgp.prev = x</span><br><span class="line">    x.next = sgp</span><br><span class="line">    q.last = sgp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把sudog移出队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *waitq)</span></span> dequeue() *sudog &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 从头部开始</span></span><br><span class="line">        sgp := q.first</span><br><span class="line">        <span class="comment">// 队列为空</span></span><br><span class="line">        <span class="keyword">if</span> sgp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// next</span></span><br><span class="line">        y := sgp.next</span><br><span class="line">        <span class="comment">// 队列只有一个数据</span></span><br><span class="line">        <span class="keyword">if</span> y == <span class="literal">nil</span> &#123;</span><br><span class="line">            q.first = <span class="literal">nil</span></span><br><span class="line">            q.last = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 队列有多个数据</span></span><br><span class="line">            y.prev = <span class="literal">nil</span></span><br><span class="line">            q.first = y</span><br><span class="line">            sgp.next = <span class="literal">nil</span> <span class="comment">// mark as removed (see dequeueSudoG)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了一个sudog，但还有一个问题需要判断</span></span><br><span class="line">        <span class="comment">// G被select唤醒时，可能还未被移出队列</span></span><br><span class="line">        <span class="keyword">if</span> sgp.isSelect &#123;</span><br><span class="line">            <span class="keyword">if</span> !sgp.g.selectDone.CompareAndSwap(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// We lost the race to wake this goroutine.</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sgp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>如何从channel接收数据？当使用代码<code>&lt;- c</code>时，系统将根据返回值编译为对chanrecv1或chanrecv2的调用；当使用select接收数据时，编译为对selectnbrecv的调用；而这三个函数最终会调用chanrecv</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `&lt;- c` 或 `y := &lt;- c`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `y, ok := &lt;- c`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">    _, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select代码块</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    select &#123;</span></span><br><span class="line"><span class="comment">//    case v, ok = &lt;-c:</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    default:</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 编译为如下代码</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    if selected, ok = selectnbrecv(&amp;v, c); selected &#123;</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chanrecv代码如下，具体逻辑为</p>
<ol>
<li>select场景，非阻塞<ul>
<li>如果  channel  未初始化或已关闭或buf为空，无数据，返回</li>
</ul>
</li>
<li>c &lt;- v场景，阻塞<ul>
<li>如果channel  未初始化，异常</li>
</ul>
</li>
<li>共同逻辑<ul>
<li>加锁double-check</li>
<li>如果channel  已关闭且buf为空，无数据，返回</li>
<li>如果已经有写G在等待，说明buf已满，读取队列的第一个写G并唤醒，返回</li>
<li>buf不为空，读循环队列，更新索引、计数器，返回</li>
<li>buf为空，非阻塞则返回读取失败，阻塞则把当前G封装到sudog放进读队列，挂起等待<ul>
<li>数据已从写G读到，清理收尾</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;chanrecv: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;receive on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步timer（&lt;=go1.22)</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line">        c.timer.maybeRunChan()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞 and buf为空</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line">        <span class="comment">// channel未关闭</span></span><br><span class="line">        <span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已关闭</span></span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="keyword">if</span> empty(c) &#123;</span><br><span class="line">            <span class="comment">// `y := &lt;- c` =&gt; ep不为nil，`&lt;- c` =&gt; ep为nil</span></span><br><span class="line">            <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">                typedmemclr(c.elemtype, ep)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 读取</span></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已关闭</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// buf为空</span></span><br><span class="line">        <span class="keyword">if</span> c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">            unlock(&amp;c.lock)</span><br><span class="line">            <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">                typedmemclr(c.elemtype, ep)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// channel已关闭但buf还有数据 0 &lt; buf_len &lt;= cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已经有写G在等待，说明buf已满，读取buf第一个数据，队列的第一个写G数据补上buf然后唤醒</span></span><br><span class="line">        <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">            recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// buf未满 0 &lt;= buf_len &lt; cap</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下场景：0 &lt;= buf_len &lt;= cap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf不为空</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取buf下一个可读取的地址</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemclr(c.elemtype, qp)</span><br><span class="line">        <span class="comment">// 读索引</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素个数</span></span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf为空</span></span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="comment">// 可以理解为加锁后的double-check</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，挂起等待</span></span><br><span class="line">    gp := getg()                    <span class="comment">// 当前G</span></span><br><span class="line">    mysg := acquireSudog()          <span class="comment">// 获取sudog</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span>            <span class="comment">// 纪录G在channel上阻塞的耗时</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    mysg.elem = ep                  <span class="comment">// y元素指针（y := &lt;- c)</span></span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span>             <span class="comment">// ？</span></span><br><span class="line">    gp.waiting = mysg               <span class="comment">// 把sudog放到当前G的waiting，双向绑定</span></span><br><span class="line">    mysg.g = gp                     <span class="comment">// 把当前G放到sudog的g，双向绑定</span></span><br><span class="line">    mysg.isSelect = <span class="literal">false</span>           <span class="comment">// 非select操作</span></span><br><span class="line">    mysg.c = c                      <span class="comment">// channel</span></span><br><span class="line">    gp.param = <span class="literal">nil</span>                  <span class="comment">// 重置sudog指针</span></span><br><span class="line">    c.recvq.enqueue(mysg)           <span class="comment">// 把sudog放进队列</span></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// G挂起休眠之前，将定时器标记为阻塞并加入最小堆</span></span><br><span class="line">        blockTimerChan(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp.parkingOnChan.Store(<span class="literal">true</span>)    <span class="comment">// 是否阻塞在channel</span></span><br><span class="line">    reason := waitReasonChanReceive</span><br><span class="line">    <span class="keyword">if</span> c.synctest &#123;</span><br><span class="line">        reason = waitReasonSynctestChanReceive</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起</span></span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), reason, traceBlockChanRecv, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向绑定异常</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// G唤醒后，将定时器标记为非阻塞、删除状态</span></span><br><span class="line">        unblockTimerChan(c)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span>                <span class="comment">// 当前G移除sudog绑定</span></span><br><span class="line">    gp.activeStackChans = <span class="literal">false</span>     <span class="comment">// 是否在等待channel操作</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 纪录阻塞事件</span></span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    success := mysg.success         <span class="comment">// 关闭channel时设置为false，其他情况为true</span></span><br><span class="line">    gp.param = <span class="literal">nil</span>                  <span class="comment">// 重置sudog指针</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span>                    <span class="comment">// 移除channel绑定</span></span><br><span class="line">    releaseSudog(mysg)              <span class="comment">// 释放sudog</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从写G读取元素value并将其唤醒，buf已满才会走到这里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// synctest，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; sg.g.syncGroup != getg().syncGroup &#123;</span><br><span class="line">        unlockf()</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;receive on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sg =&gt; 从sendq拿到的，ep =&gt; y元素指针（y := &lt;- c)</span></span><br><span class="line">    <span class="comment">// 无缓冲channel</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            recvDirect(c.elemtype, sg, ep)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有缓冲channel</span></span><br><span class="line">        <span class="comment">// buf已满</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="comment">// 把数组第一个可读元素复制给读G</span></span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把写G的数据复制到这个位置上，补充数组元素</span></span><br><span class="line">        typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">        <span class="comment">// 读索引</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写索引，既然buf已满，读跟写的位置自然一样</span></span><br><span class="line">        c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写G的数据已经复制到buf上了</span></span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 写G</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    <span class="comment">// 写G的sudog放到param</span></span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="comment">// 关闭channel时设置为false，其他情况为true</span></span><br><span class="line">    sg.success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒写G</span></span><br><span class="line">    goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// sg =&gt; 从sendq获取的</span></span><br><span class="line">    <span class="comment">// 元素指针</span></span><br><span class="line">    src := sg.elem</span><br><span class="line">    typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.Size_)</span><br><span class="line">    memmove(dst, src, t.Size_)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h2><p>关闭channel  ，具体逻辑如下</p>
<ol>
<li>如果channel  未初始化或已关闭，异常</li>
<li>channel  设为已关闭closed&#x3D;1</li>
<li>收集并唤醒所有在读写队列的G（写G会抛出异常）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 已关闭，异常</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭channel</span></span><br><span class="line">    c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集所有在读写队列里的G</span></span><br><span class="line">    <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有读G</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.recvq.dequeue()</span><br><span class="line">        <span class="comment">// 没数据，退出</span></span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">            sg.elem = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = unsafe.Pointer(sg)</span><br><span class="line">        sg.success = <span class="literal">false</span></span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有写G</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.sendq.dequeue()</span><br><span class="line">        <span class="comment">// 没数据，退出</span></span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = unsafe.Pointer(sg)</span><br><span class="line">        sg.success = <span class="literal">false</span></span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有G</span></span><br><span class="line">    <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">        gp := glist.pop()</span><br><span class="line">        gp.schedlink = <span class="number">0</span></span><br><span class="line">        goready(gp, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取channel-数据量"><a href="#获取channel-数据量" class="headerlink" title="获取channel  数据量"></a>获取channel  数据量</h2><p>当调用<code>len(c)</code>时，系统调用chanlen实现，具体逻辑如下</p>
<ol>
<li>未初始化的channel  数据量为0</li>
<li>如果是异步timer，返回qcount的数值</li>
<li>如果是同步timer，返回0</li>
<li>其他情况一律返回channel  字段qcount的数值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanlen</span><span class="params">(c *hchan)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// asynctimerchan=0 =&gt; 如果是go1.23版本及以后</span></span><br><span class="line">    <span class="comment">// asynctimerchan=1 =&gt; 如果是go1.22版本及以前</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 异步timer（&lt;=go1.22)</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &amp;&amp; async &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line">        c.timer.maybeRunChan()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步timer（&gt;=go1.23)，dirty hack，让timer的len一直为0</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &amp;&amp; !async &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(c.qcount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取channel-容量"><a href="#获取channel-容量" class="headerlink" title="获取channel  容量"></a>获取channel  容量</h2><p>当调用<code>cap(c)</code>时，系统调用chancap实现，具体逻辑如下</p>
<ol>
<li>未初始化的channel  容量为0</li>
<li>如果是异步timer，返回dataqsiz的数值</li>
<li>如果是同步timer，返回0</li>
<li>其他情况一律返回channel  字段dataqsiz的数值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chancap</span><span class="params">(c *hchan)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// asynctimerchan=0 =&gt; 如果是go1.23版本及以后</span></span><br><span class="line">        <span class="comment">// asynctimerchan=1 =&gt; 如果是go1.22版本及以前</span></span><br><span class="line">        async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> async &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">int</span>(c.dataqsiz)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同步timer（&gt;=go1.23)，dirty hack，让timer的cap一直为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(c.dataqsiz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器相关"><a href="#定时器相关" class="headerlink" title="定时器相关"></a>定时器相关</h2><h3 id="maybeRunChan"><a href="#maybeRunChan" class="headerlink" title="maybeRunChan"></a>maybeRunChan</h3><p>判断是否需要更新timer状态、执行函数f。具体逻辑如下</p>
<ol>
<li>不满足条件则返回<ul>
<li>timer已经放在最小堆上，那么过期后自动发送到channel</li>
<li>timer从未执行过</li>
<li>timer还未到触发时刻</li>
</ul>
</li>
<li>满足条件则更新timer状态、执行函数f</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeRunChan() &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="keyword">var</span> timerGroup *synctestGroup</span><br><span class="line">        <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">            timerGroup = t.ts.syncGroup</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        sg := getg().syncGroup</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;synctest timer accessed from outside bubble&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> timerGroup != <span class="literal">nil</span> &amp;&amp; sg != timerGroup &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;timer moved between synctest bubbles&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果timer已经在最小堆中，过期后自动发送到channel</span></span><br><span class="line">    <span class="keyword">if</span> t.astate.Load()&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 当前时刻，单调时钟</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 加锁后double-check</span></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer从未执行过</span></span><br><span class="line">    <span class="comment">// 3. timer还未到触发时刻</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> || t.when == <span class="number">0</span> || t.when &gt; now &#123;</span><br><span class="line">        <span class="comment">// debug用，忽略</span></span><br><span class="line">        t.trace(<span class="string">&quot;maybeRunChan-&quot;</span>)</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;maybeRunChan+&quot;</span>)</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">        t.unlockAndRun(now)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="blockTimerChan-unblockTimerChan"><a href="#blockTimerChan-unblockTimerChan" class="headerlink" title="blockTimerChan &amp; unblockTimerChan"></a>blockTimerChan &amp; unblockTimerChan</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个10ms过期的定时器</span></span><br><span class="line">t := time.NewTimer(<span class="number">10</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待定时器过期信号</span></span><br><span class="line">&lt;-t.C</span><br></pre></td></tr></table></figure>

<p>上述示例代码，如果这个channel是属于一个定时器的，那么在G挂起前、唤醒后，需要修改定时器的state-状态、blocked-标记等。函数详细注释如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// G挂起休眠之前，将定时器标记为阻塞并加入最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;blockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer已标记删除</span></span><br><span class="line">    <span class="comment">// 3. 过期时刻大于0</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie != <span class="number">0</span> &amp;&amp; t.when &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t.state &amp;^= timerZombie <span class="comment">// 移除标志位</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">-1</span>)    <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要把定时器放到timers.heap</span></span><br><span class="line">    add := t.needsAdd()</span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line">        t.maybeAdd()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G唤醒后，将定时器标记为非阻塞、删除状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unblockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;unblockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器 or 计数器为0，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan || t.blocked == <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器为0 and timer已经在最小堆中 and timer无删除标记</span></span><br><span class="line">    <span class="keyword">if</span> t.blocked == <span class="number">0</span> &amp;&amp; t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 标记为删除</span></span><br><span class="line">        t.state |= timerZombie</span><br><span class="line">        <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">6.4 Channel</a><br><a href="https://www.youtube.com/watch?v=KBZlN0izeiY">GopherCon 2017: Kavya Joshi - Understanding Channels</a><br><a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8">Diving Deep Into The Golang Channels.</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Map(HashTrieMap)</title>
    <url>/golang-series-hashtriemap/</url>
    <content><![CDATA[<p>从1.24版开始，sync.Map改用HashTrieMap重构，与之前的双map实现不同，HashTrieMap更像是一个B树，简单的示例图如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  root -&gt; | idx0    | idx1       | ... | idx15 |</span></span><br><span class="line"><span class="comment">//          | &amp;entry0 | &amp;indirect0 | ... | nil   |</span></span><br><span class="line"><span class="comment">//                          |</span></span><br><span class="line"><span class="comment">//                       children</span></span><br><span class="line"><span class="comment">//                          v</span></span><br><span class="line"><span class="comment">//                    | idx0 | idx1    | ... | idx15 |</span></span><br><span class="line"><span class="comment">//                    | nil  | &amp;entry1 | ... | nil   |</span></span><br></pre></td></tr></table></figure>

<p>使用哈希函数生成64位的哈希值，从高到低4位为一个idx，最多有16层，每个节点可容纳16个元素，最多可容纳16^16&#x3D;2^64个元素</p>
<p>当前go版本：1.24</p>
<blockquote>
<p>HashTrieMap的开关放在文件<code>src/internal/buildcfg/exp.go</code>的函数<code>ParseGOEXPERIMENT</code>中</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HashTrieMap[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    inited   atomic.Uint32                          <span class="comment">// 是否已初始化</span></span><br><span class="line">    initMu   Mutex                                  <span class="comment">// 锁，用于初始化</span></span><br><span class="line">    root     atomic.Pointer[indirect[K, V]]         <span class="comment">// 根节点</span></span><br><span class="line">    keyHash  hashFunc                               <span class="comment">// 哈希函数，用于key</span></span><br><span class="line">    valEqual equalFunc                              <span class="comment">// cmp函数，用于value</span></span><br><span class="line">    seed     <span class="type">uintptr</span>                                <span class="comment">// 哈希种子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部节点</span></span><br><span class="line"><span class="keyword">type</span> indirect[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    node[K, V]                                      <span class="comment">// isEntry=false</span></span><br><span class="line">    dead     atomic.Bool                            <span class="comment">// 是否被删除</span></span><br><span class="line">    mu       Mutex                                  <span class="comment">// 锁，用于children</span></span><br><span class="line">    parent   *indirect[K, V]                        <span class="comment">// 父节点指针</span></span><br><span class="line">    children [nChildren]atomic.Pointer[node[K, V]]  <span class="comment">// 16个子节点，指向indirect或entry</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点</span></span><br><span class="line"><span class="keyword">type</span> entry[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    node[K, V]                                      <span class="comment">// isEntry=true</span></span><br><span class="line">    overflow atomic.Pointer[entry[K, V]]            <span class="comment">// 指针，当两个entry哈希值相同时以链表方式存储</span></span><br><span class="line">    key      K                                      <span class="comment">// 键</span></span><br><span class="line">    value    V                                      <span class="comment">// 值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry和indirect的共有属性</span></span><br><span class="line"><span class="keyword">type</span> node[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    isEntry <span class="type">bool</span>                                    <span class="comment">// 判断是叶子节点还是内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>根据key获取value，具体逻辑如下</p>
<ol>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，即没找到，返回</li>
<li>如果子节点是叶子节点，搜索链表并返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Load(key K) (value V, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">    i := ht.root.Load()</span><br><span class="line">    <span class="comment">// hashShift=64 =&gt; 64/4=16，整个trie最多有16层</span></span><br><span class="line">    hashShift := <span class="number">8</span> * goarch.PtrSize</span><br><span class="line">    <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// hashShift-=4</span></span><br><span class="line">        hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">        n := i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask].Load()</span><br><span class="line">        <span class="comment">// 子节点为nil，返回空值</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> n.isEntry &#123;</span><br><span class="line">            <span class="comment">// 搜索链表</span></span><br><span class="line">            <span class="keyword">return</span> n.entry().lookup(key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// curr指针指向子节点</span></span><br><span class="line">        i = n.indirect()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> init() &#123;</span><br><span class="line">    <span class="keyword">if</span> ht.inited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 未初始化</span></span><br><span class="line">        ht.initSlow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> initSlow() &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    ht.initMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> ht.initMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="keyword">if</span> ht.inited.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 其他G在当前G等待时已经初始化了</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[K]V                               <span class="comment">// 临时map</span></span><br><span class="line">    mapType := abi.TypeOf(m).MapType()          <span class="comment">// 获取maptype</span></span><br><span class="line">    ht.root.Store(newIndirectNode[K, V](<span class="literal">nil</span>))   <span class="comment">// parent=nil</span></span><br><span class="line">    ht.keyHash = mapType.Hasher                 <span class="comment">// 复制map的哈希函数</span></span><br><span class="line">    ht.valEqual = mapType.Elem.Equal            <span class="comment">// 复制map的cmp函数</span></span><br><span class="line">    ht.seed = <span class="type">uintptr</span>(runtime_rand())           <span class="comment">// 生成哈希种子</span></span><br><span class="line"></span><br><span class="line">    ht.inited.Store(<span class="number">1</span>)                          <span class="comment">// inited设为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成内部节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newIndirectNode</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(parent *indirect[K, V])</span></span> *indirect[K, V] &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;indirect[K, V]&#123;node: node[K, V]&#123;isEntry: <span class="literal">false</span>&#125;, parent: parent&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表搜索key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry[K, V])</span></span> lookup(key K) (V, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &#123;</span><br><span class="line">            <span class="keyword">return</span> e.value, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>存储key&#x2F;value。本质就是Swap方法，但丢弃其返回值，具体看Swap</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Store(key K, old V) &#123;</span><br><span class="line">    _, _ = ht.Swap(key, old)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadOrStore"><a href="#LoadOrStore" class="headerlink" title="LoadOrStore"></a>LoadOrStore</h3><p>根据key获取value，获取失败则保存key&#x2F;value，具体逻辑如下</p>
<ol>
<li>Load<ul>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则返回</li>
</ul>
</li>
<li>Store<ul>
<li>纪录搜索中断位置的curr节点指针i和子节点指针slot、n</li>
<li>如果n为nil，直接写入children</li>
<li>如果n为叶子节点，放进链表，或者分裂后再存储进children</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> LoadOrStore(key K, value V) (result V, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i *indirect[K, V]                   <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">    <span class="keyword">var</span> hashShift <span class="type">uint</span>                      <span class="comment">// 用于计算idx</span></span><br><span class="line">    <span class="keyword">var</span> slot *atomic.Pointer[node[K, V]]    <span class="comment">// 子节点指针的指针</span></span><br><span class="line">    <span class="keyword">var</span> n *node[K, V]                       <span class="comment">// 子节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Load</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">        i = ht.root.Load()</span><br><span class="line">        <span class="comment">// hashShift=64 =&gt; 64/4=16，整个trie最多有16层</span></span><br><span class="line">        hashShift = <span class="number">8</span> * goarch.PtrSize</span><br><span class="line">        <span class="comment">// 当前循环是否已经找到写入点</span></span><br><span class="line">        haveInsertPoint := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// hashShift-=4</span></span><br><span class="line">            hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取子节点指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">            slot = &amp;i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask]</span><br><span class="line">            n = slot.Load()</span><br><span class="line">            <span class="comment">// 子节点为nil，可写入，结束循环</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">                haveInsertPoint = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> n.isEntry &#123;</span><br><span class="line">                <span class="comment">// 搜索链表 -&gt; Load</span></span><br><span class="line">                <span class="keyword">if</span> v, ok := n.entry().lookup(key); ok &#123;</span><br><span class="line">                    <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 叶子节点默认可写</span></span><br><span class="line">                haveInsertPoint = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = n.indirect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> !haveInsertPoint &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        i.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        n = slot.Load()</span><br><span class="line">        <span class="comment">// 子节点为nil或叶子节点 and 当前节点未删除</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nil</span> || n.isEntry) &amp;&amp; !i.dead.Load() &#123;</span><br><span class="line">            <span class="comment">// 确认可写入，slot查找结束</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Load失败，改为Store</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在for循环里已经加锁了</span></span><br><span class="line">    <span class="keyword">defer</span> i.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oldEntry *entry[K, V]</span><br><span class="line">    <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">        oldEntry = n.entry()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="keyword">if</span> v, ok := oldEntry.lookup(key); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建叶子节点</span></span><br><span class="line">    newEntry := newEntryNode(key, value)</span><br><span class="line">    <span class="comment">// 原子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> oldEntry == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接存储</span></span><br><span class="line">        slot.Store(&amp;newEntry.node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 原子节点为叶子节点</span></span><br><span class="line">        <span class="comment">// 放进链表，或者分裂后再存储进children</span></span><br><span class="line">        slot.Store(ht.expand(oldEntry, newEntry, hash, hashShift, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> expand(oldEntry, newEntry *entry[K, V], newHash <span class="type">uintptr</span>, hashShift <span class="type">uint</span>, parent *indirect[K, V]) *node[K, V] &#123;</span><br><span class="line">    <span class="comment">// 哈希碰撞</span></span><br><span class="line">    oldHash := ht.keyHash(unsafe.Pointer(&amp;oldEntry.key), ht.seed)</span><br><span class="line">    <span class="comment">// 1. 新旧哈希值相同</span></span><br><span class="line">    <span class="keyword">if</span> oldHash == newHash &#123;</span><br><span class="line">        <span class="comment">// 放进链表开头</span></span><br><span class="line">        newEntry.overflow.Store(oldEntry)</span><br><span class="line">        <span class="keyword">return</span> &amp;newEntry.node</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 新旧哈希值不同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建内部节点</span></span><br><span class="line">    newIndirect := newIndirectNode(parent)</span><br><span class="line">    <span class="comment">// 纪录父节点</span></span><br><span class="line">    top := newIndirect</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> hashShift == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while inserting&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hashShift-=4</span></span><br><span class="line">        hashShift -= nChildrenLog2</span><br><span class="line">        <span class="comment">// 从高到低，找到两个哈希值不同的4位</span></span><br><span class="line">        oi := (oldHash &gt;&gt; hashShift) &amp; nChildrenMask</span><br><span class="line">        ni := (newHash &gt;&gt; hashShift) &amp; nChildrenMask</span><br><span class="line">        <span class="comment">// idx不同</span></span><br><span class="line">        <span class="keyword">if</span> oi != ni &#123;</span><br><span class="line">            newIndirect.children[oi].Store(&amp;oldEntry.node)</span><br><span class="line">            newIndirect.children[ni].Store(&amp;newEntry.node)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// idx相同</span></span><br><span class="line">        <span class="comment">// 把oldEntry向下挪动一层</span></span><br><span class="line">        nextIndirect := newIndirectNode(newIndirect)</span><br><span class="line">        newIndirect.children[oi].Store(&amp;nextIndirect.node)</span><br><span class="line">        newIndirect = nextIndirect</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回top节点</span></span><br><span class="line">    <span class="keyword">return</span> &amp;top.node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntryNode</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(key K, value V)</span></span> *entry[K, V] &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;entry[K, V]&#123;</span><br><span class="line">        node:  node[K, V]&#123;isEntry: <span class="literal">true</span>&#125;,</span><br><span class="line">        key:   key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>删除指定key，具体看LoadAndDelete</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Delete(key K) &#123;</span><br><span class="line">    _, _ = ht.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadAndDelete"><a href="#LoadAndDelete" class="headerlink" title="LoadAndDelete"></a>LoadAndDelete</h3><p>根据key获取value并删除该key，具体逻辑如下</p>
<ol>
<li>Load<ul>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，返回</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则纪录起来</li>
</ul>
</li>
<li>Delete<ul>
<li>纪录子节点位置的curr节点指针i和子节点指针slot、n</li>
<li>如果删除key后，叶子节点链表不为空，回写并返回</li>
<li>如果删除key后，叶子节点链表为空，从curr开始往上搜索删除空的节点</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> LoadAndDelete(key K) (value V, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key和value查找子节点，返回curr节点指针i、子节点索引idx、子节点指针slot、n</span></span><br><span class="line">    i, hashShift, slot, n := ht.find(key, hash, <span class="literal">nil</span>, *<span class="built_in">new</span>(V))</span><br><span class="line">    <span class="comment">// 子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 子节点被删除</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">            i.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点获取并删除指定key，返回旧值v、链表头e、是否成功获取loaded</span></span><br><span class="line">    v, e, loaded := n.entry().loadAndDelete(key)</span><br><span class="line">    <span class="comment">// 获取key失败</span></span><br><span class="line">    <span class="keyword">if</span> !loaded &#123;</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除key后，链表不为空</span></span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 回写</span></span><br><span class="line">        slot.Store(&amp;e.node)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除key后，链表为空，把叶子节点也删掉</span></span><br><span class="line">    slot.Store(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从curr开始往上搜索删除空的节点</span></span><br><span class="line">    <span class="comment">// curr节点的父节点不为nil and curr节点没有子节点</span></span><br><span class="line">    <span class="keyword">for</span> i.parent != <span class="literal">nil</span> &amp;&amp; i.empty() &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> hashShift == <span class="number">8</span>*goarch.PtrSize &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hashShift+=4</span></span><br><span class="line">        hashShift += nChildrenLog2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在父节点删除curr节点</span></span><br><span class="line">        parent := i.parent</span><br><span class="line">        parent.mu.Lock()</span><br><span class="line">        i.dead.Store(<span class="literal">true</span>)</span><br><span class="line">        parent.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask].Store(<span class="literal">nil</span>)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        i = parent</span><br><span class="line">    &#125;</span><br><span class="line">    i.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key和value查找子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> find(key K, hash <span class="type">uintptr</span>, valEqual equalFunc, value V) (i *indirect[K, V], hashShift <span class="type">uint</span>, slot *atomic.Pointer[node[K, V]], n *node[K, V]) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">        i = ht.root.Load()</span><br><span class="line">        hashShift = <span class="number">8</span> * goarch.PtrSize <span class="comment">// 64</span></span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 找到i和n</span></span><br><span class="line">        <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// hashShift-=4</span></span><br><span class="line">            hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">            slot = &amp;i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask]</span><br><span class="line">            n = slot.Load()</span><br><span class="line">            <span class="comment">// 子节点为nil</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">                i = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> n.isEntry &#123;</span><br><span class="line">                <span class="comment">// 根据key和value比对搜索</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := n.entry().lookupWithValue(key, value, valEqual); !ok &#123;</span><br><span class="line">                    i = <span class="literal">nil</span></span><br><span class="line">                    n = <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到了</span></span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = n.indirect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">if</span> !found &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到了</span></span><br><span class="line"></span><br><span class="line">        i.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        n = slot.Load()</span><br><span class="line">        <span class="comment">// 当前节点未删除</span></span><br><span class="line">        <span class="keyword">if</span> !i.dead.Load() &amp;&amp; (n == <span class="literal">nil</span> || n.isEntry) &#123;</span><br><span class="line">            <span class="comment">// 不管现在子节点是什么状态</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新扫描</span></span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key和value比对搜索</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry[K, V])</span></span> lookupWithValue(key K, value V, valEqual equalFunc) (V, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 比对key和value</span></span><br><span class="line">        <span class="keyword">if</span> e.key == key &amp;&amp; (valEqual == <span class="literal">nil</span> || valEqual(unsafe.Pointer(&amp;e.value), abi.NoEscape(unsafe.Pointer(&amp;value)))) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.value, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> loadAndDelete(key K) (V, *entry[K, V], <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> head.value, head.overflow.Load(), <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &#123;</span><br><span class="line">            <span class="comment">// 移除当前节点 =&gt; 使prev指向next</span></span><br><span class="line">            i.Store(e.overflow.Load())</span><br><span class="line">            <span class="keyword">return</span> e.value, head, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回零值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">new</span>(V), head, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点是否有children</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *indirect[K, V])</span></span> empty() <span class="type">bool</span> &#123;</span><br><span class="line">    nc := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> i.children &#123;</span><br><span class="line">        <span class="keyword">if</span> i.children[j].Load() != <span class="literal">nil</span> &#123;</span><br><span class="line">            nc++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nc == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndDelete"><a href="#CompareAndDelete" class="headerlink" title="CompareAndDelete"></a>CompareAndDelete</h3><p>根据key和value搜索，如找到则删除该数据，具体逻辑如下</p>
<ol>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，返回</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则删除</li>
<li>如果删除key后，叶子节点链表不为空，回写并返回</li>
<li>如果删除key后，叶子节点链表为空，从curr开始往上搜索删除空的节点</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> CompareAndDelete(key K, old V) (deleted <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// value对比函数不能为空 =&gt; 类型无法比对</span></span><br><span class="line">    <span class="keyword">if</span> ht.valEqual == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;called CompareAndDelete when value is not of comparable type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key和value查找子节点，返回curr节点指针i、子节点索引idx、子节点指针slot、n</span></span><br><span class="line">    i, hashShift, slot, n := ht.find(key, hash, <span class="literal">nil</span>, *<span class="built_in">new</span>(V))</span><br><span class="line">    <span class="comment">// 子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 被删除</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">            i.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点比对并删除指定key/value，返回链表头e、是否成功删除deleted</span></span><br><span class="line">    e, deleted := n.entry().compareAndDelete(key, old, ht.valEqual)</span><br><span class="line">    <span class="comment">// 删除失败</span></span><br><span class="line">    <span class="keyword">if</span> !deleted &#123;</span><br><span class="line">        <span class="comment">// Nothing was actually deleted, which means the node is no longer there.</span></span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除key后，链表不为空</span></span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 回写</span></span><br><span class="line">        slot.Store(&amp;e.node)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除key后，链表为空，把叶子节点也删掉</span></span><br><span class="line">    slot.Store(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从curr开始往上搜索删除空的节点</span></span><br><span class="line">    <span class="comment">// curr节点的父节点不为nil and curr节点没有子节点</span></span><br><span class="line">    <span class="keyword">for</span> i.parent != <span class="literal">nil</span> &amp;&amp; i.empty() &#123;</span><br><span class="line">        <span class="keyword">if</span> hashShift == <span class="number">8</span>*goarch.PtrSize &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hashShift+=4</span></span><br><span class="line">        hashShift += nChildrenLog2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在父节点中删除当前节点</span></span><br><span class="line">        parent := i.parent</span><br><span class="line">        parent.mu.Lock()</span><br><span class="line">        i.dead.Store(<span class="literal">true</span>)</span><br><span class="line">        parent.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask].Store(<span class="literal">nil</span>)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        i = parent</span><br><span class="line">    &#125;</span><br><span class="line">    i.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> compareAndDelete(key K, value V, valEqual equalFunc) (*entry[K, V], <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;head.value), abi.NoEscape(unsafe.Pointer(&amp;value))) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.overflow.Load(), <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;e.value), abi.NoEscape(unsafe.Pointer(&amp;value))) &#123;</span><br><span class="line">            <span class="comment">// 移除当前节点 =&gt; prev指向next</span></span><br><span class="line">            i.Store(e.overflow.Load())</span><br><span class="line">            <span class="keyword">return</span> head, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>用新的value替换旧的value，具体逻辑如下</p>
<ol>
<li>查找可替换key的位置<ul>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点为nil或叶子节点，且当前节点未被删除，纪录位置信息，结束查找</li>
</ul>
</li>
<li>替换value<ul>
<li>如果子节点是叶子节点，在链表查找并替换value，替换成功回写并返回</li>
<li>如果子节点是nil<ul>
<li>如果slot为空，直接写入</li>
<li>如果slot不为空，放进链表，或者分裂后再存储进children</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Swap(key K, <span class="built_in">new</span> V) (previous V, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i *indirect[K, V]                   <span class="comment">// curr节点指针，从根节点开始</span></span><br><span class="line">    <span class="keyword">var</span> hashShift <span class="type">uint</span>                      <span class="comment">// 用于计算idx</span></span><br><span class="line">    <span class="keyword">var</span> slot *atomic.Pointer[node[K, V]]    <span class="comment">// 子节点指针的指针</span></span><br><span class="line">    <span class="keyword">var</span> n *node[K, V]                       <span class="comment">// 子节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 查找可替换key的位置</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">        i = ht.root.Load()</span><br><span class="line">        <span class="comment">// hashShift=64 =&gt; 64/4=16，整个trie最多有16层</span></span><br><span class="line">        hashShift = <span class="number">8</span> * goarch.PtrSize</span><br><span class="line">        <span class="comment">// 当前循环是否已经找到写入点</span></span><br><span class="line">        haveInsertPoint := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// hashShift-=4</span></span><br><span class="line">            hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取子节点指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">            slot = &amp;i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask]</span><br><span class="line">            n = slot.Load()</span><br><span class="line">            <span class="comment">// 子节点为nil或叶子节点，可替换，结束循环</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> || n.isEntry &#123;</span><br><span class="line">                haveInsertPoint = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = n.indirect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> !haveInsertPoint &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        i.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        n = slot.Load()</span><br><span class="line">        <span class="comment">// 子节点为nil或叶子节点 and 当前节点未删除</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nil</span> || n.isEntry) &amp;&amp; !i.dead.Load() &#123;</span><br><span class="line">            <span class="comment">// 确认可替换，slot查找结束</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 替换value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在for循环里已经加锁了</span></span><br><span class="line">    <span class="keyword">defer</span> i.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> zero V</span><br><span class="line">    <span class="keyword">var</span> oldEntry *entry[K, V]</span><br><span class="line">    <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 替换value</span></span><br><span class="line">        oldEntry = n.entry()</span><br><span class="line">        newEntry, old, swapped := oldEntry.swap(key, <span class="built_in">new</span>)</span><br><span class="line">        <span class="keyword">if</span> swapped &#123;</span><br><span class="line">            <span class="comment">// 替换成功，回写</span></span><br><span class="line">            slot.Store(&amp;newEntry.node)</span><br><span class="line">            <span class="keyword">return</span> old, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建叶子节点</span></span><br><span class="line">    newEntry := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">    <span class="comment">// 原子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> oldEntry == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接存储</span></span><br><span class="line">        slot.Store(&amp;newEntry.node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 原子节点为叶子节点</span></span><br><span class="line">        <span class="comment">// 放进链表，或者分裂后再存储进children</span></span><br><span class="line">        slot.Store(ht.expand(oldEntry, newEntry, hash, hashShift, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zero, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> swap(key K, <span class="built_in">new</span> V) (*entry[K, V], V, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &#123;</span><br><span class="line">        <span class="comment">// 替换entry</span></span><br><span class="line">        e := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">        <span class="keyword">if</span> chain := head.overflow.Load(); chain != <span class="literal">nil</span> &#123;</span><br><span class="line">            e.overflow.Store(chain)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e, head.value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &#123;</span><br><span class="line">            <span class="comment">// 替换当前节点</span></span><br><span class="line">            eNew := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">            eNew.overflow.Store(e.overflow.Load())</span><br><span class="line">            i.Store(eNew)</span><br><span class="line">            <span class="keyword">return</span> head, e.value, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回零值</span></span><br><span class="line">    <span class="keyword">var</span> zero V</span><br><span class="line">    <span class="keyword">return</span> head, zero, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h3><p>根据key和value搜索，如找到则用新的value替换旧的value，具体逻辑如下</p>
<ol>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，返回</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则替换</li>
<li>替换失败，直接返回；替换成功，回写并返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> CompareAndSwap(key K, old, <span class="built_in">new</span> V) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// value对比函数不能为空 =&gt; 类型无法比对</span></span><br><span class="line">    <span class="keyword">if</span> ht.valEqual == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;called CompareAndSwap when value is not of comparable type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key和value查找子节点，返回curr节点指针i、子节点索引idx、子节点指针slot、n</span></span><br><span class="line">    i, _, slot, n := ht.find(key, hash, ht.valEqual, old)</span><br><span class="line">    <span class="keyword">if</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点搜索并替换指定key/value，返回链表头e、是否成功交换swapped</span></span><br><span class="line">    e, swapped := n.entry().compareAndSwap(key, old, <span class="built_in">new</span>, ht.valEqual)</span><br><span class="line">    <span class="comment">// 替换失败</span></span><br><span class="line">    <span class="keyword">if</span> !swapped &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功，回写</span></span><br><span class="line">    slot.Store(&amp;e.node)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> compareAndSwap(key K, old, <span class="built_in">new</span> V, valEqual equalFunc) (*entry[K, V], <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;head.value), abi.NoEscape(unsafe.Pointer(&amp;old))) &#123;</span><br><span class="line">        e := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">        <span class="keyword">if</span> chain := head.overflow.Load(); chain != <span class="literal">nil</span> &#123;</span><br><span class="line">            e.overflow.Store(chain)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;e.value), abi.NoEscape(unsafe.Pointer(&amp;old))) &#123;</span><br><span class="line">            <span class="comment">// 替换当前节点</span></span><br><span class="line">            eNew := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">            eNew.overflow.Store(e.overflow.Load())</span><br><span class="line">            i.Store(eNew)</span><br><span class="line">            <span class="keyword">return</span> head, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>遍历整个HashTrieMap，逻辑如下</p>
<ol>
<li>从根节点开始遍历children</li>
<li>子节点为nil，跳过</li>
<li>子节点不是叶子节点，递归遍历children</li>
<li>子节点是叶子节点，遍历整个链表<ul>
<li>key&#x2F;value传递给用户自定义函数，失败中断整个遍历</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Range(yield <span class="function"><span class="keyword">func</span><span class="params">(K, V)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 遍历，从根节点开始</span></span><br><span class="line">    ht.iter(ht.root.Load(), yield)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> iter(i *indirect[K, V], yield <span class="function"><span class="keyword">func</span><span class="params">(key K, value V)</span></span> <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> i.children &#123;</span><br><span class="line">        n := i.children[j].Load()</span><br><span class="line">        <span class="comment">// 子节点为nil，继续下一个</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子节点不是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> !n.isEntry &#123;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="keyword">if</span> !ht.iter(n.indirect(), yield) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        e := n.entry()</span><br><span class="line">        <span class="comment">// 扫描整个链表</span></span><br><span class="line">        <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，中断遍历</span></span><br><span class="line">            <span class="keyword">if</span> !yield(e.key, e.value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            e = e.overflow.Load()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="All"><a href="#All" class="headerlink" title="All"></a>All</h3><p>封装Range方法并返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> All() <span class="function"><span class="keyword">func</span><span class="params">(yield <span class="keyword">func</span>(K, V)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 把Range方法封装在一个函数里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(yield <span class="keyword">func</span>(key K, value V)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">        ht.iter(ht.root.Load(), yield)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h3><p>清空整个HashTrieMap，直接用新的nil节点更新root</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Clear() &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接用新的节点替换root</span></span><br><span class="line">    ht.root.Store(newIndirectNode[K, V](<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-swiss map</title>
    <url>/golang-series-map-swiss/</url>
    <content><![CDATA[<p>map&#x2F;哈希表，是golang常用的数据结构之一，也充当set数据结构的存在，相对slice要复杂很多。从1.24开始，swiss table替代noswiss成为默认实现，swiss与noswiss区别在于，swiss使用开放地址法，noswiss使用拉链法</p>
<p>当前go版本：1.24</p>
<blockquote>
<p>swiss map的开关放在文件<code>src/internal/buildcfg/exp.go</code>的函数<code>ParseGOEXPERIMENT</code>中</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// table-groups是二维数组，算上slot的话是三维</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// map_header -&gt; table1 -&gt; group1(8个slot)</span></span><br><span class="line"><span class="comment">//                      -&gt; group2</span></span><br><span class="line"><span class="comment">//                      ...</span></span><br><span class="line"><span class="comment">//                      -&gt; group127</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//            -&gt; table2</span></span><br><span class="line"><span class="comment">//            -&gt; ...</span></span><br><span class="line"><span class="comment">//            -&gt; tableN</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当hint&lt;=8时，map_header直接指向一个group，全量扫描操作</span></span><br><span class="line"><span class="comment">// 当hint&gt;8 and hint&lt;=1024*7/8时，一个table，2~128个group</span></span><br><span class="line"><span class="comment">// 当hint&gt;1024*7/8时，多个table，多个group</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// hash高B位 - 用于定位table</span></span><br><span class="line"><span class="comment">// h1-hash高57位 - 用于定位group</span></span><br><span class="line"><span class="comment">// h2-hash低7位 - 用于匹配hash，类似tophash</span></span><br></pre></td></tr></table></figure>

<p>核心数据结构包括Map、table、groupsReference、groupReference，具体如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    used <span class="type">uint64</span>            <span class="comment">// 已用slot，当数据量&lt;=8时用来替换table的used使用</span></span><br><span class="line">    seed <span class="type">uintptr</span>           <span class="comment">// 哈希函数种子</span></span><br><span class="line">    dirPtr unsafe.Pointer  <span class="comment">// table数组指针/group指针</span></span><br><span class="line">    dirLen <span class="type">int</span>             <span class="comment">// table数组大小</span></span><br><span class="line">    globalDepth <span class="type">uint8</span>      <span class="comment">// log2(dirLen)（相当于旧版的B）</span></span><br><span class="line">    globalShift <span class="type">uint8</span>      <span class="comment">// 64-globalDepth，高B位用做table的索引</span></span><br><span class="line">    writing <span class="type">uint8</span>          <span class="comment">// 是否正在写入，乐观锁</span></span><br><span class="line">    clearSeq <span class="type">uint64</span>        <span class="comment">// 执行过多少次clear，扩容时，获取数据判断用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="keyword">type</span> table <span class="keyword">struct</span> &#123;</span><br><span class="line">    used <span class="type">uint16</span>            <span class="comment">// 已用slot，最多能写入1024*7/8=896个slot</span></span><br><span class="line">    capacity <span class="type">uint16</span>        <span class="comment">// slot容量 &lt;=1024（由hint算出，2的乘方向上取整）</span></span><br><span class="line">    growthLeft <span class="type">uint16</span>      <span class="comment">// 可用slot，与used相反，初始值最大为896</span></span><br><span class="line">    localDepth <span class="type">uint8</span>       <span class="comment">// &gt;globalDepth？分裂/遍历时使用</span></span><br><span class="line">    index <span class="type">int</span>              <span class="comment">// 上层directory数组中的index（-1-过期，作用类似localDepth）</span></span><br><span class="line">    groups groupsReference <span class="comment">// group数组，8个slot为一组，最多1024/8=128组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/group.go</span></span><br><span class="line"><span class="keyword">type</span> groupsReference <span class="keyword">struct</span> &#123;</span><br><span class="line">    data unsafe.Pointer    <span class="comment">// group数组，8个slot为一组，具体结构看下方</span></span><br><span class="line">    lengthMask <span class="type">uint64</span>      <span class="comment">// 长度固定为2^N，因此mask=2^N-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> groupReference <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 结构如下</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// type group struct &#123;</span></span><br><span class="line">    <span class="comment">//     ctrls ctrlGroup                    // 8个8bit的ctrl，共三种状态</span></span><br><span class="line">    <span class="comment">//     slots [abi.SwissMapGroupSlots]slot // 8个slot(key/value对)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 三种状态如下：</span></span><br><span class="line">    <span class="comment">//      empty: 1 0 0 0 0 0 0 0</span></span><br><span class="line">    <span class="comment">//    deleted: 1 1 1 1 1 1 1 0</span></span><br><span class="line">    <span class="comment">//       full: 0 h h h h h h h  // h represents the H2 hash bits</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// type slot struct &#123;</span></span><br><span class="line">    <span class="comment">//     key  typ.Key  // 键</span></span><br><span class="line">    <span class="comment">//     elem typ.Elem // 值</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    data unsafe.Pointer <span class="comment">// ctrls数组+slots数组</span></span><br><span class="line">    <span class="comment">// 内存布局如下（C语言开发者真的很喜欢这种内存布局啊）</span></span><br><span class="line">    <span class="comment">// | ctrls         | slots         |</span></span><br><span class="line">    <span class="comment">// |ctrl7|...|ctrl0|slot0|...|slot7|</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量初始化调用的是maplit，具体看代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/walk/complit.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maplit</span><span class="params">(n *ir.CompLitExpr, m ir.Node, init *ir.Nodes)</span></span> &#123;</span><br><span class="line">    args := []ir.Node&#123;ir.TypeNode(n.Type()), ir.NewInt(base.Pos, n.Len+<span class="type">int64</span>(<span class="built_in">len</span>(n.List)))&#125;</span><br><span class="line">    a := typecheck.Expr(ir.NewCallExpr(base.Pos, ir.OMAKE, <span class="literal">nil</span>, args)).(*ir.MakeExpr)</span><br><span class="line">    a.RType = n.RType</span><br><span class="line">    a.SetEsc(n.Esc())</span><br><span class="line">    appendWalkStmt(init, ir.NewAssignStmt(base.Pos, m, a))</span><br><span class="line"></span><br><span class="line">    entries := n.List</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> entries &#123;</span><br><span class="line">        r := r.(*ir.KeyExpr)</span><br><span class="line">        <span class="keyword">if</span> !isStaticCompositeLiteral(r.Key) || !isStaticCompositeLiteral(r.Value) &#123;</span><br><span class="line">            base.Fatalf(<span class="string">&quot;maplit: entry is not a literal: %v&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(entries) &gt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// loop adding structure elements to map</span></span><br><span class="line">        <span class="comment">// for i = 0; i &lt; len(vstatk); i++ &#123;</span></span><br><span class="line">        <span class="comment">//    map[vstatk[i]] = vstate[i]</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，如果小于等于25个元素，直接赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>如果，大于25个元素，分key&#x2F;value两组，使用for循环进行赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstatk); i++ &#123;</span><br><span class="line">    <span class="keyword">map</span>[vstatk[i]] = vstate[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>当使用make关键字初始化map时，调用的是makemap，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *abi.SwissMapType, hint <span class="type">int</span>, m *maps.Map)</span></span> *maps.Map &#123;</span><br><span class="line">    <span class="keyword">if</span> hint &lt; <span class="number">0</span> &#123;</span><br><span class="line">        hint = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maps.NewMap(t, <span class="type">uintptr</span>(hint), m, maxAlloc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMap</span><span class="params">(mt *abi.SwissMapType, hint <span class="type">uintptr</span>, m *Map, maxAlloc <span class="type">uintptr</span>)</span></span> *Map &#123;</span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> &#123;</span><br><span class="line">        m = <span class="built_in">new</span>(Map)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希种子</span></span><br><span class="line">    m.seed = <span class="type">uintptr</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hint&lt;=8</span></span><br><span class="line">    <span class="keyword">if</span> hint &lt;= abi.SwissMapGroupSlots &#123;</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// capacity = hint*8/7 =&gt; 每个group最多容纳7个slot，不能直接按hint计算group数量</span></span><br><span class="line">    targetCapacity := (hint * abi.SwissMapGroupSlots) / maxAvgGroupLoad</span><br><span class="line">    <span class="keyword">if</span> targetCapacity &lt; hint &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirSize = (capacity+1024-1)/1024 =&gt; table数量 =&gt; 一个table=128个group=1024个slot</span></span><br><span class="line">    dirSize := (<span class="type">uint64</span>(targetCapacity) + maxTableCapacity - <span class="number">1</span>) / maxTableCapacity</span><br><span class="line">    <span class="comment">// 2的乘方向上取整，如dirSize=40? =&gt; dirSize=64</span></span><br><span class="line">    dirSize, overflow := alignUpPow2(dirSize)</span><br><span class="line">    <span class="comment">// overflow?</span></span><br><span class="line">    <span class="keyword">if</span> overflow || dirSize &gt; <span class="type">uint64</span>(math.MaxUintptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reject hints that are obviously too large.</span></span><br><span class="line">    <span class="comment">// ngroup = dirSize*1024</span></span><br><span class="line">    groups, overflow := math.MulUintptr(<span class="type">uintptr</span>(dirSize), maxTableCapacity)</span><br><span class="line">    <span class="keyword">if</span> overflow &#123;</span><br><span class="line">        <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ngroup*GroupSize overflow?</span></span><br><span class="line">        mem, overflow := math.MulUintptr(groups, mt.GroupSize)</span><br><span class="line">        <span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">            <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// globalDepth = 二进制数dirSize末尾有多少个0 =&gt; 2^globalDepth=dirSize</span></span><br><span class="line">    m.globalDepth = <span class="type">uint8</span>(sys.TrailingZeros64(dirSize))</span><br><span class="line">    <span class="comment">// globalShift = 64-globalDepth</span></span><br><span class="line">    m.globalShift = depthToShift(m.globalDepth)</span><br><span class="line"></span><br><span class="line">    directory := <span class="built_in">make</span>([]*table, dirSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建table</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> directory &#123;</span><br><span class="line">        <span class="comment">// (type, a/b, i, d)</span></span><br><span class="line">        <span class="comment">// capacity = a/b &lt;= 1024</span></span><br><span class="line">        directory[i] = newTable(mt, <span class="type">uint64</span>(targetCapacity)/dirSize, i, m.globalDepth)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m.dirPtr = unsafe.Pointer(&amp;directory[<span class="number">0</span>])</span><br><span class="line">    m.dirLen = <span class="built_in">len</span>(directory) <span class="comment">// 为什么不能直接用dirSize？</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="comment">// 创建table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTable</span><span class="params">(typ *abi.SwissMapType, capacity <span class="type">uint64</span>, index <span class="type">int</span>, localDepth <span class="type">uint8</span>)</span></span> *table &#123;</span><br><span class="line">    <span class="comment">// capacity最小值为8</span></span><br><span class="line">    <span class="keyword">if</span> capacity &lt; abi.SwissMapGroupSlots &#123;</span><br><span class="line">        capacity = abi.SwissMapGroupSlots</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t := &amp;table&#123;</span><br><span class="line">        index:      index,      <span class="comment">// 上层directory数组中的index</span></span><br><span class="line">        localDepth: localDepth, <span class="comment">// &lt;= globalDepth</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;1024 =&gt; 异常</span></span><br><span class="line">    <span class="keyword">if</span> capacity &gt; maxTableCapacity &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;initial table capacity too large&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2的乘方向上取整</span></span><br><span class="line">    capacity, overflow := alignUpPow2(capacity)</span><br><span class="line">    <span class="keyword">if</span> overflow &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;rounded-up capacity overflows uint64&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建groups</span></span><br><span class="line">    t.reset(typ, <span class="type">uint16</span>(capacity))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要职责 =&gt; 创建groups</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> reset(typ *abi.SwissMapType, capacity <span class="type">uint16</span>) &#123;</span><br><span class="line">    <span class="comment">// 8个slot为一组，最多1024/8=128组</span></span><br><span class="line">    groupCount := <span class="type">uint64</span>(capacity) / abi.SwissMapGroupSlots</span><br><span class="line">    <span class="comment">// 创建groups</span></span><br><span class="line">    t.groups = newGroups(typ, groupCount)</span><br><span class="line">    t.capacity = capacity</span><br><span class="line">    <span class="comment">// 根据capacity重置growthLeft字段</span></span><br><span class="line">    t.resetGrowthLeft()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于for i, g := range t.groups </span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">        g := t.groups.group(typ, i)</span><br><span class="line">        <span class="comment">// 每组有8个slot，每个slot对应的ctrl都设置为empty =&gt; 0b10000000</span></span><br><span class="line">        g.ctrls().setEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置table的growthLeft字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> resetGrowthLeft() &#123;</span><br><span class="line">    <span class="keyword">var</span> growthLeft <span class="type">uint16</span></span><br><span class="line">    <span class="keyword">if</span> t.capacity == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 1. capacity不能为0</span></span><br><span class="line">        <span class="comment">// No real reason to support zero capacity table, since an</span></span><br><span class="line">        <span class="comment">// empty Map simply won&#x27;t have a table.</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;table must have positive capacity&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.capacity &lt;= abi.SwissMapGroupSlots &#123;</span><br><span class="line">        <span class="comment">// 2. capacity &lt;= 8</span></span><br><span class="line">        <span class="comment">// If the map fits in a single group then we&#x27;re able to fill all of</span></span><br><span class="line">        <span class="comment">// the slots except 1 (an empty slot is needed to terminate find</span></span><br><span class="line">        <span class="comment">// operations).</span></span><br><span class="line">        growthLeft = t.capacity - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. capacity &gt; 8</span></span><br><span class="line">        <span class="comment">// capacity*7 &lt; capacity？</span></span><br><span class="line">        <span class="keyword">if</span> t.capacity*maxAvgGroupLoad &lt; t.capacity &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;overflow&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// growthLeft = capacity*7/8</span></span><br><span class="line">        growthLeft = (t.capacity * maxAvgGroupLoad) / abi.SwissMapGroupSlots</span><br><span class="line">    &#125;</span><br><span class="line">    t.growthLeft = growthLeft</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/group.go</span></span><br><span class="line"><span class="comment">// length =&gt; 2^N</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGroups</span><span class="params">(typ *abi.SwissMapType, length <span class="type">uint64</span>)</span></span> groupsReference &#123;</span><br><span class="line">    <span class="keyword">return</span> groupsReference&#123;</span><br><span class="line">        data:       newarray(typ.Group, <span class="type">int</span>(length)), <span class="comment">// 申请一片内存</span></span><br><span class="line">        lengthMask: length - <span class="number">1</span>, <span class="comment">// 2^N-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// group=8*ctrl+8*slot</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *groupsReference)</span></span> group(typ *abi.SwissMapType, i <span class="type">uint64</span>) groupReference &#123;</span><br><span class="line">    offset := <span class="type">uintptr</span>(i) * typ.GroupSize</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> groupReference&#123;</span><br><span class="line">        data: unsafe.Pointer(<span class="type">uintptr</span>(g.data) + offset),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对旧版，新版的逻辑看起来会复杂一些，大概的逻辑如下</p>
<ol>
<li>如果hint的数量不超过8，生成map header返回</li>
<li>如果hint的数量超过8<ul>
<li>新版map只能容纳7&#x2F;8的数据量，因此需要根据公式<code>hint*8/7</code>重新计算容量</li>
<li>根据容量计算table数量、group数量，基本都是2的乘方向上取整</li>
<li>生成table数组、group数组</li>
<li>map header、table、group等参数初始化</li>
</ul>
</li>
</ol>
<p>globalDepth、globalShift一部份数据示例如下</p>
<table>
<thead>
<tr>
<th align="left">dirSize(10)</th>
<th align="left">dirSize(2)</th>
<th align="left">globalDepth</th>
<th align="left">globalShift</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">0001</td>
<td align="left">0</td>
<td align="left">64</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">0010</td>
<td align="left">1</td>
<td align="left">63</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">0100</td>
<td align="left">2</td>
<td align="left">62</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">1000</td>
<td align="left">3</td>
<td align="left">61</td>
</tr>
</tbody></table>
<p>其他：</p>
<ol>
<li>table数量、group数量固定为2的乘方</li>
<li>table最大容量&#x3D;1024个slot&#x3D;128个group</li>
<li>group最大容量&#x3D;8个slot</li>
</ol>
<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>swiss table使用二次探测法法用于定位group，而终止扫描依赖group的ctrls字段，只要该字段中有一个处于empty状态，立即终止扫描，具体通过probeSeq实现</p>
<p>使用的二次探测法公式为：<code>p(i) := (i^2 + i)/2 + hash (mod mask+1)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// quadratic probing - 二次探测法</span></span><br><span class="line"><span class="keyword">type</span> probeSeq <span class="keyword">struct</span> &#123;</span><br><span class="line">    mask   <span class="type">uint64</span> <span class="comment">// groups数组的索引的最大值=2^N-1</span></span><br><span class="line">    offset <span class="type">uint64</span> <span class="comment">// groups数组索引（取hash的低N位）</span></span><br><span class="line">    index  <span class="type">uint64</span> <span class="comment">// 扫描计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeProbeSeq</span><span class="params">(hash <span class="type">uintptr</span>, mask <span class="type">uint64</span>)</span></span> probeSeq &#123;</span><br><span class="line">    <span class="keyword">return</span> probeSeq&#123;</span><br><span class="line">        mask:   mask,</span><br><span class="line">        offset: <span class="type">uint64</span>(hash) &amp; mask,</span><br><span class="line">        index:  <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s probeSeq)</span></span> next() probeSeq &#123;</span><br><span class="line">    s.index++</span><br><span class="line">    <span class="comment">// 从offset的位置开始循环groups数组扫描</span></span><br><span class="line">    <span class="comment">// 保证不超过groups数组的最大索引</span></span><br><span class="line">    <span class="comment">// p(i) := (i^2 + i)/2 + hash (mod mask+1)</span></span><br><span class="line">    s.offset = (s.offset + s.index) &amp; s.mask</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>probeSeq的使用示例如下，其中offset是group的定位索引，看起来还是比较均匀的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">seq := makeProbeSeq(<span class="number">12345678</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, seq)</span><br><span class="line">    seq = seq.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:6 index:0&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:7 index:1&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:1 index:2&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:4 index:3&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:0 index:4&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:5 index:5&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:3 index:6&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:2 index:7&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:2 index:8&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:3 index:9&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h3><p>使用索引获取map的数值有两种</p>
<ol>
<li>仅接受一个参数</li>
<li>接受两个参数</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅接受一个参数</span></span><br><span class="line">v := h[key]</span><br><span class="line"><span class="comment">// 接受两个参数</span></span><br><span class="line">v, ok := h[key]</span><br></pre></td></tr></table></figure>

<p>当仅接受一个参数时，底层使用runtime_mapaccess1，当接受两个参数时，底层使用runtime_mapaccess2，其与runtime_mapaccess1只有返回值的不同</p>
<p>这里的runtime_mapaccess1逻辑与Get方法相似，因此只介绍maps包的接口方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/maps/runtime_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_mapaccess1</span><span class="params">(typ *abi.SwissMapType, m *Map, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_mapaccess2</span><span class="params">(typ *abi.SwissMapType, m *Map, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Get(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m.getWithoutKey(typ, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回key、value指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> getWithKey(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 无数据</span></span><br><span class="line">    <span class="keyword">if</span> m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个table一个group，数据量&lt;8</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.getWithKeySmall(typ, hash, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">    idx := m.directoryIndex(hash)</span><br><span class="line">    <span class="comment">// 找到table再找group最后找slot</span></span><br><span class="line">    <span class="keyword">return</span> m.directoryAt(idx).getWithKey(typ, hash, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回value指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> getWithoutKey(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 无数据</span></span><br><span class="line">    <span class="keyword">if</span> m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个table一个group，数据量&lt;8</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        _, elem, ok := m.getWithKeySmall(typ, hash, key)</span><br><span class="line">        <span class="keyword">return</span> elem, ok</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">    idx := m.directoryIndex(hash)</span><br><span class="line">    <span class="comment">// 找到table再找group最后找slot</span></span><br><span class="line">    <span class="keyword">return</span> m.directoryAt(idx).getWithoutKey(typ, hash, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据量小于等于8时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> getWithKeySmall(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 只有一个table一个group</span></span><br><span class="line">    <span class="comment">// table.groups不是第一个字段也能cast？</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取哈希值低7位</span></span><br><span class="line">    h2 := <span class="type">uint8</span>(h2(hash))</span><br><span class="line">    <span class="comment">// data的前64位为ctrls</span></span><br><span class="line">    ctrls := *g.ctrls()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8个slot</span></span><br><span class="line">    <span class="comment">// |ctrl7|...|ctrl0|slot0|...|slot7|</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.SwissMapGroupSlots; i++ &#123;</span><br><span class="line">        <span class="comment">// ctrls从后往前扫描，但i从0开始</span></span><br><span class="line">        c := <span class="type">uint8</span>(ctrls)</span><br><span class="line">        ctrls &gt;&gt;= <span class="number">8</span></span><br><span class="line">        <span class="keyword">if</span> c != h2 &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slot从前往后扫描</span></span><br><span class="line">        <span class="comment">// key</span></span><br><span class="line">        slotKey := g.key(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value</span></span><br><span class="line">        <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slotKey, slotElem, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是table相关</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> getWithKey(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">        match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match不为0，至少找到一个（假阳性）</span></span><br><span class="line">        <span class="comment">// |ctrl7|...|ctrl0|slot0|...|slot7|</span></span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            <span class="comment">// 看样子同一个i会被用很多次</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">                slotElem := g.elem(typ, i)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slotKey, slotElem, <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">            match = match.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmpty将非empty的ctrl全部置为0，如果8个ctrl都有数据，如full或者deleted状态，那么match=0</span></span><br><span class="line">        match = g.ctrls().matchEmpty()</span><br><span class="line">        <span class="keyword">if</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Finding an empty slot means we&#x27;ve reached the end of</span></span><br><span class="line">            <span class="comment">// the probe sequence.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与getWithKey相同，只有返回值不同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> getWithoutKey(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历访问"><a href="#遍历访问" class="headerlink" title="遍历访问"></a>遍历访问</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用for range遍历整个map时，依赖Iter数据结构实现该操作，大概过程如下</p>
<ol>
<li>创建Iter，纪录map的快照信息、生成随机数作为table、slot的索引偏移</li>
<li>调用Next方法，获取并存储第一个key&#x2F;value地址</li>
<li>上层函数继续调用Next方法，获取并存储下一个key&#x2F;value地址，或者主动退出循环</li>
</ol>
<p>注意：如果发生了扩容，iter.tab的index显示是已过时，需要从旧的table获取key，从新的table获取新的key&#x2F;value</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Iter <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  unsafe.Pointer     <span class="comment">// key指针 为nil结束遍历</span></span><br><span class="line">    elem unsafe.Pointer     <span class="comment">// value指针</span></span><br><span class="line">    typ  *abi.SwissMapType  <span class="comment">// 类型</span></span><br><span class="line">    m    *Map               <span class="comment">// map指针</span></span><br><span class="line">    entryOffset <span class="type">uint64</span>      <span class="comment">// slot计数器的偏移量（随机）</span></span><br><span class="line">    dirOffset   <span class="type">uint64</span>      <span class="comment">// table索引初始偏移（随机） -&gt; head</span></span><br><span class="line">    clearSeq <span class="type">uint64</span>         <span class="comment">// 执行过多少次clear</span></span><br><span class="line">    globalDepth <span class="type">uint8</span>       <span class="comment">// log2(dirLen)（相当于以前的B）</span></span><br><span class="line">    dirIdx <span class="type">int</span>              <span class="comment">// table索引 -&gt; curr</span></span><br><span class="line">    tab *table              <span class="comment">// table指针，不同dirIdx可以指向同一个tab</span></span><br><span class="line">    group groupReference    <span class="comment">// group指针</span></span><br><span class="line">    entryIdx <span class="type">uint64</span>         <span class="comment">// 整个table的slot计数器 [0,1023]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapIterStart</span><span class="params">(t *abi.SwissMapType, m *maps.Map, it *maps.Iter)</span></span> &#123;</span><br><span class="line">    it.Init(t, m)</span><br><span class="line">    it.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> Init(typ *abi.SwissMapType, m *Map) &#123;</span><br><span class="line">    it.typ = typ</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> || m.used == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    dirIdx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> groupSmall groupReference</span><br><span class="line">    <span class="comment">// 只有一个table一个group，数据量&lt;8</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Use dirIdx == -1 as sentinel for small maps.</span></span><br><span class="line">        dirIdx = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">        groupSmall.data = m.dirPtr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it.m = m</span><br><span class="line">    it.entryOffset = rand()        <span class="comment">// slot索引初始偏移</span></span><br><span class="line">    it.dirOffset = rand()          <span class="comment">// table索引初始偏移</span></span><br><span class="line">    it.globalDepth = m.globalDepth <span class="comment">// 2^B个table</span></span><br><span class="line">    it.dirIdx = dirIdx             <span class="comment">// 0-默认 -1-small map</span></span><br><span class="line">    it.group = groupSmall          <span class="comment">// nil-默认 否则 small map</span></span><br><span class="line">    it.clearSeq = m.clearSeq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapIterNext</span><span class="params">(it *maps.Iter)</span></span> &#123;</span><br><span class="line">    it.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> Next() &#123;</span><br><span class="line">    <span class="comment">// 空map，直接终止</span></span><br><span class="line">    <span class="keyword">if</span> it.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        it.key = <span class="literal">nil</span></span><br><span class="line">        it.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> it.m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. small map ，单个group</span></span><br><span class="line">    <span class="keyword">if</span> it.dirIdx &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有slot，从entryOffset开始</span></span><br><span class="line">        <span class="keyword">for</span> ; it.entryIdx &lt; abi.SwissMapGroupSlots; it.entryIdx++ &#123;</span><br><span class="line">            k := <span class="type">uintptr</span>(it.entryIdx+it.entryOffset) % abi.SwissMapGroupSlots</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除的或空的slot？跳过（small map删除直接设置为empty）</span></span><br><span class="line">            <span class="keyword">if</span> (it.group.ctrls().get(k) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            key := it.group.key(it.typ, k)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            grown := it.m.dirLen &gt; <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">            <span class="comment">// 还在扩容中</span></span><br><span class="line">            <span class="keyword">if</span> grown &#123;</span><br><span class="line">                <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">                <span class="comment">// 从扩容后的map获取</span></span><br><span class="line">                newKey, newElem, ok := it.m.getWithKey(it.typ, key)</span><br><span class="line">                <span class="comment">// 找不到</span></span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">// key是NaN</span></span><br><span class="line">                    <span class="comment">// NaN无法被update/delete，只能clear，如果很幸运，没有clear过，那么可以从旧的table里拿到数据</span></span><br><span class="line">                    <span class="comment">// 详细可以看grownKeyElem注释</span></span><br><span class="line">                    <span class="keyword">if</span> it.clearSeq == it.m.clearSeq &amp;&amp; !it.typ.Key.Equal(key, key) &#123;</span><br><span class="line">                        elem = it.group.elem(it.typ, k)</span><br><span class="line">                        <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                            elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 被删除了</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 按新的key/value为准</span></span><br><span class="line">                    key = newKey</span><br><span class="line">                    elem = newElem</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有扩容</span></span><br><span class="line">                elem = it.group.elem(it.typ, k)</span><br><span class="line">                <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新iter，方便下次调用</span></span><br><span class="line">            it.entryIdx++  <span class="comment">// [0,1023]</span></span><br><span class="line">            it.key = key   <span class="comment">// 上层读取数据用</span></span><br><span class="line">            it.elem = elem <span class="comment">// 上层读取数据用</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经扫描完所有slot</span></span><br><span class="line">        it.key = <span class="literal">nil</span></span><br><span class="line">        it.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 常规map</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果map在iter的过程中分裂了</span></span><br><span class="line">    <span class="keyword">if</span> it.globalDepth != it.m.globalDepth &#123;</span><br><span class="line">        <span class="comment">// Consider:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Before:</span></span><br><span class="line">        <span class="comment">// - 0: *t1</span></span><br><span class="line">        <span class="comment">// - 1: *t2  &lt;- dirIdx</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// After:</span></span><br><span class="line">        <span class="comment">// - 0: *t1a (split)</span></span><br><span class="line">        <span class="comment">// - 1: *t1b (split)</span></span><br><span class="line">        <span class="comment">// - 2: *t2  &lt;- dirIdx</span></span><br><span class="line">        <span class="comment">// - 3: *t2</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// dirIdx*(2^分裂次数)即可指向正确的table</span></span><br><span class="line">        <span class="comment">// 具体公式如下</span></span><br><span class="line">        <span class="comment">// dirIdx := (it.dirIdx + it.dirOffset) % it.m.dirLen</span></span><br><span class="line">        <span class="comment">// 需要保证结果为正</span></span><br><span class="line">        orders := it.m.globalDepth - it.globalDepth <span class="comment">// 分裂次数</span></span><br><span class="line">        it.dirIdx &lt;&lt;= orders    <span class="comment">// 2^orders</span></span><br><span class="line">        it.dirOffset &lt;&lt;= orders</span><br><span class="line">        <span class="comment">// it.m.dirLen // 调整directory时已经调整了dirLen，这里不需要再处理</span></span><br><span class="line">        it.globalDepth = it.m.globalDepth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描所有table [0,dirLen]，当然nextDirIdx会根据分裂等情况调整table的索引</span></span><br><span class="line">    <span class="keyword">for</span> ; it.dirIdx &lt; it.m.dirLen; it.nextDirIdx() &#123;</span><br><span class="line">        <span class="comment">// table第一次扫描时</span></span><br><span class="line">        <span class="keyword">if</span> it.tab == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// local dirIdx</span></span><br><span class="line">            dirIdx := <span class="type">int</span>((<span class="type">uint64</span>(it.dirIdx) + it.dirOffset) &amp; <span class="type">uint64</span>(it.m.dirLen<span class="number">-1</span>))</span><br><span class="line">            <span class="comment">// 找到目标table</span></span><br><span class="line">            newTab := it.m.directoryAt(<span class="type">uintptr</span>(dirIdx))</span><br><span class="line">            <span class="comment">// 解决随机dirIdx可能引发的问题</span></span><br><span class="line">            <span class="comment">// 扩容/分裂后，两个dirIdx可能指向同一个table</span></span><br><span class="line">            <span class="keyword">if</span> newTab.index != dirIdx &#123;</span><br><span class="line">                diff := dirIdx - newTab.index</span><br><span class="line">                <span class="comment">// 调整dirOffset，使其能指向table的index</span></span><br><span class="line">                it.dirOffset -= <span class="type">uint64</span>(diff)</span><br><span class="line">                <span class="comment">// 以table的index为准</span></span><br><span class="line">                dirIdx = newTab.index</span><br><span class="line">            &#125;</span><br><span class="line">            it.tab = newTab</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        entryMask := <span class="type">uint64</span>(it.tab.capacity) - <span class="number">1</span></span><br><span class="line">        <span class="comment">// 全局计数器超过table的容量时，扫描下一个table</span></span><br><span class="line">        <span class="keyword">if</span> it.entryIdx &gt; entryMask &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 Fast path：只判断当前idx指向的ctrl，这要比匹配一组ctrls快</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// slot全局计数器</span></span><br><span class="line">        entryIdx := (it.entryIdx + it.entryOffset) &amp; entryMask</span><br><span class="line">        <span class="comment">// slot局部计数器-按8取模</span></span><br><span class="line">        slotIdx := <span class="type">uintptr</span>(entryIdx &amp; (abi.SwissMapGroupSlots - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slotIdx重新回到0 or 第一次遍历当前table</span></span><br><span class="line">        <span class="keyword">if</span> slotIdx == <span class="number">0</span> || it.group.data == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// groupIdx=entryIdx丢弃低3位 =&gt; [0,127]</span></span><br><span class="line">            groupIdx := entryIdx &gt;&gt; abi.SwissMapGroupSlotsBits</span><br><span class="line">            it.group = it.tab.groups.group(it.typ, groupIdx)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，table、group、slot的索引都已经确认了，只判断单个slot即可</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前slot是刚好是有值的，ctrl=full</span></span><br><span class="line">        <span class="keyword">if</span> (it.group.ctrls().get(slotIdx) &amp; ctrlEmpty) == <span class="number">0</span> &#123;</span><br><span class="line">            key := it.group.key(it.typ, slotIdx)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            grown := it.tab.index == <span class="number">-1</span></span><br><span class="line">            <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">            <span class="comment">// 扩容中</span></span><br><span class="line">            <span class="keyword">if</span> grown &#123;</span><br><span class="line">                <span class="comment">// 从新table拿数据，如果拿不到，确认是NaN还是已删除</span></span><br><span class="line">                newKey, newElem, ok := it.grownKeyElem(key, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">// 没找到，走slow path</span></span><br><span class="line">                    <span class="keyword">goto</span> next</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    key = newKey</span><br><span class="line">                    elem = newElem</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非扩容</span></span><br><span class="line">                elem = it.group.elem(it.typ, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 纪录key/value</span></span><br><span class="line">            it.entryIdx++</span><br><span class="line">            it.key = key</span><br><span class="line">            it.elem = elem</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    next:</span><br><span class="line">        <span class="comment">// 计数器+1</span></span><br><span class="line">        it.entryIdx++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 Slow path：批量匹配一组ctrl</span></span><br><span class="line">        <span class="comment">// 如果map比较稀疏效率会比较高</span></span><br><span class="line">        <span class="comment">// 如果是中等负载运行效果亦佳，如每个group有3-4个empty的slot</span></span><br><span class="line">        <span class="comment">// 遍历过程可能会发生删除等操作，需要double-check</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> groupMatch bitset</span><br><span class="line">        <span class="keyword">for</span> it.entryIdx &lt;= entryMask &#123;</span><br><span class="line">            <span class="comment">// slot全局计数器</span></span><br><span class="line">            entryIdx := (it.entryIdx + it.entryOffset) &amp; entryMask</span><br><span class="line">            <span class="comment">// slot局部计数器-按8取模</span></span><br><span class="line">            slotIdx := <span class="type">uintptr</span>(entryIdx &amp; (abi.SwissMapGroupSlots - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// slotIdx重新回到0 or 第一次遍历当前table</span></span><br><span class="line">            <span class="keyword">if</span> slotIdx == <span class="number">0</span> || it.group.data == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// groupIdx=entryIdx丢弃低3位 =&gt; [0,127]</span></span><br><span class="line">                groupIdx := entryIdx &gt;&gt; abi.SwissMapGroupSlotsBits</span><br><span class="line">                it.group = it.tab.groups.group(it.typ, groupIdx)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 刚开始 或者 上一轮没找到</span></span><br><span class="line">            <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 寻找ctrl=full状态的slot</span></span><br><span class="line">                groupMatch = it.group.ctrls().matchFull()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> slotIdx != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 把当前group的idx&lt;slotIdx的ctrl全部置为0，即丢弃掉</span></span><br><span class="line">                    <span class="comment">// 扫描过？or 随机？</span></span><br><span class="line">                    groupMatch = groupMatch.removeBelow(slotIdx)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有找到</span></span><br><span class="line">                <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 扫描下一个group</span></span><br><span class="line">                    it.entryIdx += abi.SwissMapGroupSlots - <span class="type">uint64</span>(slotIdx)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到一组数据了</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取第一个full slot</span></span><br><span class="line">                i := groupMatch.first()</span><br><span class="line">                <span class="comment">// 调整计数器，使其指向当前slot =&gt; slotIdx=i</span></span><br><span class="line">                it.entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">                <span class="comment">// 扫描了table全部数据了，扫描下一个table</span></span><br><span class="line">                <span class="comment">// idx roll over了，这个数据之前已经返回过了</span></span><br><span class="line">                <span class="keyword">if</span> it.entryIdx &gt; entryMask &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这句源代码应该是写重复了</span></span><br><span class="line">                entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">                slotIdx = i</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            key := it.group.key(it.typ, slotIdx)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            grown := it.tab.index == <span class="number">-1</span></span><br><span class="line">            <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">            <span class="comment">// 扩容/分裂后</span></span><br><span class="line">            <span class="keyword">if</span> grown &#123;</span><br><span class="line">                <span class="comment">// 从新table拿数据，如果拿不到，确认是NaN还是已删除</span></span><br><span class="line">                newKey, newElem, ok := it.grownKeyElem(key, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">// 没找到</span></span><br><span class="line">                    <span class="comment">// groupMatch末尾第一个1将会被置为0</span></span><br><span class="line">                    groupMatch = groupMatch.removeFirst()</span><br><span class="line">                    <span class="comment">// 当前组的slot扫描完了</span></span><br><span class="line">                    <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 指向下一个group开始位置</span></span><br><span class="line">                        it.entryIdx += abi.SwissMapGroupSlots - <span class="type">uint64</span>(slotIdx)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 下一个非空的slot的idx</span></span><br><span class="line">                    i := groupMatch.first()</span><br><span class="line">                    it.entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    key = newKey</span><br><span class="line">                    elem = newElem</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非扩容</span></span><br><span class="line">                elem = it.group.elem(it.typ, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// groupMatch末尾第一个1将会被置为0</span></span><br><span class="line">            groupMatch = groupMatch.removeFirst()</span><br><span class="line">            <span class="comment">// 当前组的slot扫描完了</span></span><br><span class="line">            <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 指向下一个group开始位置</span></span><br><span class="line">                it.entryIdx += abi.SwissMapGroupSlots - <span class="type">uint64</span>(slotIdx)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一个非空的slot的idx</span></span><br><span class="line">                i := groupMatch.first()</span><br><span class="line">                it.entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it.key = key</span><br><span class="line">            it.elem = elem</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Continue to next table.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描完所有table，结束</span></span><br><span class="line">    it.key = <span class="literal">nil</span></span><br><span class="line">    it.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个dirIdx，原文已经详细介绍了原理，不再赘述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> nextDirIdx() &#123;</span><br><span class="line">    <span class="comment">// Consider this directory:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// - 0: *t1</span></span><br><span class="line">    <span class="comment">// - 1: *t1</span></span><br><span class="line">    <span class="comment">// - 2: *t2a</span></span><br><span class="line">    <span class="comment">// - 3: *t2b</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果随机的dirIdx指向1，调整为0，上层代码已处理</span></span><br><span class="line">    <span class="comment">// 如果dirIdx指向0，下一个dirIdx指向2，跳过1</span></span><br><span class="line">    <span class="comment">// 如果此时t1分裂了，而我们的tab指向是旧的t1而不是t1a、t1b，依然要指跳过1</span></span><br><span class="line">    entries := <span class="number">1</span> &lt;&lt; (it.m.globalDepth - it.tab.localDepth)</span><br><span class="line">    it.dirIdx += entries</span><br><span class="line">    it.tab = <span class="literal">nil</span></span><br><span class="line">    it.group = groupReference&#123;&#125;</span><br><span class="line">    it.entryIdx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从新table拿数据，如果拿不到，确认是NaN还是已删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> grownKeyElem(key unsafe.Pointer, slotIdx <span class="type">uintptr</span>) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    newKey, newElem, ok := it.m.getWithKey(it.typ, key)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// Key has likely been deleted, and</span></span><br><span class="line">        <span class="comment">// should be skipped.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// One exception is keys that don&#x27;t</span></span><br><span class="line">        <span class="comment">// compare equal to themselves (e.g.,</span></span><br><span class="line">        <span class="comment">// NaN). These keys cannot be looked</span></span><br><span class="line">        <span class="comment">// up, so getWithKey will fail even if</span></span><br><span class="line">        <span class="comment">// the key exists.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// However, we are in luck because such</span></span><br><span class="line">        <span class="comment">// keys cannot be updated and they</span></span><br><span class="line">        <span class="comment">// cannot be deleted except with clear.</span></span><br><span class="line">        <span class="comment">// Thus if no clear has occurred, the</span></span><br><span class="line">        <span class="comment">// key/elem must still exist exactly as</span></span><br><span class="line">        <span class="comment">// in the old groups, so we can return</span></span><br><span class="line">        <span class="comment">// them from there.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// TODO(prattmic): Consider checking</span></span><br><span class="line">        <span class="comment">// clearSeq early. If a clear occurred,</span></span><br><span class="line">        <span class="comment">// Next could always return</span></span><br><span class="line">        <span class="comment">// immediately, as iteration doesn&#x27;t</span></span><br><span class="line">        <span class="comment">// need to return anything added after</span></span><br><span class="line">        <span class="comment">// clear.</span></span><br><span class="line">        <span class="keyword">if</span> it.clearSeq == it.m.clearSeq &amp;&amp; !it.typ.Key.Equal(key, key) &#123;</span><br><span class="line">            elem := it.group.elem(it.typ, slotIdx)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> key, elem, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This entry doesn&#x27;t exist anymore.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newKey, newElem, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">v1[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>系统调用runtime_mapassign实现map的赋值操作，其代码逻辑与Put方法相似，大概逻辑如下</p>
<ol>
<li>如果是小map，扫描group，找到空位置返回地址</li>
<li>如果是常规大小的map，根据哈希值找到table，用二次探测法找到合适的group，最后找到空位置返回地址</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_mapassign</span><span class="params">(typ *abi.SwissMapType, m *Map, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Put(typ *abi.SwissMapType, key, elem unsafe.Pointer) &#123;</span><br><span class="line">    slotElem := m.PutSlot(typ, key)</span><br><span class="line">    typedmemmove(typ.Elem, slotElem, elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutSlot returns a pointer to the element slot where an inserted element</span></span><br><span class="line"><span class="comment">// should be written.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PutSlot never returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> PutSlot(typ *abi.SwissMapType, key unsafe.Pointer) unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set writing after calling Hasher, since Hasher may panic, in which</span></span><br><span class="line">    <span class="comment">// case we have not actually done a write.</span></span><br><span class="line">    m.writing ^= <span class="number">1</span> <span class="comment">// toggle, see comment on writing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空的，原因有很多，这里初始化一个table一个group</span></span><br><span class="line">    <span class="keyword">if</span> m.dirPtr == <span class="literal">nil</span> &#123;</span><br><span class="line">        m.growToSmall(typ)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// used&lt;8</span></span><br><span class="line">        <span class="keyword">if</span> m.used &lt; abi.SwissMapGroupSlots &#123;</span><br><span class="line">            <span class="comment">// value指针</span></span><br><span class="line">            elem := m.putSlotSmall(typ, hash, key)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">            <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">                fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取消writing标志</span></span><br><span class="line">            m.writing ^= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> elem</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// used&gt;=8？扩容</span></span><br><span class="line">        <span class="comment">// 单个group到完整的table-groups结构</span></span><br><span class="line">        m.growToTable(typ)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirLen&gt;0 or used&gt;=8</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">        idx := m.directoryIndex(hash)</span><br><span class="line">        elem, ok := m.directoryAt(idx).PutSlot(typ, m, hash, key)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">        <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">            fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取消writing标志</span></span><br><span class="line">        m.writing ^= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// small map初始化group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> growToSmall(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 创建一个group</span></span><br><span class="line">    grp := newGroups(typ, <span class="number">1</span>)</span><br><span class="line">    m.dirPtr = grp.data</span><br><span class="line"></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个slot对应的ctrl都设置为empty =&gt; 0b10000000</span></span><br><span class="line">    g.ctrls().setEmpty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个group到完整的table-groups结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> growToTable(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 一个table，两个group</span></span><br><span class="line">    <span class="comment">// capacity=16 index=0 localDepth=0</span></span><br><span class="line">    tab := newTable(typ, <span class="number">2</span>*abi.SwissMapGroupSlots, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原先的group指针</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.SwissMapGroupSlots; i++ &#123;</span><br><span class="line">        <span class="comment">// 空的不处理</span></span><br><span class="line">        <span class="keyword">if</span> (g.ctrls().get(i) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">            <span class="comment">// Empty</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key地址</span></span><br><span class="line">        key := g.key(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            key = *((*unsafe.Pointer)(key))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value地址</span></span><br><span class="line">        elem := g.elem(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">            elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key的hash</span></span><br><span class="line">        hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">        tab.uncheckedPutSlot(typ, hash, key, elem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个table</span></span><br><span class="line">    directory := <span class="built_in">make</span>([]*table, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    directory[<span class="number">0</span>] = tab</span><br><span class="line"></span><br><span class="line">    m.dirPtr = unsafe.Pointer(&amp;directory[<span class="number">0</span>])</span><br><span class="line">    m.dirLen = <span class="built_in">len</span>(directory)</span><br><span class="line"></span><br><span class="line">    m.globalDepth = <span class="number">0</span> <span class="comment">// 2^0=1</span></span><br><span class="line">    m.globalShift = depthToShift(m.globalDepth) <span class="comment">// 64-0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有一个table一个group时，或者说只有一个group时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> putSlotSmall(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">    match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已存在（假阳性）</span></span><br><span class="line">    <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个非空的slot</span></span><br><span class="line">        i := match.first()</span><br><span class="line"></span><br><span class="line">        slotKey := g.key(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">            <span class="keyword">if</span> typ.NeedKeyUpdate() &#123;</span><br><span class="line">                typedmemmove(typ.Key, slotKey, key)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回value的地址</span></span><br><span class="line">            <span class="keyword">return</span> slotElem</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">        match = match.removeFirst()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// matchEmptyOrDeleted将full状态的ctrl全部置为0，找到empty和deleted的slot</span></span><br><span class="line">    <span class="comment">// small map不能删除slot</span></span><br><span class="line">    match = g.ctrls().matchEmptyOrDeleted()</span><br><span class="line">    <span class="comment">// 8个slot都被使用了</span></span><br><span class="line">    <span class="keyword">if</span> match == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;small map with no empty slot (concurrent map writes?)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过上一步，empty跟delete标记的slot都被找出来了</span></span><br><span class="line">    i := match.first()</span><br><span class="line"></span><br><span class="line">    slotKey := g.key(typ, i)</span><br><span class="line">    <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">        kmem := newobject(typ.Key)</span><br><span class="line">        *(*unsafe.Pointer)(slotKey) = kmem</span><br><span class="line">        slotKey = kmem</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemmove(typ.Key, slotKey, key)</span><br><span class="line"></span><br><span class="line">    slotElem := g.elem(typ, i)</span><br><span class="line">    <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">        emem := newobject(typ.Elem)</span><br><span class="line">        *(*unsafe.Pointer)(slotElem) = emem</span><br><span class="line">        slotElem = emem</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctrl状态更新</span></span><br><span class="line">    g.ctrls().set(i, ctrl(h2(hash)))</span><br><span class="line">    <span class="comment">// 计数器更新，small map用的是map结构体的used</span></span><br><span class="line">    m.used++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slotElem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> PutSlot(typ *abi.SwissMapType, m *Map, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录第一个已删除slot的group指针和slot索引</span></span><br><span class="line">    <span class="keyword">var</span> firstDeletedGroup groupReference</span><br><span class="line">    <span class="keyword">var</span> firstDeletedSlot <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line">        <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">        match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match不为0，至少找到一个（假阳性）</span></span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            <span class="comment">// 看样子同一个i会被用很多次</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">                <span class="comment">// 更新key？</span></span><br><span class="line">                <span class="keyword">if</span> typ.NeedKeyUpdate() &#123;</span><br><span class="line">                    typedmemmove(typ.Key, slotKey, key)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// value</span></span><br><span class="line">                slotElem := g.elem(typ, i)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// debug时开启，忽略</span></span><br><span class="line">                t.checkInvariants(typ, m)</span><br><span class="line">                <span class="keyword">return</span> slotElem, <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">            match = match.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmptyOrDeleted将full状态的ctrl全部置为0，找到empty和deleted的slot</span></span><br><span class="line">        match = g.ctrls().matchEmptyOrDeleted()</span><br><span class="line">        <span class="comment">// 8个slot都被使用了，看是否在其他group</span></span><br><span class="line">        <span class="keyword">if</span> match == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// nothing but filled slots. Keep probing.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有空的或被删除的slot</span></span><br><span class="line">        i := match.first()</span><br><span class="line">        <span class="comment">// 该slot已删除，继续找其他group</span></span><br><span class="line">        <span class="comment">// todo 其他index都是已删除吗？为什么不继续找当前group</span></span><br><span class="line">        <span class="keyword">if</span> g.ctrls().get(i) == ctrlDeleted &#123;</span><br><span class="line">            <span class="comment">// 纪录group指针和slot的index</span></span><br><span class="line">            <span class="keyword">if</span> firstDeletedGroup.data == <span class="literal">nil</span> &#123;</span><br><span class="line">                firstDeletedGroup = g</span><br><span class="line">                firstDeletedSlot = i</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// empty代表探测的末尾，不用再找了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we found a deleted slot along the way, we can</span></span><br><span class="line">        <span class="comment">// replace it without consuming growthLeft.</span></span><br><span class="line">        <span class="keyword">if</span> firstDeletedGroup.data != <span class="literal">nil</span> &#123;</span><br><span class="line">            g = firstDeletedGroup</span><br><span class="line">            i = firstDeletedSlot</span><br><span class="line">            t.growthLeft++ <span class="comment">// will be decremented below to become a no-op.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is room left to grow, just insert the new entry.</span></span><br><span class="line">        <span class="keyword">if</span> t.growthLeft &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                kmem := newobject(typ.Key)</span><br><span class="line">                *(*unsafe.Pointer)(slotKey) = kmem</span><br><span class="line">                slotKey = kmem</span><br><span class="line">            &#125;</span><br><span class="line">            typedmemmove(typ.Key, slotKey, key)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                emem := newobject(typ.Elem)</span><br><span class="line">                *(*unsafe.Pointer)(slotElem) = emem</span><br><span class="line">                slotElem = emem</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// map/table/group状态更新</span></span><br><span class="line">            g.ctrls().set(i, ctrl(h2(hash)))</span><br><span class="line">            t.growthLeft--</span><br><span class="line">            t.used++</span><br><span class="line">            m.used++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// debug时开启，忽略</span></span><br><span class="line">            t.checkInvariants(typ, m)</span><br><span class="line">            <span class="keyword">return</span> slotElem, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// table扩容，如果超过限制的1024个slot，分裂并更新map</span></span><br><span class="line">        t.rehash(typ, m)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时用，复制旧的table的slot数据到新的table</span></span><br><span class="line"><span class="comment">// 1. growthLeft-- used++</span></span><br><span class="line"><span class="comment">// 2. 不能有已删除的slot</span></span><br><span class="line"><span class="comment">// 3. indirect的key和value可以直接复制，由调用者保证key/value数据不变</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> uncheckedPutSlot(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key, elem unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> t.growthLeft == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;invariant failed: growthLeft is unexpectedly 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmptyOrDeleted将full状态的ctrl全部置为0，找到empty和deleted的slot</span></span><br><span class="line">        match := g.ctrls().matchEmptyOrDeleted()</span><br><span class="line">        <span class="comment">// match不为0，至少找到一个</span></span><br><span class="line">        <span class="keyword">if</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(slotKey) = key</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                typedmemmove(typ.Key, slotKey, key)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制value</span></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(slotElem) = elem</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                typedmemmove(typ.Elem, slotElem, elem)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 状态更新</span></span><br><span class="line">            t.growthLeft--</span><br><span class="line">            t.used++</span><br><span class="line">            g.ctrls().set(i, ctrl(h2(hash)))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>map使用growthLeft作为可用的slot大小，该值一般为capacity*7&#x2F;8，最大值为896。每次写入都会消耗growthLeft，当growthLeft减少到0时，触发扩容，扩容函数为rehash</p>
<p>大概逻辑如下</p>
<ol>
<li>如果扩容后到容量没有超过单个table的容量限制<ul>
<li>创建双倍容量的新table，将旧table的数据拷贝到新的table</li>
<li>dirPtr按指定索引替换掉table指针</li>
</ul>
</li>
<li>如果扩容后容量超过单个table的容量限制<ul>
<li>创建两个容量为1024的table_a和table_b</li>
<li>按哈希值高B+1位疏散slot数据到新的table</li>
<li>疏散完毕后，双倍扩容dirPtr数组</li>
<li>重新调整dirPtr数组指针</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// table扩容，如果超过限制的1024个slot，分裂并更新map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> rehash(typ *abi.SwissMapType, m *Map) &#123;</span><br><span class="line">    <span class="comment">// 双倍容量</span></span><br><span class="line">    newCapacity := <span class="number">2</span> * t.capacity</span><br><span class="line">    <span class="comment">// 没有超过单个table的容量限制 -&gt; 扩容</span></span><br><span class="line">    <span class="keyword">if</span> newCapacity &lt;= maxTableCapacity &#123;</span><br><span class="line">        t.grow(typ, m, newCapacity)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过单个table容量限制 -&gt; 分裂</span></span><br><span class="line">    t.split(typ, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> grow(typ *abi.SwissMapType, m *Map, newCapacity <span class="type">uint16</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建table</span></span><br><span class="line">    newTable := newTable(typ, <span class="type">uint64</span>(newCapacity), t.index, t.localDepth)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里还能等于0？</span></span><br><span class="line">    <span class="keyword">if</span> t.capacity &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有group</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">            g := t.groups.group(typ, i)</span><br><span class="line">            <span class="comment">// 遍历所有slot</span></span><br><span class="line">            <span class="keyword">for</span> j := <span class="type">uintptr</span>(<span class="number">0</span>); j &lt; abi.SwissMapGroupSlots; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> (g.ctrls().get(j) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">                    <span class="comment">// Empty or deleted</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// key</span></span><br><span class="line">                key := g.key(typ, j)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                    key = *((*unsafe.Pointer)(key))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// value</span></span><br><span class="line">                elem := g.elem(typ, j)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// hash</span></span><br><span class="line">                hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 复制key和value到newTable</span></span><br><span class="line">                newTable.uncheckedPutSlot(typ, hash, key, elem)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug时开启，忽略</span></span><br><span class="line">    newTable.checkInvariants(typ, m)</span><br><span class="line">    <span class="comment">// dirPtr指定index关联newTable</span></span><br><span class="line">    m.replaceTable(newTable)</span><br><span class="line">    <span class="comment">// 旧的table标记为过期</span></span><br><span class="line">    t.index = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// table分裂</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    directory (globalDepth=2)</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="comment">//    | 00 | --\</span></span><br><span class="line"><span class="comment">//    +----+    +--&gt; table (localDepth=1)</span></span><br><span class="line"><span class="comment">//    | 01 | --/</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="comment">//    | 10 | ------&gt; table (localDepth=2)</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="comment">//    | 11 | ------&gt; table (localDepth=2)</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> split(typ *abi.SwissMapType, m *Map) &#123;</span><br><span class="line">    localDepth := t.localDepth</span><br><span class="line">    localDepth++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// capacity=1024 index=-1 localDepth=localDepth+1</span></span><br><span class="line">    <span class="comment">// 两个table设置为已过期</span></span><br><span class="line">    left := newTable(typ, maxTableCapacity, <span class="number">-1</span>, localDepth)</span><br><span class="line">    right := newTable(typ, maxTableCapacity, <span class="number">-1</span>, localDepth)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1&lt;&lt;(64-localDepth) 高(B+1)位所谓索引</span></span><br><span class="line">    <span class="comment">// origin_depth=1 index =&gt; [0,1]</span></span><br><span class="line">    <span class="comment">// current_depth=2 index =&gt; [0,1,2,3]</span></span><br><span class="line">    mask := localDepthMask(localDepth)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有group</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">        g := t.groups.group(typ, i)</span><br><span class="line">        <span class="comment">// 遍历所有slot</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="type">uintptr</span>(<span class="number">0</span>); j &lt; abi.SwissMapGroupSlots; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.ctrls().get(j) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">                <span class="comment">// Empty or deleted</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            key := g.key(typ, j)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            elem := g.elem(typ, j)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// hash</span></span><br><span class="line">            hash := typ.Hasher(key, m.seed)</span><br><span class="line">            <span class="keyword">var</span> newTable *table</span><br><span class="line">            <span class="comment">// 按hash新的bit进行分组</span></span><br><span class="line">            <span class="keyword">if</span> hash&amp;mask == <span class="number">0</span> &#123;</span><br><span class="line">                newTable = left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newTable = right</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 复制key和value到newTable</span></span><br><span class="line">            newTable.uncheckedPutSlot(typ, hash, key, elem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    m.installTableSplit(t, left, right)</span><br><span class="line">    <span class="comment">// 旧的table标记为过期</span></span><br><span class="line">    t.index = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据table的index，更新dirPtr数组的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> replaceTable(nt *table) &#123;</span><br><span class="line">    <span class="comment">// The number of entries that reference the same table doubles for each</span></span><br><span class="line">    <span class="comment">// time the globalDepth grows without the table splitting.</span></span><br><span class="line">    entries := <span class="number">1</span> &lt;&lt; (m.globalDepth - nt.localDepth)</span><br><span class="line">    <span class="comment">// 有分裂？更新多个dirPtr数组的table指针，没有分裂就会只有一个index</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; entries; i++ &#123;</span><br><span class="line">        <span class="comment">//m.directory[nt.index+i] = nt</span></span><br><span class="line">        m.directorySet(<span class="type">uintptr</span>(nt.index+i), nt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> installTableSplit(old, left, right *table) &#123;</span><br><span class="line">    <span class="comment">// table分裂了，dirPtr数组需要扩容</span></span><br><span class="line">    <span class="comment">// 第一个分裂的table</span></span><br><span class="line">    <span class="keyword">if</span> old.localDepth == m.globalDepth &#123;</span><br><span class="line">        <span class="comment">// 双倍扩容</span></span><br><span class="line">        newDir := <span class="built_in">make</span>([]*table, m.dirLen*<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> m.dirLen &#123;</span><br><span class="line">            t := m.directoryAt(<span class="type">uintptr</span>(i))</span><br><span class="line">            <span class="comment">// 指向同一个table</span></span><br><span class="line">            newDir[<span class="number">2</span>*i] = t</span><br><span class="line">            newDir[<span class="number">2</span>*i+<span class="number">1</span>] = t</span><br><span class="line">            <span class="comment">// t may already exist in multiple indicies. We should</span></span><br><span class="line">            <span class="comment">// only update t.index once. Since the index must</span></span><br><span class="line">            <span class="comment">// increase, seeing the original index means this must</span></span><br><span class="line">            <span class="comment">// be the first time we&#x27;ve encountered this table.</span></span><br><span class="line">            <span class="keyword">if</span> t.index == i &#123;</span><br><span class="line">                t.index = <span class="number">2</span> * i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m.globalDepth++</span><br><span class="line">        m.globalShift--</span><br><span class="line">        m.dirPtr = unsafe.Pointer(&amp;newDir[<span class="number">0</span>])</span><br><span class="line">        m.dirLen = <span class="built_in">len</span>(newDir)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// N.B. left and right may still consume multiple indicies if the</span></span><br><span class="line">    <span class="comment">// directory has grown multiple times since old was last split.</span></span><br><span class="line">    left.index = old.index</span><br><span class="line">    <span class="comment">// dirPtr指定index关联newTable</span></span><br><span class="line">    m.replaceTable(left)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他table可能分裂多次，导致localDepth远小于globalDepth，无法直接+1</span></span><br><span class="line">    entries := <span class="number">1</span> &lt;&lt; (m.globalDepth - left.localDepth)</span><br><span class="line">    right.index = left.index + entries</span><br><span class="line">    <span class="comment">// dirPtr指定index关联newTable</span></span><br><span class="line">    m.replaceTable(right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(v1, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当使用关键字delete删除指定key时，调用mapdelete，大概逻辑如下</p>
<ol>
<li>如果map的slot数量小于等于8，small map，直接扫描dirPtr指向的group，删除key&#x2F;value并将对应的ctrl改为empty</li>
<li>如果map的slot数量大于8，根据hash使用二次探测查找法定位table、group，找到目标slot<ul>
<li>如果该group是满数据的，将ctrl改为deleted</li>
<li>如果该group是有空位的，将ctrl改为empty</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *abi.SwissMapType, m *maps.Map, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    m.Delete(t, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(typ *abi.SwissMapType, key unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> || m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := mapKeyError(typ, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set writing after calling Hasher, since Hasher may panic, in which</span></span><br><span class="line">    <span class="comment">// case we have not actually done a write.</span></span><br><span class="line">    m.writing ^= <span class="number">1</span> <span class="comment">// toggle, see comment on writing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        m.deleteSmall(typ, hash, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">        idx := m.directoryIndex(hash)</span><br><span class="line">        m.directoryAt(idx).Delete(typ, m, hash, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删光了？重置hash种子</span></span><br><span class="line">    <span class="keyword">if</span> m.used == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Reset the hash seed to make it more difficult for attackers</span></span><br><span class="line">        <span class="comment">// to repeatedly trigger hash collisions. See</span></span><br><span class="line">        <span class="comment">// https://go.dev/issue/25237.</span></span><br><span class="line">        m.seed = <span class="type">uintptr</span>(rand())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消writing标志</span></span><br><span class="line">    m.writing ^= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有一个table一个group时，或者说只有一个group时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> deleteSmall(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">    match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到了（假阳性）</span></span><br><span class="line">    <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 按顺序比对ctrl</span></span><br><span class="line">        i := match.first()</span><br><span class="line">        slotKey := g.key(typ, i)</span><br><span class="line">        origSlotKey := slotKey</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key比对成功</span></span><br><span class="line">        <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">            <span class="comment">// 计数器更新，small map用的是map结构体的used</span></span><br><span class="line">            m.used--</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key是一个指针，直接置为nil</span></span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                *(*unsafe.Pointer)(origSlotKey) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> typ.Key.Pointers() &#123;</span><br><span class="line">                <span class="comment">// key存储的是一个指针</span></span><br><span class="line">                <span class="comment">// Only bother clearing if there are pointers.</span></span><br><span class="line">                typedmemclr(typ.Key, slotKey)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                *(*unsafe.Pointer)(slotElem) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Unlike keys, always clear the elem (even if</span></span><br><span class="line">                <span class="comment">// it contains no pointers), as compound</span></span><br><span class="line">                <span class="comment">// assignment operations depend on cleared</span></span><br><span class="line">                <span class="comment">// deleted values. See</span></span><br><span class="line">                <span class="comment">// https://go.dev/issue/25936.</span></span><br><span class="line">                typedmemclr(typ.Elem, slotElem)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置为empty而不是deleted</span></span><br><span class="line">            <span class="comment">// We only have 1 group, so it is OK to immediately</span></span><br><span class="line">            <span class="comment">// reuse deleted slots.</span></span><br><span class="line">            g.ctrls().set(i, ctrlEmpty)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">        match = match.removeFirst()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> Delete(typ *abi.SwissMapType, m *Map, hash <span class="type">uintptr</span>, key unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line">        <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">        match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了（假阳性）</span></span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            origSlotKey := slotKey</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key比对成功</span></span><br><span class="line">            <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">                <span class="comment">// 计数器更新</span></span><br><span class="line">                t.used--</span><br><span class="line">                m.used--</span><br><span class="line"></span><br><span class="line">                <span class="comment">// key是一个指针，直接置为nil</span></span><br><span class="line">                <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                    <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                    *(*unsafe.Pointer)(origSlotKey) = <span class="literal">nil</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> typ.Key.Pointers() &#123;</span><br><span class="line">                    <span class="comment">// key存储的是一个指针</span></span><br><span class="line">                    <span class="comment">// Only bothing clear the key if there</span></span><br><span class="line">                    <span class="comment">// are pointers in it.</span></span><br><span class="line">                    typedmemclr(typ.Key, slotKey)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// value</span></span><br><span class="line">                slotElem := g.elem(typ, i)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                    *(*unsafe.Pointer)(slotElem) = <span class="literal">nil</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Unlike keys, always clear the elem (even if</span></span><br><span class="line">                    <span class="comment">// it contains no pointers), as compound</span></span><br><span class="line">                    <span class="comment">// assignment operations depend on cleared</span></span><br><span class="line">                    <span class="comment">// deleted values. See</span></span><br><span class="line">                    <span class="comment">// https://go.dev/issue/25936.</span></span><br><span class="line">                    typedmemclr(typ.Elem, slotElem)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// matchEmpty将非empty的ctrl全部置为0，如果8个ctrl都有数据，如full或者deleted状态，那么match=0</span></span><br><span class="line">                <span class="comment">// Only a full group can appear in the middle</span></span><br><span class="line">                <span class="comment">// of a probe sequence (a group with at least</span></span><br><span class="line">                <span class="comment">// one empty slot terminates probing). Once a</span></span><br><span class="line">                <span class="comment">// group becomes full, it stays full until</span></span><br><span class="line">                <span class="comment">// rehashing/resizing. So if the group isn&#x27;t</span></span><br><span class="line">                <span class="comment">// full now, we can simply remove the element.</span></span><br><span class="line">                <span class="comment">// Otherwise, we create a tombstone to mark the</span></span><br><span class="line">                <span class="comment">// slot as deleted.</span></span><br><span class="line">                <span class="keyword">if</span> g.ctrls().matchEmpty() != <span class="number">0</span> &#123;</span><br><span class="line">                    g.ctrls().set(i, ctrlEmpty)</span><br><span class="line">                    t.growthLeft++</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// tombstone</span></span><br><span class="line">                    g.ctrls().set(i, ctrlDeleted)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// debug时开启，忽略</span></span><br><span class="line">                t.checkInvariants(typ, m)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">            match = match.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmpty将非empty的ctrl全部置为0，如果8个ctrl都有数据，如full或者deleted状态，那么match=0</span></span><br><span class="line">        match = g.ctrls().matchEmpty()</span><br><span class="line">        <span class="keyword">if</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Finding an empty slot means we&#x27;ve reached the end of</span></span><br><span class="line">            <span class="comment">// the probe sequence.</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line">clear(v1)</span><br></pre></td></tr></table></figure>

<p>使用clear清理map的所有元素时，系统调用mapclear进行处理，大概逻辑如下</p>
<ol>
<li>如果是small map，直接清理掉group数据</li>
<li>如果是常规map，遍历table、group清理</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclear</span><span class="params">(t *abi.SwissMapType, m *maps.Map)</span></span> &#123;</span><br><span class="line">    m.Clear(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Clear(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> || m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    m.writing ^= <span class="number">1</span> <span class="comment">// toggle, see comment on writing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        m.clearSmall(typ)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> lastTab *table</span><br><span class="line">        <span class="comment">// 遍历所有table</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> m.dirLen &#123;</span><br><span class="line">            t := m.directoryAt(<span class="type">uintptr</span>(i))</span><br><span class="line">            <span class="comment">// 分裂时，会指向同一个table</span></span><br><span class="line">            <span class="keyword">if</span> t == lastTab &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清理groups、重置table状态</span></span><br><span class="line">            t.Clear(typ)</span><br><span class="line">            lastTab = t</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置map状态</span></span><br><span class="line">        m.used = <span class="number">0</span></span><br><span class="line">        m.clearSeq++</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> shrink directory?</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置hash种子</span></span><br><span class="line">    <span class="comment">// Reset the hash seed to make it more difficult for attackers to</span></span><br><span class="line">    <span class="comment">// repeatedly trigger hash collisions. See https://go.dev/issue/25237.</span></span><br><span class="line">    m.seed = <span class="type">uintptr</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消writing标志</span></span><br><span class="line">    m.writing ^= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> clearSmall(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    typedmemclr(typ.Group, g.data) <span class="comment">// slot数据</span></span><br><span class="line">    g.ctrls().setEmpty() <span class="comment">// ctrl状态</span></span><br><span class="line"></span><br><span class="line">    m.used = <span class="number">0</span></span><br><span class="line">    m.clearSeq++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> Clear(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 遍历所有group</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">        g := t.groups.group(typ, i)</span><br><span class="line">        typedmemclr(typ.Group, g.data) <span class="comment">// slot数据</span></span><br><span class="line">        g.ctrls().setEmpty() <span class="comment">// ctrl状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.used = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 根据capacity重置growthLeft字段</span></span><br><span class="line">    t.resetGrowthLeft()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下非克隆，只是复制了header</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = v1</span><br><span class="line"></span><br><span class="line"><span class="comment">// go 1.21</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = maps.Clone(v1)</span><br></pre></td></tr></table></figure>

<p>当使用maps.Clone复制数据时，系统使用mapclone2实现该操作，大概逻辑如下大概逻辑如下</p>
<ol>
<li>创建一个Iter</li>
<li>不断调用Next获取数据，写入新的map</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclone2</span><span class="params">(t *abi.SwissMapType, src *maps.Map)</span></span> *maps.Map &#123;</span><br><span class="line">    dst := makemap(t, <span class="type">int</span>(src.Used()), <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iter maps.Iter</span><br><span class="line">    iter.Init(t, src)</span><br><span class="line">    <span class="keyword">for</span> iter.Next(); iter.Key() != <span class="literal">nil</span>; iter.Next() &#123;</span><br><span class="line">        dst.Put(t, iter.Key(), iter.Elem())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-slice</title>
    <url>/golang-series-slice/</url>
    <content><![CDATA[<p>slice&#x2F;切片-动态数组，golang常用的数据结构之一，相对于数组，slice可以追加元素，在容量不足时自动扩容</p>
<p>当前go版本：1.24</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>slice数据结构如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li><code>array</code> - 指向一片连续内存区域的第一个元素</li>
<li><code>len</code> - 已有元素数量</li>
<li><code>cap</code> - 可容纳元素总数量</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>slice初始化方式有三种</p>
<ol>
<li>使用字面量创建新切片</li>
<li>使用关键字make创建切片</li>
<li>通过下标获取数组或切片的一部份</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// len=3 cap=3</span></span><br><span class="line"><span class="keyword">var</span> v1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// len=10 cap=10</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>) <span class="comment">// var v2 = make([]int, 0, 10)</span></span><br><span class="line"><span class="comment">// len=4 cap=9</span></span><br><span class="line"><span class="keyword">var</span> v3 = v2[<span class="number">1</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>使用<code>ssa</code>包打印<code>var v1 = []int&#123;1, 2, 3&#125;</code>，得到结果如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t0 = new [3]int (slicelit)                                      *[3]int</span><br><span class="line">t1 = &amp;t0[0:int]                                                    *int</span><br><span class="line">*t1 = 1:int</span><br><span class="line">t2 = &amp;t0[1:int]                                                    *int</span><br><span class="line">*t2 = 2:int</span><br><span class="line">t3 = &amp;t0[2:int]                                                    *int</span><br><span class="line">*t3 = 3:int</span><br><span class="line">t4 = slice t0[:]   </span><br></pre></td></tr></table></figure>

<ol>
<li>根据字面量的数量创建一个数组t0</li>
<li>初始化数组元素t1&#x2F;t2&#x2F;t3</li>
<li>在t0基础上创建一个切片t4</li>
</ol>
<p><code>src/cmd/compile/internal/walk/complit.go</code>slicelit</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>使用<code>ssa</code>包打印<code>var v2 = make([]int, 10)</code>，得到结果如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t0 = new [10]int (makeslice)                                   *[10]int</span><br><span class="line">t1 = slice t0[:10:int]                                            []int</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个数组t0</li>
<li>在t0基础上创建一个切片t1</li>
</ol>
<p><code>makeslice</code>源代码如下，做了一些精简</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 1. mem（连续内存区域大小） = 元素类型占用大小(type_size)*容量大小(cap)</span></span><br><span class="line">    <span class="comment">// 2. overflow（是否溢出） = !(type_size|cap &lt; 4GB or type_size=0 or cap &gt; uint_max/type_size)</span></span><br><span class="line">    mem, overflow := math.MulUintptr(et.Size_, <span class="type">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">        mem, overflow := math.MulUintptr(et.Size_, <span class="type">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">        <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            panicmakeslicelen()</span><br><span class="line">        &#125;</span><br><span class="line">        panicmakeslicecap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v2 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> v3 = v2[<span class="number">1</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>使用<code>ssa</code>包打印上述代码，得到结果如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t0 = new [10]int (makeslice)                                   *[10]int</span><br><span class="line">t1 = slice t0[:10:int]                                            []int</span><br><span class="line">t2 = slice t1[1:int:5:int]                                        []int</span><br></pre></td></tr></table></figure>

<ol>
<li>使用关键字make创建一个切片t1</li>
<li>在上一步基础上，创建一个切片t2，指定下标left&#x3D;1 right&#x3D;5</li>
</ol>
<h2 id="追加和扩容"><a href="#追加和扩容" class="headerlink" title="追加和扩容"></a>追加和扩容</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">v1 = <span class="built_in">append</span>(v1, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>slice使用<code>append</code>关键字实现追加操作，当数据量超过底层cap大小时，触发扩容，扩容代码精简后如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(oldPtr unsafe.Pointer, newLen, oldCap, num <span class="type">int</span>, et *_type)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 根据当前cap以及新len计算新cap</span></span><br><span class="line">    newcap := nextslicecap(newLen, oldCap)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line">    <span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line">    noscan := !et.Pointers() <span class="comment">// 指针？</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="comment">// ... （优化）</span></span><br><span class="line">    <span class="comment">// 以下是通用操作</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen) * et.Size_</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen) * et.Size_</span><br><span class="line">        capmem, overflow = math.MulUintptr(et.Size_, <span class="type">uintptr</span>(newcap))</span><br><span class="line">        capmem = roundupsize(capmem, noscan)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / et.Size_)</span><br><span class="line">        capmem = <span class="type">uintptr</span>(newcap) * et.Size_</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextslicecap</span><span class="params">(newLen, oldCap <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 双倍cap仍然小于newLen，直接返回newLen</span></span><br><span class="line">    newcap := oldCap</span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> newLen &gt; doublecap &#123;</span><br><span class="line">        <span class="keyword">return</span> newLen</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 双倍cap小于512，返回双倍cap</span></span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">    <span class="keyword">if</span> oldCap &lt; threshold &#123;</span><br><span class="line">        <span class="keyword">return</span> doublecap</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 计算公式：x = 5/4*x + 192，直到x&gt;=newLen</span></span><br><span class="line">        newcap += (newcap + <span class="number">3</span>*threshold) &gt;&gt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">uint</span>(newcap) &gt;= <span class="type">uint</span>(newLen) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出？</span></span><br><span class="line">    <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newLen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newcap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在1.18版本，Keith Randall对slice的growth factor进行了调整，使其增长更为平滑，详细见提交：<code>https://github.com/golang/go/blob/2dda92ff6f9f07eeb110ecbf0fc2d7a0ddd27f9d/src/runtime/slice.go</code></p>
<p>不同cap对应的扩容因子如下</p>
<table>
<thead>
<tr>
<th align="left">starting cap</th>
<th align="left">growth factor</th>
</tr>
</thead>
<tbody><tr>
<td align="left">256</td>
<td align="left">2.0</td>
</tr>
<tr>
<td align="left">512</td>
<td align="left">1.63</td>
</tr>
<tr>
<td align="left">1024</td>
<td align="left">1.44</td>
</tr>
<tr>
<td align="left">2048</td>
<td align="left">1.35</td>
</tr>
<tr>
<td align="left">4096</td>
<td align="left">1.30</td>
</tr>
</tbody></table>
<h2 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h2><p>切片的拷贝也归类于appendSlice，具体在<code>src/cmd/compile/internal/walk/assign.go:appendSlice</code>。</p>
<p>这里的copy可能与我们预期不一样，并不是浅层或深层拷贝，是拷贝与目标dst的len长度一致的数据，与容量cap无关</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 []<span class="type">int</span> <span class="comment">// or `var v2 = make([]int, 0, 3)`</span></span><br><span class="line"><span class="built_in">copy</span>(v2, v1) <span class="comment">// v2仍然是空切片</span></span><br></pre></td></tr></table></figure>

<p>slicecopy函数具体如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(toPtr unsafe.Pointer, toLen <span class="type">int</span>, fromPtr unsafe.Pointer, fromLen <span class="type">int</span>, width <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// fromLen和toLen都为0，不处理</span></span><br><span class="line">    <span class="keyword">if</span> fromLen == <span class="number">0</span> || toLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n=min(fromLen, toLen)</span></span><br><span class="line">    n := fromLen</span><br><span class="line">    <span class="keyword">if</span> toLen &lt; n &#123;</span><br><span class="line">        n = toLen</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// type_size大小为0</span></span><br><span class="line">    <span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size := <span class="type">uintptr</span>(n) * width</span><br><span class="line">    <span class="comment">// copy</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span> &#123;</span><br><span class="line">        *(*<span class="type">byte</span>)(toPtr) = *(*<span class="type">byte</span>)(fromPtr)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memmove(toPtr, fromPtr, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://gist.github.com/Integralist/22ced4b4700df1e6cbec88c1074c8b2d">1. Memory Allocation Summary.md</a><br><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/">3.2 切片</a><br><a href="https://pkg.go.dev/golang.org/x/tools/go/ssa#example-package-BuildPackage">ssa</a><br><a href="https://go.dev/blog/slices-intro">Go Slices: usage and internals</a><br><a href="https://go101.org/article/container.html">Arrays, Slices and Maps in Go</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-netpoll</title>
    <url>/golang-series-netpoll/</url>
    <content><![CDATA[<p>netpoll是golang用来处理网络I&#x2F;O事件的底层机制，主要通过操作系统的I&#x2F;O多路复用机制如Linux的epoll、BSD的kqueue、Windows的IOCP等来实现</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>核心的数据结构是pollDesc，用于存储与文件描述符相关的事件数据，一般被放入如epoll的epoll_event.data来传递信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">    _          sys.NotInHeap    <span class="comment">// 放置转换成interface&#123;&#125;时申请heap内存</span></span><br><span class="line">    link       *pollDesc        <span class="comment">// next指针，用于pollcache链表</span></span><br><span class="line">    fd         <span class="type">uintptr</span>          <span class="comment">// 文件描述符</span></span><br><span class="line">    fdseq      atomic.Uintptr   <span class="comment">// 计数器，类似时间戳，确保过期的消息不会被处理，只在获取/放回cache时改变</span></span><br><span class="line">    atomicInfo atomic.Uint32    <span class="comment">// 5个状态位+fdseq（这两个数据有位交叉冲突，没搞懂）</span></span><br><span class="line">    rg         atomic.Uintptr   <span class="comment">// 读状态，读G的地址也作为一种状态</span></span><br><span class="line">    wg         atomic.Uintptr   <span class="comment">// 写状态，写G的地址也作为一种状态</span></span><br><span class="line">    lock       mutex            <span class="comment">// 锁，保护下列字段</span></span><br><span class="line">    closing    <span class="type">bool</span>             <span class="comment">// 是否被移除出netpoll</span></span><br><span class="line">    rrun       <span class="type">bool</span>             <span class="comment">// rt-读定时器是否在运行</span></span><br><span class="line">    wrun       <span class="type">bool</span>             <span class="comment">// wt-写定时器是否在运行</span></span><br><span class="line">    user       <span class="type">uint32</span>           <span class="comment">// cookie，linux/bsd应该没用到</span></span><br><span class="line">    rseq       <span class="type">uintptr</span>          <span class="comment">// 读计数器，类似fdseq，只有获取/放回cache以及设置deadline时改变</span></span><br><span class="line">    rt         timer            <span class="comment">// 读定时器</span></span><br><span class="line">    rd         <span class="type">int64</span>            <span class="comment">// 读过期时刻，-1为已过期</span></span><br><span class="line">    wseq       <span class="type">uintptr</span>          <span class="comment">// 写计数器，类似fdseq，只有获取/放回cache以及设置deadline时改变</span></span><br><span class="line">    wt         timer            <span class="comment">// 写定时器</span></span><br><span class="line">    wd         <span class="type">int64</span>            <span class="comment">// 写过期时刻，-1为已过期</span></span><br><span class="line">    self       *pollDesc        <span class="comment">// 当前实例指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pollDesc缓存，重复使用，避免反复申请内存</span></span><br><span class="line"><span class="keyword">type</span> pollCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock  mutex                 <span class="comment">// 锁</span></span><br><span class="line">    first *pollDesc             <span class="comment">// 链表头部指针，pollDesc指针都从头部写入 new -&gt; old -&gt; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pollDesc部份字段讲解如下</p>
<ol>
<li><code>atomicInfo</code>是一个无符号32位整型数，每位用途如下</li>
</ol>
<table>
<thead>
<tr>
<th align="left">16bit</th>
<th align="left">11bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fdseq</td>
<td align="left">unused</td>
<td align="left">pollFDSeq</td>
<td align="left">pollExpiredWriteDeadline</td>
<td align="left">pollExpiredReadDeadline</td>
<td align="left">pollEventErr</td>
<td align="left">pollClosing</td>
</tr>
</tbody></table>
<p><em>注意</em>：fdseq占据20位数据，但在atomicInfo里，fdseq要向左移位16位，看起来是数据丢失了，没搞明白。同样有问题的还有taggedPointerPack</p>
<ol start="2">
<li><code>rg</code>和<code>wg</code>的状态列表如下</li>
</ol>
<table>
<thead>
<tr>
<th align="left">state_name</th>
<th align="left">state_val</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pdNil</td>
<td align="left">0</td>
<td align="left">默认值</td>
</tr>
<tr>
<td align="left">pdReady</td>
<td align="left">1</td>
<td align="left">io可读，下一个状态是pdNil</td>
</tr>
<tr>
<td align="left">pdWait</td>
<td align="left">2</td>
<td align="left">准备挂起，下一个状态是G pointer-挂起，pdReady-io可读，pdNil-超时&#x2F;关闭</td>
</tr>
<tr>
<td align="left">G pointer</td>
<td align="left">0xabc</td>
<td align="left">goroutine指针-挂起，下一个状态是pdReady-io可读，pdNil-超时&#x2F;关闭</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="netpoll初始化"><a href="#netpoll初始化" class="headerlink" title="netpoll初始化"></a>netpoll初始化</h2><p>初始化与netpoll有关的底层资源，如epoll实例、eventfd实例等，用sync.Once限制只执行一次。逻辑如下</p>
<ol>
<li>通用&#x2F;平台无关<ul>
<li>初始化锁，包括netpollInitLock、pollcache.lock</li>
<li>如果netpollInited为0，执行平台相关初始化，最后netpollInited设为1</li>
</ul>
</li>
<li>平台相关(linux-epoll)<ul>
<li>生成epoll实例</li>
<li>生成eventfd实例、封装epoll事件数据</li>
<li>将文件描述符eventfd和事件数据添加到epoll实例</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="comment">// src/runtime/netpoll.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    netpollInitLock mutex           <span class="comment">// netpoll初始化锁</span></span><br><span class="line">    netpollInited   atomic.Uint32   <span class="comment">// 判断netpoll是否已初始化</span></span><br><span class="line"></span><br><span class="line">    pollcache      pollCache        <span class="comment">// pollDesc链表</span></span><br><span class="line">    netpollWaiters atomic.Uint32    <span class="comment">// 挂起的goroutine数量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器链接为internal/poll.runtime_pollServerInit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollServerInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    netpollGenericInit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// netpoll初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollGenericInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        lockInit(&amp;netpollInitLock, lockRankNetpollInit)</span><br><span class="line">        lockInit(&amp;pollcache.lock, lockRankPollCache)</span><br><span class="line">        lock(&amp;netpollInitLock)</span><br><span class="line">        <span class="comment">// 加锁后double-check</span></span><br><span class="line">        <span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 调用平台相关实现，如linux-epoll</span></span><br><span class="line">            netpollinit()</span><br><span class="line">            <span class="comment">// 0 -&gt; 1（已初始化）</span></span><br><span class="line">            netpollInited.Store(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;netpollInitLock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台相关-linux/epoll</span></span><br><span class="line"><span class="comment">// src/runtime/netpoll_epoll.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    epfd           <span class="type">int32</span>         = <span class="number">-1</span> <span class="comment">// epoll实例</span></span><br><span class="line">    netpollEventFd <span class="type">uintptr</span>            <span class="comment">// eventfd实例</span></span><br><span class="line">    netpollWakeSig atomic.Uint32      <span class="comment">// 标志，防止重复调用netpollBreak</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> errno <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// 1. 创建epoll实例</span></span><br><span class="line">    <span class="comment">// EPOLL_CLOEXEC =&gt; 安全设置，fork()创建子进程或exec()执行新程序时，关闭epoll实例</span></span><br><span class="line">    epfd, errno = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: epollcreate failed with&quot;</span>, errno)</span><br><span class="line">        throw(<span class="string">&quot;runtime: netpollinit failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建eventfd实例</span></span><br><span class="line">    <span class="comment">// 2.1. 创建eventfd文件描述符</span></span><br><span class="line">    <span class="comment">// 0 =&gt; 计数器初始值，如果为0，epollWait时会阻塞住</span></span><br><span class="line">    <span class="comment">// EPOLL_CLOEXEC =&gt; 执行exec()时，关闭efd</span></span><br><span class="line">    <span class="comment">// EFD_NONBLOCK  =&gt; 非阻塞</span></span><br><span class="line">    efd, errno := syscall.Eventfd(<span class="number">0</span>, syscall.EFD_CLOEXEC|syscall.EFD_NONBLOCK)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: eventfd failed with&quot;</span>, -errno)</span><br><span class="line">        throw(<span class="string">&quot;runtime: eventfd failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2. 创建epoll事件</span></span><br><span class="line">    <span class="comment">// EPOLLIN =&gt; 可读时通知</span></span><br><span class="line">	<span class="comment">// 默认水平触发</span></span><br><span class="line">    ev := syscall.EpollEvent&#123;</span><br><span class="line">        Events: syscall.EPOLLIN,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 事件元数据绑定</span></span><br><span class="line">    <span class="comment">// efd指针存储在netpollEventFd，最后再存储于Data</span></span><br><span class="line">    *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.Data)) = &amp;netpollEventFd</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将eventfd文件描述符efd加入epoll实例epfd</span></span><br><span class="line">    errno = syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, efd, &amp;ev)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: epollctl failed with&quot;</span>, errno)</span><br><span class="line">        throw(<span class="string">&quot;runtime: epollctl failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    netpollEventFd = <span class="type">uintptr</span>(efd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll添加文件描述符"><a href="#netpoll添加文件描述符" class="headerlink" title="netpoll添加文件描述符"></a>netpoll添加文件描述符</h2><p>将一个文件描述符（FD）或网络连接添加到I&#x2F;O事件多路复用系统中，使其能够被监听，以便在该文件描述符上发生事件时被唤醒并进行相应处理。逻辑如下</p>
<ol>
<li>生成&#x2F;初始化事件元数据pd<ul>
<li>确保rg&#x2F;wg重置为pdNil</li>
<li>fdseq默认为1</li>
<li>更新atomicInfo错误标志</li>
<li>rd&#x2F;wd过期时刻设置为0，rseq&#x2F;wseq计数器更新</li>
<li>绑定self</li>
<li>重新更新atomicInfo</li>
</ul>
</li>
<li>将文件描述符、事件数据添加到epoll实例（平台相关）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> (*pollDesc, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 生成/初始化事件元数据</span></span><br><span class="line">    pd := pollcache.alloc()</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    wg := pd.wg.Load()</span><br><span class="line">    <span class="keyword">if</span> wg != pdNil &amp;&amp; wg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked write on free polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    rg := pd.rg.Load()</span><br><span class="line">    <span class="keyword">if</span> rg != pdNil &amp;&amp; rg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked read on free polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pd.fd = fd</span><br><span class="line">    <span class="keyword">if</span> pd.fdseq.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 修改fdseq，0-特殊用途，不能使用</span></span><br><span class="line">        pd.fdseq.Store(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pd.closing = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 更新atomicInfo错误标志</span></span><br><span class="line">    pd.setEventErr(<span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    pd.rseq++</span><br><span class="line">    pd.rg.Store(pdNil)</span><br><span class="line">    pd.rd = <span class="number">0</span></span><br><span class="line">    pd.wseq++</span><br><span class="line">    pd.wg.Store(pdNil)</span><br><span class="line">    pd.wd = <span class="number">0</span></span><br><span class="line">    pd.self = pd</span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将fd加入epoll实例（平台相关）</span></span><br><span class="line">    errno := netpollopen(fd, pd)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        pollcache.free(pd)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="type">int</span>(errno)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回事件元数据、错误代码</span></span><br><span class="line">    <span class="keyword">return</span> pd, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台相关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建epoll事件</span></span><br><span class="line">    <span class="comment">// 1.1. 参数解读如下</span></span><br><span class="line">    <span class="comment">// EPOLLIN      =&gt; 可读</span></span><br><span class="line">    <span class="comment">// EPOLLOUT     =&gt; 可写</span></span><br><span class="line">    <span class="comment">// EPOLLRDHUP   =&gt; 连接被对端关闭（tcp服务器）</span></span><br><span class="line">    <span class="comment">// EPOLLET      =&gt; 边缘触发模式</span></span><br><span class="line">    <span class="keyword">var</span> ev syscall.EpollEvent</span><br><span class="line">    ev.Events = syscall.EPOLLIN | syscall.EPOLLOUT | syscall.EPOLLRDHUP | syscall.EPOLLET</span><br><span class="line">    <span class="comment">// 1.2. 将事件元数据pd组装成带标签的指针</span></span><br><span class="line">    <span class="comment">// pd指针放高48位，fdseq放低19位，这里交叉的3个位没搞懂</span></span><br><span class="line">    tp := taggedPointerPack(unsafe.Pointer(pd), pd.fdseq.Load())</span><br><span class="line">    <span class="comment">// 1.3. 绑定</span></span><br><span class="line">    *(*taggedPointer)(unsafe.Pointer(&amp;ev.Data)) = tp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将文件描述符fd加入epfd实例</span></span><br><span class="line">    <span class="keyword">return</span> syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个可用的事件元数据pollDesc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> alloc() *pollDesc &#123;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 链表为空</span></span><br><span class="line">    <span class="keyword">if</span> c.first == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> pdSize = unsafe.Sizeof(pollDesc&#123;&#125;)</span><br><span class="line">        <span class="comment">// n=4096/280=14</span></span><br><span class="line">        n := pollBlockSize / pdSize</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            n = <span class="number">1</span> <span class="comment">// 最低为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次性申请14个pollDesc的内存</span></span><br><span class="line">        <span class="comment">// 注意：这里必须位于非GC内存区域，epoll/queue内部使用</span></span><br><span class="line">        mem := persistentalloc(n*pdSize, <span class="number">0</span>, &amp;memstats.other_sys)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">            pd := (*pollDesc)(add(mem, i*pdSize))</span><br><span class="line">            lockInit(&amp;pd.lock, lockRankPollDesc)</span><br><span class="line">            pd.rt.init(<span class="literal">nil</span>, <span class="literal">nil</span>) <span class="comment">// 读定时器初始化</span></span><br><span class="line">            pd.wt.init(<span class="literal">nil</span>, <span class="literal">nil</span>) <span class="comment">// 写定时器初始化</span></span><br><span class="line">            pd.link = c.first    <span class="comment">// 放到cache链表</span></span><br><span class="line">            c.first = pd</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿链表头部第一个pollDesc</span></span><br><span class="line">    pd := c.first</span><br><span class="line">    c.first = pd.link</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> pd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把事件元数据pollDesc放到pollCache，留待后续使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> free(pd *pollDesc) &#123;</span><br><span class="line">    <span class="comment">// pd不能被共享</span></span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fdseq++，确保pd状态不会被设置为ready</span></span><br><span class="line">    fdseq := pd.fdseq.Load()</span><br><span class="line">    fdseq = (fdseq + <span class="number">1</span>) &amp; (<span class="number">1</span>&lt;&lt;taggedPointerBits - <span class="number">1</span>) <span class="comment">// fdseq++，保留低19位</span></span><br><span class="line">    pd.fdseq.Store(fdseq)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line"></span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把pollDesc放回cache链表的头部</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    pd.link = c.first</span><br><span class="line">    c.first = pd</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新atomicInfo错误标志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> setEventErr(b <span class="type">bool</span>, seq <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// fdseq1 =&gt; 参数值，只保留低20位</span></span><br><span class="line">    mSeq := <span class="type">uint32</span>(seq &amp; pollFDSeqMask)</span><br><span class="line">    <span class="comment">// 获取atomicInfo</span></span><br><span class="line">    x := pd.atomicInfo.Load()</span><br><span class="line">    <span class="comment">// fdseq2 =&gt; 事件元数据存储，atomicInfo丢弃低16位后再保留低20位</span></span><br><span class="line">    xSeq := (x &gt;&gt; pollFDSeq) &amp; pollFDSeqMask</span><br><span class="line">    <span class="comment">// 两者不相等</span></span><br><span class="line">    <span class="keyword">if</span> seq != <span class="number">0</span> &amp;&amp; xSeq != mSeq &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新错误标志失败时重试</span></span><br><span class="line">    <span class="comment">// 1. atomicInfo的错误标志跟b不同，表示错误标志变更</span></span><br><span class="line">    <span class="comment">// 2. 取反错误标志失败</span></span><br><span class="line">    <span class="keyword">for</span> (x&amp;pollEventErr != <span class="number">0</span>) != b &amp;&amp; !pd.atomicInfo.CompareAndSwap(x, x^pollEventErr) &#123;</span><br><span class="line">        <span class="comment">// 逻辑同上，这里应为double-check</span></span><br><span class="line">        x = pd.atomicInfo.Load()</span><br><span class="line">        xSeq := (x &gt;&gt; pollFDSeq) &amp; pollFDSeqMask</span><br><span class="line">        <span class="keyword">if</span> seq != <span class="number">0</span> &amp;&amp; xSeq != mSeq &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新atomicInfo字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> publishInfo() &#123;</span><br><span class="line">    <span class="keyword">var</span> info <span class="type">uint32</span></span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123; <span class="comment">// fd被移除出netpoll</span></span><br><span class="line">        info |= pollClosing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.rd &lt; <span class="number">0</span> &#123;  <span class="comment">// 读过期时刻，-1为已过期</span></span><br><span class="line">        info |= pollExpiredReadDeadline</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.wd &lt; <span class="number">0</span> &#123;  <span class="comment">// 写过期时刻，-1为已过期</span></span><br><span class="line">        info |= pollExpiredWriteDeadline</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fdseq低20位放到info高16位，没搞懂</span></span><br><span class="line">    info |= <span class="type">uint32</span>(pd.fdseq.Load()&amp;pollFDSeqMask) &lt;&lt; pollFDSeq</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧info</span></span><br><span class="line">    x := pd.atomicInfo.Load()</span><br><span class="line">    <span class="comment">// 旧info的错误标志位纪录到新的info，然后替换</span></span><br><span class="line">    <span class="keyword">for</span> !pd.atomicInfo.CompareAndSwap(x, (x&amp;pollEventErr)|info) &#123;</span><br><span class="line">        x = pd.atomicInfo.Load()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll移除文件描述符"><a href="#netpoll移除文件描述符" class="headerlink" title="netpoll移除文件描述符"></a>netpoll移除文件描述符</h2><p>将不再需要监听的文件描述符或网络连接从事件轮询中移除，以释放资源并停止对该描述符的轮询。逻辑如下</p>
<ol>
<li>guard，确认无异常情况</li>
<li>调用平台相关实现，如epoll实例，删除目标文件描述符fd</li>
<li>事件元数据清理<ul>
<li>fdseq++，确保pd状态不会被设置为ready</li>
<li>更新atomicInfo字段</li>
<li>把pd事件元数据放到cache链表的头部</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="comment">// 彻底删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollClose</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要先调用poll_runtime_pollUnblock</span></span><br><span class="line">    <span class="keyword">if</span> !pd.closing &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: close polldesc w/o unblock&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写G/读G状态异常</span></span><br><span class="line">    wg := pd.wg.Load()</span><br><span class="line">    <span class="keyword">if</span> wg != pdNil &amp;&amp; wg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked write on closing polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    rg := pd.rg.Load()</span><br><span class="line">    <span class="keyword">if</span> rg != pdNil &amp;&amp; rg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked read on closing polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// epoll删除fd</span></span><br><span class="line">    netpollclose(pd.fd)</span><br><span class="line">    <span class="comment">// 把pollDesc放回cache链表</span></span><br><span class="line">    pollcache.free(pd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台相关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollclose</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ev syscall.EpollEvent</span><br><span class="line">    <span class="comment">// EPOLL_CTL_DEL =&gt; 删除</span></span><br><span class="line">    <span class="keyword">return</span> syscall.EpollCtl(epfd, syscall.EPOLL_CTL_DEL, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll轮询事件"><a href="#netpoll轮询事件" class="headerlink" title="netpoll轮询事件"></a>netpoll轮询事件</h2><p>通常由调度器触发，轮询所有的I&#x2F;O事件并唤醒相应的goroutine。与netpollBreak搭配使用，目前用在findRunnable、startTheWorldWithSema、pollWork、sysmon函数。具体逻辑如下</p>
<ol>
<li>计算等待事件waitms</li>
<li>调用syscall.EpollWait来等待事件<ul>
<li>异常情况中断轮询</li>
<li>被中断，重新执行</li>
</ul>
</li>
<li>遍历所有发生的事件<ul>
<li>如果Events为0，跳过</li>
<li>如果是eventfd事件，检查类型、读取事件数据并重置事件标志</li>
<li>其他事件<ul>
<li>检查事件类型是读&#x2F;写</li>
<li>通过fdseq和tag判断是否已处理</li>
<li>调用netpollready处理事件</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>参数delay的说明如下</p>
<table>
<thead>
<tr>
<th align="left">delay</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt;0</td>
<td align="left">永久阻塞</td>
</tr>
<tr>
<td align="left">&#x3D;0</td>
<td align="left">非阻塞，轮训</td>
</tr>
<tr>
<td align="left">&gt;0</td>
<td align="left">阻塞delay时长，单位ms</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平台相关，不通用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> (gList, <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保epoll已初始化</span></span><br><span class="line">    <span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gList&#123;&#125;, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算等待时间（epoll需要毫秒）</span></span><br><span class="line">    <span class="keyword">var</span> waitms <span class="type">int32</span></span><br><span class="line">    <span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;              <span class="comment">// 无限等待</span></span><br><span class="line">        waitms = <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> delay == <span class="number">0</span> &#123;      <span class="comment">// 立刻返回，非阻塞</span></span><br><span class="line">        waitms = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e6</span> &#123;     <span class="comment">// 等待 1 毫秒</span></span><br><span class="line">        waitms = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e15</span> &#123;    <span class="comment">// 转换为毫秒</span></span><br><span class="line">        waitms = <span class="type">int32</span>(delay / <span class="number">1e6</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 超过最大值1e15，设置1e9，约为11.5天</span></span><br><span class="line">        waitms = <span class="number">1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 128个事件</span></span><br><span class="line">    <span class="keyword">var</span> events [<span class="number">128</span>]syscall.EpollEvent</span><br><span class="line">retry:</span><br><span class="line">    n, errno := syscall.EpollWait(epfd, events[:], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> errno != _EINTR &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: epollwait on fd&quot;</span>, epfd, <span class="string">&quot;failed with&quot;</span>, errno)</span><br><span class="line">            throw(<span class="string">&quot;runtime: netpoll failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被中断，重新执行</span></span><br><span class="line">        <span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gList&#123;&#125;, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> retry</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 待执行的 goroutines 列表</span></span><br><span class="line">    <span class="keyword">var</span> toRun gList</span><br><span class="line">    <span class="comment">// 累计处理事件</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 遍历所有发生的事件</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        ev := events[i]</span><br><span class="line">        <span class="comment">// 跳过，一般不为0</span></span><br><span class="line">        <span class="keyword">if</span> ev.Events == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// eventfd</span></span><br><span class="line">        <span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.Data)) == &amp;netpollEventFd &#123;</span><br><span class="line">            <span class="comment">// 是否可读</span></span><br><span class="line">            <span class="keyword">if</span> ev.Events != syscall.EPOLLIN &#123;</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;runtime: netpoll: eventfd ready for&quot;</span>, ev.Events)</span><br><span class="line">                throw(<span class="string">&quot;runtime: netpoll: eventfd ready for something unexpected&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> delay != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 读取事件数据</span></span><br><span class="line">                <span class="keyword">var</span> one <span class="type">uint64</span></span><br><span class="line">                read(<span class="type">int32</span>(netpollEventFd), noescape(unsafe.Pointer(&amp;one)), <span class="type">int32</span>(unsafe.Sizeof(one)))</span><br><span class="line">                <span class="comment">// 重置</span></span><br><span class="line">                netpollWakeSig.Store(<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他fd</span></span><br><span class="line">        <span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line">        <span class="comment">// 可读</span></span><br><span class="line">        <span class="keyword">if</span> ev.Events&amp;(syscall.EPOLLIN|syscall.EPOLLRDHUP|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">            mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可写</span></span><br><span class="line">        <span class="keyword">if</span> ev.Events&amp;(syscall.EPOLLOUT|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">            mode += <span class="string">&#x27;w&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 获取pollDesc以及fdseq</span></span><br><span class="line">            tp := *(*taggedPointer)(unsafe.Pointer(&amp;ev.Data))</span><br><span class="line">            pd := (*pollDesc)(tp.pointer()) <span class="comment">// *pollDesc</span></span><br><span class="line">            tag := tp.tag()                 <span class="comment">// fdseq</span></span><br><span class="line">            <span class="comment">// 只在获取/放回cache时改变</span></span><br><span class="line">            <span class="comment">// 如果fdseq不同，那么可能是过期的或重复使用的*pollDesc</span></span><br><span class="line">            <span class="keyword">if</span> pd.fdseq.Load() == tag &#123;</span><br><span class="line">                <span class="comment">// 更新atomicInfo错误标志</span></span><br><span class="line">                pd.setEventErr(ev.Events == syscall.EPOLLERR, tag)</span><br><span class="line">                <span class="comment">// 调用netpollready处理事件</span></span><br><span class="line">                delta += netpollready(&amp;toRun, pd, mode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toRun, delta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒goroutine，数据已经可读/可写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> rg, wg *g</span><br><span class="line">    <span class="comment">// 1. 唤醒goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rg/wg状态修改</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">true</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将唤醒的goroutine放到toRun列表</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        toRun.push(rg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        toRun.push(wg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累计唤醒的goroutine数量</span></span><br><span class="line">    <span class="keyword">return</span> delta</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rg/wg状态修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollunblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, ioready <span class="type">bool</span>, delta *<span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">    <span class="comment">// 读G/写G</span></span><br><span class="line">    gpp := &amp;pd.rg</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        gpp = &amp;pd.wg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pdReady/G pointer -&gt; pdReady</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := gpp.Load()</span><br><span class="line">        <span class="comment">// 已经是pdReady状态</span></span><br><span class="line">        <span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断io是否可读/写，超时/取消由runtime_pollWait负责判断</span></span><br><span class="line">        <span class="keyword">if</span> old == pdNil &amp;&amp; !ioready &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">new</span> := pdNil        <span class="comment">// 解除等待</span></span><br><span class="line">        <span class="keyword">if</span> ioready &#123;</span><br><span class="line">            <span class="built_in">new</span> = pdReady   <span class="comment">// 读/写就绪</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">if</span> gpp.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> old == pdWait &#123;          <span class="comment">// pdWait</span></span><br><span class="line">                old = pdNil</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> old != pdNil &#123;    <span class="comment">// G pointer</span></span><br><span class="line">                *delta -= <span class="number">1</span>             <span class="comment">// 挂起数量减一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (*g)(unsafe.Pointer(old))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打破当前I-O轮询循环"><a href="#打破当前I-O轮询循环" class="headerlink" title="打破当前I&#x2F;O轮询循环"></a>打破当前I&#x2F;O轮询循环</h2><p>打破当前的I&#x2F;O轮询循环，使得正在等待I&#x2F;O事件的goroutine能够被唤醒。与netpoll方法搭配使用，目前用在findRunnable和wakeNetPoller函数。具体逻辑如下</p>
<ol>
<li>guard，放置重复调用netpollBreak</li>
<li>中断信号准备</li>
<li>更新eventfd计数器，此时计数器的值不为0，epollWait被中断</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 防重验证</span></span><br><span class="line">    <span class="comment">// 标志为1，表示有其他G在执行当前函数</span></span><br><span class="line">    <span class="keyword">if</span> !netpollWakeSig.CompareAndSwap(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 数据准备</span></span><br><span class="line">    <span class="comment">// 中断信号数据</span></span><br><span class="line">    <span class="keyword">var</span> one <span class="type">uint64</span> = <span class="number">1</span></span><br><span class="line">    oneSize := <span class="type">int32</span>(unsafe.Sizeof(one))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发出信号，中断netpoll方法</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 更新eventfd计数器，此时计数器的值不为0，epollWait被中断</span></span><br><span class="line">        n := write(netpollEventFd, noescape(unsafe.Pointer(&amp;one)), oneSize)</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        <span class="keyword">if</span> n == oneSize &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被中断</span></span><br><span class="line">        <span class="keyword">if</span> n == -_EINTR &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 资源暂时不可用，如写缓冲区满</span></span><br><span class="line">        <span class="keyword">if</span> n == -_EAGAIN &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他异常</span></span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: netpollBreak write failed with&quot;</span>, -n)</span><br><span class="line">        throw(<span class="string">&quot;runtime: netpollBreak write failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为将要挂起的G设置超时"><a href="#为将要挂起的G设置超时" class="headerlink" title="为将要挂起的G设置超时"></a>为将要挂起的G设置超时</h2><p>通常在调用poll_runtime_pollWait之前使用，设置一个具体的超时时间，确保挂起的I&#x2F;O操作能够在指定的时间内完成。具体逻辑如下</p>
<ol>
<li>guard，已被移除出netpoll不处理</li>
<li>计算读&#x2F;写定时器新过期时刻、更新atomicInfo状态</li>
<li>修改读&#x2F;写定时器</li>
<li>rg&#x2F;wg状态修改，如果有读G&#x2F;写G需要唤醒，则唤醒并更新netpollWaiters计数器</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="type">int64</span>, mode <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 已被移除出netpoll</span></span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123;</span><br><span class="line">        unlock(&amp;pd.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取读G/写G旧过期时刻</span></span><br><span class="line">    rd0, wd0 := pd.rd, pd.wd</span><br><span class="line">    <span class="comment">// 是否读写都设置同一个过期时刻</span></span><br><span class="line">    combo0 := rd0 &gt; <span class="number">0</span> &amp;&amp; rd0 == wd0</span><br><span class="line">    <span class="keyword">if</span> d &gt; <span class="number">0</span> &#123;</span><br><span class="line">        d += nanotime()     <span class="comment">// 获取过期时刻-单调时钟</span></span><br><span class="line">        <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            d = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>   <span class="comment">// 溢出时设为最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置读G/写G新过期时刻</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        pd.rd = d</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        pd.wd = d</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line"></span><br><span class="line">    combo := pd.rd &gt; <span class="number">0</span> &amp;&amp; pd.rd == pd.wd</span><br><span class="line">    <span class="comment">// 选择定时器过期时触发的函数</span></span><br><span class="line">    rtf := netpollReadDeadline</span><br><span class="line">    <span class="keyword">if</span> combo &#123;</span><br><span class="line">        rtf = netpollDeadline</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读/写过期定时器是否在运行</span></span><br><span class="line">    <span class="keyword">if</span> !pd.rrun &#123;</span><br><span class="line">        <span class="comment">// 没有运行rt</span></span><br><span class="line">        <span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间</span></span><br><span class="line">            pd.rt.modify(pd.rd, <span class="number">0</span>, rtf, pd.makeArg(), pd.rseq)</span><br><span class="line">            pd.rrun = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.rd != rd0 || combo != combo0 &#123;</span><br><span class="line">        <span class="comment">// 有运行rt，但现在过期时刻有修改</span></span><br><span class="line">        pd.rseq++ <span class="comment">// 版本更新</span></span><br><span class="line">        <span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间</span></span><br><span class="line">            pd.rt.modify(pd.rd, <span class="number">0</span>, rtf, pd.makeArg(), pd.rseq)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &lt;=0，已过期</span></span><br><span class="line">            pd.rt.stop()</span><br><span class="line">            pd.rrun = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !pd.wrun &#123;</span><br><span class="line">        <span class="comment">// 没有运行wt</span></span><br><span class="line">        <span class="keyword">if</span> pd.wd &gt; <span class="number">0</span> &amp;&amp; !combo &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间，且读/写过期时刻不同</span></span><br><span class="line">            pd.wt.modify(pd.wd, <span class="number">0</span>, netpollWriteDeadline, pd.makeArg(), pd.wseq)</span><br><span class="line">            pd.wrun = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.wd != wd0 || combo != combo0 &#123;</span><br><span class="line">        <span class="comment">// 有运行wt，但现在过期时刻有修改</span></span><br><span class="line">        pd.wseq++ <span class="comment">// 版本更新</span></span><br><span class="line">        <span class="keyword">if</span> pd.wd &gt; <span class="number">0</span> &amp;&amp; !combo &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间，且读/写过期时刻不同</span></span><br><span class="line">            pd.wt.modify(pd.wd, <span class="number">0</span>, netpollWriteDeadline, pd.makeArg(), pd.wseq)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &lt;=0，已过期</span></span><br><span class="line">            pd.wt.stop()</span><br><span class="line">            pd.wrun = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计唤醒的G数量</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> rg, wg *g</span><br><span class="line">    <span class="comment">// rg/wg状态修改，ioready为false，不一定有G被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> pd.rd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.wd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 唤醒读G/写G</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(rg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(wg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">    netpollAdjustWaiters(delta)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写定时器同时刻过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollDeadline</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读定时器过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollReadDeadline</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写定时器过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollWriteDeadline</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读/写定时器过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpolldeadlineimpl</span><span class="params">(pd *pollDesc, seq <span class="type">uintptr</span>, read, write <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 获取pollDesc当前版本的seq</span></span><br><span class="line">    currentSeq := pd.rseq</span><br><span class="line">    <span class="keyword">if</span> !read &#123;</span><br><span class="line">        <span class="comment">// 读写放rseq，只写放wseq</span></span><br><span class="line">        currentSeq = pd.wseq</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新旧版本号不一致，pd可能被重用或定时器reset</span></span><br><span class="line">    <span class="keyword">if</span> seq != currentSeq &#123;</span><br><span class="line">        unlock(&amp;pd.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计唤醒的G数量</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> rg *g</span><br><span class="line">    <span class="comment">// 读或读写</span></span><br><span class="line">    <span class="keyword">if</span> read &#123;</span><br><span class="line">        <span class="keyword">if</span> pd.rd &lt;= <span class="number">0</span> || !pd.rrun &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: inconsistent read deadline&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -1为已过期</span></span><br><span class="line">        pd.rd = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">        pd.publishInfo()</span><br><span class="line">        <span class="comment">// rg状态修改，ioready为false，不一定有goroutine被唤醒</span></span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> wg *g</span><br><span class="line">    <span class="keyword">if</span> write &#123;</span><br><span class="line">        <span class="keyword">if</span> pd.wd &lt;= <span class="number">0</span> || !pd.wrun &amp;&amp; !read &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: inconsistent write deadline&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -1为已过期</span></span><br><span class="line">        pd.wd = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">        pd.publishInfo()</span><br><span class="line">        <span class="comment">// wg状态修改，ioready为false，不一定有goroutine被唤醒</span></span><br><span class="line">        wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 唤醒读G/写G</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(rg, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(wg, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">    netpollAdjustWaiters(delta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollgoready</span><span class="params">(gp *g, traceskip <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    goready(gp, traceskip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollAdjustWaiters</span><span class="params">(delta <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> delta != <span class="number">0</span> &#123;</span><br><span class="line">        netpollWaiters.Add(delta)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> makeArg() (i any) &#123;</span><br><span class="line">    x := (*eface)(unsafe.Pointer(&amp;i))   <span class="comment">// 转换成interface&#123;&#125;</span></span><br><span class="line">    x._type = pdType                    <span class="comment">// 类型为pollDesc</span></span><br><span class="line">    x.data = unsafe.Pointer(&amp;pd.self)   <span class="comment">// 指向pollDesc实例</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重置当前G的状态"><a href="#重置当前G的状态" class="headerlink" title="重置当前G的状态"></a>重置当前G的状态</h2><p>不管是因为何种原因，如果当前G需要重新进入队列进行新的轮询，就需要调用该函数进行状态重置。在执行poll_runtime_pollWait之前设置。具体逻辑如下</p>
<ol>
<li>检测atomicInfo标志位，查看是否有异常</li>
<li>读G&#x2F;写G状态重置为pdNil</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollReset</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 查看atomicInfo是否有错误标志</span></span><br><span class="line">    errcode := netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">    <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">        <span class="keyword">return</span> errcode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读G/写G状态重置</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> &#123;</span><br><span class="line">        pd.rg.Store(pdNil)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        pd.wg.Store(pdNil)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看atomicInfo是否有错误标志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollcheckerr</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// atomicInfo</span></span><br><span class="line">    info := pd.info()</span><br><span class="line">    <span class="comment">// pollClosing标志位是否已设置</span></span><br><span class="line">    <span class="keyword">if</span> info.closing() &#123;</span><br><span class="line">        <span class="keyword">return</span> pollErrClosing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读过期或写过期</span></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; info.expiredReadDeadline()) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; info.expiredWriteDeadline()) &#123;</span><br><span class="line">        <span class="keyword">return</span> pollErrTimeout</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读发生错误，写错误在写时处理，有更详细的错误信息</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; info.eventErr() &#123;</span><br><span class="line">        <span class="keyword">return</span> pollErrNotPollable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="当前G挂起等待事件发生"><a href="#当前G挂起等待事件发生" class="headerlink" title="当前G挂起等待事件发生"></a>当前G挂起等待事件发生</h2><p>将当前goroutine挂起，并等待事件通知，与poll_runtime_pollUnblock搭配使用。具体逻辑如下</p>
<ol>
<li>检测atomicInfo标志位，查看是否有异常</li>
<li>尝试将rg或wg状态改为pdWait，准备挂起</li>
<li>调用gopark将当前goroutine挂起等待，挂起前将rg或wg状态改为goroutine指针</li>
<li>被唤醒后，把当前状态（已准备好还是超时）告知上层函数</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 查看atomicInfo是否有错误标志</span></span><br><span class="line">    errcode := netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">    <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">        <span class="keyword">return</span> errcode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要使用水平触发的系统</span></span><br><span class="line">    <span class="keyword">if</span> GOOS == <span class="string">&quot;solaris&quot;</span> || GOOS == <span class="string">&quot;illumos&quot;</span> || GOOS == <span class="string">&quot;aix&quot;</span> || GOOS == <span class="string">&quot;wasip1&quot;</span> &#123;</span><br><span class="line">        netpollarm(pd, mode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前goroutine挂起休眠，唤醒后，rg/wg可读/写返回true</span></span><br><span class="line">    <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        errcode = netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">        <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">            <span class="keyword">return</span> errcode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, waitio <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 根据mode选择读G/写G</span></span><br><span class="line">    gpp := &amp;pd.rg</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        gpp = &amp;pd.wg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为pdWait状态</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 已经ready，返回</span></span><br><span class="line">        <span class="comment">// pdReady -&gt; pdNil</span></span><br><span class="line">        <span class="keyword">if</span> gpp.CompareAndSwap(pdReady, pdNil) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进入等待</span></span><br><span class="line">        <span class="comment">// pdNil -&gt; pdWait</span></span><br><span class="line">        <span class="keyword">if</span> gpp.CompareAndSwap(pdNil, pdWait) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常情况</span></span><br><span class="line">        <span class="keyword">if</span> v := gpp.Load(); v != pdReady &amp;&amp; v != pdNil &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: double wait&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pdWait or atomicInfo没有错误标志</span></span><br><span class="line">    <span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == pollNoError &#123;</span><br><span class="line">        <span class="comment">// 挂起等待，pdWait -&gt; goroutine指针，netpollWaiters++</span></span><br><span class="line">        gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceBlockNet, <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态设为pdNil</span></span><br><span class="line">    old := gpp.Swap(pdNil)</span><br><span class="line">    <span class="comment">// 如果old是goroutine的指针</span></span><br><span class="line">    <span class="keyword">if</span> old &gt; pdWait &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: corrupted polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起前处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblockcommit</span><span class="params">(gp *g, gpp unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// pdWait -&gt; goroutine指针</span></span><br><span class="line">    r := atomic.Casuintptr((*<span class="type">uintptr</span>)(gpp), pdWait, <span class="type">uintptr</span>(unsafe.Pointer(gp)))</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">    <span class="keyword">if</span> r &#123;</span><br><span class="line">        <span class="comment">// 计数器+1 =&gt; netpollWaiters++</span></span><br><span class="line">        netpollAdjustWaiters(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件发生唤醒挂起的G"><a href="#事件发生唤醒挂起的G" class="headerlink" title="事件发生唤醒挂起的G"></a>事件发生唤醒挂起的G</h2><p>事件发生时，唤醒被挂起等待的goroutine，与poll_runtime_pollWait搭配使用。具体逻辑如下</p>
<ol>
<li>guard，确保不会反复unblock已被移除出netpoll的pollDesc</li>
<li>事件元数据pollDesc更新<ul>
<li>计数器、atomicInfo、rg&#x2F;wg、读&#x2F;写定时器状态更新</li>
</ul>
</li>
<li>唤醒读G&#x2F;写G，并更新netpollWaiters计数器</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollUnblock</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 已被移除出netpoll</span></span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: unblock on closing polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pd.closing = <span class="literal">true</span></span><br><span class="line">    pd.rseq++</span><br><span class="line">    pd.wseq++</span><br><span class="line">    <span class="keyword">var</span> rg, wg *g</span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line">    <span class="comment">// 累计唤醒的G数量</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// rg/wg状态修改</span></span><br><span class="line">    rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    <span class="comment">// 停止读/写定时器</span></span><br><span class="line">    <span class="keyword">if</span> pd.rrun &#123;</span><br><span class="line">        pd.rt.stop()</span><br><span class="line">        pd.rrun = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.wrun &#123;</span><br><span class="line">        pd.wt.stop()</span><br><span class="line">        pd.wrun = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 唤醒读G/写G</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(rg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(wg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">    netpollAdjustWaiters(delta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://copyconstruct.medium.com/the-method-to-epolls-madness-d9d2d6378642">The method to epoll’s madness</a><br><a href="https://www.sobyte.net/post/2021-09/golang-netpoll/">golang netpoll Explained</a><br><a href="https://juejin.cn/post/6989608237226000391">Linux fd 系列 — eventfd 是什么？</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-map</title>
    <url>/golang-series-map-noswiss/</url>
    <content><![CDATA[<p>map&#x2F;哈希表，是golang常用的数据结构之一，也充当set数据结构的存在，相对slice要复杂很多。从1.24开始，swiss table替代noswiss成为默认实现，swiss与noswiss区别在于，swiss使用开放地址法，noswiss使用拉链法</p>
<p>当前go版本：1.23</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// hmap -&gt; oldbuckets</span></span><br><span class="line"><span class="comment">//      -&gt; buckets         -&gt; bmap0(8个key/value对) </span></span><br><span class="line"><span class="comment">//                         -&gt; bmap1 -&gt; overflow0(bmapX) -&gt; overflow1(bmapZ)</span></span><br><span class="line"><span class="comment">//                         -&gt; ...  </span></span><br><span class="line"><span class="comment">//                         -&gt; bmapM -&gt; overflow0(bmapY)</span></span><br><span class="line"><span class="comment">//                         -&gt; bmapN</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      -&gt; extra.overflow  -&gt; bmapX(pre-alloc)</span></span><br><span class="line"><span class="comment">//                         -&gt; bmapY(pre-alloc)</span></span><br><span class="line"><span class="comment">//                         -&gt; ...</span></span><br><span class="line"><span class="comment">//                         -&gt; bmapZ(new-alloc)</span></span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure>

<p>map的数据结构如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span>              <span class="comment">// 元素数量-key/value对</span></span><br><span class="line">    flags     <span class="type">uint8</span>            <span class="comment">// 1-iter正在使用buckets字段 2-iter正在使用oldbuckets字段 4-正在写入 8-同等大小扩容</span></span><br><span class="line">    B         <span class="type">uint8</span>            <span class="comment">// buckets数量=(loadFactor * 2^B)</span></span><br><span class="line">    noverflow <span class="type">uint16</span>           <span class="comment">// 统计溢出buckets的数量，当B大于15时不是精确值</span></span><br><span class="line">    hash0     <span class="type">uint32</span>           <span class="comment">// 哈希种子，计算hash用</span></span><br><span class="line">    buckets    unsafe.Pointer  <span class="comment">// buckets数组</span></span><br><span class="line">    oldbuckets unsafe.Pointer  <span class="comment">// 旧buckets数组，扩容时用</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>         <span class="comment">// 下一个未疏散的bucket索引</span></span><br><span class="line">    clearSeq   <span class="type">uint64</span>          <span class="comment">// 执行过多少次clear</span></span><br><span class="line">    extra *mapextra            <span class="comment">// 可选字段，不是每个map都需要，同时也需要为gc考虑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key/value都不是指针才会使用下面几个字段</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap       <span class="comment">// 溢出buckets，buckets链接使用</span></span><br><span class="line">    oldoverflow *[]*bmap       <span class="comment">// 溢出buckets，oldbuckets链接使用，扩容时</span></span><br><span class="line">    nextOverflow *bmap         <span class="comment">// 下一个可用/未使用overflow的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket结构，可存储8个key/value对及其他数据，编译时自动补充其余结构，真实结构如下</span></span><br><span class="line"><span class="comment">//    A &quot;bucket&quot; is a &quot;struct&quot; &#123;</span></span><br><span class="line"><span class="comment">//          tophash [abi.MapBucketCount]uint8  // hash的高8位</span></span><br><span class="line"><span class="comment">//          keys [abi.MapBucketCount]keyType   // 所有key</span></span><br><span class="line"><span class="comment">//          elems [abi.MapBucketCount]elemType // 所有value</span></span><br><span class="line"><span class="comment">//          overflow *bucket // 下一个溢出桶指针</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">// 详细可见MapBucketType函数（src/cmd/compile/internal/reflectdata/reflect.go）</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// abi.MapBucketCount=8</span></span><br><span class="line">    <span class="comment">// 0-默认状态 1-已删除 2-疏散到x 3-疏散到y 4-不需要疏散 5-guard xyz(&gt;5)-正常tophash值</span></span><br><span class="line">    <span class="comment">// 状态转移如下：</span></span><br><span class="line">    <span class="comment">// 0/xyz -&gt; 2/3/4 =&gt; 如果所有bucket都疏散完毕，会一次性清空释放</span></span><br><span class="line">    <span class="comment">// 0/xyz -&gt; 1 删除 =&gt; 如果idx+1的状态是0，则向前寻找状态为1数据并改为0</span></span><br><span class="line">    tophash [abi.MapBucketCount]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面数据结构中中比较关键的是</p>
<ul>
<li><code>hmap</code> - header部份，var变量存储的也是这部份</li>
<li><code>buckets</code> - 指向一片连续内存区域，bucket数组</li>
<li><code>bmap</code> - bucket的具体实现，可以存储8个key&#x2F;value对，尾部overflow是溢出bucket的指针</li>
</ul>
<span id="more"></span>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>map的初始化方式有两种</p>
<ol>
<li>使用字面量创建map</li>
<li>使用关键字make创建</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(v1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// make关键字</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">v2[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">fmt.Println(v2)</span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量初始化调用的是maplit，具体看代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/walk/complit.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maplit</span><span class="params">(n *ir.CompLitExpr, m ir.Node, init *ir.Nodes)</span></span> &#123;</span><br><span class="line">    args := []ir.Node&#123;ir.TypeNode(n.Type()), ir.NewInt(base.Pos, n.Len+<span class="type">int64</span>(<span class="built_in">len</span>(n.List)))&#125;</span><br><span class="line">    a := typecheck.Expr(ir.NewCallExpr(base.Pos, ir.OMAKE, <span class="literal">nil</span>, args)).(*ir.MakeExpr)</span><br><span class="line">    a.RType = n.RType</span><br><span class="line">    a.SetEsc(n.Esc())</span><br><span class="line">    appendWalkStmt(init, ir.NewAssignStmt(base.Pos, m, a))</span><br><span class="line"></span><br><span class="line">    entries := n.List</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> entries &#123;</span><br><span class="line">        r := r.(*ir.KeyExpr)</span><br><span class="line">        <span class="keyword">if</span> !isStaticCompositeLiteral(r.Key) || !isStaticCompositeLiteral(r.Value) &#123;</span><br><span class="line">            base.Fatalf(<span class="string">&quot;maplit: entry is not a literal: %v&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(entries) &gt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// loop adding structure elements to map</span></span><br><span class="line">        <span class="comment">// for i = 0; i &lt; len(vstatk); i++ &#123;</span></span><br><span class="line">        <span class="comment">//    map[vstatk[i]] = vstate[i]</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，如果小于等于25个元素，直接赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>如果，大于25个元素，分key&#x2F;value两组，使用for循环进行赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstatk); i++ &#123;</span><br><span class="line">    <span class="keyword">map</span>[vstatk[i]] = vstate[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>当使用make关键字初始化map时，调用的是makemap，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">    <span class="comment">// 1. mem（连续内存区域大小） = 元素类型占用大小(type_size)*数量(hint)</span></span><br><span class="line">    <span class="comment">// 2. overflow（是否溢出） = !(type_size|hint &lt; 4GB or type_size=0 or hint &gt; uint_max/type_size)</span></span><br><span class="line">    mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.Bucket.Size_)</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">        hint = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize Hmap</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h = <span class="built_in">new</span>(hmap)</span><br><span class="line">    &#125;</span><br><span class="line">    h.hash0 = <span class="type">uint32</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算B的大小</span></span><br><span class="line">    <span class="comment">// hint &lt;= 8 ？=&gt; B = 0</span></span><br><span class="line">    B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 数据量大于8且已经超过80%的饱和度</span></span><br><span class="line">    <span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">        B++</span><br><span class="line">    &#125;</span><br><span class="line">    h.B = B</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// B!=0则申请内存创建buckets和overflow</span></span><br><span class="line">    <span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">        h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">            h.extra.nextOverflow = nextOverflow</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量超过8且超到80%的饱和度（13/16 =&gt; 81.25%）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 数量 &gt; 8 and 数量 &gt; (13*2^B/2)</span></span><br><span class="line">    <span class="keyword">return</span> count &gt; abi.MapBucketCount &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buckets、overflow等字段初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">    base := bucketShift(b) <span class="comment">// 2^b</span></span><br><span class="line">    nbuckets := base</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于等于2^4=16个元素时，多准备b-4个bucket用于overflow</span></span><br><span class="line">    <span class="comment">// 比如b=4时，共有16个元素，极端情况下都放在同一个bucket，那么需要一个额外的overflow</span></span><br><span class="line">    <span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">        nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">        sz := t.Bucket.Size_ * nbuckets</span><br><span class="line">        up := roundupsize(sz, !t.Bucket.Pointers()) <span class="comment">// 按tcmalloc规则向上取整</span></span><br><span class="line">        <span class="keyword">if</span> up != sz &#123;</span><br><span class="line">            nbuckets = up / t.Bucket.Size_</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新map</span></span><br><span class="line">    <span class="keyword">if</span> dirtyalloc == <span class="literal">nil</span> &#123;</span><br><span class="line">        buckets = newarray(t.Bucket, <span class="type">int</span>(nbuckets))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 清理dirtyalloc，一般用于mapclear</span></span><br><span class="line">        buckets = dirtyalloc</span><br><span class="line">        size := t.Bucket.Size_ * nbuckets</span><br><span class="line">        <span class="keyword">if</span> t.Bucket.Pointers() &#123;</span><br><span class="line">            memclrHasPointers(buckets, size)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memclrNoHeapPointers(buckets, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有overflow，计算nextOverflow指针</span></span><br><span class="line">    <span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">        nextOverflow = (*bmap)(add(buckets, base*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        last.setoverflow(t, (*bmap)(buckets)) <span class="comment">// 防止nil pointer，将其弄成环形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概的逻辑如下</p>
<ol>
<li>新生成hmap</li>
<li>初始状态修改<ul>
<li>hash种子初始化</li>
<li>计算B，如果hint&lt;&#x3D;8则B为0</li>
</ul>
</li>
<li>如果B!&#x3D;0，初始化buckets数组</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>hint超过BUCKETSIZE则放置在heap，否则放在stack</li>
<li>key与value最大为128个字节，超过这个值则会转成指针</li>
</ol>
<p>B的计算示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">50</span> &#123;</span><br><span class="line">    b := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> overLoadFactor(i, b) &#123;</span><br><span class="line">        b++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;hint=%d; b=%d\n&quot;</span>, i, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<table>
<thead>
<tr>
<th align="left">hint</th>
<th align="left">B</th>
<th align="left">bucket count</th>
<th align="left">capacity</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[0,8]</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">[9,13]</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">[14,26]</td>
<td align="left">2</td>
<td align="left">4</td>
<td align="left">32</td>
</tr>
<tr>
<td align="left">[27,52]</td>
<td align="left">3</td>
<td align="left">8</td>
<td align="left">64</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
</tbody></table>
<p>loadFactorNum&#x3D;13是一个关键数据，右边界&#x3D;13*2^(B-1)</p>
<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><h3 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h3><p>使用索引获取map的数值有两种</p>
<ol>
<li>仅接受一个参数</li>
<li>接受两个参数</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅接受一个参数</span></span><br><span class="line">v := h[key]</span><br><span class="line"><span class="comment">// 接受两个参数</span></span><br><span class="line">v, ok := h[key]</span><br></pre></td></tr></table></figure>

<p>当仅接受一个参数时，底层使用mapaccess1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := mapKeyError(t, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">    <span class="comment">// 2^b-1</span></span><br><span class="line">    m := bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，扩容中</span></span><br><span class="line">    <span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 不是同等大小扩容，mask丢弃一位</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上，计算并移动指针指向目标bucket，这里是oldbuckets</span></span><br><span class="line">        oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        <span class="comment">// 是否已疏散，否，数据还在原位</span></span><br><span class="line">        <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">            b = oldb</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">    <span class="comment">// 进入循环</span></span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对tophash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="comment">// index后面的索引位置都为空，退出循环</span></span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不是目标数据，继续比对下一个</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="comment">// bucket的key是指针</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两个key相等</span></span><br><span class="line">            <span class="keyword">if</span> t.Key.Equal(key, k) &#123;</span><br><span class="line">                <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="comment">// bucket的value是指针</span></span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    e = *((*unsafe.Pointer)(e))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到，返回0值</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当接受两个参数时，底层使用mapaccess2，其与mapaccess1只有返回值的不同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// mapaccess2与mapaccess1基本一致，只是返回值不同</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>]), <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里补充两个用到的函数注释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否已疏散</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuated</span><span class="params">(b *bmap)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    h := b.tophash[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 如果第一个tophash的值在(1,5)之间，说明这个bucket已经疏散了</span></span><br><span class="line">    <span class="keyword">return</span> h &gt; emptyOne &amp;&amp; h &lt; minTopHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">    <span class="comment">// 获取hash的高8位</span></span><br><span class="line">    top := <span class="type">uint8</span>(hash &gt;&gt; (goarch.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">    <span class="comment">// 异常处理，加上偏移值minTopHash=5，否则容易与预设值冲突导致误判</span></span><br><span class="line">    <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历访问"><a href="#遍历访问" class="headerlink" title="遍历访问"></a>遍历访问</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用for range遍历整个map时，依赖hiter、mapiterinit、mapiternext实现该操作，大概过程如下</p>
<ol>
<li>调用mapiterinit创建hiter</li>
<li>纪录指定map的状态信息<ul>
<li>复制指定map的状态属性</li>
<li>用随机数计算出一个bucket的索引和offset，用来无序化输出</li>
<li>返回第一个key&#x2F;value对</li>
</ul>
</li>
<li>调用mapiternext，获取并存储第一个key&#x2F;value地址</li>
<li>上层函数继续调用mapiternext，获取并存储下一个key&#x2F;value地址，或者主动终止循环</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go</span></span><br><span class="line"><span class="comment">// 纪录指定map状态</span></span><br><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    key         unsafe.Pointer <span class="comment">// key，为nil时表示结束</span></span><br><span class="line">    elem        unsafe.Pointer <span class="comment">// value</span></span><br><span class="line">    t           *maptype       <span class="comment">// 类型</span></span><br><span class="line">    h           *hmap          <span class="comment">// header</span></span><br><span class="line">    buckets     unsafe.Pointer <span class="comment">// bucket指针</span></span><br><span class="line">    bptr        *bmap          <span class="comment">// 当前bucket指针</span></span><br><span class="line">    overflow    *[]*bmap       <span class="comment">// 指向overflow</span></span><br><span class="line">    oldoverflow *[]*bmap       <span class="comment">// 指向oldoverflow</span></span><br><span class="line">    startBucket <span class="type">uintptr</span>        <span class="comment">// 初始bucket索引 -&gt; head</span></span><br><span class="line">    offset      <span class="type">uint8</span>          <span class="comment">// 初始偏移-用于tophash索引匹配</span></span><br><span class="line">    wrapped     <span class="type">bool</span>           <span class="comment">// rand_idx -&gt; max_idx(7) -&gt; min_idx(0) -&gt; rand_idx</span></span><br><span class="line">    B           <span class="type">uint8</span>          <span class="comment">// h.B</span></span><br><span class="line">    i           <span class="type">uint8</span>          <span class="comment">// tophash索引</span></span><br><span class="line">    bucket      <span class="type">uintptr</span>        <span class="comment">// 当前bucket索引 -&gt; curr</span></span><br><span class="line">    checkBucket <span class="type">uintptr</span>        <span class="comment">// 扩容中且未疏散指定bucket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建hiter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">    it.t = t</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iter大小异常？</span></span><br><span class="line">    <span class="keyword">if</span> unsafe.Sizeof(hiter&#123;&#125;)/goarch.PtrSize != <span class="number">12</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;hash_iter size incorrect&quot;</span>) <span class="comment">// see cmd/compile/internal/reflectdata/reflect.go</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指向map</span></span><br><span class="line">    it.h = h</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制map当前属性</span></span><br><span class="line">    it.B = h.B</span><br><span class="line">    it.buckets = h.buckets</span><br><span class="line">    <span class="keyword">if</span> !t.Bucket.Pointers() &#123;</span><br><span class="line">        h.createOverflow()</span><br><span class="line">        it.overflow = h.extra.overflow</span><br><span class="line">        it.oldoverflow = h.extra.oldoverflow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一个随机的bucket索引以及offset作为扫描的开始地址</span></span><br><span class="line">    r := <span class="type">uintptr</span>(rand())</span><br><span class="line">    <span class="comment">// 取低B位-&gt;bucket索引</span></span><br><span class="line">    it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 丢掉低B位后再取低3位作为offset</span></span><br><span class="line">    it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (abi.MapBucketCount - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// curr指向head</span></span><br><span class="line">    it.bucket = it.startBucket</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个iter</span></span><br><span class="line">    <span class="keyword">if</span> old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;</span><br><span class="line">        atomic.Or8(&amp;h.flags, iterator|oldIterator)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapiternext(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指向map</span></span><br><span class="line">    h := it.h</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t := it.t</span><br><span class="line">    <span class="comment">// curr索引</span></span><br><span class="line">    bucket := it.bucket</span><br><span class="line">    <span class="comment">// nil-初始值（第一次访问的时候）</span></span><br><span class="line">    b := it.bptr</span><br><span class="line">    <span class="comment">// 0-初始值（第一次访问的时候）</span></span><br><span class="line">    i := it.i</span><br><span class="line">    <span class="comment">// 0-初始值（第一次访问的时候）</span></span><br><span class="line">    checkBucket := it.checkBucket</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">    <span class="comment">// 开始/结束时</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 回到了最初的位置，终止</span></span><br><span class="line">        <span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line">            it.key = <span class="literal">nil</span> <span class="comment">// 表示终止</span></span><br><span class="line">            it.elem = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是扩容时创建的iter</span></span><br><span class="line">        <span class="keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;</span><br><span class="line">            <span class="comment">// 先看oldbuckets</span></span><br><span class="line">            oldbucket := bucket &amp; it.h.oldbucketmask()</span><br><span class="line">            b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            <span class="comment">// 还没疏散</span></span><br><span class="line">            <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">                checkBucket = bucket</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 已疏散</span></span><br><span class="line">                b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">                checkBucket = noCheck</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有发生扩容或者扩容前创建的iter</span></span><br><span class="line">            b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            checkBucket = noCheck</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针继续指向下一个bucket</span></span><br><span class="line">        bucket++</span><br><span class="line">        <span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">            bucket = <span class="number">0</span></span><br><span class="line">            it.wrapped = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tophash索引回到0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bucket以及overflow逐个元素扫描</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">        <span class="comment">// 因为有offset的原因，offi =&gt; offset -&gt; 7 -&gt; 0 -&gt; offset</span></span><br><span class="line">        offi := (i + it.offset) &amp; (abi.MapBucketCount - <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 该位置全新或已删除或已疏散</span></span><br><span class="line">        <span class="keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">        k := add(unsafe.Pointer(b), dataOffset+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">            k = *((*unsafe.Pointer)(k))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">        e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">        <span class="comment">// 双倍扩容且未疏散</span></span><br><span class="line">        <span class="keyword">if</span> checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="keyword">if</span> t.ReflexiveKey() || t.Key.Equal(k, k) &#123;</span><br><span class="line">                hash := t.Hasher(k, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">                <span class="comment">// iter以新index为准，如果疏散的目的index与新index不同，跳过</span></span><br><span class="line">                <span class="keyword">if</span> hash&amp;bucketMask(it.B) != checkBucket &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// NaN判断，同上，checkBucket最高位与tophash最低位比较，不相等则跳过，一切以新index为准</span></span><br><span class="line">                <span class="keyword">if</span> checkBucket&gt;&gt;(it.B<span class="number">-1</span>) != <span class="type">uintptr</span>(b.tophash[offi]&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前面已经排除了空值</span></span><br><span class="line">        <span class="comment">// 未疏散 or key!=key（NaN）</span></span><br><span class="line">        <span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||</span><br><span class="line">            !(t.ReflexiveKey() || t.Key.Equal(k, k)) &#123;</span><br><span class="line">            <span class="comment">// NaN无法被更新/删除，无需再判断是否为nil</span></span><br><span class="line">            it.key = k</span><br><span class="line">            <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                e = *((*unsafe.Pointer)(e))</span><br><span class="line">            &#125;</span><br><span class="line">            it.elem = e</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已疏散 用mapaccessK获取key/value</span></span><br><span class="line">            rk, re := mapaccessK(t, h, k)</span><br><span class="line">            <span class="keyword">if</span> rk == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">// key has been deleted</span></span><br><span class="line">            &#125;</span><br><span class="line">            it.key = rk</span><br><span class="line">            it.elem = re</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存iter状态</span></span><br><span class="line">        it.bucket = bucket</span><br><span class="line">        <span class="keyword">if</span> it.bptr != b &#123; <span class="comment">// avoid unnecessary write barrier; see issue 14921</span></span><br><span class="line">            it.bptr = b</span><br><span class="line">        &#125;</span><br><span class="line">        it.i = i + <span class="number">1</span></span><br><span class="line">        it.checkBucket = checkBucket</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描overflow</span></span><br><span class="line">    b = b.overflow(t)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时，根据key从新的bucket数组获取key/value地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccessK</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">    <span class="comment">// 2^b-1</span></span><br><span class="line">    m := bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，扩容中</span></span><br><span class="line">    <span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 不是同等大小扩容，mask丢弃一位</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上，计算并移动指针指向目标bucket，这里是oldbuckets</span></span><br><span class="line">        oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        <span class="comment">// 是否已疏散，否，数据还在原位</span></span><br><span class="line">        <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">            b = oldb</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对tophash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 当前位置以及后面位置都没有数据了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不是目标数据，继续比对下一个</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两个key相等</span></span><br><span class="line">            <span class="keyword">if</span> t.Key.Equal(key, k) &#123;</span><br><span class="line">                <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    e = *((*unsafe.Pointer)(e))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> k, e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">v1[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>系统调用mapassign实现map的赋值操作，大概逻辑如下</p>
<ol>
<li>确保map已经初始化</li>
<li>计算key的hash值</li>
<li>判断是否需要扩容？是，则先扩容</li>
<li>算出目标bucket的位置</li>
<li>判断是否在扩容中？是，则疏散旧bucket</li>
<li>扫描整个目标bucket，包括overflow，找到可写入的位置</li>
<li>返回value的指针，由上层更新数值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据key查找value并获得指向value的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 为nil，未初始化</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;assignment to entry in nil map&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置flag，防止同时写入</span></span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时B=0，延迟</span></span><br><span class="line">    <span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        h.buckets = newobject(t.Bucket) <span class="comment">// newarray(t.Bucket, 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 获取低B位hash值，用于计算桶索引</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，即为扩容中</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// 疏散指定bucket</span></span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inserti *<span class="type">uint8</span> <span class="comment">// tophash索引</span></span><br><span class="line">    <span class="keyword">var</span> insertk unsafe.Pointer <span class="comment">// key索引</span></span><br><span class="line">    <span class="keyword">var</span> elem unsafe.Pointer <span class="comment">// value索引</span></span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对hash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="comment">// 1. 没找到key</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 该位置全新或已删除 and index还没找到 -&gt; 找到一个空的位置</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">                    inserti = &amp;b.tophash[i]</span><br><span class="line">                    <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">                    insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                    <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">                    elem = add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 按上面的顺序来说，后面基本都是0，因此执行上面代码后，到这里就可以break了</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="comment">// index后面的索引位置都为空，退出循环</span></span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前位置不为空，寻找下一个可写入位置</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 找到一个key，至少tophash是相等的</span></span><br><span class="line">            <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="comment">// bucket的key是指针</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tophash相等但key值不相等，继续寻找下一个</span></span><br><span class="line">            <span class="keyword">if</span> !t.Key.Equal(key, k) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指针？数据需要更新？</span></span><br><span class="line">            <span class="keyword">if</span> t.NeedKeyUpdate() &#123;</span><br><span class="line">                typedmemmove(t.Key, k, key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">            elem = add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            <span class="keyword">goto</span> done</span><br><span class="line">        &#125;</span><br><span class="line">        ovf := b.overflow(t)</span><br><span class="line">        <span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        b = ovf</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非扩容状态，但已经达到80%的饱和度或者数据非常稀疏</span></span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        hashGrow(t, h)</span><br><span class="line">        <span class="comment">// 扩容后，重新找位置</span></span><br><span class="line">        <span class="keyword">goto</span> again</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全满了，没有位置了</span></span><br><span class="line">    <span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从预申请获取或直接创建新的bucket，作为overflow bucket</span></span><br><span class="line">        newb := h.newoverflow(t, b)</span><br><span class="line">        <span class="comment">// overflow第一个位置</span></span><br><span class="line">        inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        elem = add(insertk, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">        kmem := newobject(t.Key)</span><br><span class="line">        *(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">        insertk = kmem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">        vmem := newobject(t.Elem)</span><br><span class="line">        *(*unsafe.Pointer)(elem) = vmem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把key拷贝到哈希表的key里</span></span><br><span class="line">    typedmemmove(t.Key, insertk, key)</span><br><span class="line">    <span class="comment">// tophash更新</span></span><br><span class="line">    *inserti = top</span><br><span class="line">    <span class="comment">// 总数量更新</span></span><br><span class="line">    h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// flag被修改了，异常</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除修改标记</span></span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">    <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">        elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回value位置的指针，上层代码会更新value</span></span><br><span class="line">    <span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疏散旧bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// todo ？ 保证当前是一次全新的扩容？</span></span><br><span class="line">    evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容中</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// 疏散</span></span><br><span class="line">        evacuate(t, h, h.nevacuate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疏散用，纪录bucket信息</span></span><br><span class="line"><span class="keyword">type</span> evacDst <span class="keyword">struct</span> &#123;</span><br><span class="line">    b *bmap          <span class="comment">// bucket指针</span></span><br><span class="line">    i <span class="type">int</span>            <span class="comment">// tophash地址</span></span><br><span class="line">    k unsafe.Pointer <span class="comment">// key地址</span></span><br><span class="line">    e unsafe.Pointer <span class="comment">// value地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疏散旧bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket，这里是oldbuckets</span></span><br><span class="line">    b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// 2^(b-1) -&gt; oldbucket+1</span></span><br><span class="line">    newbit := h.noldbuckets()</span><br><span class="line">    <span class="comment">// 如果tophash[0]的值不在在(1,5)之间</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">        <span class="comment">// 将新的buckets分为x和y两部份</span></span><br><span class="line">        <span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">        <span class="comment">// 低地址部份</span></span><br><span class="line">        x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">        x.b = (*bmap)(add(h.buckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">        x.e = add(x.k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是双倍扩容</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="comment">// 高地址部份</span></span><br><span class="line">            y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">            y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">            y.e = add(y.k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描正常桶以及溢出桶，这里是oldbuckets</span></span><br><span class="line">        <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">            <span class="comment">// key基地址</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">            <span class="comment">// value基地址</span></span><br><span class="line">            e := add(k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="comment">// 每个桶可存储8个数据，搬空所有</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; abi.MapBucketCount; i, k, e = i+<span class="number">1</span>, add(k, <span class="type">uintptr</span>(t.KeySize)), add(e, <span class="type">uintptr</span>(t.ValueSize)) &#123;</span><br><span class="line">                top := b.tophash[i]</span><br><span class="line">                <span class="comment">// 该位置全新或已删除</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(top) &#123;</span><br><span class="line">                    <span class="comment">// 设置为4-不需要疏散</span></span><br><span class="line">                    b.tophash[i] = evacuatedEmpty</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不为0，但小于5，异常</span></span><br><span class="line">                <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不为0，还未疏散</span></span><br><span class="line">                k2 := k</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> useY <span class="type">uint8</span></span><br><span class="line">                <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">                    <span class="comment">// 计算hash值</span></span><br><span class="line">                    hash := t.Hasher(k2, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 有goroutine在遍历新的buckets</span></span><br><span class="line">                    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.ReflexiveKey() &amp;&amp; !t.Key.Equal(k2, k2) &#123;</span><br><span class="line">                        <span class="comment">// 浮点数，NaN != NaN，无法判断，拿top的最低位判断应该放在哪里</span></span><br><span class="line">                        useY = top &amp; <span class="number">1</span></span><br><span class="line">                        top = tophash(hash)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 根据hash&amp;B判断是否要放在高地址部份</span></span><br><span class="line">                        <span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">                            useY = <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 异常数值？</span></span><br><span class="line">                <span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY || evacuatedX^<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad evacuatedN&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置为2或3</span></span><br><span class="line">                b.tophash[i] = evacuatedX + useY</span><br><span class="line">                <span class="comment">// 疏散的目标地址</span></span><br><span class="line">                dst := &amp;xy[useY]</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 溢出了</span></span><br><span class="line">                <span class="keyword">if</span> dst.i == abi.MapBucketCount &#123;</span><br><span class="line">                    <span class="comment">// 链接overflow并使用第一个地址</span></span><br><span class="line">                    dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">                    dst.i = <span class="number">0</span></span><br><span class="line">                    dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">                    dst.e = add(dst.k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                &#125;</span><br><span class="line">                dst.b.tophash[dst.i&amp;(abi.MapBucketCount<span class="number">-1</span>)] = top</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.Key, dst.k, k) <span class="comment">// copy elem</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.Elem, dst.e, e)</span><br><span class="line">                &#125;</span><br><span class="line">                dst.i++</span><br><span class="line">                dst.k = add(dst.k, <span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                dst.e = add(dst.e, <span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 旧的bucket已经清空且无iter在使用</span></span><br><span class="line">        <span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.Bucket.Pointers() &#123;</span><br><span class="line">            b := add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize))</span><br><span class="line">            ptr := add(b, dataOffset)</span><br><span class="line">            n := <span class="type">uintptr</span>(t.BucketSize) - dataOffset</span><br><span class="line">            <span class="comment">// 把key/value数据全部清空，方便gc做？</span></span><br><span class="line">            memclrHasPointers(ptr, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 惰性清理函数，不会每次都触发，只有oldbucket索引刚好跟nevacuate值相等才行</span></span><br><span class="line">    <span class="comment">// [0 1 2 3]共四个bucket</span></span><br><span class="line">    <span class="comment">// 当疏散了idx=2的bucket，此时nevacuate=0，不触发</span></span><br><span class="line">    <span class="comment">// 当疏散了idx=0的bucket时，与nevacuate相等，触发，将nevacuate指向1</span></span><br><span class="line">    <span class="comment">// 当nevacuate=4时，说明疏散了所有bucket，清理掉buckets数组，更新状态</span></span><br><span class="line">    <span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">        advanceEvacuationMark(h, t, newbit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否疏散完毕，是=&gt;清理oldbucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指向下一个bucket，不管有没有清理</span></span><br><span class="line">    h.nevacuate++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard，实际保证能nevacuate&lt;newbit即可</span></span><br><span class="line">    stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">    <span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">        stop = newbit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nevacuate指向下一个未清理的bucket索引</span></span><br><span class="line">    <span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">        h.nevacuate++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部疏散完毕</span></span><br><span class="line">    <span class="keyword">if</span> h.nevacuate == newbit &#123;</span><br><span class="line">        <span class="comment">// 删除oldbuckets</span></span><br><span class="line">        h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 删除oldoverflow</span></span><br><span class="line">        <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取消sameSizeGrow标记？</span></span><br><span class="line">        h.flags &amp;^= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请一个新的overflow bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> newoverflow(t *maptype, b *bmap) *bmap &#123;</span><br><span class="line">    <span class="keyword">var</span> ovf *bmap</span><br><span class="line">    <span class="comment">// 有预申请的overflow直接使用</span></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        ovf = h.extra.nextOverflow</span><br><span class="line">        <span class="comment">// next为nil，说明申请的overflow还有很多</span></span><br><span class="line">        <span class="keyword">if</span> ovf.overflow(t) == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 写上next指针，不然下一次没法用</span></span><br><span class="line">            h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), <span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用完了，bucket的overflow指针清空</span></span><br><span class="line">            ovf.setoverflow(t, <span class="literal">nil</span>)</span><br><span class="line">            h.extra.nextOverflow = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有预申请或者用完了预申请的</span></span><br><span class="line">        ovf = (*bmap)(newobject(t.Bucket))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// noverflow counter调整</span></span><br><span class="line">    <span class="comment">// &lt;16时noverflow是个精确值</span></span><br><span class="line">    <span class="comment">// &gt;=16时noverflow指数级衰减</span></span><br><span class="line">    h.incrnoverflow()</span><br><span class="line">    <span class="comment">// 不包含指针</span></span><br><span class="line">    <span class="keyword">if</span> !t.Bucket.Pointers() &#123;</span><br><span class="line">        <span class="comment">// 确保extra跟overflow已初始化</span></span><br><span class="line">        h.createOverflow()</span><br><span class="line">        <span class="comment">// 追加到末尾，超过容量还是会触发slice扩容</span></span><br><span class="line">        *h.extra.overflow = <span class="built_in">append</span>(*h.extra.overflow, ovf)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bucket的overflow指针指向ovf</span></span><br><span class="line">    b.setoverflow(t, ovf)</span><br><span class="line">    <span class="keyword">return</span> ovf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当map的元素数量超过8且达到80%的饱和度时，会触发扩容，扩容函数为hashGrow。</p>
<p><strong>注意</strong>：hashGrow只负责扩容，不负责疏散oldbucket，只有每次调用mapassign时才会去疏散旧的bucket</p>
<p>大概逻辑如下</p>
<ol>
<li>判断是双倍扩容还是同等大小扩容</li>
<li>将buckets数组搬到oldbuckets</li>
<li>更新hmap状态</li>
<li>有overflow？搬到oldoverflow并更新extra状态</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只管扩容，下一次写的时候才疏散对应的bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断是双倍扩容还是同等大小扩容</span></span><br><span class="line">    bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 未达到80%的饱和度，同等大小扩容</span></span><br><span class="line">    <span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">        bigger = <span class="number">0</span></span><br><span class="line">        h.flags |= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迁移旧的buckets</span></span><br><span class="line">    oldbuckets := h.buckets</span><br><span class="line">    <span class="comment">// 创建新的buckets</span></span><br><span class="line">    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除iterator/oldIterator标记</span></span><br><span class="line">    flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">    <span class="comment">// 加上oldIterator标记？</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= oldIterator</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    h.B += bigger</span><br><span class="line">    h.flags = flags</span><br><span class="line">    h.oldbuckets = oldbuckets</span><br><span class="line">    h.buckets = newbuckets</span><br><span class="line">    h.nevacuate = <span class="number">0</span></span><br><span class="line">    h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理overflow</span></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常状态</span></span><br><span class="line">        <span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;oldoverflow is not nil&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">        h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(v1, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当使用关键字delete删除指定key时，调用mapdelete，大概逻辑如下</p>
<ol>
<li>计算hash值，找到目标bucket</li>
<li>是否在扩容中？是，则疏散旧bucket</li>
<li>对比tophash和key，找到value的地址，清空tophash、key、value</li>
<li>idx+1位置的tophash都是0-默认值？从idx开始往前扫描，将所有tophash&#x3D;emptyOne改成0</li>
<li>更新map状态</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := mapKeyError(t, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置flag，防止同时写入</span></span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取低B位hash值，用于计算桶索引</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，即为扩容中</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// 疏散指定bucket</span></span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    bOrig := b</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">search:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对hash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="comment">// 1. 没找到key</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 后面基本都是0，到这里就可以break了</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> search</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 找到一个key，至少tophash是相等的</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            k2 := k</span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tophash相等但key值不相等，继续寻找下一个</span></span><br><span class="line">            <span class="keyword">if</span> !t.Key.Equal(key, k2) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Only clear key if there are pointers in it.</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Key.Pointers() &#123;</span><br><span class="line">                memclrHasPointers(k, t.Key.Size_)</span><br><span class="line">            &#125;</span><br><span class="line">            e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Elem.Pointers() &#123;</span><br><span class="line">                memclrHasPointers(e, t.Elem.Size_)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                memclrNoHeapPointers(e, t.Elem.Size_)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除了一个数据</span></span><br><span class="line">            b.tophash[i] = emptyOne</span><br><span class="line">            <span class="comment">// index=7，指向了bucket最后一个数据</span></span><br><span class="line">            <span class="keyword">if</span> i == abi.MapBucketCount<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="comment">// 还不是最终的数据，不处理</span></span><br><span class="line">                <span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">                    <span class="keyword">goto</span> notLast</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// index&lt;7 且 后续的元素也不为空，不处理</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">                    <span class="keyword">goto</span> notLast</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前以及前面tophash=emptyOne的tophash设置为0-默认值</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                b.tophash[i] = emptyRest</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">                        <span class="keyword">break</span> <span class="comment">// beginning of initial bucket, we&#x27;re done.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Find previous bucket, continue at its last entry.</span></span><br><span class="line">                    c := b</span><br><span class="line">                    <span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i = abi.MapBucketCount - <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i--</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        notLast:</span><br><span class="line">            h.count--</span><br><span class="line">            <span class="comment">// Reset the hash seed to make it more difficult for attackers to</span></span><br><span class="line">            <span class="comment">// repeatedly trigger hash collisions. See issue 25237.</span></span><br><span class="line">            <span class="keyword">if</span> h.count == <span class="number">0</span> &#123;</span><br><span class="line">                h.hash0 = <span class="type">uint32</span>(rand())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span> search</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常状态</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除标记</span></span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line">clear(v1)</span><br></pre></td></tr></table></figure>

<p>使用clear清理map的所有元素时，系统调用mapclear进行处理，大概逻辑如下</p>
<ol>
<li>循环将每一个bucket的tophash都设置为0，包括oldbuckets</li>
<li>重置map的所有状态、seed等</li>
<li>调用makeBucketArray，清理所有key&#x2F;value数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclear</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置flag，防止同时写入</span></span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark buckets empty, so existing iterators can be terminated, see issue #59411.</span></span><br><span class="line">    markBucketsEmpty := <span class="function"><span class="keyword">func</span><span class="params">(bucket unsafe.Pointer, mask <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt;= mask; i++ &#123;</span><br><span class="line">            b := (*bmap)(add(bucket, i*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">                <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">                    b.tophash[i] = emptyRest</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2^b-1</span></span><br><span class="line">    markBucketsEmpty(h.buckets, bucketMask(h.B))</span><br><span class="line">    <span class="keyword">if</span> oldBuckets := h.oldbuckets; oldBuckets != <span class="literal">nil</span> &#123;</span><br><span class="line">        markBucketsEmpty(oldBuckets, h.oldbucketmask())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩下的没什么好说的</span></span><br><span class="line">    h.flags &amp;^= sameSizeGrow</span><br><span class="line">    h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">    h.nevacuate = <span class="number">0</span></span><br><span class="line">    h.noverflow = <span class="number">0</span></span><br><span class="line">    h.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the hash seed to make it more difficult for attackers to</span></span><br><span class="line">    <span class="comment">// repeatedly trigger hash collisions. See issue 25237.</span></span><br><span class="line">    h.hash0 = <span class="type">uint32</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep the mapextra allocation but clear any extra information.</span></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">        *h.extra = mapextra&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// makeBucketArray clears the memory pointed to by h.buckets</span></span><br><span class="line">    <span class="comment">// and recovers any overflow buckets by generating them</span></span><br><span class="line">    <span class="comment">// as if h.buckets was newly alloced.</span></span><br><span class="line">    _, nextOverflow := makeBucketArray(t, h.B, h.buckets)</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// If overflow buckets are created then h.extra</span></span><br><span class="line">        <span class="comment">// will have been allocated during initial bucket creation.</span></span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下非克隆，只是复制了header</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = v1</span><br><span class="line"></span><br><span class="line"><span class="comment">// go 1.21</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = maps.Clone(v1)</span><br></pre></td></tr></table></figure>

<p>go 1.21增加了maps.Clone用于克隆整个map数据，系统调用mapclone2实现该操作，大概逻辑如下</p>
<ol>
<li>创建目标哈希表dst，复制源哈希表src的状态等相关数据</li>
<li>复制src的数据到dst<ul>
<li>如果B&#x3D;0且key&#x2F;value非指针，直接赋值一个bucket即可，复制完毕直接退出</li>
<li>如果dst.B&#x3D;src.B，1:1复制bucket数组</li>
<li>如果dst.B&lt;&#x3D;src.B，直接看代码吧</li>
</ul>
</li>
<li>src是否在扩容中？是，则复制src的oldbucket数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclone2</span><span class="params">(t *maptype, src *hmap)</span></span> *hmap &#123;</span><br><span class="line">    <span class="comment">// 数据量</span></span><br><span class="line">    hint := src.count</span><br><span class="line">    <span class="comment">// 已经达到80%的饱和度</span></span><br><span class="line">    <span class="keyword">if</span> overLoadFactor(hint, src.B) &#123;</span><br><span class="line">        <span class="comment">// 13*2^B/2 (why？)</span></span><br><span class="line">        hint = <span class="type">int</span>(loadFactorNum * (bucketShift(src.B) / loadFactorDen))</span><br><span class="line">    &#125;</span><br><span class="line">    dst := makemap(t, hint, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 共用hash seed</span></span><br><span class="line">    dst.hash0 = src.hash0</span><br><span class="line">    dst.nevacuate = <span class="number">0</span></span><br><span class="line">    <span class="comment">// flags不需要拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数量为0，不处理</span></span><br><span class="line">    <span class="keyword">if</span> src.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> src.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map clone and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b=0 and key跟value非指针</span></span><br><span class="line">    <span class="keyword">if</span> src.B == <span class="number">0</span> &amp;&amp; !(t.IndirectKey() &amp;&amp; t.NeedKeyUpdate()) &amp;&amp; !t.IndirectElem() &#123;</span><br><span class="line">        <span class="comment">// Quick copy for small maps.</span></span><br><span class="line">        dst.buckets = newobject(t.Bucket)</span><br><span class="line">        dst.count = src.count</span><br><span class="line">        typedmemmove(t.Bucket, dst.buckets, src.buckets)</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b=0 key或value为指针类型</span></span><br><span class="line">    <span class="keyword">if</span> dst.B == <span class="number">0</span> &#123;</span><br><span class="line">        dst.buckets = newobject(t.Bucket)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dst.B &lt;= src.B</span></span><br><span class="line">    dstArraySize := <span class="type">int</span>(bucketShift(dst.B))</span><br><span class="line">    srcArraySize := <span class="type">int</span>(bucketShift(src.B))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; dstArraySize; i++ &#123;</span><br><span class="line">        <span class="comment">// dst bucket指针</span></span><br><span class="line">        dstBmap := (*bmap)(add(dst.buckets, <span class="type">uintptr</span>(i*<span class="type">int</span>(t.BucketSize))))</span><br><span class="line">        pos := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; srcArraySize; j += dstArraySize &#123;</span><br><span class="line">            <span class="comment">// src bucket指针</span></span><br><span class="line">            <span class="comment">// 如果dst.B = src.B，1:1复制，否则多余部份wrapped写到dst前面几个bucket</span></span><br><span class="line">            srcBmap := (*bmap)(add(src.buckets, <span class="type">uintptr</span>((i+j)*<span class="type">int</span>(t.BucketSize))))</span><br><span class="line">            <span class="keyword">for</span> srcBmap != <span class="literal">nil</span> &#123;</span><br><span class="line">                dstBmap, pos = moveToBmap(t, dst, dstBmap, pos, srcBmap)</span><br><span class="line">                <span class="comment">// 包括overflow</span></span><br><span class="line">                srcBmap = srcBmap.overflow(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非扩容</span></span><br><span class="line">    <span class="keyword">if</span> src.oldbuckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面全是跟oldbuckets相关的</span></span><br><span class="line">    oldB := src.B</span><br><span class="line">    srcOldbuckets := src.oldbuckets</span><br><span class="line">    <span class="keyword">if</span> !src.sameSizeGrow() &#123;</span><br><span class="line">        oldB--</span><br><span class="line">    &#125;</span><br><span class="line">    oldSrcArraySize := <span class="type">int</span>(bucketShift(oldB))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; oldSrcArraySize; i++ &#123;</span><br><span class="line">        srcBmap := (*bmap)(add(srcOldbuckets, <span class="type">uintptr</span>(i*<span class="type">int</span>(t.BucketSize))))</span><br><span class="line">        <span class="comment">// 已疏散</span></span><br><span class="line">        <span class="keyword">if</span> evacuated(srcBmap) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// oldB比dst的B还要更大，按dst的B取hash的低位作为bucket索引</span></span><br><span class="line">        <span class="comment">// dst.B &lt;= src.B and dst.B &lt;= (src.B-1)</span></span><br><span class="line">        <span class="keyword">if</span> oldB &gt;= dst.B &#123; <span class="comment">// main bucket bits in dst is less than oldB bits in src</span></span><br><span class="line">            <span class="comment">// src.oldbuckets =&gt; dst.buckets</span></span><br><span class="line">            <span class="comment">// 索引按dst.B取低位</span></span><br><span class="line">            dstBmap := (*bmap)(add(dst.buckets, (<span class="type">uintptr</span>(i)&amp;bucketMask(dst.B))*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            <span class="keyword">for</span> dstBmap.overflow(t) != <span class="literal">nil</span> &#123;</span><br><span class="line">                dstBmap = dstBmap.overflow(t)</span><br><span class="line">            &#125;</span><br><span class="line">            pos := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> srcBmap != <span class="literal">nil</span> &#123;</span><br><span class="line">                dstBmap, pos = moveToBmap(t, dst, dstBmap, pos, srcBmap)</span><br><span class="line">                srcBmap = srcBmap.overflow(t)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// oldB &lt; dst.B (说明dst.B == src.B ?)</span></span><br><span class="line">        <span class="keyword">for</span> srcBmap != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// oldbuckets分成x/y两个部份疏散</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">                <span class="comment">// 该位置全新或已删除</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(srcBmap.tophash[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// // 有goroutine在写入，不允许</span></span><br><span class="line">                <span class="keyword">if</span> src.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">                    fatal(<span class="string">&quot;concurrent map clone and map write&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                srcK := add(unsafe.Pointer(srcBmap), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    srcK = *((*unsafe.Pointer)(srcK))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                srcEle := add(unsafe.Pointer(srcBmap), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    srcEle = *((*unsafe.Pointer)(srcEle))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到key在dst的位置，然后复制数据</span></span><br><span class="line">                dstEle := mapassign(t, dst, srcK)</span><br><span class="line">                typedmemmove(t.Elem, dstEle, srcEle)</span><br><span class="line">            &#125;</span><br><span class="line">            srcBmap = srcBmap.overflow(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveToBmap</span><span class="params">(t *maptype, h *hmap, dst *bmap, pos <span class="type">int</span>, src *bmap)</span></span> (*bmap, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// src的bucket数据复制到dst的bucket，overflow在上一层做处理</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">        <span class="comment">// src-该位置全新或已删除</span></span><br><span class="line">        <span class="keyword">if</span> isEmpty(src.tophash[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 索引 0-7</span></span><br><span class="line">        <span class="keyword">for</span> ; pos &lt; abi.MapBucketCount; pos++ &#123;</span><br><span class="line">            <span class="comment">// dst-找到一个可写入的位置</span></span><br><span class="line">            <span class="keyword">if</span> isEmpty(dst.tophash[pos]) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dst写满了，加一个overflow bucket</span></span><br><span class="line">        <span class="keyword">if</span> pos == abi.MapBucketCount &#123;</span><br><span class="line">            dst = h.newoverflow(t, dst)</span><br><span class="line">            pos = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srcK := add(unsafe.Pointer(src), dataOffset+<span class="type">uintptr</span>(i)*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        srcEle := add(unsafe.Pointer(src), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+<span class="type">uintptr</span>(i)*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">        dstK := add(unsafe.Pointer(dst), dataOffset+<span class="type">uintptr</span>(pos)*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        dstEle := add(unsafe.Pointer(dst), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+<span class="type">uintptr</span>(pos)*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制tophash</span></span><br><span class="line">        dst.tophash[pos] = src.tophash[i]</span><br><span class="line">        <span class="comment">// 复制key</span></span><br><span class="line">        <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">            srcK = *(*unsafe.Pointer)(srcK)</span><br><span class="line">            <span class="keyword">if</span> t.NeedKeyUpdate() &#123;</span><br><span class="line">                kStore := newobject(t.Key)</span><br><span class="line">                typedmemmove(t.Key, kStore, srcK)</span><br><span class="line">                srcK = kStore</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Note: if NeedKeyUpdate is false, then the memory</span></span><br><span class="line">            <span class="comment">// used to store the key is immutable, so we can share</span></span><br><span class="line">            <span class="comment">// it between the original map and its clone.</span></span><br><span class="line">            *(*unsafe.Pointer)(dstK) = srcK</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typedmemmove(t.Key, dstK, srcK)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制value</span></span><br><span class="line">        <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">            srcEle = *(*unsafe.Pointer)(srcEle)</span><br><span class="line">            eStore := newobject(t.Elem)</span><br><span class="line">            typedmemmove(t.Elem, eStore, srcEle)</span><br><span class="line">            *(*unsafe.Pointer)(dstEle) = eStore</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typedmemmove(t.Elem, dstEle, srcEle)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// counter更新</span></span><br><span class="line">        pos++</span><br><span class="line">        h.count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst, pos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">3.3 哈希表</a><br><a href="https://victoriametrics.com/blog/go-map/">Go Maps Explained: How Key-Value Pairs Are Actually Stored</a><br><a href="https://www.youtube.com/watch?v=Tl7mi9QmLns">GopherCon 2016: Keith Randall - Inside the Map Implementation</a><br><a href="https://docs.google.com/presentation/d/1CxamWsvHReswNZc7N2HMV7WPFqS8pvlPVZcDegdC_T4/edit#slide=id.g14067a566a_0_0">Inside the Map Implementation - Gophercon</a><br><a href="https://go101.org/article/container.html">Arrays, Slices and Maps in Go</a><br><a href="https://100go.co/28-maps-memory-leaks/">Maps and memory leaks</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Cond</title>
    <url>/golang-series-sync-cond/</url>
    <content><![CDATA[<p>sync.Cond经常用在多个 goroutine 等待，一个 goroutine 通知（事件发生）的场景。如果是一个通知，一个等待，使用互斥锁或 channel 就能搞定了</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>以下展示一个sync.Cond的使用案例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shared = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reader 打印shared[key]</span></span><br><span class="line">    reader := <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        cond.L.Lock()</span><br><span class="line">        <span class="comment">// 等待，直到shared有数据</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(shared) == <span class="number">0</span> &#123;</span><br><span class="line">            cond.Wait() <span class="comment">// Wait内部会暂时解锁/加锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(shared[key])</span><br><span class="line">        cond.L.Unlock()</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> reader(<span class="string">&quot;rsc1&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> reader(<span class="string">&quot;rsc2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writer</span></span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    shared[<span class="string">&quot;rsc1&quot;</span>] = <span class="string">&quot;foo&quot;</span></span><br><span class="line">    shared[<span class="string">&quot;rsc2&quot;</span>] = <span class="string">&quot;bar&quot;</span></span><br><span class="line">    <span class="comment">// 通知所有goroutine</span></span><br><span class="line">    cond.Broadcast()</span><br><span class="line">    cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>Cond的数据结构如下</p>
<ul>
<li><code>L</code> - 只要实现Locker接口的类型都可以，比如Mutex</li>
<li><code>notify</code> - 计数器也是ticket生成器，可实现等待队列的先进先出-FIFO，由内部sema使用</li>
<li><code>checker</code> - 用来检测是否被复制</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cond implements a condition variable, a rendezvous point</span></span><br><span class="line"><span class="comment">// for goroutines waiting for or announcing the occurrence</span></span><br><span class="line"><span class="comment">// of an event.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Each Cond has an associated Locker L (often a [*Mutex] or [*RWMutex]),</span></span><br><span class="line"><span class="comment">// which must be held when changing the condition and</span></span><br><span class="line"><span class="comment">// when calling the [Cond.Wait] method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Cond must not be copied after first use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In the terminology of [the Go memory model], Cond arranges that</span></span><br><span class="line"><span class="comment">// a call to [Cond.Broadcast] or [Cond.Signal] “synchronizes before” any Wait call</span></span><br><span class="line"><span class="comment">// that it unblocks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For many simple use cases, users will be better off using channels than a</span></span><br><span class="line"><span class="comment">// Cond (Broadcast corresponds to closing a channel, and Signal corresponds to</span></span><br><span class="line"><span class="comment">// sending on a channel).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For more on replacements for [sync.Cond], see [Roberto Clapis&#x27;s series on</span></span><br><span class="line"><span class="comment">// advanced concurrency patterns], as well as [Bryan Mills&#x27;s talk on concurrency</span></span><br><span class="line"><span class="comment">// patterns].</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// [the Go memory model]: https://go.dev/ref/mem</span></span><br><span class="line"><span class="comment">// [Roberto Clapis&#x27;s series on advanced concurrency patterns]: https://blogtitle.github.io/categories/concurrency/</span></span><br><span class="line"><span class="comment">// [Bryan Mills&#x27;s talk on concurrency patterns]: https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view</span></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker                <span class="comment">// mutex，由外部传入</span></span><br><span class="line"></span><br><span class="line">    notify  notifyList      <span class="comment">// 计数器+sudog链表，内部sema使用</span></span><br><span class="line">    checker copyChecker     <span class="comment">// 检查Cond是否被复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">    wait atomic.Uint32      <span class="comment">// waiter计数器，只增不减</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// notify is the ticket number of the next waiter to be notified. It can</span></span><br><span class="line">    <span class="comment">// be read outside the lock, but is only written to with lock held.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Both wait &amp; notify can wrap around, and such cases will be correctly</span></span><br><span class="line">    <span class="comment">// handled as long as their &quot;unwrapped&quot; difference is bounded by 2^31.</span></span><br><span class="line">    <span class="comment">// For this not to be the case, we&#x27;d need to have 2^31+ goroutines</span></span><br><span class="line">    <span class="comment">// blocked on the same condvar, which is currently not possible.</span></span><br><span class="line">    notify <span class="type">uint32</span>           <span class="comment">// 范围[0,wait]，保证waiter先进先出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// List of parked waiters.</span></span><br><span class="line">    lock mutex              <span class="comment">// mutex</span></span><br><span class="line">    head *sudog             <span class="comment">// 指向第一个sudog</span></span><br><span class="line">    tail *sudog             <span class="comment">// 指向最后一个sudog</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="NewCond"><a href="#NewCond" class="headerlink" title="NewCond"></a>NewCond</h3><p>创建一个condition variable，没什么好讲的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewCond returns a new Cond with Locker l.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h2><p>大概逻辑如下</p>
<ol>
<li>更新wait计数器，获得ticket，临时解锁cond，让其他goroutine可以获得ticket并挂起</li>
<li>将当前goroutine和ticket打包进sudog，放进队列，当前goroutine挂起陷入等待</li>
<li>goroutine被唤醒，加锁cond</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wait atomically unlocks c.L and suspends execution</span></span><br><span class="line"><span class="comment">// of the calling goroutine. After later resuming execution,</span></span><br><span class="line"><span class="comment">// Wait locks c.L before returning. Unlike in other systems,</span></span><br><span class="line"><span class="comment">// Wait cannot return unless awoken by [Cond.Broadcast] or [Cond.Signal].</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because c.L is not locked while Wait is waiting, the caller</span></span><br><span class="line"><span class="comment">// typically cannot assume that the condition is true when</span></span><br><span class="line"><span class="comment">// Wait returns. Instead, the caller should Wait in a loop:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c.L.Lock()</span></span><br><span class="line"><span class="comment">//    for !condition() &#123;</span></span><br><span class="line"><span class="comment">//        c.Wait()</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    ... make use of condition ...</span></span><br><span class="line"><span class="comment">//    c.L.Unlock()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 上层业务逻辑已加锁 =&gt; cond.L.Lock()</span></span><br><span class="line"></span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// waiter_counter++ =&gt; t = waiter_counter-1</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">    <span class="comment">// 解锁，这样其他goroutine现在可以调用Wait了</span></span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    <span class="comment">// 将当前goroutine挂起，等待唤醒</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁，由上层业务逻辑负责继续解锁 =&gt; cond.L.Unlock()</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// notifyListWait waits for a notification. If one has been sent since</span></span><br><span class="line"><span class="comment">// notifyListAdd was called, it returns immediately. Otherwise, it blocks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:linkname notifyListWait sync.runtime_notifyListWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return right away if this ticket has already been notified.</span></span><br><span class="line">	<span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">		unlock(&amp;l.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enqueue itself.</span></span><br><span class="line">	s := acquireSudog()</span><br><span class="line">	s.g = getg()</span><br><span class="line">	s.ticket = t</span><br><span class="line">	s.releasetime = <span class="number">0</span></span><br><span class="line">	t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">		s.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">		l.head = s</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		l.tail.next = s</span><br><span class="line">	&#125;</span><br><span class="line">	l.tail = s</span><br><span class="line">	goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceBlockCondWait, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>大概逻辑如下</p>
<ol>
<li>如果waiter数量为0（wait&#x3D;&#x3D;notify），不处理</li>
<li>根据notify计算出待唤醒的waiter_id，并更新notify</li>
<li>在sudog列表查找ticket&#x3D;&#x3D;waiter_id的goroutine，将其唤醒</li>
<li>如果goroutine在wait时就接到信号，那么它肯定不在sudog列表，不处理</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Signal wakes one goroutine waiting on c, if there is any.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is allowed but not required for the caller to hold c.L</span></span><br><span class="line"><span class="comment">// during the call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Signal() does not affect goroutine scheduling priority; if other goroutines</span></span><br><span class="line"><span class="comment">// are attempting to lock c.L, they may be awoken before a &quot;waiting&quot; goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 按顺序唤醒一个goroutine</span></span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// notifyListNotifyOne notifies one entry in the list.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:linkname notifyListNotifyOne sync.runtime_notifyListNotifyOne</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast-path: if there are no new waiters since the last notification</span></span><br><span class="line">	<span class="comment">// we don&#x27;t need to acquire the lock at all.</span></span><br><span class="line">	<span class="keyword">if</span> l.wait.Load() == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Re-check under the lock if we need to do anything.</span></span><br><span class="line">	t := l.notify</span><br><span class="line">	<span class="keyword">if</span> t == l.wait.Load() &#123;</span><br><span class="line">		unlock(&amp;l.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the next notify ticket number.</span></span><br><span class="line">	atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try to find the g that needs to be notified.</span></span><br><span class="line">	<span class="comment">// If it hasn&#x27;t made it to the list yet we won&#x27;t find it,</span></span><br><span class="line">	<span class="comment">// but it won&#x27;t park itself once it sees the new notify number.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This scan looks linear but essentially always stops quickly.</span></span><br><span class="line">	<span class="comment">// Because g&#x27;s queue separately from taking numbers,</span></span><br><span class="line">	<span class="comment">// there may be minor reorderings in the list, but we</span></span><br><span class="line">	<span class="comment">// expect the g we&#x27;re looking for to be near the front.</span></span><br><span class="line">	<span class="comment">// The g has others in front of it on the list only to the</span></span><br><span class="line">	<span class="comment">// extent that it lost the race, so the iteration will not</span></span><br><span class="line">	<span class="comment">// be too long. This applies even when the g is missing:</span></span><br><span class="line">	<span class="comment">// it hasn&#x27;t yet gotten to sleep and has lost the race to</span></span><br><span class="line">	<span class="comment">// the (few) other g&#x27;s that we find on the list.</span></span><br><span class="line">	<span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">		<span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">			n := s.next</span><br><span class="line">			<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.next = n</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l.head = n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">				l.tail = p</span><br><span class="line">			&#125;</span><br><span class="line">			unlock(&amp;l.lock)</span><br><span class="line">			s.next = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">if</span> s.g.syncGroup != <span class="literal">nil</span> &amp;&amp; getg().syncGroup != s.g.syncGroup &#123;</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">&quot;semaphore wake of synctest goroutine&quot;</span>, s.g.goid, <span class="string">&quot;from outside bubble&quot;</span>)</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;semaphore wake of synctest goroutine from outside bubble&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h2><p>大概逻辑如下</p>
<ol>
<li>如果waiter数量为0（wait&#x3D;&#x3D;notify），不处理</li>
<li>更新notify，使其等于wait</li>
<li>扫描sudog列表，逐个唤醒goroutine</li>
<li>如果goroutine在wait时就接到信号，那么它肯定不在sudog列表，不处理</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broadcast wakes all goroutines waiting on c.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is allowed but not required for the caller to hold c.L</span></span><br><span class="line"><span class="comment">// during the call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 唤醒所有goroutine</span></span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// notifyListNotifyAll notifies all entries in the list.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:linkname notifyListNotifyAll sync.runtime_notifyListNotifyAll</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast-path: if there are no new waiters since the last notification</span></span><br><span class="line">	<span class="comment">// we don&#x27;t need to acquire the lock.</span></span><br><span class="line">	<span class="keyword">if</span> l.wait.Load() == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pull the list out into a local variable, waiters will be readied</span></span><br><span class="line">	<span class="comment">// outside the lock.</span></span><br><span class="line">	lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line">	s := l.head</span><br><span class="line">	l.head = <span class="literal">nil</span></span><br><span class="line">	l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the next ticket to be notified. We can set it to the current</span></span><br><span class="line">	<span class="comment">// value of wait because any previous waiters are already in the list</span></span><br><span class="line">	<span class="comment">// or will notice that they have already been notified when trying to</span></span><br><span class="line">	<span class="comment">// add themselves to the list.</span></span><br><span class="line">	atomic.Store(&amp;l.notify, l.wait.Load())</span><br><span class="line">	unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Go through the local list and ready all waiters.</span></span><br><span class="line">	<span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := s.next</span><br><span class="line">		s.next = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> s.g.syncGroup != <span class="literal">nil</span> &amp;&amp; getg().syncGroup != s.g.syncGroup &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;semaphore wake of synctest goroutine&quot;</span>, s.g.goid, <span class="string">&quot;from outside bubble&quot;</span>)</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;semaphore wake of synctest goroutine from outside bubble&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">		s = next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://victoriametrics.com/blog/go-sync-cond/index.html">Go sync.Cond, the Most Overlooked Sync Mechanism</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Map</title>
    <url>/golang-series-sync-map/</url>
    <content><![CDATA[<p>map不支持并发读写，但我们可以转变下思路，将value改为一个指向结构体entry的指针，结构体内部的字段我们是可以随意修改的，如下，将并发读写map改为并发读map，读写转移到entry</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]*entry</span><br></pre></td></tr></table></figure>

<p>上面的方法看起来解决了并发读写的问题，但还不够，当有新的key写入时，还是变回了原来的map并发读写。sync.Map提供了一种思路，使用两个map，read负责已有key的并发读写，dirty负责新key的读写，只有当read找不到key，才去找dirty。</p>
<p>现在还剩最后一个问题，read和dirty如何保证数据一致&#x2F;同步，我们可以改造entry，使其指向value的指针，如此一来，read和dirty的entry可以指向同一个value，如下，这就是sync.Map的大致思路</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p *any</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read  -&gt; key0|*entry0         entry0.p -&gt; &amp;value</span></span><br><span class="line"><span class="comment">//       -&gt; key1|*entry1</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// dirty -&gt; key0|*entry0</span></span><br><span class="line"><span class="comment">//       -&gt; key1|*entry1</span></span><br><span class="line"><span class="comment">//       -&gt; key2|*entry2</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>尽管如此，sync.Map并不完美，以上设计导致我们无法直接计算出哈希表的元素数量，需要遍历进行统计，而且还不一定准确</p>
<p>当前go版本：1.23，1.24版本改为HashTrieMap实现</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> syncMap sync.Map</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写</span></span><br><span class="line">    syncMap.Store(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;VictoriaMetrics&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读</span></span><br><span class="line">    value, ok := syncMap.Load(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">    fmt.Println(value, ok)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    syncMap.Delete(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">    value, ok = syncMap.Load(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">    fmt.Println(value, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># VictoriaMetrics true</span></span><br><span class="line"><span class="comment"># &lt;nil&gt; false</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sync/map.go</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex                        <span class="comment">// dirty锁</span></span><br><span class="line">    read atomic.Pointer[readOnly]   <span class="comment">// 负责已有key的读写</span></span><br><span class="line">    dirty <span class="keyword">map</span>[any]*entry            <span class="comment">// 负责新key的读写，替换read后设置为nil</span></span><br><span class="line">    misses <span class="type">int</span>                      <span class="comment">// 计数器，如果read找不到key时加一，当misses==len(dirty)，用dirty替换掉read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map+amended</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    m       <span class="keyword">map</span>[any]*entry          <span class="comment">// </span></span><br><span class="line">    amended <span class="type">bool</span>                    <span class="comment">// 修正，当dirty有新的key写入时为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针-运行时生成，表示数据已完全删除</span></span><br><span class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any)</span><br><span class="line"></span><br><span class="line"><span class="comment">// value的封装，被read和dirty共享</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p atomic.Pointer[any]           <span class="comment">// 指针-任意类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里值得注意的是entry的p指针，有三个状态</p>
<table>
<thead>
<tr>
<th align="left">p</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;value</td>
<td align="left">正常状态</td>
</tr>
<tr>
<td align="left">nil</td>
<td align="left">已删除，可以当作是墓碑来理解</td>
</tr>
<tr>
<td align="left">expunged</td>
<td align="left">dirty替代read时，从nil改为expunged，在下一轮替换中，移除该key</td>
</tr>
</tbody></table>
<p>三种状态转移路线：</p>
<ol>
<li>&amp;value   -&gt; nil -&gt; expunged</li>
<li>expunged -&gt; nil -&gt; &amp;value</li>
</ol>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>根据key获取value，具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，返回</li>
<li>加锁，再找一遍read，如果找到，返回（double-check）</li>
<li>amended为true表示dirty有新的key，在dirty找</li>
<li>更新misses计数器，如果misses&#x3D;&#x3D;len(dirty)，用dirty替换掉read</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key any) (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 没找到但dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 在dirty找</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// misses++</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取m.read</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> loadReadOnly() readOnly &#123;</span><br><span class="line">    <span class="keyword">if</span> p := m.read.Load(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readOnly&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="comment">// 已删除</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// misses计数器更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// misses == len(m.dirty)</span></span><br><span class="line">    <span class="comment">// 用dirty替换read</span></span><br><span class="line">    m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>存储key&#x2F;value。本质就是Swap方法，但丢弃其返回值，具体看Swap</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    _, _ = m.Swap(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadOrStore"><a href="#LoadOrStore" class="headerlink" title="LoadOrStore"></a>LoadOrStore</h3><p>根据key获取value，如果没有该key&#x2F;value，则改为写入。该方法逻辑与Swap方法十分相似</p>
<p>具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，返回</li>
<li>加锁，再找一遍read，如果找到，返回（double-check）</li>
<li>如果在dirty找到，获取&#x2F;更新key，同时更新misses计数器，返回</li>
<li>都没找到说明是新key，写入dirty，返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value any) (actual any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// e有数值则获取，没有则更新并获取</span></span><br><span class="line">        actual, loaded, ok := e.tryLoadOrStore(value)</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> actual, loaded</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在read中没找到（dirty可能有）</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 在read找到</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// e指针从expunged改为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 凡是expunged变为nil状态的，read要同步到dirty</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 在dirty找到</span></span><br><span class="line">        actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">        <span class="comment">// misses++</span></span><br><span class="line">        m.missLocked()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dirty也没有 =&gt; 全新写入</span></span><br><span class="line">        <span class="comment">// 有新的key写入，需要更新amended</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            <span class="comment">// 克隆read到dirty（只保留未删除的纪录）</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            <span class="comment">// 有新key写入，需要将amended改为true</span></span><br><span class="line">            m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 凡是新key，都放在dirty</span></span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">        actual, loaded = value, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> actual, loaded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有数值则获取，没有则更新并获取返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryLoadOrStore(i any) (actual any, loaded, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="comment">// 完全删除</span></span><br><span class="line">    <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不为nil</span></span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *p, <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为nil</span></span><br><span class="line">    ic := i</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 替换成功</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, &amp;ic) &#123;</span><br><span class="line">            <span class="keyword">return</span> i, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重复上面的操作</span></span><br><span class="line">        p = e.p.Load()</span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *p, <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e指针从expunged改为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> unexpungeLocked() (wasExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> e.p.CompareAndSwap(expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">    <span class="comment">// dirty已经存在了，忽略</span></span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 创建dirty，与read同等大小</span></span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="comment">// 把nil的entry改为expunged</span></span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 其他非删除数据复制到dirty</span></span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.p指针从nil改为expunged</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// nil -&gt; expunged</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = e.p.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>删除指定key，具体看LoadAndDelete</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key any) &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadAndDelete"><a href="#LoadAndDelete" class="headerlink" title="LoadAndDelete"></a>LoadAndDelete</h3><p>逻辑与Load相似，具体如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，将entry置为nil</li>
<li>加锁，再找一遍read，如果找到，将entry置为nil（double-check）</li>
<li>amended为true表示dirty有新的key，在dirty找</li>
<li>更新misses计数器，如果misses&#x3D;&#x3D;len(dirty)，将dirty迁移到read</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key any) (value any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 没找到但dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 在dirty找</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// read没有但dirty有，直接删除</span></span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">            <span class="comment">// misses++</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="comment">// e.p改为nil</span></span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.p改为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 已删除</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndDelete"><a href="#CompareAndDelete" class="headerlink" title="CompareAndDelete"></a>CompareAndDelete</h3><p>具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，纪录e</li>
<li>加锁，再找一遍read，如果找到，纪录e（double-check）</li>
<li>amended为true表示dirty有新的key，在dirty找</li>
<li>更新misses计数器，如果misses&#x3D;&#x3D;len(dirty)，用dirty替换掉read</li>
<li>已删除或比对失败返回false，否则将e.p置为nil，返回true</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> CompareAndDelete(key, old any) (deleted <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 没找到但dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 在dirty找</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// misses++</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ok &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 已删除或比对失败</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged || *p != old &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>使用value替换key当前存储的数据。具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，替换并返回</li>
<li>加锁，再找一遍read，如果找到，替换并返回（double-check）</li>
<li>如果在dirty找到，替换并返回</li>
<li>都没找到说明是新key，写入dirty，返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Swap(key, value any) (previous any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">if</span> v, ok := e.trySwap(&amp;value); ok &#123;</span><br><span class="line">            <span class="comment">// 已删除</span></span><br><span class="line">            <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有值，返回</span></span><br><span class="line">            <span class="keyword">return</span> *v, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在read中没找到（dirty可能有）</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 在read找到</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// e指针从expunged改为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 凡是expunged变为nil状态的，read要同步到dirty</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            loaded = <span class="literal">true</span></span><br><span class="line">            previous = *v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 在dirty找到</span></span><br><span class="line">        <span class="comment">// 修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            loaded = <span class="literal">true</span></span><br><span class="line">            previous = *v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dirty也没有 =&gt; 全新写入</span></span><br><span class="line">        <span class="comment">// 有新的key写入，需要更新amended</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            <span class="comment">// 克隆read到dirty（只保留未删除的纪录）</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            <span class="comment">// 有新key写入，需要将amended改为true</span></span><br><span class="line">            m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 凡是新key，都放在dirty</span></span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> previous, loaded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> trySwap(i *any) (*any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 已删除</span></span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换成功</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;</span><br><span class="line">            <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> swapLocked(i *any) *any &#123;</span><br><span class="line">    <span class="keyword">return</span> e.p.Swap(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h3><p>具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，替换并返回</li>
<li>如果dirty没有新key，到此为止，返回</li>
<li>加锁，再找一遍read，如果找到，替换并返回（double-check）</li>
<li>如果在dirty找到，替换并返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> CompareAndSwap(key, old, <span class="built_in">new</span> any) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 尝试修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">return</span> e.tryCompareAndSwap(old, <span class="built_in">new</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">        <span class="comment">// 没找到，dirty也没有新key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在read中没找到但dirty可能有</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    swapped = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        swapped = e.tryCompareAndSwap(old, <span class="built_in">new</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 在dirty找到</span></span><br><span class="line">        <span class="comment">// 尝试修改指针指向新的value</span></span><br><span class="line">        swapped = e.tryCompareAndSwap(old, <span class="built_in">new</span>)</span><br><span class="line">        <span class="comment">// misses++</span></span><br><span class="line">        m.missLocked()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> swapped</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryCompareAndSwap(old, <span class="built_in">new</span> any) <span class="type">bool</span> &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="comment">// 已删除或比对失败</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged || *p != old &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子替换</span></span><br><span class="line">    nc := <span class="built_in">new</span> <span class="comment">// 优化，具体看原注释</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, &amp;nc) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = e.p.Load()</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged || *p != old &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>具体逻辑如下</p>
<ol>
<li>复制read，如果dirty有新key写入，则复制dirty并用dirty替换read</li>
<li>遍历哈希表</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value any)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 复制read</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">            <span class="comment">// 复制dirty</span></span><br><span class="line">            read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">            copyRead := read</span><br><span class="line">            <span class="comment">// 用dirty替换掉read</span></span><br><span class="line">            m.read.Store(&amp;copyRead)</span><br><span class="line">            m.dirty = <span class="literal">nil</span></span><br><span class="line">            m.misses = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希表</span></span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        v, ok := e.load()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h3><p>具体逻辑如下</p>
<ol>
<li>read为空且dirty也为空，返回</li>
<li>read不为空或者dirty有新数据<ul>
<li>复制read并将read置空</li>
<li>将dirty清空</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Clear() &#123;</span><br><span class="line">    <span class="comment">// 复制read</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// read为空且dirty也为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(read.m) == <span class="number">0</span> &amp;&amp; !read.amended &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read不为空或者dirty有新数据</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制read</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    <span class="comment">// read置空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(read.m) &gt; <span class="number">0</span> || read.amended &#123;</span><br><span class="line">        m.read.Store(&amp;readOnly&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirty清空</span></span><br><span class="line">    clear(m.dirty)</span><br><span class="line">    <span class="comment">// Don&#x27;t immediately promote the newly-cleared dirty map on the next operation.</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://victoriametrics.com/blog/go-sync-map/index.html">Go sync.Map: The Right Tool for the Right Job</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync/atomic</title>
    <url>/golang-series-sync-atomic/</url>
    <content><![CDATA[<p>sync&#x2F;atomic标准库包中提供的原子操作。原子操作是无锁的，直接通过CPU指令实现。</p>
<p>当你想要在多个goroutine中无锁访问一个变量时，就可以考虑使用atomic包提供的数据类型实现</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>以下是一个使用atomic.Uint64数据类型实现的计数器，它确保了多个goroutine按顺序正确更新数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ops atomic.Uint64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line"></span><br><span class="line">                ops.Add(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;ops:&quot;</span>, ops.Load())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><p>sync&#x2F;atomic包中，通用的数据结构有</p>
<ul>
<li><code>Value</code></li>
</ul>
<p>使用Value可以存储任意类型的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    v any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// efaceWords is interface&#123;&#125; internal representation.</span></span><br><span class="line"><span class="keyword">type</span> efaceWords <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ  unsafe.Pointer</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他具体的数据结构有</p>
<ul>
<li><code>Bool</code></li>
<li><code>Int32</code></li>
<li><code>Int64</code></li>
<li><code>Uint32</code></li>
<li><code>Uint64</code></li>
<li><code>Uintptr</code></li>
<li><code>Pointer</code></li>
</ul>
<p>举个例子，Pointer类型的数据结构如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Pointer is an atomic pointer of type *T. The zero value is a nil *T.</span></span><br><span class="line"><span class="keyword">type</span> Pointer[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Mention *T in a field to disallow conversion between Pointer types.</span></span><br><span class="line">    <span class="comment">// See go.dev/issue/56603 for more details.</span></span><br><span class="line">    <span class="comment">// Use *T, not T, to avoid spurious recursive type definition errors.</span></span><br><span class="line">    _ [<span class="number">0</span>]*T</span><br><span class="line"></span><br><span class="line">    _ noCopy</span><br><span class="line">    v unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>基本上，atomic提供的数据类型有几个通用的方法：Load、Store、Swap、CompareAndSwap</p>
<p>下面展示一个基本的使用方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init  -&gt; v=nil</span></span><br><span class="line">v := atomic.Value&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store -&gt; v=1</span></span><br><span class="line">v.Store(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// load</span></span><br><span class="line"><span class="comment">// print 1</span></span><br><span class="line">fmt.Println(v.Load())</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap  -&gt; v=2</span></span><br><span class="line"><span class="comment">// print 1</span></span><br><span class="line">fmt.Println(v.Swap(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// print 2</span></span><br><span class="line">fmt.Println(v.Load())</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS   -&gt; v=3</span></span><br><span class="line"><span class="comment">// print true</span></span><br><span class="line">fmt.Println(v.CompareAndSwap(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// print 3</span></span><br><span class="line">fmt.Println(v.Load())</span><br></pre></td></tr></table></figure>

<h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>获取atomic类型存储的数值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Load returns the value set by the most recent Store.</span></span><br><span class="line"><span class="comment">// It returns nil if there has been no call to Store for this Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (val any) &#123;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">    <span class="keyword">if</span> typ == <span class="literal">nil</span> || typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">        <span class="comment">// First store not yet completed.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    data := LoadPointer(&amp;vp.data)</span><br><span class="line">    vlp := (*efaceWords)(unsafe.Pointer(&amp;val))</span><br><span class="line">    vlp.typ = typ</span><br><span class="line">    vlp.data = data</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>更新&#x2F;覆盖atomic类型的数值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Store sets the value of the [Value] v to val.</span></span><br><span class="line"><span class="comment">// All calls to Store for a given Value must use values of the same concrete type.</span></span><br><span class="line"><span class="comment">// Store of an inconsistent type panics, as does Store(nil).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(val any) &#123;</span><br><span class="line">    <span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of nil value into Value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    vlp := (*efaceWords)(unsafe.Pointer(&amp;val))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Attempt to start first store.</span></span><br><span class="line">            <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">            <span class="comment">// active spin wait to wait for completion.</span></span><br><span class="line">            runtime_procPin()</span><br><span class="line">            <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">                runtime_procUnpin()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Complete first store.</span></span><br><span class="line">            StorePointer(&amp;vp.data, vlp.data)</span><br><span class="line">            StorePointer(&amp;vp.typ, vlp.typ)</span><br><span class="line">            runtime_procUnpin()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">            <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">            <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">            <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">        <span class="keyword">if</span> typ != vlp.typ &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        StorePointer(&amp;vp.data, vlp.data)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>类似Store，更新atomic类型的数值-&gt;newVal，并返回先前数值-&gt;oldVal</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swap stores new into Value and returns the previous value. It returns nil if</span></span><br><span class="line"><span class="comment">// the Value is empty.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All calls to Swap for a given Value must use values of the same concrete</span></span><br><span class="line"><span class="comment">// type. Swap of an inconsistent type panics, as does Swap(nil).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Swap(<span class="built_in">new</span> any) (old any) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: swap of nil value into Value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    np := (*efaceWords)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Attempt to start first store.</span></span><br><span class="line">            <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">            <span class="comment">// active spin wait to wait for completion; and so that</span></span><br><span class="line">            <span class="comment">// GC does not see the fake type accidentally.</span></span><br><span class="line">            runtime_procPin()</span><br><span class="line">            <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">                runtime_procUnpin()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Complete first store.</span></span><br><span class="line">            StorePointer(&amp;vp.data, np.data)</span><br><span class="line">            StorePointer(&amp;vp.typ, np.typ)</span><br><span class="line">            runtime_procUnpin()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">            <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">            <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">            <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">        <span class="keyword">if</span> typ != np.typ &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: swap of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        op := (*efaceWords)(unsafe.Pointer(&amp;old))</span><br><span class="line">        op.typ, op.data = np.typ, SwapPointer(&amp;vp.data, np.data)</span><br><span class="line">        <span class="keyword">return</span> old</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h3><p>对比atomic类型当前数值，相同则更新并返回true，否则不处理并返回false</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CompareAndSwap executes the compare-and-swap operation for the [Value].</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All calls to CompareAndSwap for a given Value must use values of the same</span></span><br><span class="line"><span class="comment">// concrete type. CompareAndSwap of an inconsistent type panics, as does</span></span><br><span class="line"><span class="comment">// CompareAndSwap(old, nil).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> CompareAndSwap(old, <span class="built_in">new</span> any) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of nil value into Value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    np := (*efaceWords)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">    op := (*efaceWords)(unsafe.Pointer(&amp;old))</span><br><span class="line">    <span class="keyword">if</span> op.typ != <span class="literal">nil</span> &amp;&amp; np.typ != op.typ &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of inconsistently typed values&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Attempt to start first store.</span></span><br><span class="line">            <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">            <span class="comment">// active spin wait to wait for completion; and so that</span></span><br><span class="line">            <span class="comment">// GC does not see the fake type accidentally.</span></span><br><span class="line">            runtime_procPin()</span><br><span class="line">            <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">                runtime_procUnpin()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Complete first store.</span></span><br><span class="line">            StorePointer(&amp;vp.data, np.data)</span><br><span class="line">            StorePointer(&amp;vp.typ, np.typ)</span><br><span class="line">            runtime_procUnpin()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">            <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">            <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">            <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">        <span class="keyword">if</span> typ != np.typ &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Compare old and current via runtime equality check.</span></span><br><span class="line">        <span class="comment">// This allows value types to be compared, something</span></span><br><span class="line">        <span class="comment">// not offered by the package functions.</span></span><br><span class="line">        <span class="comment">// CompareAndSwapPointer below only ensures vp.data</span></span><br><span class="line">        <span class="comment">// has not changed since LoadPointer.</span></span><br><span class="line">        data := LoadPointer(&amp;vp.data)</span><br><span class="line">        <span class="keyword">var</span> i any</span><br><span class="line">        (*efaceWords)(unsafe.Pointer(&amp;i)).typ = typ</span><br><span class="line">        (*efaceWords)(unsafe.Pointer(&amp;i)).data = data</span><br><span class="line">        <span class="keyword">if</span> i != old &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CompareAndSwapPointer(&amp;vp.data, data, np.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特定类型方法"><a href="#特定类型方法" class="headerlink" title="特定类型方法"></a>特定类型方法</h2><p>相对于其他，整型数有几个额外方法：Add、And、Or，相关类型是</p>
<ul>
<li><code>Int32</code></li>
<li><code>Int64</code></li>
<li><code>Uint32</code></li>
<li><code>Uint64</code></li>
<li><code>Uintptr</code></li>
</ul>
<p>示例代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">counter := <span class="type">int32</span>(<span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter += 1</span></span><br><span class="line">counter = atomic.AddInt32(&amp;counter, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// print 100</span></span><br><span class="line">fmt.Println(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0110 0100 &amp; 0000 0111 -&gt; 0000 0100 =&gt; 4</span></span><br><span class="line"><span class="comment">// print 100</span></span><br><span class="line">fmt.Println(atomic.AndInt32(&amp;counter, <span class="number">7</span>))</span><br><span class="line"><span class="comment">// print 4</span></span><br><span class="line">fmt.Println(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0100 | 0000 0010 -&gt; 0000 0110 =&gt; 6</span></span><br><span class="line"><span class="comment">// print 4</span></span><br><span class="line">fmt.Println(atomic.OrInt32(&amp;counter, <span class="number">2</span>))</span><br><span class="line"><span class="comment">// print 6</span></span><br><span class="line">fmt.Println(counter)</span><br></pre></td></tr></table></figure>

<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a><code>Add</code></h3><p>原子加法操作，两个数相加，返回结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/atomic/atomic_amd64.s</span></span><br><span class="line"><span class="comment">// src/sync/atomic/type.go</span></span><br><span class="line"><span class="comment">// Add atomically adds delta to x and returns the new value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int64)</span></span> Add(delta <span class="type">int64</span>) (<span class="built_in">new</span> <span class="type">int64</span>) &#123; <span class="keyword">return</span> AddInt64(&amp;x.v, delta) &#125;</span><br></pre></td></tr></table></figure>

<p>AddInt64汇编代码如下，本人对汇编代码不了解，下面的注释是由ChatGPT提供的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// uint64 Xadd64(uint64 volatile *val, int64 delta)</span><br><span class="line">// Atomically:</span><br><span class="line">//    *val += delta;</span><br><span class="line">//    return *val;</span><br><span class="line">TEXT ·Xadd64(SB), NOSPLIT, $0-24</span><br><span class="line">    MOVQ    ptr+0(FP), BX       // ptr（val 的地址）被加载到寄存器 BX 中</span><br><span class="line">    MOVQ    delta+8(FP), AX     // delta 被加载到寄存器 AX 中</span><br><span class="line">    MOVQ    AX, CX              // 复制 AX 的值到 CX，以便后面能把 delta 加到返回值中</span><br><span class="line">    LOCK                        // 确保接下来的操作是原子性的</span><br><span class="line">    XADDQ    AX, 0(BX)           // 指令会将 AX 加到 BX 指向的值，并返回加法操作前的旧值（旧值会存入 AX）</span><br><span class="line">    ADDQ    CX, AX              // 将之前存储的delta加回AX上，得到最终结果</span><br><span class="line">    MOVQ    AX, ret+16(FP)      // 把最终的结果存入返回值地址</span><br><span class="line">    RET                         // 返回</span><br><span class="line"></span><br><span class="line">TEXT ·Xaddint64(SB), NOSPLIT, $0-24</span><br><span class="line">    JMP    ·Xadd64(SB)</span><br></pre></td></tr></table></figure>

<p>更多的注释如下</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>TEXT</code></td>
<td align="left">标志这段代码是一个函数</td>
</tr>
<tr>
<td align="left"><code>·Xadd64(SB)</code></td>
<td align="left">函数名称</td>
</tr>
<tr>
<td align="left"><code>SB</code></td>
<td align="left">是指向当前函数栈帧的偏移量，传递给 racecallatomic 作为栈帧的指针。</td>
</tr>
<tr>
<td align="left"><code>NOSPLIT</code></td>
<td align="left">表示该函数不会执行栈分割，也就是说，它不会访问 Go 层的栈分配</td>
</tr>
<tr>
<td align="left"><code>$0-24</code></td>
<td align="left">指示函数参数的大小范围，在这种情况下，0-24 意味着该函数有 24 字节的局部空间（用于存储传入的参数等）</td>
</tr>
</tbody></table>
<h3 id="And"><a href="#And" class="headerlink" title="And"></a><code>And</code></h3><p>原子位与（&amp;）操作，新结果写入变量，返回旧的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// And atomically performs a bitwise AND operation on x using the bitmask</span></span><br><span class="line"><span class="comment">// provided as mask and returns the old value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int64)</span></span> And(mask <span class="type">int64</span>) (old <span class="type">int64</span>) &#123; <span class="keyword">return</span> AndInt64(&amp;x.v, mask) &#125;</span><br></pre></td></tr></table></figure>

<p>AndInt64汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEXT    sync∕atomic·AndInt64(SB), NOSPLIT|NOFRAME, $0-24    // </span><br><span class="line">    GO_ARGS</span><br><span class="line">    MOVQ    $__tsan_go_atomic64_fetch_and(SB), AX</span><br><span class="line">    CALL    racecallatomic&lt;&gt;(SB)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<p>相关注释如下，只展示与AddInt64汇编代码不同的部份</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>GO_ARGS</code></td>
<td align="left">这是一个宏，表示处理传入的 Go 参数，具体的参数内容会根据函数调用的上下文进行调整。这是 Go 编译器用来处理函数调用时的一些约定。它会将传入的参数从 Go 栈中提取到寄存器中</td>
</tr>
<tr>
<td align="left"><code>__tsan_go_atomic64_fetch_and</code></td>
<td align="left">是一个标识符，Go 在进行原子操作时，通常会使用一个特殊的函数来标识和追踪潜在的数据竞争。这种操作确保了线程安全，并且在并发环境中避免了出现未同步的数据访问</td>
</tr>
<tr>
<td align="left"><code>racecallatomic</code></td>
<td align="left">Go 的一个内建函数，用来执行原子操作并同时为 ThreadSanitizer（TSan）提供监控支持。它会根据 AX 寄存器中存储的函数地址（即 __tsan_go_atomic64_fetch_and）执行对应的操作</td>
</tr>
<tr>
<td align="left"><code>&lt;&gt;</code></td>
<td align="left">表示泛型类型参数，在 Go 汇编中表示函数的参数类型。racecallatomic 函数会根据这些类型参数来处理实际的原子操作。</td>
</tr>
</tbody></table>
<h3 id="Or"><a href="#Or" class="headerlink" title="Or"></a><code>Or</code></h3><p>原子位或（|）操作，新结果写入变量，返回旧的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Or atomically performs a bitwise OR operation on x using the bitmask</span></span><br><span class="line"><span class="comment">// provided as mask and returns the old value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int64)</span></span> Or(mask <span class="type">int64</span>) (old <span class="type">int64</span>) &#123; <span class="keyword">return</span> OrInt64(&amp;x.v, mask) &#125;</span><br></pre></td></tr></table></figure>

<p>OrInt64的汇编代码如下，不再展示注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEXT    sync∕atomic·OrInt64(SB), NOSPLIT|NOFRAME, $0-24</span><br><span class="line">    GO_ARGS</span><br><span class="line">    MOVQ    $__tsan_go_atomic64_fetch_or(SB), AX</span><br><span class="line">    CALL    racecallatomic&lt;&gt;(SB)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://pkg.go.dev/sync/atomic">atomic</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Once</title>
    <url>/golang-series-sync-once/</url>
    <content><![CDATA[<p>如果要实现如Singleton、Lazy Initialization模式，那么你需要了解sync.Once，它可以用于保证如：只加载一次配置文件、只初始化一次数据库连接等，此外它还可以帮助实现更好的Plugin封装</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>以下代码展示了如何使用sync.Once实现singleton模式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    data <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Creating Singleton instance&quot;</span>)</span><br><span class="line">        instance = &amp;Singleton&#123;data: <span class="string">&quot;I&#x27;m the only one!&quot;</span>&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, GetInstance())</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for goroutines to finish</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>sync.Once的数据结构由一个atomic类型和一个mutex锁组成，通过加锁访问done标志判断</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// done indicates whether the action has been performed.</span></span><br><span class="line">    <span class="comment">// It is first in the struct because it is used in the hot path.</span></span><br><span class="line">    <span class="comment">// The hot path is inlined at every call site.</span></span><br><span class="line">    <span class="comment">// Placing done first allows more compact instructions on some architectures (amd64/386),</span></span><br><span class="line">    <span class="comment">// and fewer instructions (to calculate offset) on other architectures.</span></span><br><span class="line">    done atomic.Uint32</span><br><span class="line">    m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h3><p>Do方法的逻辑如下</p>
<ol>
<li>通过CAS原子操作读取done字段数据，如果值是1-已执行则立即返回，否则进入加锁状态</li>
<li>加锁，执行传入的函数代码，并更新done的数值</li>
</ol>
<p>原本代码的注释挺有用的，就不再赘述了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do calls the function f if and only if Do is being called for the</span></span><br><span class="line"><span class="comment">// first time for this instance of [Once]. In other words, given</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    var once Once</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// if once.Do(f) is called multiple times, only the first call will invoke f,</span></span><br><span class="line"><span class="comment">// even if f has a different value in each invocation. A new instance of</span></span><br><span class="line"><span class="comment">// Once is required for each function to execute.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do is intended for initialization that must be run exactly once. Since f</span></span><br><span class="line"><span class="comment">// is niladic, it may be necessary to use a function literal to capture the</span></span><br><span class="line"><span class="comment">// arguments to a function to be invoked by Do:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    config.once.Do(func() &#123; config.init(filename) &#125;)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because no call to Do returns until the one call to f returns, if f causes</span></span><br><span class="line"><span class="comment">// Do to be called, it will deadlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, Do considers it to have returned; future calls of Do return</span></span><br><span class="line"><span class="comment">// without calling f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">    <span class="comment">// Note: Here is an incorrect implementation of Do:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    if o.done.CompareAndSwap(0, 1) &#123;</span></span><br><span class="line">    <span class="comment">//        f()</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do guarantees that when it returns, f has finished.</span></span><br><span class="line">    <span class="comment">// This implementation would not implement that guarantee:</span></span><br><span class="line">    <span class="comment">// given two simultaneous calls, the winner of the cas would</span></span><br><span class="line">    <span class="comment">// call f, and the second would return immediately, without</span></span><br><span class="line">    <span class="comment">// waiting for the first&#x27;s call to f to complete.</span></span><br><span class="line">    <span class="comment">// This is why the slow path falls back to a mutex, and why</span></span><br><span class="line">    <span class="comment">// the o.done.Store must be delayed until after f returns.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> o.done.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">        o.doSlow(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="keyword">if</span> o.done.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> o.done.Store(<span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>从1.21版本开始，Austin Clements添加了三个sync.Once的封装：OnceFunc、OnceValue、OnceValues，方便写出更简洁紧凑的代码</p>
<h3 id="OnceFunc"><a href="#OnceFunc" class="headerlink" title="OnceFunc"></a>OnceFunc</h3><p>OnceFunc适合无任何返回值的业务逻辑，不适合用作Singleton、Lazy Initialization模式，下面是一个简单的示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    onceVoid := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    call := sync.OnceFunc(onceVoid)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        call()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnceFunc内部实现逻辑如下</p>
<ol>
<li>定义状态、封装传入的函数</li>
<li>只要f执行成功，更新状态，如将valid设置为true（已执行）</li>
<li>如果f的执行有panic，继续向上抛出异常</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OnceFunc returns a function that invokes f only once. The returned function</span></span><br><span class="line"><span class="comment">// may be called concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, the returned function will panic with the same value on every call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceFunc</span><span class="params">(f <span class="keyword">func</span>()</span></span>) <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        once  Once</span><br><span class="line">        valid <span class="type">bool</span></span><br><span class="line">        p     any</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// Construct the inner closure just once to reduce costs on the fast path.</span></span><br><span class="line">    g := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            p = <span class="built_in">recover</span>()</span><br><span class="line">            <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                <span class="comment">// Re-panic immediately so on the first call the user gets a</span></span><br><span class="line">                <span class="comment">// complete stack trace into f.</span></span><br><span class="line">                <span class="built_in">panic</span>(p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        f()</span><br><span class="line">        f = <span class="literal">nil</span>      <span class="comment">// Do not keep f alive after invoking it.</span></span><br><span class="line">        valid = <span class="literal">true</span> <span class="comment">// Set only if f does not panic.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        once.Do(g)</span><br><span class="line">        <span class="keyword">if</span> !valid &#123;</span><br><span class="line">            <span class="built_in">panic</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OnceValue"><a href="#OnceValue" class="headerlink" title="OnceValue"></a>OnceValue</h3><p>一般情况下，我们的业务逻辑使用用OnceValue即可，不够的话，还可以使用OnceValues，下面是使用OnceValue改造后的【快速上手】的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    data <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例/惰性加载</span></span><br><span class="line"><span class="keyword">var</span> instance = sync.OnceValue(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Creating Singleton instance&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;Singleton&#123;data: <span class="string">&quot;I&#x27;m the only one!&quot;</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, instance)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for goroutines to finish</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnceValue内部实现逻辑与OnceFunc一致，不同的是，内部增加了result字段用于缓存函数的返回值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OnceValue returns a function that invokes f only once and returns the value</span></span><br><span class="line"><span class="comment">// returned by f. The returned function may be called concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, the returned function will panic with the same value on every call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceValue</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(f <span class="keyword">func</span>()</span></span> T) <span class="function"><span class="keyword">func</span><span class="params">()</span></span> T &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        once   Once</span><br><span class="line">        valid  <span class="type">bool</span></span><br><span class="line">        p      any</span><br><span class="line">        result T</span><br><span class="line">    )</span><br><span class="line">    g := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            p = <span class="built_in">recover</span>()</span><br><span class="line">            <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                <span class="built_in">panic</span>(p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        result = f()</span><br><span class="line">        f = <span class="literal">nil</span></span><br><span class="line">        valid = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> T &#123;</span><br><span class="line">        once.Do(g)</span><br><span class="line">        <span class="keyword">if</span> !valid &#123;</span><br><span class="line">            <span class="built_in">panic</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OnceValues"><a href="#OnceValues" class="headerlink" title="OnceValues"></a>OnceValues</h3><p>与OnceValue不同的是，OnceValues会返回两个数值，很适合用于加载配置文件、创建数据库连接等。下面代码展示了如何使用OnceValues创建数据库连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/golang/go/issues/56102</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    db <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*sql.DB, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(dbPath <span class="type">string</span>)</span></span> *Server &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Server&#123;</span><br><span class="line">        db: sync.OnceFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*sql.DB, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sql.Open(<span class="string">&quot;sqlite&quot;</span>, dbPath)</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> DoSomething() <span class="type">error</span> &#123;</span><br><span class="line">    db, err := s.db()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    _ = db <span class="comment">// do something with db</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnceValues内部实现逻辑与OnceValue一致，不同的是，内部使用的是r1、r2两个字段用于缓存函数的返回值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OnceValues returns a function that invokes f only once and returns the values</span></span><br><span class="line"><span class="comment">// returned by f. The returned function may be called concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, the returned function will panic with the same value on every call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceValues</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(f <span class="keyword">func</span>()</span></span> (T1, T2)) <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (T1, T2) &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        once  Once</span><br><span class="line">        valid <span class="type">bool</span></span><br><span class="line">        p     any</span><br><span class="line">        r1    T1</span><br><span class="line">        r2    T2</span><br><span class="line">    )</span><br><span class="line">    g := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            p = <span class="built_in">recover</span>()</span><br><span class="line">            <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                <span class="built_in">panic</span>(p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        r1, r2 = f()</span><br><span class="line">        f = <span class="literal">nil</span></span><br><span class="line">        valid = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (T1, T2) &#123;</span><br><span class="line">        once.Do(g)</span><br><span class="line">        <span class="keyword">if</span> !valid &#123;</span><br><span class="line">            <span class="built_in">panic</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1, r2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://cristiancurteanu.com/understanding-go-sync-once/">Understanding Golang’s sync.Once: Practical Examples in 2024</a><br><a href="https://github.com/golang/go/issues/56102">sync: add OnceFunc, OnceValue, OnceValues</a><br><a href="https://victoriametrics.com/blog/go-sync-once/index.html">Go sync.Once is Simple… Does It Really?</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Mutex</title>
    <url>/golang-series-sync-mutex/</url>
    <content><![CDATA[<p>Mutex（MUTualEx）-互斥锁是一种可以保证每次只有一个goroutine访问贡献资源的方法。这个资源可以是一段程序代码、一个整数、一个map、一个struct、一个channel或其他任何东西。通过观察Mutex的源代码实现，可以将Mutex看作是一个队列（FIFO&#x2F;LIFO），具体看后面的详细描述</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu       sync.Mutex</span><br><span class="line">    counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span></span> inc(name <span class="type">string</span>) &#123;</span><br><span class="line">    c.mu.Lock()         <span class="comment">// 互斥锁，获取失败等待挂起</span></span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">    c.counters[name]++  <span class="comment">// 共享资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Container&#123;</span><br><span class="line">        counters: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">0</span>, <span class="string">&quot;b&quot;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    doIncrement := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            c.inc(name)</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> doIncrement(<span class="string">&quot;a&quot;</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">go</span> doIncrement(<span class="string">&quot;a&quot;</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">go</span> doIncrement(<span class="string">&quot;b&quot;</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(c.counters)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># map[a:20000 b:10000]</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>sync.Mutex提供的数据结构跟方法只是一层封装，实际的代码放在<code>src/internal/sync/mutex.go</code></p>
<p>Mutex的数据结构由state、sema字段组成，其中state是由三个状态位和一个29位的waiter计数器组成，sema使waiter陷入等待</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/sync/mutex.go</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 由29位的waiter_counter和3个状态位组成，结构如下</span></span><br><span class="line">    <span class="comment">// | &lt;- 29bit -&gt;    | 1bit          | 1bit       | 1bit        |</span></span><br><span class="line">    <span class="comment">// | waiter_counter | mutexStarving | mutexWoken | mutexLocked |</span></span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    <span class="comment">// semaphore</span></span><br><span class="line">    sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>mutex分为Normal-普通模式和Starvation-饥饿模式，两个模式的区别如下</p>
<p><strong>普通模式</strong></p>
<ol>
<li>新的goroutine不会进入队列排队等待，而是会尝试通过自旋抢占锁，排队中的goroutine会陷入更长时间的等待</li>
<li>当goroutine释放锁时，因为支持锁被抢占（避免CPU上下文切换）的缘故，不一定会唤醒其他goroutine</li>
</ol>
<p><strong>饥饿模式</strong></p>
<ol>
<li>禁止自旋抢占，在goroutine释放锁时，一定会唤醒队列中的其他goroutine</li>
</ol>
<p><strong>注意</strong></p>
<p>只有被唤醒woken的goroutine才能等待锁释放，其他都要挂起排队等待被唤醒</p>
<h3 id="状态位"><a href="#状态位" class="headerlink" title="状态位"></a>状态位</h3><p>mutex的三个状态位说明如下</p>
<p><strong>mutexLocked</strong></p>
<p>第1位，为0表示未锁定，为1表示已锁定</p>
<p><strong>mutexWoken</strong></p>
<p>第2位，只在普通模式使用，有woken位才能等待锁释放，该位可被新goroutine抢占。注意：goroutine在Unlock时如果判断有该标志位则不能唤醒队列中的goroutine</p>
<p><strong>mutexStarving</strong></p>
<p>第3位，goroutine等待超过1ms时设置该位，如果当前G的等待时间小于1ms或者是队列中最后一个排队的G则取消该位。该位被设置时的具体行为见上面饥饿模式的介绍</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>Mutex的方法有Lock、Unlock、TryLock，具体如下</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>大概逻辑如下</p>
<ol>
<li>CAS获取锁，成功返回</li>
<li>满足条件则进入自旋等待锁释放</li>
<li>更新state<ul>
<li>获取锁成功，返回（普通模式）</li>
<li>失败则挂起等待唤醒</li>
<li>唤醒后<ul>
<li>如果不是饥饿模式，回到第2步重试</li>
<li>如果是饥饿模式，直接获取锁返回</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// 设置locked位成功，返回</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="type">int64</span>     <span class="comment">// 用于计算等待耗时</span></span><br><span class="line">    starving := <span class="literal">false</span>           <span class="comment">// 排队等待超过1ms，进入饥饿模式</span></span><br><span class="line">    awoke := <span class="literal">false</span>              <span class="comment">// 普通模式自旋抢占锁</span></span><br><span class="line">    iter := <span class="number">0</span>                   <span class="comment">// 自旋计数器，最多4次，被唤醒后重置</span></span><br><span class="line">    old := m.state              <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 普通模式，进入自旋等待锁的释放</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">            <span class="comment">// 尝试抢占woken位，让Unlock方法不要唤醒其他goroutine</span></span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进入自旋等待</span></span><br><span class="line">            runtime_doSpin()</span><br><span class="line">            iter++</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 其他情况：饥饿模式 or 锁可用 or 自旋次数过多</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        <span class="comment">// 普通模式</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked <span class="comment">// 饥饿模式下不能动这个位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 饥饿模式 or 锁被占用</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 只要没拿到锁就等待，waiter_counter++</span></span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前G陷入饥饿 and 锁被占用</span></span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving <span class="comment">// 已经是饥饿模式的话不用再设置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通模式下被唤醒，清除woken位</span></span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清除woken位</span></span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 普通模式 获取锁成功</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 队列进出策略是LIFO还是FIFO</span></span><br><span class="line">            <span class="comment">// LIFO：如果被挂起等待好几次了，放队列前面</span></span><br><span class="line">            <span class="comment">// FIFO：新的goroutine，放队列后面</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 挂起等待</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">2</span>)</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算耗时，如果当前goroutine等待超过1ms，进入饥饿状态</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒后再一次读取state</span></span><br><span class="line">            old = m.state</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 饥饿模式</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Unlock已经将mutexLocked位设置为0</span></span><br><span class="line">                <span class="comment">// 饥饿模式下，Unlock唤醒goroutine时不会设置mutexWoken位，也不会更新waiter数量，由当前goroutine处理</span></span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// delta = 1-2^3 =&gt; -7 (0b00000111)</span></span><br><span class="line">                delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前G运行不超过1ms or 当前G是最后一个waiter</span></span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="comment">// delta -= 4 (0b00001011)</span></span><br><span class="line">                    delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 初始状态-delta -&gt; 结果状态</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 示例1：饥饿模式+两个排队的goroutine</span></span><br><span class="line">                <span class="comment">// 10 100 - 00 111(7)  -&gt; 01 101</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="comment">// 示例2：饥饿模式+1个排队的goroutine</span></span><br><span class="line">                <span class="comment">// 01 100 - 01 011(11) -&gt; 00 001</span></span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="comment">// 获取锁成功</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以下两个字段影响普通模式，对饥饿模式没影响</span></span><br><span class="line">            awoke = <span class="literal">true</span>    <span class="comment">// 唤醒后设置为true，因为woken标志位在goroutine唤醒时已设置，见Unlock</span></span><br><span class="line">            iter = <span class="number">0</span>        <span class="comment">// 可以重新进入自旋</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 更新失败，再一次读取state</span></span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname internal_sync_runtime_canSpin internal/sync.runtime_canSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internal_sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 自旋次数不能超过4次</span></span><br><span class="line">    <span class="comment">// 2. cpu只有一个的话不能自旋</span></span><br><span class="line">    <span class="comment">// 3. 不能有大量的空闲、自旋的goroutine</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= sched.npidle.Load()+sched.nmspinning.Load()+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前P的runq不为空，不应该自旋</span></span><br><span class="line">    <span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname internal_sync_runtime_SemacquireMutex internal/sync.runtime_SemacquireMutex</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internal_sync_runtime_SemacquireMutex</span><span class="params">(addr *<span class="type">uint32</span>, lifo <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile, skipframes, waitReasonSyncMutexLock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryLock"><a href="#TryLock" class="headerlink" title="TryLock"></a>TryLock</h3><p>大概逻辑如下</p>
<ol>
<li>获取state判断，如果锁被其他goroutine获取则返回false</li>
<li>锁可以被获取则使用CAS尝试获得锁，失败返回false，成功返回true</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> TryLock() <span class="type">bool</span> &#123;</span><br><span class="line">    old := m.state</span><br><span class="line">    <span class="comment">// 锁被其他goroutine获取 or 饥饿模式</span></span><br><span class="line">    <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置locked位</span></span><br><span class="line">    <span class="comment">// 直接return不行？</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><p>大概逻辑如下</p>
<ol>
<li>state-1，非常理想的情况下，如没有排队的goroutine，则state为0</li>
<li>如果unlock了一个unlocked的mutex，异常，不允许这么做</li>
<li>普通模式下因为支持抢占的原因，需要根据woken标记判断是否要唤醒队列中的goroutine</li>
<li>饥饿模式下直接唤醒一个goroutine</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// locked置0</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="comment">// 有waiter or 饥饿模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">        m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 异常，不能unlock已经unlocked的mutex</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否要去唤醒goroutine</span></span><br><span class="line">            <span class="comment">// 1. waiter数量为0，不用唤醒</span></span><br><span class="line">            <span class="comment">// 2. 锁已经被其他goroutine获取</span></span><br><span class="line">            <span class="comment">// 3. 如果有goroutine被唤醒，那么不再唤醒其他</span></span><br><span class="line">            <span class="comment">// 4. 饥饿模式不走这个逻辑</span></span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// waiter数量减一 并 设置woken位</span></span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                <span class="comment">// 唤醒一个goroutine</span></span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败重试</span></span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 饥饿模式，没有减少counter，也没有设置woken位</span></span><br><span class="line">        <span class="comment">// 唤醒一个goroutine</span></span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://victoriametrics.com/blog/go-sync-mutex/index.html">Go sync.Mutex: Normal and Starvation Mode</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.RWMutex</title>
    <url>/golang-series-sync-rwmutex/</url>
    <content><![CDATA[<p>RWMutex-读写锁，该锁可以被任意多个reader持有，或被一个writer持有。通过观察RWMutex的源代码实现，可以将RWMutex看作是FIFO队列，具体看后面的详细描述</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line"></span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="type">int</span>, size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">            rwm.Lock()          <span class="comment">// 写锁</span></span><br><span class="line">            count++             <span class="comment">// 更新资源</span></span><br><span class="line">            rwm.Unlock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        indx := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">            rwm.RLock()         <span class="comment">// 读锁</span></span><br><span class="line">            queue[indx] = count <span class="comment">// 只读</span></span><br><span class="line">            rwm.RUnlock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(count)</span><br><span class="line">    fmt.Println(queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>RWMutex结构如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sync/rwmutex.go</span></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex</span><br><span class="line">    writerSem   <span class="type">uint32</span></span><br><span class="line">    readerSem   <span class="type">uint32</span></span><br><span class="line">    readerCount atomic.Int32</span><br><span class="line">    readerWait  atomic.Int32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各字段说明如下</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>w</code></td>
<td align="left">写锁，所有的writer都会阻塞在这里</td>
</tr>
<tr>
<td align="left"><code>writerSem</code></td>
<td align="left">writer队列，获取w锁成功后，如果readerCount不为0，挂起等待reader释放锁</td>
</tr>
<tr>
<td align="left"><code>readerSem</code></td>
<td align="left">reader队列，readerCount为负时，新的reader都在这里挂起等待</td>
</tr>
<tr>
<td align="left"><code>readerCount</code></td>
<td align="left">读锁&#x2F;reader总数，max&#x3D;2^30&#x3D;1GB，为负数时表示有writer等待</td>
</tr>
<tr>
<td align="left"><code>readerWait</code></td>
<td align="left">待释放锁reader总数，获取w锁成功后纪录当前reader数量，等待reader释放读锁</td>
</tr>
</tbody></table>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><p>读加锁，具体逻辑如下</p>
<ol>
<li>readerCount++，如果返回的结果小于0，说明有writer在等待或执行，放进readerSem等待唤醒</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">    <span class="comment">// readerCount++</span></span><br><span class="line">    <span class="comment">// readerCount &lt; 0？有writer等待</span></span><br><span class="line">    <span class="keyword">if</span> rw.readerCount.Add(<span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 放到队列里等待</span></span><br><span class="line">        runtime_SemacquireRWMutexR(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryRLock"><a href="#TryRLock" class="headerlink" title="TryRLock"></a>TryRLock</h3><p>尝试获取读锁，具体逻辑如下</p>
<ol>
<li>readerCount如果小于0，说明有writer在等待或执行，返回false</li>
<li>CAS尝试更新readerCount，成功则返回，失败则回到第一步重试，永久尝试</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryRLock() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c := rw.readerCount.Load()</span><br><span class="line">        <span class="comment">// readerCount &lt; 0？有writer等待</span></span><br><span class="line">        <span class="keyword">if</span> c &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS加锁，成功则返回，失败则再次尝试</span></span><br><span class="line">        <span class="keyword">if</span> rw.readerCount.CompareAndSwap(c, c+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RUnlock"><a href="#RUnlock" class="headerlink" title="RUnlock"></a>RUnlock</h3><p>读解锁，具体逻辑如下</p>
<ol>
<li>readerCount减1，如果结果小于0，说明有writer在等待</li>
<li>readerWait减1，如果结果等于0，唤醒writer</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">    <span class="comment">// readerCount &lt; 0？有writer等待</span></span><br><span class="line">    <span class="keyword">if</span> r := rw.readerCount.Add(<span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        rw.rUnlockSlow(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复释放锁，异常</span></span><br><span class="line">    <span class="comment">// org_r == 0 =&gt; 无任何goroutine访问</span></span><br><span class="line">    <span class="comment">// org_r == -rwmutexMaxReaders =&gt; 有writer无reader</span></span><br><span class="line">    <span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">        fatal(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writer在等待，新reader肯定不会unlock，能unlock的只有readerWait</span></span><br><span class="line">    <span class="keyword">if</span> rw.readerWait.Add(<span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// readerWait归零，唤醒writer</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>写加锁，具体逻辑如下</p>
<ol>
<li>w加锁，使其它writer排队等待</li>
<li>readerCount-&#x3D;rwmutexMaxReaders，通知新的reader有writer在等待</li>
<li>原readerCount不为0，说明有reader在运行，纪录到readerWait</li>
<li>将writer放到writerSem队列，等待唤醒</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// w加锁，使其它writer排队等待</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知新的reader有writer在等待</span></span><br><span class="line">    <span class="comment">// r = readerCount =&gt; 理想情况下为0</span></span><br><span class="line">    <span class="comment">// readerCount -= 2^30</span></span><br><span class="line">    r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录在运行的reader的数量到readerWait</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; rw.readerWait.Add(r) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前goroutine放进writerSem队列，等待唤醒</span></span><br><span class="line">        runtime_SemacquireRWMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryLock"><a href="#TryLock" class="headerlink" title="TryLock"></a>TryLock</h3><p>尝试换取写锁，具体逻辑如下</p>
<ol>
<li>w尝试加锁，失败返回false</li>
<li>CAS尝试更新readerCount-&#x3D;rwmutexMaxReaders，成功则返回true，失败则解锁w并返回false</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryLock() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// w尝试加锁</span></span><br><span class="line">    <span class="keyword">if</span> !rw.w.TryLock() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知新的reader有writer在等待写入</span></span><br><span class="line">    <span class="comment">// readerCount=-rwmutexMaxReaders =&gt; 期望当前reader的数量为0</span></span><br><span class="line">    <span class="keyword">if</span> !rw.readerCount.CompareAndSwap(<span class="number">0</span>, -rwmutexMaxReaders) &#123;</span><br><span class="line">        <span class="comment">// 失败解锁w</span></span><br><span class="line">        rw.w.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><p>写解锁，具体逻辑如下</p>
<ol>
<li>readerCount+&#x3D;rwmutexMaxReaders，使其为正数，让新的reader知道锁可用</li>
<li>如果readerCount不为0，说明有reader在排队，唤醒全部reader</li>
<li>w解锁，唤醒其他排队的writer</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// 更新readerCount，让新的reader知道锁可用</span></span><br><span class="line">    r := rw.readerCount.Add(rwmutexMaxReaders)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复释放锁，异常</span></span><br><span class="line">    <span class="comment">// org_r == 0 =&gt; 无任何goroutine访问</span></span><br><span class="line">    <span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">        fatal(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将readerSem队列里等待的reader全部唤醒</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// w解锁，唤醒其他排队的writer</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-singleflight</title>
    <url>/golang-series-sync-singleflight/</url>
    <content><![CDATA[<p>在使用redis&#x2F;memcached缓存系统时，可能会遇到以下三个问题</p>
<ol>
<li>cache penetration(缓存穿透) - 数据既不在cache中也不在db中，可以用布龙过滤器处理</li>
<li>cache avalanche(缓存雪崩) - 同一时刻出现大量的key失效，可以将过期时间随机化或者不设置过期时间</li>
<li>cache breakdown(缓存击穿)&#x2F;cache stampede(缓存踩踏) - 热门的key过期，客户端加锁或者不设置过期时间</li>
</ol>
<p>缓存击穿问题中，客户端加锁使穿行化访问是一个值得考虑的解决方法，可以降低服务器（cache&#x2F;db）的压力。但另一方面，这也会让大量的请求被阻塞，吞吐量下降。实际上，同一时刻的请求可以共享响应数据，这就是singleflight解决的问题</p>
<p>singleflight不是标准库的一部份，但go的internal目录内复制了一份singleflight源码，该源码也是本文在讨论的</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/singleflight&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callCount atomic.Int32</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟db请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    callCount.Add(<span class="number">1</span>)</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="comment">// 返回的数据是随机的</span></span><br><span class="line">    <span class="keyword">return</span> rand.Intn(<span class="number">100</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装fetchData和singleflight</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchDataWrapper</span><span class="params">(g *singleflight.Group, id <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Duration(id) * <span class="number">40</span> * time.Millisecond)</span><br><span class="line">    v, err, shared := g.Do(<span class="string">&quot;key-fetch-data&quot;</span>, fetchData)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Goroutine %d: result: %v, shared: %v\n&quot;</span>, id, v, shared)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> g singleflight.Group</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> numGoroutines = <span class="number">5</span></span><br><span class="line">    wg.Add(numGoroutines)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟：发起5个请求访问db</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGoroutines; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> fetchDataWrapper(&amp;g, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Function was called %d times\n&quot;</span>, callCount.Load())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下，结果是随机的</span></span><br><span class="line"><span class="comment"># Goroutine 1: result: 2, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 0: result: 2, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 2: result: 2, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 3: result: 94, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 4: result: 94, shared: true</span></span><br><span class="line"><span class="comment"># Function was called 2 times</span></span><br></pre></td></tr></table></figure>

<p>可以看到，G0、G1、G2共享result&#x3D;2，G3、G4共享result&#x3D;94</p>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>singleflight数据结构如下所示，其中</p>
<ul>
<li><code>Group</code>  - 由mutex和map组成，本质就是map，因为map不允许并发读写，所以才加了mutex</li>
<li><code>call</code>   - 是响应数据的封装，与请求key关联在一起，因为内部的dup计数器，或许可以将其按上下文来理解</li>
<li><code>Result</code> - 也是响应数据的封装，跟channel搭配使用</li>
</ul>
<p>响应数据的封装方式有两种</p>
<ol>
<li>通过函数返回值返回</li>
<li>通过channel返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/singleflight/singleflight.go</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex           <span class="comment">// 锁，map不能并发读写</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="type">string</span>]*call     <span class="comment">// 关联key跟结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应数据封装</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    val any                    <span class="comment">// 结果值</span></span><br><span class="line">    err <span class="type">error</span>                <span class="comment">// 异常值</span></span><br><span class="line">    dups  <span class="type">int</span>                <span class="comment">// 计数器（等待中的goroutine），同时用来判断是否共享</span></span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    chans []<span class="keyword">chan</span>&lt;- Result    <span class="comment">// 结果值/异常值/是否共享（通过channel传递）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应数据封装，与channel搭配</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val    any                <span class="comment">// 结果值</span></span><br><span class="line">    Err    <span class="type">error</span>            <span class="comment">// 异常值</span></span><br><span class="line">    Shared <span class="type">bool</span>                <span class="comment">// 是否共享</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>核心的方法有Do、DoChan、ForgetUnshared，具体看下面描述</p>
<h3 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h3><p>具体逻辑如下</p>
<ol>
<li>如果key已存在，挂起等待，唤醒后读取响应数据</li>
<li>如果key不存在，为key创建响应数据封装，写入map，然后调用doCall获取响应数据</li>
<li>删除key</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (any, <span class="type">error</span>)) (v any, err <span class="type">error</span>, shared <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 为key与结果创建关联</span></span><br><span class="line"></span><br><span class="line">    g.mu.Lock() <span class="comment">// map不能并发读写，需要加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1. 相同的请求已存在，等待结果返回</span></span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        c.dups++</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        c.wg.Wait()        <span class="comment">// 挂起等待</span></span><br><span class="line">        <span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2. 新请求，创建结果并关联</span></span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 调用函数获取结果</span></span><br><span class="line">    g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> doCall(c *call, key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (any, <span class="type">error</span>)) &#123;</span><br><span class="line">    <span class="comment">// 1. 拿到结果</span></span><br><span class="line">    c.val, c.err = fn()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. map删除该key</span></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    c.wg.Done()</span><br><span class="line">    <span class="keyword">if</span> g.m[key] == c &#123;</span><br><span class="line">        <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是通过channel传递数据</span></span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">        ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DoChan"><a href="#DoChan" class="headerlink" title="DoChan"></a>DoChan</h3><p>具体逻辑同Do，只是响应数据是通过channel传递的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> DoChan(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (any, <span class="type">error</span>)) &lt;-<span class="keyword">chan</span> Result &#123;</span><br><span class="line">    <span class="comment">// 1. 为key与结果创建关联</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置容量，使当前goroutine不阻塞</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    g.mu.Lock() <span class="comment">// map不能并发读写，需要加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1. 相同的请求已存在，等待结果返回</span></span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        c.dups++</span><br><span class="line">        c.chans = <span class="built_in">append</span>(c.chans, ch)</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> ch</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2. 新请求，创建结果并关联</span></span><br><span class="line">    c := &amp;call&#123;chans: []<span class="keyword">chan</span>&lt;- Result&#123;ch&#125;&#125;</span><br><span class="line">    c.wg.Add(<span class="number">1</span>) <span class="comment">// 如果Do和DoChan混用还是需要使用到wg，否则异常</span></span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 调用函数获取结果</span></span><br><span class="line">    <span class="keyword">go</span> g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ForgetUnshared"><a href="#ForgetUnshared" class="headerlink" title="ForgetUnshared"></a>ForgetUnshared</h3><p>删除指定key，如果该key已经有其他goroutine等待，不处理</p>
<p>具体逻辑如下</p>
<ol>
<li>key不存在，返回true</li>
<li>key存在，如果dup等于0，删除并返回true，否则不处理，返回false</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> ForgetUnshared(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// map加锁</span></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">    c, ok := g.m[key]</span><br><span class="line">    <span class="comment">// key不存在</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key存在但没有共享</span></span><br><span class="line">    <span class="keyword">if</span> c.dups == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://victoriametrics.com/blog/go-singleflight/index.html">Go Singleflight Melts in Your Code, Not in Your DB</a><br><a href="https://www.dragonflydb.io/blog/developing-with-dragonfly-part-02-solve-caching-problems">Developing with Dragonfly: Solve Caching Problems</a><br><a href="https://philosophyotaku.medium.com/a-complete-beginner-guide-for-cache-penetration-stampede-avalanche-ecadd7f16009">A Complete Beginner Guide for Cache Penetration, Stampede, and Avalanche</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Pool</title>
    <url>/golang-series-sync-pool/</url>
    <content><![CDATA[<p>sync.Pool-临时对象池，是golang一个很关键的数据结构，通过复用历史对象，缓解因频繁创建、删除对象而导致的内存分配压力、GC压力，在社区中被广泛使用，有如go-gin、kubernetes等</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>下面展示一个简单的使用示例，用于帮助用户快速上手</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> JobState <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    JobStateFresh JobState = <span class="literal">iota</span></span><br><span class="line">    JobStateRunning</span><br><span class="line">    JobStateRecycled</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    state JobState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *Job)</span></span> Run() &#123;</span><br><span class="line">    <span class="keyword">switch</span> j.state &#123;</span><br><span class="line">    <span class="keyword">case</span> JobStateRecycled:</span><br><span class="line">        fmt.Println(<span class="string">&quot;this job came from the pool&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> JobStateFresh:</span><br><span class="line">        fmt.Println(<span class="string">&quot;this job just got allocated&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j.state = JobStateRunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个对象池</span></span><br><span class="line">    pool := &amp;sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;Job&#123;state: JobStateFresh&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个对象，可以是新建的或者是历史使用过的</span></span><br><span class="line">    job := pool.Get().(*Job)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行业务代码</span></span><br><span class="line">    job.Run()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset状态并放回池子里，方便下次使用</span></span><br><span class="line">    job.state = JobStateRecycled</span><br><span class="line">    pool.Put(job)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>sync.Pool的源代码注释被我删除了，建议自行查看源代码，简单总结如下</p>
<ol>
<li>sync.Pool用于临时对象服务存储&#x2F;获取（临时对象可能随时被清理掉）</li>
<li>sync.Pool是线程安全的</li>
<li>sync.Pool使用后不应该也不能被复制</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pool -&gt; local -&gt; poolLocal_0 -&gt; poolChainElt_0(head) -&gt; poolDequeue(2^(3+N)</span></span><br><span class="line"><span class="comment">//                                  ↕</span></span><br><span class="line"><span class="comment">//                              -&gt; poolChainElt_1       -&gt; poolDequeue(2^(3+N-1)</span></span><br><span class="line"><span class="comment">//                              -&gt; ...</span></span><br><span class="line"><span class="comment">//                              -&gt; poolChainElt_N(tail) -&gt; poolDequeue(2^3=8个数据)</span></span><br><span class="line"><span class="comment">//               -&gt; ...</span></span><br><span class="line"><span class="comment">//               -&gt; poolLocal_P</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      -&gt; victim</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/pool.go</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    local     unsafe.Pointer  <span class="comment">// 临时对象数组指针，真实结构是[P]poolLocal，每个P一个poolLocal链表</span></span><br><span class="line">    localSize <span class="type">uintptr</span>         <span class="comment">// local数组的大小，一般情况下与P的数量相同</span></span><br><span class="line">    victim     unsafe.Pointer <span class="comment">// 前local数组，被GC搬过来的</span></span><br><span class="line">    victimSize <span class="type">uintptr</span>        <span class="comment">// 前local数组的大小</span></span><br><span class="line">    New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any            <span class="comment">// New 用于创建临时对象，如果池子内没有数据的话</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">    poolLocalInternal         <span class="comment">// 实际数据存储位置-链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevents false sharing on widespread platforms with</span></span><br><span class="line">    <span class="comment">// 128 mod (cache line size) = 0 .</span></span><br><span class="line">    <span class="comment">// pad在amd64平台下是96个字节大小</span></span><br><span class="line">    pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">    private any               <span class="comment">// 单个数据，优化读写，该字段只被当前P访问</span></span><br><span class="line">    shared  poolChain         <span class="comment">// 链表，当前P读写都在头部，其他P没数据时从末尾偷</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 新的poolChainElt在head，容量是上一个poolChainElt的双倍</span></span><br><span class="line">    head *poolChainElt                      <span class="comment">// 头部 数据读写 =&gt; 1 write</span></span><br><span class="line">    tail atomic.Pointer[poolChainElt]       <span class="comment">// 尾部 数据读取 =&gt; N read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">    poolDequeue                             <span class="comment">// 数据部份-环形数组</span></span><br><span class="line">    <span class="comment">// next and prev link to the adjacent poolChainElts in this</span></span><br><span class="line">    <span class="comment">// poolChain.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// next is written atomically by the producer and read</span></span><br><span class="line">    <span class="comment">// atomically by the consumer. It only transitions from nil to</span></span><br><span class="line">    <span class="comment">// non-nil.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// prev is written atomically by the consumer and read</span></span><br><span class="line">    <span class="comment">// atomically by the producer. It only transitions from</span></span><br><span class="line">    <span class="comment">// non-nil to nil.</span></span><br><span class="line">    <span class="comment">// prev指向旧poolChainElt</span></span><br><span class="line">    <span class="comment">// next指向新poolChainElt</span></span><br><span class="line">    next, prev atomic.Pointer[poolChainElt]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ptr -&gt; | tail |      |      |      | head |     |</span></span><br><span class="line">    <span class="comment">// idx -&gt; | 0    | 1    | ...  | 98   | 99   | ... |</span></span><br><span class="line">    <span class="comment">// val -&gt; | 1    | 2    | ...  | 98   | nil  | nil |</span></span><br><span class="line">    headTail atomic.Uint64                  <span class="comment">// head(高32bit) + tail(低32bit)</span></span><br><span class="line">    vals []eface                            <span class="comment">// 环形数组 初始容量=8 =&gt; 2的乘方，最大不能超过2^30 =&gt; 1GB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里有几个全局变量用于纪录所有创建的池子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// Pool创建或者local扩容时使用</span></span><br><span class="line">    allPoolsMu Mutex</span><br><span class="line">    <span class="comment">// 所有创建的Pool都纪录到这里</span></span><br><span class="line">    allPools []*Pool</span><br><span class="line">    <span class="comment">// allPools的上一个历史版本，每次GC都会将allPools移动到oldPools</span></span><br><span class="line">    oldPools []*Pool</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>Get和Put操作都依赖的几个公共方法放在这里，可以先看后续的读写代码再回头看这部份</p>
<ol>
<li>pin - 用于绑定goroutine和P，阻止进入抢占模式，并返回pid</li>
<li>indexLocal - 获取local数组中指定的P的poolLocal索引</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pin pins the current goroutine to P, disables preemption and</span></span><br><span class="line"><span class="comment">// returns poolLocal pool for the P and the P&#x27;s id.</span></span><br><span class="line"><span class="comment">// Caller must call runtime_procUnpin() when done with the pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// pool不能为nil</span></span><br><span class="line">    <span class="comment">// Check whether p is nil to get a panic.</span></span><br><span class="line">    <span class="comment">// Otherwise the nil dereference happens while the m is pinned,</span></span><br><span class="line">    <span class="comment">// causing a fatal error rather than a panic.</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;nil Pool&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取pid</span></span><br><span class="line">    pid := runtime_procPin()</span><br><span class="line">    <span class="comment">// In pinSlow we store to local and then to localSize, here we load in opposite order.</span></span><br><span class="line">    <span class="comment">// Since we&#x27;ve disabled preemption, GC cannot happen in between.</span></span><br><span class="line">    <span class="comment">// Thus here we must observe local at least as large localSize.</span></span><br><span class="line">    <span class="comment">// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).</span></span><br><span class="line">    s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">    l := p.local                              <span class="comment">// load-consume</span></span><br><span class="line">    <span class="comment">// 正常情况或P缩小了</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">        <span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// P扩容了，池子不够大</span></span><br><span class="line">    <span class="keyword">return</span> p.pinSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// Retry under the mutex.</span></span><br><span class="line">    <span class="comment">// Can not lock the mutex while pinned.</span></span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    allPoolsMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> allPoolsMu.Unlock()</span><br><span class="line">    <span class="comment">// 重新pin</span></span><br><span class="line">    pid := runtime_procPin()</span><br><span class="line">    <span class="comment">// poolCleanup won&#x27;t be called while we are pinned.</span></span><br><span class="line">    s := p.localSize</span><br><span class="line">    l := p.local</span><br><span class="line">    <span class="comment">// 其他goroutine完成了扩容？</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">        <span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的池子，注册到allPools</span></span><br><span class="line">    <span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;</span><br><span class="line">        allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span></span><br><span class="line">    size := runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 一个P一个poolLocal</span></span><br><span class="line">    local := <span class="built_in">make</span>([]poolLocal, size)</span><br><span class="line">    atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release</span></span><br><span class="line">    runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release</span></span><br><span class="line">    <span class="keyword">return</span> &amp;local[pid], pid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// local数组索引，根据P的值定位poolLocal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexLocal</span><span class="params">(l unsafe.Pointer, i <span class="type">int</span>)</span></span> *poolLocal &#123;</span><br><span class="line">    lp := unsafe.Pointer(<span class="type">uintptr</span>(l) + <span class="type">uintptr</span>(i)*unsafe.Sizeof(poolLocal&#123;&#125;))</span><br><span class="line">    <span class="keyword">return</span> (*poolLocal)(lp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取一个对象"><a href="#获取一个对象" class="headerlink" title="获取一个对象"></a>获取一个对象</h3><p>大概逻辑如下</p>
<ol>
<li>根据P的值定位poolLocal链表</li>
<li>如果private有数值，返回该值</li>
<li>从shared(head)获取一个数据</li>
<li>从所有P的poolLocal链表找数据（从下一个P开始）<ul>
<li>从local查找              -&gt; private      -&gt; shared(tail)</li>
<li>从victim查找（只使用一次） -&gt; shared(tail)</li>
</ul>
</li>
<li>使用New方法生成一个新对象</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() any &#123;</span><br><span class="line">    <span class="comment">// 获取pid和poolLocal链表</span></span><br><span class="line">    l, pid := p.pin()</span><br><span class="line">    <span class="comment">// 直接读取private字段，如果有数据的话，这是一个优化，避免去查队列</span></span><br><span class="line">    x := l.private</span><br><span class="line">    l.private = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 如果private没有数据</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从shared头部获取一个数据</span></span><br><span class="line">        x, _ = l.shared.popHead()</span><br><span class="line">        <span class="comment">// 还是没有</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 从别的P偷一个回来</span></span><br><span class="line">            x = p.getSlow(pid)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unpin</span></span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">    <span class="comment">// 也没偷到</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 调用New函数</span></span><br><span class="line">        x = p.New()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) any &#123;</span><br><span class="line">    size := runtime_LoadAcquintptr(&amp;p.localSize)</span><br><span class="line">    locals := p.local</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 在local找</span></span><br><span class="line">    <span class="comment">// P可能扩容也可能缩容</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">        <span class="comment">// local数组索引，根据P的值定位poolLocal</span></span><br><span class="line">        <span class="comment">// 遍历所有P，从下一个P开始</span></span><br><span class="line">        l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size))</span><br><span class="line">        <span class="comment">// 从shared尾部获取一个数据</span></span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在victim找</span></span><br><span class="line">    size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">    <span class="comment">// 1. gc后P扩容了，没有当前P的数据</span></span><br><span class="line">    <span class="comment">// 2. victim被其他P访问过了</span></span><br><span class="line">    <span class="comment">// 3. victim为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有扩容或者缩容了</span></span><br><span class="line">    locals = p.victim</span><br><span class="line">    <span class="comment">// local数组索引，根据P的值定位poolLocal</span></span><br><span class="line">    l := indexLocal(locals, pid)</span><br><span class="line">    <span class="comment">// 下面同Get方法 </span></span><br><span class="line">    <span class="comment">// -&gt; private -&gt; shared</span></span><br><span class="line">    <span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;</span><br><span class="line">        l.private = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">        l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))</span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// victimSize设置为0</span></span><br><span class="line">    atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// poolChainElt</span></span><br><span class="line">    d := c.head</span><br><span class="line">    <span class="comment">// 从head扫描到tail</span></span><br><span class="line">    <span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 找到一个数据</span></span><br><span class="line">        <span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> val, ok</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// prev？</span></span><br><span class="line">        d = d.prev.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// poolChainElt</span></span><br><span class="line">    d := c.tail.Load()</span><br><span class="line">    <span class="comment">// shared链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// next？</span></span><br><span class="line">        d2 := d.next.Load()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前d找到一个数据</span></span><br><span class="line">        <span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> val, ok</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next为nil</span></span><br><span class="line">        <span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前d没数据，next不为nil，修改tail指针以及prev指针</span></span><br><span class="line">        <span class="keyword">if</span> c.tail.CompareAndSwap(d, d2) &#123;</span><br><span class="line">            d2.prev.Store(<span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        d = d2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> slot *eface</span><br><span class="line">    <span class="comment">// vals是一个环形数组</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ptrs := d.headTail.Load()</span><br><span class="line">        <span class="comment">// 从headTail解析</span></span><br><span class="line">        head, tail := d.unpack(ptrs)</span><br><span class="line">        <span class="comment">// 数组是空的</span></span><br><span class="line">        <span class="keyword">if</span> tail == head &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挪动指针</span></span><br><span class="line">        head--</span><br><span class="line">        ptrs2 := d.pack(head, tail)</span><br><span class="line">        <span class="comment">// 回写成功</span></span><br><span class="line">        <span class="keyword">if</span> d.headTail.CompareAndSwap(ptrs, ptrs2) &#123;</span><br><span class="line">            slot = &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">    <span class="comment">// nil特殊处理判断</span></span><br><span class="line">    <span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">        val = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Zero the slot. Unlike popTail, this isn&#x27;t racing with</span></span><br><span class="line">    <span class="comment">// pushHead, so we don&#x27;t need to be careful here.</span></span><br><span class="line">    *slot = eface&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> slot *eface</span><br><span class="line">    <span class="comment">// vals是一个环形数组</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ptrs := d.headTail.Load()</span><br><span class="line">        <span class="comment">// 从headTail解析</span></span><br><span class="line">        head, tail := d.unpack(ptrs)</span><br><span class="line">        <span class="comment">// 数组是空的</span></span><br><span class="line">        <span class="keyword">if</span> tail == head &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        ptrs2 := d.pack(head, tail+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 回写成功</span></span><br><span class="line">        <span class="keyword">if</span> d.headTail.CompareAndSwap(ptrs, ptrs2) &#123;</span><br><span class="line">            slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We now own slot.</span></span><br><span class="line">    val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">    <span class="comment">// nil特殊处理判断</span></span><br><span class="line">    <span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">        val = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell pushHead that we&#x27;re done with this slot. Zeroing the</span></span><br><span class="line">    <span class="comment">// slot is also important so we don&#x27;t leave behind references</span></span><br><span class="line">    <span class="comment">// that could keep this object live longer than necessary.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We write to val first and then publish that we&#x27;re done with</span></span><br><span class="line">    <span class="comment">// this slot by atomically writing to typ.</span></span><br><span class="line">    slot.val = <span class="literal">nil</span></span><br><span class="line">    atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>) <span class="comment">// 读写判断该字段</span></span><br><span class="line">    <span class="comment">// At this point pushHead owns the slot.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保存一个对象"><a href="#保存一个对象" class="headerlink" title="保存一个对象"></a>保存一个对象</h3><p>大概逻辑如下</p>
<ol>
<li>如果对象为nil，不处理</li>
<li>根据P的值定位poolLocal链表</li>
<li>如果private为nil，直接写入</li>
<li>如果private有数据，写入shared(head)<ul>
<li>shared链表为空，创建链表（初始数据量为8）</li>
<li>写入成功？返回</li>
<li>写入失败？扩容后再次写入（数据量最大不能超过2^30&#x3D;1GB）</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sync/pool.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x any) &#123;</span><br><span class="line">    <span class="comment">// x=nil，不操作</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取pid和poolLocal链表</span></span><br><span class="line">    l, _ := p.pin()</span><br><span class="line">    <span class="comment">// private字段是空的？直接写入</span></span><br><span class="line">    <span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.private = x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 放置在shared头部</span></span><br><span class="line">        l.shared.pushHead(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unpin</span></span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val any) &#123;</span><br><span class="line">    d := c.head</span><br><span class="line">    <span class="comment">// shared链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个poolChainElt，关联head和tail</span></span><br><span class="line">        <span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2</span></span><br><span class="line">        d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">        d.vals = <span class="built_in">make</span>([]eface, initSize)</span><br><span class="line">        c.head = d</span><br><span class="line">        c.tail.Store(d)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入成功</span></span><br><span class="line">    <span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入失败</span></span><br><span class="line">    <span class="comment">// 当前poolChainElt数据满了，双倍扩容</span></span><br><span class="line">    newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line">    <span class="comment">// 最大不能超过2^30 =&gt; 1GB</span></span><br><span class="line">    <span class="keyword">if</span> newSize &gt;= dequeueLimit &#123;</span><br><span class="line">        newSize = dequeueLimit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d2 := &amp;poolChainElt&#123;&#125;</span><br><span class="line">    d2.prev.Store(d)</span><br><span class="line">    d2.vals = <span class="built_in">make</span>([]eface, newSize)</span><br><span class="line">    c.head = d2</span><br><span class="line">    d.next.Store(d2)</span><br><span class="line">    d2.pushHead(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val any) <span class="type">bool</span> &#123;</span><br><span class="line">    ptrs := d.headTail.Load()</span><br><span class="line">    <span class="comment">// 从headTail解析</span></span><br><span class="line">    head, tail := d.unpack(ptrs)</span><br><span class="line">    <span class="comment">// (tail_idx+size)&amp;mask == head</span></span><br><span class="line">    <span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;</span><br><span class="line">        <span class="comment">// Queue is full.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标slot还有数据</span></span><br><span class="line">    <span class="comment">// Check if the head slot has been released by popTail.</span></span><br><span class="line">    typ := atomic.LoadPointer(&amp;slot.typ)</span><br><span class="line">    <span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Another goroutine is still cleaning up the tail, so</span></span><br><span class="line">        <span class="comment">// the queue is actually still full.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil转换</span></span><br><span class="line">    <span class="comment">// The head slot is free, so we own it.</span></span><br><span class="line">    <span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">        val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    *(*any)(unsafe.Pointer(slot)) = val</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increment head. This passes ownership of slot to popTail</span></span><br><span class="line">    <span class="comment">// and acts as a store barrier for writing the slot.</span></span><br><span class="line">    d.headTail.Add(<span class="number">1</span> &lt;&lt; dequeueBits)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h3><p>每当GC进入STW状态时，清理Pool相关数据</p>
<ol>
<li>Pool内数据过期：local -&gt; victim &amp; victim -&gt; nil</li>
<li>全局变量数据过期：allPools -&gt; oldPools &amp; oldPools -&gt; nil</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// This function is called with the world stopped, at the beginning of a garbage collection.</span></span><br><span class="line">    <span class="comment">// It must not allocate and probably should not call any runtime functions.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Because the world is stopped, no pool user can be in a</span></span><br><span class="line">    <span class="comment">// pinned section (in effect, this has all Ps pinned).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drop victim caches from all pools.</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">        p.victim = <span class="literal">nil</span></span><br><span class="line">        p.victimSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move primary cache to victim cache.</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">        p.victim = p.local</span><br><span class="line">        p.victimSize = p.localSize</span><br><span class="line">        p.local = <span class="literal">nil</span></span><br><span class="line">        p.localSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The pools with non-empty primary caches now have non-empty</span></span><br><span class="line">    <span class="comment">// victim caches and no pools have primary caches.</span></span><br><span class="line">    oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储切片注意"><a href="#存储切片注意" class="headerlink" title="存储切片注意"></a>存储切片注意</h2><p>当使用sync.Pool存储切片时，sync.Pool会如何处理呢？看下面示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool = sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := pool.Get().([]<span class="type">byte</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...do something with b</span></span><br><span class="line">    _ = b</span><br><span class="line"></span><br><span class="line">    pool.Put(b) <span class="comment">// this is line 21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码看，我们创建了一个可以重复利用的切片&#x2F;缓存区。打开Escape Analysis-逃逸分析运行看看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run -gcflags=<span class="string">&quot;-m&quot;</span> hello.go  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># # command-line-arguments</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: can inline init.0.func1</span></span><br><span class="line"><span class="comment"># ./hello.go:7:6: can inline init.0</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ./hello.go:10:15: make([]byte, 4096) escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:10:15: make([]byte, 4096) escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: func literal escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:21:11: b escapes to heap</span></span><br></pre></td></tr></table></figure>

<p>当创建一个slice-切片时，我们得到的是一个header，系统判断其不仅局限于New函数，使其逃逸至heap上分配，而b也是一个header，同样，系统也会使其逃逸至heap</p>
<p>重新调整代码，改为一个指向slice的指针，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool = sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">            b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> &amp;b</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bPtr := pool.Get().(*[]<span class="type">byte</span>)</span><br><span class="line">    b := *bPtr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...do something with b</span></span><br><span class="line">    _ = b</span><br><span class="line"></span><br><span class="line">    pool.Put(bPtr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再一次运行逃逸分析，得到结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run -gcflags=<span class="string">&quot;-m&quot;</span> hello.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # command-line-arguments</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: can inline init.0.func1</span></span><br><span class="line"><span class="comment"># ./hello.go:7:6: can inline init.0</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ./hello.go:10:4: moved to heap: b</span></span><br><span class="line"><span class="comment"># ./hello.go:10:13: make([]byte, 4096) escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: func literal escapes to heap</span></span><br></pre></td></tr></table></figure>

<p>这一次，把原始指针放回Pool就不会发生逃逸现象</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://unskilled.blog/posts/lets-dive-a-tour-of-sync.pool-internals/">Let’s dive: a tour of sync.Pool internals</a><br><a href="https://www.cyhone.com/articles/think-in-sync-pool/">深度分析 Golang sync.Pool 底层原理</a><br><a href="https://victoriametrics.com/blog/go-sync-pool/index.html">Go sync.Pool and the Mechanics Behind It</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Waitgroup</title>
    <url>/golang-series-sync-waitgroup/</url>
    <content><![CDATA[<p>并发情况下，如果需要等待所有的goroutine完成任务，需要使用Waitgroup等待</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>先简单列举一个使用案例，了解Waitgroup的使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d starting\n&quot;</span>, id)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// counter++</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// counter--</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            worker(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码执行后，系统输出如下，可以看到系统等待5个goroutine完成任务后才退出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># Worker 5 starting</span></span><br><span class="line"><span class="comment"># Worker 2 starting</span></span><br><span class="line"><span class="comment"># Worker 1 starting</span></span><br><span class="line"><span class="comment"># Worker 3 starting</span></span><br><span class="line"><span class="comment"># Worker 4 starting</span></span><br><span class="line"><span class="comment"># Worker 4 done</span></span><br><span class="line"><span class="comment"># Worker 5 done</span></span><br><span class="line"><span class="comment"># Worker 2 done</span></span><br><span class="line"><span class="comment"># Worker 3 done</span></span><br><span class="line"><span class="comment"># Worker 1 done</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>Waitgroup的数据结构由noCopy、state、sema三个字段组成，其中state是goroutine、waiter的计数器，sema使waiter陷入等待</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    state atomic.Uint64 <span class="comment">// high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line">    sema  <span class="type">uint32</span>        <span class="comment">// semaphore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>state的高32位：正在运行中的goroutine数量<br>state低低32为：等待中的goroutine数量</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>WaitGroup只提供了Add、Done、Wait三个方法</p>
<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>Add方法的大概逻辑如下</p>
<ol>
<li>counter+&#x3D;delta</li>
<li>counter小于0，数值异常</li>
<li>发现goroutine出现并发调用Add、Wait，异常</li>
<li>有正在运行的goroutine或者没有等待的goroutine，返回（成功）</li>
<li>唤醒所有等待中的goroutine</li>
</ol>
<p>具体源代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) &#123;</span><br><span class="line">    state := wg.state.Add(<span class="type">uint64</span>(delta) &lt;&lt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">// counter：还在运行中的goroutine数量</span></span><br><span class="line">    w := <span class="type">uint32</span>(state)      <span class="comment">// waiter_counter：等待中的goroutine数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// counter不能为负，只能大于等于0</span></span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常，这个场景不好想象，先忽略</span></span><br><span class="line">    <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="type">int32</span>(delta) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有正在运行的goroutine or 没有等待的goroutine</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有等待中的goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> wg.state.Load() != state &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性将waiter_counter清零</span></span><br><span class="line">    wg.state.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有等待中的goroutine</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(&amp;wg.sema, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h3><p>Done方法时add方法的一种封装，不多介绍，见Add</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// counter--</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() &#123;</span><br><span class="line">    wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><p>Wait本质是一个无限循环，一直等待sema释放</p>
<ol>
<li>counter&#x3D;&#x3D;0，不需要等待，返回</li>
<li>waiter_counter++，当前goroutine挂起等待</li>
<li>被唤醒后直接返回</li>
</ol>
<p>具体源代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wait blocks until the [WaitGroup] counter is zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := wg.state.Load()</span><br><span class="line"></span><br><span class="line">        v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)     <span class="comment">// counter：还在运行中的goroutine数量</span></span><br><span class="line">        w := <span class="type">uint32</span>(state)          <span class="comment">// waiter_counter：等待中的goroutine数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有在运行中的goroutine，不需要等待</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// waiter_counter++</span></span><br><span class="line">        <span class="keyword">if</span> wg.state.CompareAndSwap(state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 挂起等待</span></span><br><span class="line">            runtime_SemacquireWaitGroup(&amp;wg.sema)</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            <span class="keyword">if</span> wg.state.Load() != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_SemacquireWaitGroup sync.runtime_SemacquireWaitGroup</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_SemacquireWaitGroup</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	semacquire1(addr, <span class="literal">false</span>, semaBlockProfile, <span class="number">0</span>, waitReasonSyncWaitGroupWait)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://victoriametrics.com/blog/go-sync-waitgroup/index.html">Go sync.WaitGroup and The Alignment Problem</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-time</title>
    <url>/golang-series-time/</url>
    <content><![CDATA[<p>time涉及的内容较多，如生成&#x2F;存储时间、比较时间、获取时间信息、时区、夏令时等，本文仅介绍一些自己感兴趣的地方</p>
<p>日历计算基于格里高利历（公历），1年有365天（闰年有366天）。同时支持墙上时钟（wall clock）和单调时钟（monotonic clock），其中墙上时钟用于时间同步、报时（time-telling），单调时钟用于时间测量（time-measuring）。并不是所有函数都支持单调时钟，如字符串编码&#x2F;解码函数就会舍弃单调时钟数据</p>
<p>注意：</p>
<ol>
<li>时间精确度：纳秒</li>
<li>大部分都是线程安全，除了<ul>
<li>GobDecode</li>
<li>UnmarshalBinary</li>
<li>UnmarshalJSON</li>
<li>UnmarshalText</li>
</ul>
</li>
<li>有些系统会在进程休眠时停止单调时钟，会导致一些函数计算异常，如<ul>
<li>Sub</li>
<li>Since</li>
<li>Until</li>
<li>Before</li>
<li>After</li>
<li>Add</li>
<li>Equal</li>
<li>Compare</li>
</ul>
</li>
<li>字符串编码时，保存的是Location的offset，会导致dst-夏令时丢失，相关函数<ul>
<li>GobEncode</li>
<li>MarshalBinary</li>
<li>AppendBinary</li>
<li>MarshalJSON</li>
<li>MarshalText</li>
<li>AppendText</li>
</ul>
</li>
<li>字符串编码&#x2F;解码时，会丢弃单调时钟信息</li>
</ol>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := fmt.Println</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := time.Now()</span><br><span class="line">    p(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定时刻</span></span><br><span class="line">    then := time.Date(</span><br><span class="line">        <span class="number">2009</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">651387237</span>, time.UTC)</span><br><span class="line">    p(then)</span><br><span class="line"></span><br><span class="line">    p(then.Year())          <span class="comment">// 年</span></span><br><span class="line">    p(then.Month())         <span class="comment">// 月</span></span><br><span class="line">    p(then.Day())           <span class="comment">// 日</span></span><br><span class="line">    p(then.Hour())          <span class="comment">// 时</span></span><br><span class="line">    p(then.Minute())        <span class="comment">// 分</span></span><br><span class="line">    p(then.Second())        <span class="comment">// 秒</span></span><br><span class="line">    p(then.Nanosecond())    <span class="comment">// 纳秒</span></span><br><span class="line">    p(then.Location())      <span class="comment">// 时区</span></span><br><span class="line"></span><br><span class="line">    p(then.Weekday())       <span class="comment">// 星期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个时刻先后顺序</span></span><br><span class="line">    p(then.Before(now))</span><br><span class="line">    p(then.After(now))</span><br><span class="line">    p(then.Equal(now))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时长/时刻差值</span></span><br><span class="line">    diff := now.Sub(then)</span><br><span class="line">    p(diff)</span><br><span class="line"></span><br><span class="line">    p(diff.Hours())         <span class="comment">// 转换成总小时数</span></span><br><span class="line">    p(diff.Minutes())       <span class="comment">// 转换成总分钟数</span></span><br><span class="line">    p(diff.Seconds())       <span class="comment">// 转换成总秒数</span></span><br><span class="line">    p(diff.Nanoseconds())   <span class="comment">// 转换成总纳秒数</span></span><br><span class="line"></span><br><span class="line">    p(then.Add(diff))</span><br><span class="line">    p(then.Add(-diff))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2025-02-22 10:30:14.247195 +0800 CST m=+0.000103986  # 当前时刻</span></span><br><span class="line"><span class="comment"># 2009-11-17 20:34:58.651387237 +0000 UTC              # 指定时刻</span></span><br><span class="line"><span class="comment"># 2009                                                 # 年</span></span><br><span class="line"><span class="comment"># November                                             # 月</span></span><br><span class="line"><span class="comment"># 17                                                   # 日</span></span><br><span class="line"><span class="comment"># 20                                                   # 时</span></span><br><span class="line"><span class="comment"># 34                                                   # 分</span></span><br><span class="line"><span class="comment"># 58                                                   # 秒</span></span><br><span class="line"><span class="comment"># 651387237                                            # 纳秒</span></span><br><span class="line"><span class="comment"># UTC                                                  # 时区</span></span><br><span class="line"><span class="comment"># Tuesday                                              # 星期</span></span><br><span class="line"><span class="comment"># true</span></span><br><span class="line"><span class="comment"># false</span></span><br><span class="line"><span class="comment"># false</span></span><br><span class="line"><span class="comment"># 133805h55m15.595807763s                              # 时长/时刻差值</span></span><br><span class="line"><span class="comment"># 133805.9209988355                                    # 总小时数</span></span><br><span class="line"><span class="comment"># 8.028355259930129e+06                                # 总分钟数</span></span><br><span class="line"><span class="comment"># 4.817013155958078e+08                                # 总秒数</span></span><br><span class="line"><span class="comment"># 481701315595807763                                   # 总纳秒数</span></span><br><span class="line"><span class="comment"># 2025-02-22 02:30:14.247195 +0000 UTC</span></span><br><span class="line"><span class="comment"># 1994-08-13 14:39:43.055579474 +0000 UTC</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>时间由Time数据结构表示，具体如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/time/time.go</span></span><br><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    wall <span class="type">uint64</span>      <span class="comment">// 1位表示flag，33位表示秒数，30位表示纳秒数</span></span><br><span class="line">    ext  <span class="type">int64</span>       <span class="comment">// wall与ext组合表示：秒数（墙上时钟）+纳秒数（墙上时钟）+纳秒数（单调时钟）【可选】</span></span><br><span class="line">    loc *Location    <span class="comment">// 时区，为nil时表示UTC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间存储"><a href="#时间存储" class="headerlink" title="时间存储"></a>时间存储</h3><p>Time结构使用wall和ext两个字段来存储时间，具体表示如下</p>
<ol>
<li>当wall第一位即flag为0时，表示没有单调时钟数据，wall和ext存储内容如下</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wall -&gt; | 1bit | 33bit                     | 30bit                     |</span></span><br><span class="line"><span class="comment">//         | 0    | 0                         | def(ns) -&gt; [0, 999999999] |</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// ext  -&gt; | 64bit                                                        |</span></span><br><span class="line"><span class="comment">//         | abc(s) =&gt; int64                                              |</span></span><br></pre></td></tr></table></figure>

<p>其中，abc伪数据表示秒数，从1年1月1日开始算起；def伪数据表示纳秒数，范围[0, 999999999]</p>
<ol start="2">
<li>当wall第一位为1时，表示有单调时钟数据，wall和ext存储内容如下</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wall -&gt; | 1bit | 33bit                     | 30bit                     |</span></span><br><span class="line"><span class="comment">//         | 1    | abc(s) =&gt; unsigned        | def(ns) -&gt; [0, 999999999] |</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// ext  -&gt; | 64bit                                                        |</span></span><br><span class="line"><span class="comment">//         | xyz(ns) =&gt; int64                                             |</span></span><br></pre></td></tr></table></figure>

<p>其中，abc伪数据表示秒数，def伪数据表示纳秒数，范围[0, 999999999]，xyz为单调时钟的纳秒数，从进程启动开始计时</p>
<p>此时，墙上时钟能表示的时间范围是[1885, 2157]</p>
<h2 id="获取时间对象Time"><a href="#获取时间对象Time" class="headerlink" title="获取时间对象Time"></a>获取时间对象Time</h2><h3 id="当前时刻Now"><a href="#当前时刻Now" class="headerlink" title="当前时刻Now"></a>当前时刻Now</h3><p>Now返回系统时间，返回的Time一般包含单调时钟数据</p>
<p>具体逻辑</p>
<ol>
<li>从系统获取时间数据（通过VDSO或clock_gettime获取）</li>
<li>如果返回的时间没有单调时钟数据，按墙上时钟格式存储</li>
<li>如果秒数出现溢出的情况，按墙上时钟格式存储</li>
<li>存储墙上时钟和单调时钟</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回本地当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 从系统获取时间数据</span></span><br><span class="line">    sec, nsec, mono := runtimeNow()</span><br><span class="line">    <span class="comment">// 没有单调时间</span></span><br><span class="line">    <span class="keyword">if</span> mono == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// unix时间戳存储时都要加上unixToInternal</span></span><br><span class="line">        <span class="keyword">return</span> Time&#123;<span class="type">uint64</span>(nsec), sec + unixToInternal, Local&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减去进程启动时获取的nanotime</span></span><br><span class="line">    mono -= startNano</span><br><span class="line">    <span class="comment">// 检测是否会溢出，2157年3月16日耗尽所有bit</span></span><br><span class="line">    sec += unixToInternal - minWall</span><br><span class="line">    <span class="comment">// 溢出？丢弃单调时钟，只存墙上时钟</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uint64</span>(sec)&gt;&gt;<span class="number">33</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Time&#123;<span class="type">uint64</span>(nsec), sec + minWall, Local&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 墙上时钟+单调时钟</span></span><br><span class="line">    <span class="keyword">return</span> Time&#123;hasMonotonic | <span class="type">uint64</span>(sec)&lt;&lt;nsecShift | <span class="type">uint64</span>(nsec), mono, Local&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程启动时初始化该变量</span></span><br><span class="line"><span class="keyword">var</span> startNano <span class="type">int64</span> = runtimeNano() - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">time_runtimeNow</span><span class="params">()</span></span> (sec <span class="type">int64</span>, nsec <span class="type">int32</span>, mono <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> sg := getg().syncGroup; sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        sec = sg.now / (<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>)</span><br><span class="line">        nsec = <span class="type">int32</span>(sg.now % (<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>))</span><br><span class="line">        <span class="keyword">return</span> sec, nsec, sg.now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time_now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/timestub.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">time_now</span><span class="params">()</span></span> (sec <span class="type">int64</span>, nsec <span class="type">int32</span>, mono <span class="type">int64</span>) &#123;</span><br><span class="line">    sec, nsec = walltime() <span class="comment">// 通过VDSO或clock_gettime获取</span></span><br><span class="line">    <span class="keyword">return</span> sec, nsec, nanotime()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">time_runtimeNano</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp.syncGroup.now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nanotime()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time_nofake.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nanotime</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// linux+amd64看相关汇编代码 src/runtime/sys_linux_amd64.s</span></span><br><span class="line">	<span class="keyword">return</span> nanotime1() <span class="comment">// 通过VDSO或clock_gettime获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unix时间戳转换"><a href="#Unix时间戳转换" class="headerlink" title="Unix时间戳转换"></a>Unix时间戳转换</h3><p>根据秒数、纳秒数返回一个从1970年1月1日开始计时的unix时间戳的Time，该Time不包含单调时钟数据。按参数精度分为Unix&#x2F;UnixMilli&#x2F;UnixMicro</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精度：秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unix</span><span class="params">(sec <span class="type">int64</span>, nsec <span class="type">int64</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 负数或超过1e9</span></span><br><span class="line">    <span class="keyword">if</span> nsec &lt; <span class="number">0</span> || nsec &gt;= <span class="number">1e9</span> &#123;</span><br><span class="line">        n := nsec / <span class="number">1e9</span></span><br><span class="line">        sec += n           <span class="comment">// 溢出部份换算成秒，加到sec</span></span><br><span class="line">        nsec -= n * <span class="number">1e9</span>    <span class="comment">// 移除溢出部份</span></span><br><span class="line">        <span class="keyword">if</span> nsec &lt; <span class="number">0</span> &#123;      <span class="comment">// 负数</span></span><br><span class="line">            nsec += <span class="number">1e9</span>    <span class="comment">// 从sec拿1s加上，使其为正</span></span><br><span class="line">            sec--          <span class="comment">// sec减去1s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unixTime(sec, <span class="type">int32</span>(nsec))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unixTime</span><span class="params">(sec <span class="type">int64</span>, nsec <span class="type">int32</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 存储时加上一个预设值unixToInternal，读取的时候减掉</span></span><br><span class="line">    <span class="keyword">return</span> Time&#123;<span class="type">uint64</span>(nsec), sec + unixToInternal, Local&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixMilli</span><span class="params">(msec <span class="type">int64</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="keyword">return</span> Unix(msec/<span class="number">1e3</span>, (msec%<span class="number">1e3</span>)*<span class="number">1e6</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：微秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixMicro</span><span class="params">(usec <span class="type">int64</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="keyword">return</span> Unix(usec/<span class="number">1e6</span>, (usec%<span class="number">1e6</span>)*<span class="number">1e3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Date获取指定时刻"><a href="#Date获取指定时刻" class="headerlink" title="Date获取指定时刻"></a>Date获取指定时刻</h3><p>根据提供的时间信息如：年&#x2F;月&#x2F;日&#x2F;时&#x2F;分&#x2F;秒以及时区获得指定时刻，具体逻辑如下</p>
<ol>
<li>规范化后计算出一个unix时间戳</li>
<li>根据时区的偏移量调整unix时间戳</li>
<li>生成Time示例</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date</span><span class="params">(year <span class="type">int</span>, month Month, day, hour, min, sec, nsec <span class="type">int</span>, loc *Location)</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 时区不能为空</span></span><br><span class="line">    <span class="keyword">if</span> loc == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: missing Location in call to Date&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规范月份，溢出值加到年上</span></span><br><span class="line">    m := <span class="type">int</span>(month) - <span class="number">1</span></span><br><span class="line">    year, m = norm(year, m, <span class="number">12</span>)</span><br><span class="line">    month = Month(m) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规范nsec, sec, min, hour, 溢出值加到天上</span></span><br><span class="line">    sec, nsec = norm(sec, nsec, <span class="number">1e9</span>)</span><br><span class="line">    min, sec = norm(min, sec, <span class="number">60</span>)</span><br><span class="line">    hour, min = norm(hour, min, <span class="number">60</span>)</span><br><span class="line">    day, hour = norm(day, hour, <span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为绝对时间，然后转换为unix时间戳</span></span><br><span class="line">    unix := <span class="type">int64</span>(dateToAbsDays(<span class="type">int64</span>(year), month, day))*secondsPerDay +</span><br><span class="line">        <span class="type">int64</span>(hour*secondsPerHour+min*secondsPerMinute+sec) +</span><br><span class="line">        absoluteToUnix</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时区偏移量</span></span><br><span class="line">    _, offset, start, end, _ := loc.lookup(unix)</span><br><span class="line">    <span class="keyword">if</span> offset != <span class="number">0</span> &#123;</span><br><span class="line">        utc := unix - <span class="type">int64</span>(offset)</span><br><span class="line">        <span class="keyword">if</span> utc &lt; start || utc &gt;= end &#123;</span><br><span class="line">            _, offset, _, _, _ = loc.lookup(utc)</span><br><span class="line">        &#125;</span><br><span class="line">        unix -= <span class="type">int64</span>(offset)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unix时间戳</span></span><br><span class="line">    t := unixTime(unix, <span class="type">int32</span>(nsec))</span><br><span class="line">    t.setLoc(loc)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi * base + lo == nhi * base + nlo</span></span><br><span class="line"><span class="comment">// 0 &lt;= nlo &lt; base</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">norm</span><span class="params">(hi, lo, base <span class="type">int</span>)</span></span> (nhi, nlo <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span> &#123;</span><br><span class="line">        n := (-lo<span class="number">-1</span>)/base + <span class="number">1</span></span><br><span class="line">        hi -= n</span><br><span class="line">        lo += n * base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lo &gt;= base &#123;</span><br><span class="line">        n := lo / base</span><br><span class="line">        hi += n</span><br><span class="line">        lo -= n * base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hi, lo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为天数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dateToAbsDays</span><span class="params">(year <span class="type">int64</span>, month Month, day <span class="type">int</span>)</span></span> absDays &#123;</span><br><span class="line">    amonth := <span class="type">uint32</span>(month)</span><br><span class="line">    janFeb := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> amonth &lt; <span class="number">3</span> &#123;</span><br><span class="line">        janFeb = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是1月和2月，再加12个月</span></span><br><span class="line">    amonth += <span class="number">12</span> * janFeb</span><br><span class="line">    <span class="comment">// year-janFeb+292277022400</span></span><br><span class="line">    y := <span class="type">uint64</span>(year) - <span class="type">uint64</span>(janFeb) + absoluteYears</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果3 &lt;= amonth &lt;= 14</span></span><br><span class="line">    <span class="comment">// ayday := (153*amonth - 457) / 5</span></span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="comment">// ayday := (979*amonth - 2919) &gt;&gt; 5</span></span><br><span class="line">    ayday := (<span class="number">979</span>*amonth - <span class="number">2919</span>) &gt;&gt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    century := y / <span class="number">100</span></span><br><span class="line">    cyear := <span class="type">uint32</span>(y % <span class="number">100</span>)</span><br><span class="line">    cday := <span class="number">1461</span> * cyear / <span class="number">4</span></span><br><span class="line">    centurydays := <span class="number">146097</span> * century / <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// absDays =&gt; uint64的别名</span></span><br><span class="line">    <span class="keyword">return</span> absDays(centurydays + <span class="type">uint64</span>(<span class="type">int64</span>(cday+ayday)+<span class="type">int64</span>(day)<span class="number">-1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增加时长获取指定时刻"><a href="#增加时长获取指定时刻" class="headerlink" title="增加时长获取指定时刻"></a>增加时长获取指定时刻</h3><h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><p>时刻t增加时长d，获得指定时刻，该方法会同时更新墙上时钟和单调时钟</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Add(d Duration) Time &#123;</span><br><span class="line">    dsec := <span class="type">int64</span>(d / <span class="number">1e9</span>)            <span class="comment">// 秒数</span></span><br><span class="line">    nsec := t.nsec() + <span class="type">int32</span>(d%<span class="number">1e9</span>)   <span class="comment">// 纳秒数</span></span><br><span class="line">    <span class="keyword">if</span> nsec &gt;= <span class="number">1e9</span> &#123;</span><br><span class="line">        dsec++</span><br><span class="line">        nsec -= <span class="number">1e9</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nsec &lt; <span class="number">0</span> &#123;</span><br><span class="line">        dsec--</span><br><span class="line">        nsec += <span class="number">1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.wall = t.wall&amp;^nsecMask | <span class="type">uint64</span>(nsec) <span class="comment">// 更新纳秒数</span></span><br><span class="line">    t.addSec(dsec)</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        te := t.ext + <span class="type">int64</span>(d)</span><br><span class="line">        <span class="keyword">if</span> d &lt; <span class="number">0</span> &amp;&amp; te &gt; t.ext || d &gt; <span class="number">0</span> &amp;&amp; te &lt; t.ext &#123;</span><br><span class="line">            <span class="comment">// 单调时钟溢出，降级成墙上时钟</span></span><br><span class="line">            t.stripMono()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t.ext = te</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> addSec(d <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        sec := <span class="type">int64</span>(t.wall &lt;&lt; <span class="number">1</span> &gt;&gt; (nsecShift + <span class="number">1</span>))</span><br><span class="line">        dsec := sec + d</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= dsec &amp;&amp; dsec &lt;= <span class="number">1</span>&lt;&lt;<span class="number">33</span><span class="number">-1</span> &#123;</span><br><span class="line">            t.wall = t.wall&amp;nsecMask | <span class="type">uint64</span>(dsec)&lt;&lt;nsecShift | hasMonotonic</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 秒数溢出，把单调时钟数据移除，降级为墙上时钟</span></span><br><span class="line">        t.stripMono()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 墙上时钟</span></span><br><span class="line">    sum := t.ext + d</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; t.ext) == (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        t.ext = sum</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> d &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t.ext = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.ext = -(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除mono时钟数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> stripMono() &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        t.ext = t.sec()     <span class="comment">// 复制秒数到ext</span></span><br><span class="line">        t.wall &amp;= nsecMask    <span class="comment">// 移除flag</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AddDate"><a href="#AddDate" class="headerlink" title="AddDate"></a>AddDate</h4><p>Time根据提供的年数&#x2F;月数&#x2F;日数获得目标指定时刻，底层实际调用的是Date方法，只更新wall clock</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> AddDate(years <span class="type">int</span>, months <span class="type">int</span>, days <span class="type">int</span>) Time &#123;</span><br><span class="line">    year, month, day := t.Date()</span><br><span class="line">    hour, min, sec := t.Clock()</span><br><span class="line">    <span class="keyword">return</span> Date(year+years, month+Month(months), day+days, hour, min, sec, <span class="type">int</span>(t.nsec()), t.Location())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串转换成Time"><a href="#字符串转换成Time" class="headerlink" title="字符串转换成Time"></a>字符串转换成Time</h3><p>常用的layout有：</p>
<table>
<thead>
<tr>
<th align="left">constant</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DateTime</td>
<td align="left">“2006-01-02 15:04:05”</td>
</tr>
<tr>
<td align="left">DateOnly</td>
<td align="left">“2006-01-02”</td>
</tr>
<tr>
<td align="left">TimeOnly</td>
<td align="left">“15:04:05”</td>
</tr>
</tbody></table>
<h4 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h4><p>解析字符串获得Time对象以及异常信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="type">string</span>)</span></span> (Time, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// RFC3339 =&gt; 2006-01-02T15:04:05Z07:00</span></span><br><span class="line">    <span class="keyword">if</span> layout == RFC3339 || layout == RFC3339Nano &#123;</span><br><span class="line">        <span class="keyword">if</span> t, ok := parseRFC3339(value, Local); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parse函数太长了，有兴趣可以看源码</span></span><br><span class="line">    <span class="keyword">return</span> parse(layout, value, UTC, Local)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ParseInLocation"><a href="#ParseInLocation" class="headerlink" title="ParseInLocation"></a>ParseInLocation</h4><p>指定时区，解析字符串获得Time对象以及异常信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInLocation</span><span class="params">(layout, value <span class="type">string</span>, loc *Location)</span></span> (Time, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// RFC3339 =&gt; 2006-01-02T15:04:05Z07:00</span></span><br><span class="line">    <span class="keyword">if</span> layout == RFC3339 || layout == RFC3339Nano &#123;</span><br><span class="line">        <span class="keyword">if</span> t, ok := parseRFC3339(value, loc); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parse函数太长了，有兴趣可以看源码</span></span><br><span class="line">    <span class="keyword">return</span> parse(layout, value, loc, loc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算两个时刻的差值"><a href="#计算两个时刻的差值" class="headerlink" title="计算两个时刻的差值"></a>计算两个时刻的差值</h2><h3 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h3><p>计算t时刻-u时刻的差值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Sub(u Time) Duration &#123;</span><br><span class="line">    <span class="comment">// 两个时刻都有单调时钟</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subMono(t.ext, u.ext)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 秒数+纳秒数</span></span><br><span class="line">    d := Duration(t.sec()-u.sec())*Second + Duration(t.nsec()-u.nsec())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> u.Add(d).Equal(t):</span><br><span class="line">        <span class="keyword">return</span> d <span class="comment">// d is correct</span></span><br><span class="line">    <span class="keyword">case</span> t.Before(u):</span><br><span class="line">        <span class="keyword">return</span> minDuration <span class="comment">// t - u is negative out of range</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> maxDuration <span class="comment">// t - u is positive out of range</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subMono</span><span class="params">(t, u <span class="type">int64</span>)</span></span> Duration &#123;</span><br><span class="line">    d := Duration(t - u)</span><br><span class="line">    <span class="keyword">if</span> d &lt; <span class="number">0</span> &amp;&amp; t &gt; u &#123;</span><br><span class="line">        <span class="keyword">return</span> maxDuration <span class="comment">// t - u is positive out of range</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> d &gt; <span class="number">0</span> &amp;&amp; t &lt; u &#123;</span><br><span class="line">        <span class="keyword">return</span> minDuration <span class="comment">// t - u is negative out of range</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Since"><a href="#Since" class="headerlink" title="Since"></a>Since</h3><p>计算从指定时刻（过去）到现在时刻的差值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Since</span><span class="params">(t Time)</span></span> Duration &#123;</span><br><span class="line">    <span class="comment">// 目标时刻有单调时钟数据</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subMono(runtimeNano()-startNano, t.ext)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Now().Sub(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Until"><a href="#Until" class="headerlink" title="Until"></a>Until</h3><p>计算从现在时刻到指定时刻（将来）的差值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Until</span><span class="params">(t Time)</span></span> Duration &#123;</span><br><span class="line">    <span class="comment">// 目标时刻有单调时钟数据</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subMono(t.ext, runtimeNano()-startNano)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.Sub(Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比较两个时刻的先后顺序"><a href="#比较两个时刻的先后顺序" class="headerlink" title="比较两个时刻的先后顺序"></a>比较两个时刻的先后顺序</h2><p>如果两个Time都包含wall clock和mono clock，则只比较mono clock，否则比较wall clock</p>
<h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><p>判断t时刻是否先于u时刻</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Before(u Time) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.ext &lt; u.ext</span><br><span class="line">    &#125;</span><br><span class="line">    ts := t.sec()</span><br><span class="line">    us := u.sec()</span><br><span class="line">    <span class="keyword">return</span> ts &lt; us || ts == us &amp;&amp; t.nsec() &lt; u.nsec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><p>判断t时刻是否晚于u时刻</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> After(u Time) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.ext &gt; u.ext</span><br><span class="line">    &#125;</span><br><span class="line">    ts := t.sec()</span><br><span class="line">    us := u.sec()</span><br><span class="line">    <span class="keyword">return</span> ts &gt; us || ts == us &amp;&amp; t.nsec() &gt; u.nsec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h3><p>判断t时刻与u时刻是否相等</p>
<p>注意：时刻比较不要使用<code>==</code>，因为<code>==</code>会比较整个Time结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Equal(u Time) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.ext == u.ext</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.sec() == u.sec() &amp;&amp; t.nsec() == u.nsec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IsZero"><a href="#IsZero" class="headerlink" title="IsZero"></a>IsZero</h3><p>判断t时刻是否是零值。</p>
<p>注意：零值是UTC时间1年1月1日0时0分0秒</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> IsZero() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.sec() == <span class="number">0</span> &amp;&amp; t.nsec() == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h3><p>比较两个时刻</p>
<ol>
<li>如果t时刻先于u时刻，返回-1</li>
<li>如果t时刻晚与u时刻，返回+1</li>
<li>如果t时刻与u时刻相等，返回0</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Compare(u Time) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tc, uc <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        tc, uc = t.ext, u.ext</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tc, uc = t.sec(), u.sec()</span><br><span class="line">        <span class="keyword">if</span> tc == uc &#123;</span><br><span class="line">            tc, uc = <span class="type">int64</span>(t.nsec()), <span class="type">int64</span>(u.nsec())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> tc &lt; uc:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">case</span> tc &gt; uc:</span><br><span class="line">        <span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><h3 id="转换时区"><a href="#转换时区" class="headerlink" title="转换时区"></a>转换时区</h3><p>时区不会改变Time存储的数值，影响的是数据输出&#x2F;表示</p>
<h4 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h4><p>切换为本机时区</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Local() Time &#123;</span><br><span class="line">    t.setLoc(Local)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> setLoc(loc *Location) &#123;</span><br><span class="line">    <span class="comment">// nil表示UTC</span></span><br><span class="line">    <span class="keyword">if</span> loc == &amp;utcLoc &#123;</span><br><span class="line">        loc = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.stripMono()</span><br><span class="line">    t.loc = loc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h4><p>切换为UTC时区</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> utcLoc = Location&#123;name: <span class="string">&quot;UTC&quot;</span>&#125; <span class="comment">// 启动时初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UTC() Time &#123;</span><br><span class="line">    t.setLoc(&amp;utcLoc)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指定时区"><a href="#指定时区" class="headerlink" title="指定时区"></a>指定时区</h4><p>切换为指定时区</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> In(loc *Location) Time &#123;</span><br><span class="line">    <span class="keyword">if</span> loc == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: missing Location in call to Time.In&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.setLoc(loc)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取报时信息"><a href="#获取报时信息" class="headerlink" title="获取报时信息"></a>获取报时信息</h2><h3 id="获取Unix时间戳"><a href="#获取Unix时间戳" class="headerlink" title="获取Unix时间戳"></a>获取Unix时间戳</h3><p>获取从1970年1月1日开始到现在的秒数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精度：秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Unix() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.unixSec()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UnixMilli() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.unixSec()*<span class="number">1e3</span> + <span class="type">int64</span>(t.nsec())/<span class="number">1e6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：微秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UnixMicro() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.unixSec()*<span class="number">1e6</span> + <span class="type">int64</span>(t.nsec())/<span class="number">1e3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：纳秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UnixNano() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (t.unixSec())*<span class="number">1e9</span> + <span class="type">int64</span>(t.nsec())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含秒数和纳秒数</span></span><br><span class="line"><span class="comment">// unix时间戳读取时都要加上internalToUnix（也就是减去unixToInternal）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> unixSec() <span class="type">int64</span> &#123; <span class="keyword">return</span> t.sec() + internalToUnix &#125;</span><br></pre></td></tr></table></figure>

<h3 id="提取日期等信息"><a href="#提取日期等信息" class="headerlink" title="提取日期等信息"></a>提取日期等信息</h3><p>业务逻辑经常需要判断两个时刻是否处在同一天&#x2F;同一周等，此外，也需要获取当前周&#x2F;当前月等的起止时刻，列举如下依赖方法</p>
<table>
<thead>
<tr>
<th align="left">method</th>
<th align="left">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Date</td>
<td align="left">获取年月日</td>
</tr>
<tr>
<td align="left">Clock</td>
<td align="left">获取时分秒</td>
</tr>
<tr>
<td align="left">ISOWeek</td>
<td align="left">获取年和周数</td>
</tr>
<tr>
<td align="left">Year</td>
<td align="left">获取年</td>
</tr>
<tr>
<td align="left">Month</td>
<td align="left">获取月</td>
</tr>
<tr>
<td align="left">Day</td>
<td align="left">获取天</td>
</tr>
<tr>
<td align="left">Hour</td>
<td align="left">获取时</td>
</tr>
<tr>
<td align="left">Minute</td>
<td align="left">获取分</td>
</tr>
<tr>
<td align="left">Second</td>
<td align="left">获取秒</td>
</tr>
<tr>
<td align="left">Round</td>
<td align="left">获取秒</td>
</tr>
<tr>
<td align="left">Truncate</td>
<td align="left">按给定时长截断</td>
</tr>
<tr>
<td align="left">Round</td>
<td align="left">按给定时长向上取整</td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 两个时刻是否是同一天</span></span><br><span class="line">NewDate(t1.Date()) == NewDate(t2.Date())</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Date <span class="keyword">struct</span> &#123;</span><br><span class="line">    YearMonth</span><br><span class="line">    day <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDate</span><span class="params">(year <span class="type">int</span>, month time.Month, day <span class="type">int</span>)</span></span> Date &#123;</span><br><span class="line">    <span class="keyword">return</span> Date&#123;</span><br><span class="line">        YearMonth: YearMonth&#123;</span><br><span class="line">            year:  year,</span><br><span class="line">            month: month,</span><br><span class="line">        &#125;,</span><br><span class="line">        day: day,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取当月开始和结束时刻</span></span><br><span class="line">startOfMonth := time.Date(t1.Year(), t1.Month(), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, t1.Location())</span><br><span class="line">endOfMonth := startOfMonth.AddDate(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>).Add(<span class="number">-1</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取当个星期的开始和结束时刻</span></span><br><span class="line"><span class="comment">// 从星期天开始计起</span></span><br><span class="line">tmp := t1.Truncate(<span class="number">7</span> * <span class="number">24</span> * time.Hour)</span><br><span class="line">startOfWeek := time.Date(tmp.Year(), tmp.Month(), tmp.Day(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, tmp.Location())</span><br><span class="line">endOfWeek := startOfWeek.AddDate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>).Add(<span class="number">-1</span> * time.Second)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样从公网访问k8s服务</title>
    <url>/how-to-access-k8s-service-from-public-network/</url>
    <content><![CDATA[<p>默认情况下，k8s创建的服务是无法对公网提供访问的，如果要从公网访问k8s服务，一般有三种方式，NodePort、LoadBalancer、Ingress，下面简单介绍NodePort、LoadBalancer，着重讲解Ingress</p>
<p>本文使用的deployment同官方教程<a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">nginx-deployment</a>，图片是从ingress-nginx官方文档拷贝过来借用，如侵必删</p>
<h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p><img src="/images/nodeport.jpg" alt="nodeport"></p>
<p>如上图所示，客户端访问集群内任意机器端口30100，k8s自动将请求转发到对应的服务</p>
<ol>
<li>创建NodePort类型的service（不指定nodeport的情况下，默认从30000-32767中挑选一个端口使用）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment nginx-deployment --<span class="built_in">type</span>=<span class="string">&quot;NodePort&quot;</span> --port 80</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看service <code>kubectl get svc</code>，输出如下</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes         ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP        12d</span><br><span class="line">nginx-deployment   NodePort    10.110.255.135   &lt;none&gt;        80:31402/TCP   4s</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证</li>
</ol>
<p>外部客户端先访问集群内任意节点端口31402，然后节点会转发到与端口关联的k8s内部服务nginx-deployment。</p>
<p>在物理机上访问服务<code>curl http://vm1:31402</code>，对比在虚拟机如vm1上执行<code>curl http://10.110.255.135</code>，两者的输出是一致的</p>
<ol start="4">
<li>删除service</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete svc nginx-deployment</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：考虑到线上一般是直接通过域名访问，如果不想在域名后还要添加端口访问服务，如<code>www.noname.io:31402</code>，那么还需要使用nginx&#x2F;haproxy建立一个反向代理的网关进行管理</p>
<span id="more"></span>

<h2 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h2><p><img src="/images/metallb.jpg" alt="metallb"></p>
<p>如上图所示，客户端的请求抵达LoadBalancer指定的IP（这里的IP有点奇怪，应该是与节点IP同一个CIDR但被保留的IP才对，看下面metallb），然后机器将流量转发到对应的服务</p>
<p>一般情况下，各个云服务厂商有提供专门支持k8s的LoadBalancer，本文依赖的k8s是自建的裸集群（bare-metal），默认不支持LoadBalancer，因此需要先安装metallb</p>
<h3 id="metallb安装"><a href="#metallb安装" class="headerlink" title="metallb安装"></a>metallb安装</h3><ol>
<li>下载配置文件，修改image地址，然后使用kubectl执行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ./metallb-native.yaml</span><br><span class="line"><span class="comment"># 如果你的网络正常</span></span><br><span class="line"><span class="comment"># kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.14.8/config/manifests/metallb-native.yaml</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看pod运行状态</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n metallb-system -o wide</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP                NODE   NOMINATED NODE   READINESS GATES</span><br><span class="line">controller-f6d7bd7b-7kg47   1/1     Running   0          51s   10.0.2.19         vm3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">speaker-8fgzx               1/1     Running   0          51s   192.168.122.235   vm3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">speaker-bfbtk               1/1     Running   0          51s   192.168.122.11    vm1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">speaker-t4lv8               1/1     Running   0          51s   192.168.122.126   vm2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置IP池</li>
</ol>
<p>配置IP池用于LoadBalancer分配，注意，要确保这部分IP不要被dhcp分配给其他任何机器</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi ip-address-pool.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">metallb.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IPAddressPool</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metallb-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.122</span><span class="number">.20</span><span class="number">-192.168</span><span class="number">.122</span><span class="number">.25</span></span><br><span class="line">  <span class="attr">autoAssign:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">metallb.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">L2Advertisement</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metallb-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ipAddressPools:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>

<p>执行命令<code>kubectl apply -f ip-address-pool.yaml</code></p>
<p>到这里就创建好了</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ol>
<li>创建LoadBalancer类型的service</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment nginx-deployment --<span class="built_in">type</span>=<span class="string">&quot;LoadBalancer&quot;</span> --port 80</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看service <code>kubectl get svc</code>，输出如下</li>
</ol>
<p>192.168.122.20这个地址不是节点IP，而是从IP池里挑选的未被使用的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME               TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)        AGE</span><br><span class="line">kubernetes         ClusterIP      10.96.0.1        &lt;none&gt;           443/TCP        12d</span><br><span class="line">nginx-deployment   LoadBalancer   10.111.110.163   192.168.122.20   80:30804/TCP   8s</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证</li>
</ol>
<p>在物理机上访问服务<code>curl -D- http://192.168.122.20 -H &#39;Host: www.noname.io&#39;</code>，对比在虚拟机上执行<code>curl -D- http://10.111.110.163</code>，两者的输出是一致的</p>
<ol start="4">
<li>删除service</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete svc nginx-deployment</span><br></pre></td></tr></table></figure>

<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>Ingress在整个k8s架构中扮演着集群网关的角色，提供了如负载均衡、SSL终结和基于名称的虚拟托管功能，当然，你可以用在a&#x2F;b测试、版本升级这种用途，目前支持的协议是http，后续的继任者Gateway提供了更强大的功能，如支持更多协议、流量管理、更灵活的配置等，但这里暂不做过多介绍</p>
<p>Ingress的运行方式有好几种，其中比较常见的是NodePort以及LoadBalancer。其工作原理是：客户端通过NodePort或者LoadBalancer的方式访问ingress，ingress再通过路由转发到指定的k8s内部服务</p>
<p>本文使用的ingress是ingress-nginx，当然，你也可以选择envoy或higress等</p>
<h3 id="ingress-nginx"><a href="#ingress-nginx" class="headerlink" title="ingress-nginx"></a>ingress-nginx</h3><p>将repo下载到本地，地址：<a href="https://github.com/kubernetes/ingress-nginx%EF%BC%8Ck8s%E4%BE%9D%E8%B5%96%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%60deploy/static/provider/%60%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8CNodePort%E6%96%B9%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%60baremetal%60%EF%BC%8C%E8%80%8CLoadBalancer%E6%96%B9%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%60cloud%60">https://github.com/kubernetes/ingress-nginx，k8s依赖的部署文件放在`deploy/static/provider/`目录下，NodePort方式的文件放在`baremetal`，而LoadBalancer方式的文件放在`cloud`</a></p>
<ol>
<li><p>拷贝文件夹<code>baremetal</code>或<code>cloud</code>，修改deploy.yaml中的image地址</p>
</li>
<li><p>执行命令<code>kubectl apply -k .</code></p>
</li>
<li><p>查看pod运行状况</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -o wide -n ingress-nginx</span><br></pre></td></tr></table></figure>

<p>输出如下，前两个是一次性的job，忽略</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME                                        READY   STATUS      RESTARTS   AGE     IP           NODE   NOMINATED NODE   READINESS GATES</span><br><span class="line">ingress-nginx-admission-create-6mmd6        0/1     Completed   0          2m33s   10.0.2.178   vm3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-admission-patch-clnr4         0/1     Completed   0          2m33s   10.0.1.235   vm2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-controller-5989548bf5-tjv5t   1/1     Running     0          2m33s   10.0.2.12    vm3    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查看controller运行状况</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get svc ingress-nginx-controller -n ingress-nginx</span><br></pre></td></tr></table></figure>

<p>如果你执行的是<code>cloud</code>配置，也就是<code>LoadBalancer</code>方式，输出如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME                       TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller   LoadBalancer   10.109.74.112   192.168.122.20   80:31608/TCP,443:30939/TCP   77m</span><br></pre></td></tr></table></figure>

<p>如果你执行的是<code>baremetal</code>配置，也就是<code>NodePort</code>方式，输出如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME                       TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller   NodePort   10.104.202.43   &lt;none&gt;        80:31880/TCP,443:30184/TCP   3m27s</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>验证</li>
</ol>
<p>访问ingress地址</p>
<p><code>LoadBalancer</code>方式如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LoadBalancer如下</span></span><br><span class="line">curl -D- http://192.168.122.20 -H <span class="string">&#x27;Host: www.noname.io&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NodePort如下</span></span><br><span class="line">curl -D- http://vm1:31880 -H <span class="string">&#x27;Host: www.noname.io&#x27;</span></span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Date: Wed, 28 Aug 2024 04:09:19 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 146</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>到这里，ingress安装完成</p>
<h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><ol>
<li>创建默认类型为ClusterIP的服务（该服务无法在集群外部访问，适合验证我们创建的ingress）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment nginx-deployment</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看service <code>kubectl get svc</code>，输出如下</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME               TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes         ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP   12d</span><br><span class="line">nginx-deployment   ClusterIP   10.106.19.73   &lt;none&gt;        80/TCP    12m</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置ingress规则</li>
</ol>
<p>该规则指定<a href="http://www.noname.io的所有流量都转发到nginx-deployment服务/">www.noname.io的所有流量都转发到nginx-deployment服务</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example-ingress.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">example-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">rules:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.noname.io</span></span><br><span class="line">   <span class="attr">http:</span></span><br><span class="line">     <span class="attr">paths:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">       <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">       <span class="attr">backend:</span></span><br><span class="line">         <span class="attr">service:</span></span><br><span class="line">           <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">           <span class="attr">port:</span></span><br><span class="line">             <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>验证</li>
</ol>
<p>访问ingress地址，仅展示LoadBalancer方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -D- http://192.168.122.20 -H <span class="string">&#x27;Host: www.noname.io&#x27;</span></span><br></pre></td></tr></table></figure>

<p>done</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://medium.com/@seanlinsanity/how-to-expose-applications-running-in-kubernetes-cluster-to-public-access-65c2fa959a3b">3 Ways to Expose Applications Running in Kubernetes Cluster to Public Access</a><br><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">Ingress</a><br><a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/ingress-minikube/">在 Minikube 环境中使用 NGINX Ingress 控制器配置 Ingress</a><br><a href="https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/baremetal.md">Bare-metal considerations</a><br><a href="https://medium.com/tektutor/using-nginx-ingress-controller-in-kubernetes-bare-metal-setup-890eb4e7772">Using Nginx Ingress Controller in Kubernetes bare-metal setup</a><br><a href="https://medium.com/tektutor/using-metal-lb-on-a-bare-metal-onprem-kubernetes-setup-6d036af1d20c">Using Metal LB on a bare-metal(OnPrem) Kubernetes Setup</a></p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>如何下载网站视频</title>
    <url>/how-to-download-online-video/</url>
    <content><![CDATA[<p>现在的在线视频网站为了打击盗版、保护资源&#x2F;网络流量，不再直接使用mp4等视频格式，而是转而使用m3u8文件（播放索引列表）+ts文件（视频分段技术），其中有的视频还用了加密，下面简单展示下如何下载ts文件并合并为mp4</p>
<h2 id="m3u8索引"><a href="#m3u8索引" class="headerlink" title="m3u8索引"></a>m3u8索引</h2><p>从浏览器的dev tool找到m3u8文件的连接并下载，该m3u8文件内有所有的ts文件列表，你可以将他们复制出来，通过编辑器补全制作成完整的url，通过下载器批量下载</p>
<h2 id="未加密"><a href="#未加密" class="headerlink" title="未加密"></a>未加密</h2><p>如果视频没有加密（m3u8文件中#EXT-X-KEY字段为空），那么在下载所有ts文件后，可以直接用linux命令合并</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ts段一般都有固定格式，如example_1.ts</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;ts_link_in_m3u8_file_&#x27;</span>&#123;number_first..number_end&#125;.ts | <span class="built_in">tr</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;\n&quot;</span> &gt; tslist</span><br><span class="line"><span class="comment"># 将所有相关的ts文件合并</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> <span class="built_in">cat</span> <span class="variable">$line</span> &gt;&gt; the_final_video.mp4; <span class="keyword">done</span> &lt; tslist</span><br></pre></td></tr></table></figure>

<p>到这里就不需要再往下看了</p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>如果视频加密（m3u8文件中#EXT-X-KEY字段不为空），如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:3</span><br><span class="line">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://hentai.com/xxxxxx&quot;,IV=0xa746ff934e7fff621ba2cf5a32608914</span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class="line">#EXT-X-TARGETDURATION:6</span><br><span class="line">#EXTINF:5.881,</span><br><span class="line">https://hentai.com/xxxxxxyyyyyyyy.ts</span><br></pre></td></tr></table></figure>

<p>处理步骤：</p>
<ol>
<li>下载必须的文件</li>
<li>修改m3u8文件</li>
<li>使用ffmpeg合并</li>
</ol>
<span id="more"></span>

<h3 id="下载必须的文件"><a href="#下载必须的文件" class="headerlink" title="下载必须的文件"></a>下载必须的文件</h3><ol>
<li>通过浏览器dev tool找到m3u8文件url</li>
<li>复制m3u8文件内所有ts文件地址到下载器下载，这里可能还需要通过编辑器补全url</li>
<li>复制m3u8文件内记录的key的地址（从EXT-X-KEY字段获取链接）到下载器下载，可进一步重命名，如改为crypt.key，该文件文件大小一般是16字节</li>
</ol>
<h3 id="修改m3u8文件"><a href="#修改m3u8文件" class="headerlink" title="修改m3u8文件"></a>修改m3u8文件</h3><ol>
<li>修改key的地址，将url改为本地文件路径</li>
<li>如果ts文件url是http链接，那么也改为本地文件路径</li>
</ol>
<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:3</span><br><span class="line">#EXT-X-KEY:METHOD=AES-128,URI=&quot;crypt.key&quot;,IV=0xa746ff934e7fff621ba2cf5a32608914</span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class="line">#EXT-X-TARGETDURATION:6</span><br><span class="line">#EXTINF:5.881,</span><br><span class="line">xxxxxxyyyyyyyy.ts</span><br></pre></td></tr></table></figure>

<h3 id="使用ffmpeg合并"><a href="#使用ffmpeg合并" class="headerlink" title="使用ffmpeg合并"></a>使用ffmpeg合并</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -allowed_extensions ALL -protocol_whitelist <span class="string">&quot;file,http,crypto,tcp&quot;</span> -i example.m3u8 -c copy the_final_video.mp4</span><br></pre></td></tr></table></figure>

<p>done</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/warcraft/p/13388280.html">记一次加密的ts视频下载</a></p>
]]></content>
      <tags>
        <tag>ffmpeg</tag>
        <tag>hls</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-定时器Timer和Ticker</title>
    <url>/golang-series-timer-and-ticker/</url>
    <content><![CDATA[<p>Timer-一次性定时器，Ticker-周期性定时器。从1.23版本开始，将异步实现改为同步实现，但你仍然可以使用AfterFunc创建异步定时器，或者通过改变asynctimerchan变量启用异步实现</p>
<p>asynctimerchan变量可选项如下</p>
<table>
<thead>
<tr>
<th align="left">asynctimerchan</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">同步实现，从1.23版本开始启用</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">旧版异步实现</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">同1，异步实现，但修复了1的问题，debug用</td>
</tr>
</tbody></table>
<p>定时器的精确度因系统不同而不同，具体如下</p>
<table>
<thead>
<tr>
<th align="left">OS</th>
<th align="left">resolution</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Unix</td>
<td align="left">~1ms</td>
</tr>
<tr>
<td align="left">&gt;&#x3D; Windows 1803</td>
<td align="left">~0.5ms</td>
</tr>
<tr>
<td align="left">&lt; Windows 1803</td>
<td align="left">~16ms</td>
</tr>
</tbody></table>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>深入了解源代码前，先了解其功能如何使用</p>
<h3 id="Timer-一次性定时器"><a href="#Timer-一次性定时器" class="headerlink" title="Timer-一次性定时器"></a>Timer-一次性定时器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定时器1</span></span><br><span class="line">    timer1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    &lt;-timer1.C</span><br><span class="line">    fmt.Println(<span class="string">&quot;Timer 1 fired&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器2</span></span><br><span class="line">    timer2 := time.NewTimer(time.Second)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-timer2.C</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer 2 fired&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    stop2 := timer2.Stop()</span><br><span class="line">    <span class="keyword">if</span> stop2 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer 2 stopped&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器3</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例代码运行效果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># Timer 1 fired</span></span><br><span class="line"><span class="comment"># Timer 2 stopped</span></span><br></pre></td></tr></table></figure>

<h3 id="Ticker-周期性定时器"><a href="#Ticker-周期性定时器" class="headerlink" title="Ticker-周期性定时器"></a>Ticker-周期性定时器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 每500ms执行一次</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Tick at&quot;</span>, t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起休眠1600ms</span></span><br><span class="line">    time.Sleep(<span class="number">1600</span> * time.Millisecond)</span><br><span class="line">    <span class="comment">// 停止定时器</span></span><br><span class="line">    ticker.Stop()</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Ticker stopped&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例代码运行效果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tick at 2025-02-27 10:41:07.875146141 +0800 CST m=+0.500099485</span></span><br><span class="line"><span class="comment"># Tick at 2025-02-27 10:41:08.37515345 +0800 CST m=+1.000100767</span></span><br><span class="line"><span class="comment"># Tick at 2025-02-27 10:41:08.875159521 +0800 CST m=+1.500100789</span></span><br><span class="line"><span class="comment"># Ticker stopped</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>time.Timer以及time.Ticker数据结构同源，在实际运行时都会转换成runtime的timeTimer，数据结构的字段释义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/time/sleep.go</span></span><br><span class="line"><span class="comment">// time.Timer结构，可以忽略，实际使用会转换成runtime的timeTimer</span></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    C         &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    initTimer <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/time/tick.go</span></span><br><span class="line"><span class="comment">// time.Ticker，可以忽略，实际使用会转换成runtime的timeTimer</span></span><br><span class="line"><span class="keyword">type</span> Ticker <span class="keyword">struct</span> &#123;</span><br><span class="line">    C          &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    initTicker <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time.go</span></span><br><span class="line"><span class="comment">// 下面几个数据结构才是实际使用的</span></span><br><span class="line"><span class="keyword">type</span> timeTimer <span class="keyword">struct</span> &#123;</span><br><span class="line">    c     unsafe.Pointer            <span class="comment">// channel</span></span><br><span class="line">    init  <span class="type">bool</span>                      <span class="comment">// 是否已经初始化</span></span><br><span class="line">    timer                           <span class="comment">// 具体看下方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu        mutex                 <span class="comment">// 锁，保护以下所有字段</span></span><br><span class="line">    astate    atomic.Uint8          <span class="comment">// state字段的复制，modify以及unlock时复制</span></span><br><span class="line">    state     <span class="type">uint8</span>                 <span class="comment">// 状态位，具体见后面的列表</span></span><br><span class="line">    isChan    <span class="type">bool</span>                  <span class="comment">// 同步还是异步（go1.23开始设置为true，除非自己设置asynctimerchan）</span></span><br><span class="line">    isFake    <span class="type">bool</span>                  <span class="comment">// 测试用</span></span><br><span class="line">    blocked   <span class="type">uint32</span>                <span class="comment">// 阻塞在channel中的G数量</span></span><br><span class="line">    when      <span class="type">int64</span>                 <span class="comment">// 目标过期时刻</span></span><br><span class="line">    period    <span class="type">int64</span>                 <span class="comment">// 时长-周期性定时器使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数f内部不能出现阻塞，默认为sendTime，也可以是goroutineReady或用户自定义函数</span></span><br><span class="line">    f         <span class="function"><span class="keyword">func</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span></span><br><span class="line">    <span class="comment">// 当与netpoll一起使用时</span></span><br><span class="line">    <span class="comment">// arg是*pollDesc</span></span><br><span class="line">    <span class="comment">// seq是版本计数器，类似时间戳，确保过期的消息不会被处理，stop以及modify时自增</span></span><br><span class="line">    <span class="comment">// 当作为time包时</span></span><br><span class="line">    <span class="comment">// arg是一个channel（After/NewTicker）或一个函数（AfterFunc）</span></span><br><span class="line">    <span class="comment">// seq同上，但没有使用</span></span><br><span class="line">    arg       any                   <span class="comment">// 见上方解释</span></span><br><span class="line">    seq       <span class="type">uintptr</span>               <span class="comment">// 版本计数器</span></span><br><span class="line"></span><br><span class="line">    ts        *timers               <span class="comment">// 判断timer属于哪个P</span></span><br><span class="line">    </span><br><span class="line">    sendLock  mutex                 <span class="comment">// 用于channel加锁（go1.23开始启用）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于处理运行定时器和停止/重置定时器的冲突检测</span></span><br><span class="line">    <span class="comment">// 只用于同步定时器（isChan == true），周期性定时器不可用</span></span><br><span class="line">    <span class="comment">// 发送数据到channel时isSending++，发送后isSending--</span></span><br><span class="line">    <span class="comment">// t.mu加锁             =&gt; isSending可自增</span></span><br><span class="line">    <span class="comment">// t.sendLock加锁       =&gt; isSending可自减</span></span><br><span class="line">    <span class="comment">// t.mu、t.sendLock加锁 =&gt; 数据只读</span></span><br><span class="line">    isSending atomic.Int32          <span class="comment">// 见上方解释</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆及其元数据，该结构放在p数据结构里（每个P一个timers）</span></span><br><span class="line"><span class="keyword">type</span> timers <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu              mutex           <span class="comment">// 锁，保护下面字段，因为其他P的G可以访问当前P的timers</span></span><br><span class="line">    heap            []timerWhen     <span class="comment">// 最小堆，用于存储timer，按heap[i].when排序</span></span><br><span class="line">    <span class="built_in">len</span>             atomic.Uint32   <span class="comment">// 最小堆中的元素数量 =&gt; len(heap)</span></span><br><span class="line">    zombies         atomic.Int32    <span class="comment">// 最小堆中，timer.state设置了timerZombie位的定时器数量</span></span><br><span class="line">    raceCtx         <span class="type">uintptr</span>         <span class="comment">// 冲突检测用，忽略</span></span><br><span class="line">    minWhenHeap     atomic.Int64    <span class="comment">// 最小堆中的最小when（=heap[0].when），为0时表示heap为空</span></span><br><span class="line">    minWhenModified atomic.Int64    <span class="comment">// 最小堆中的最小when，但仅限timer.state设置了timerModified位的定时器</span></span><br><span class="line">    syncGroup       *synctestGroup  <span class="comment">// 测试用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器及其过期时刻</span></span><br><span class="line"><span class="keyword">type</span> timerWhen <span class="keyword">struct</span> &#123;</span><br><span class="line">    timer *timer                    <span class="comment">// 定时器指针</span></span><br><span class="line">    when  <span class="type">int64</span>                     <span class="comment">// 目标过期时刻</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>timer的state状态总共占用3个位，如下所示</p>
<table>
<thead>
<tr>
<th align="left">state_name</th>
<th align="left">state_value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">timerHeaped</td>
<td align="left">1</td>
<td align="left">定时器已经放在某个P的timers最小堆中</td>
</tr>
<tr>
<td align="left">timerModified</td>
<td align="left">2</td>
<td align="left">t.when被修改但还没更新heap[i].when，如果定时器不在heap，忽略</td>
</tr>
<tr>
<td align="left">timerZombie</td>
<td align="left">4</td>
<td align="left">定时器被停止，但还放在heap里，可以跟timerModified位共存。定时器为zombie时可以发送数据到channel，因为数据不会被读取</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>timerModified和timerZombie的前提都是timerHeaped</li>
<li>无法直接把timer移除出timers.heap，因为别的P可能已经拿到了这个timer</li>
<li>timer有这几个状态位意味着最小堆还没有重新调整，timer还放在之前的位置上（不满足最小堆）</li>
</ol>
<h2 id="创建定时器"><a href="#创建定时器" class="headerlink" title="创建定时器"></a>创建定时器</h2><h3 id="NewTimer-NewTicker"><a href="#NewTimer-NewTicker" class="headerlink" title="NewTimer &amp; NewTicker"></a>NewTimer &amp; NewTicker</h3><p>创建&#x2F;获取定时器，过期时刻为当前时刻加目标时长</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span></span> *Timer &#123;</span><br><span class="line">    <span class="comment">// channel，有缓冲</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    t := (*Timer)(newTimer(when(d), <span class="number">0</span>, sendTime, c, syncTimer(c)))</span><br><span class="line">    <span class="comment">// 定时器绑定channel</span></span><br><span class="line">    t.C = c</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTicker</span><span class="params">(d Duration)</span></span> *Ticker &#123;</span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;non-positive interval for NewTicker&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// channel，有缓冲</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    t := (*Ticker)(unsafe.Pointer(newTimer(when(d), <span class="type">int64</span>(d), sendTime, c, syncTimer(c))))</span><br><span class="line">    <span class="comment">// 定时器绑定channel</span></span><br><span class="line">    t.C = c</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建定时器time.Timer或time.Ticker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTimer</span><span class="params">(when, period <span class="type">int64</span>, f <span class="keyword">func</span>(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span>, arg any, c *hchan) *timeTimer &#123;</span><br><span class="line">    t := <span class="built_in">new</span>(timeTimer)</span><br><span class="line">    <span class="comment">// mu/f/arg参数初始化，这里传nil，后面用t.modify修改</span></span><br><span class="line">    t.timer.init(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;new&quot;</span>)</span><br><span class="line">    <span class="comment">// 同步定时器（go1.23开始默认启用），初始化sendLock、isChan</span></span><br><span class="line">    <span class="keyword">if</span> c != <span class="literal">nil</span> &#123;</span><br><span class="line">        lockInit(&amp;t.sendLock, lockRankTimerSend)</span><br><span class="line">        t.isChan = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 双向绑定</span></span><br><span class="line">        c.timer = &amp;t.timer</span><br><span class="line">        <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;invalid timer channel: no capacity&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> gr := getg().syncGroup; gr != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.isFake = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line">    t.modify(when, period, f, arg, <span class="number">0</span>)</span><br><span class="line">    t.init = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取定时器触发时刻</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">when</span><span class="params">(d Duration)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 时长不能为负</span></span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> runtimeNano()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    t := runtimeNano() + <span class="type">int64</span>(d)</span><br><span class="line">    <span class="comment">// 溢出时，设置为最大值math.MaxInt64</span></span><br><span class="line">    <span class="keyword">if</span> t &lt; <span class="number">0</span> &#123;</span><br><span class="line">        t = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把目标触发时刻发送给channel，定时器过期时调用</span></span><br><span class="line"><span class="comment">// 目前有maybeRunAsync、unlockAndRun、maybeRunChan在使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendTime</span><span class="params">(c any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// delta =&gt; 实际触发时刻-目标触发时刻</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c.(<span class="keyword">chan</span> Time) &lt;- Now().Add(Duration(-delta)):</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取同步定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncTimer</span><span class="params">(c <span class="keyword">chan</span> Time)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// async，go1.22及之前版本</span></span><br><span class="line">    <span class="keyword">if</span> asynctimerchan.Value() == <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">        asynctimerchan.IncNonDefault()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sync，go1.23及以后，返回channel的指针</span></span><br><span class="line">    <span class="comment">// asynctimerchan=2作用同asynctimerchan=1，修复了旧版问题，用于debug</span></span><br><span class="line">    <span class="keyword">return</span> *(*unsafe.Pointer)(unsafe.Pointer(&amp;c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化timer的mu/f/arg字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> init(f <span class="function"><span class="keyword">func</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span>, arg any) &#123;</span><br><span class="line">    lockInit(&amp;t.mu, lockRankTimer)</span><br><span class="line">    t.f = f</span><br><span class="line">    t.arg = arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line"><span class="comment">// 一般是netpoll、time.Ticker.Reset、time.Timer.Reset调用。该方法修改的是timer的when/period/f/arg/seq字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> modify(when, period <span class="type">int64</span>, f <span class="function"><span class="keyword">func</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span>, arg any, seq <span class="type">uintptr</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line">    <span class="keyword">if</span> when &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;timer when must be positive&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> period &lt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;timer period must be non-negative&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是异步还是同步定时器（go1.23开始默认是同步定时器）</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 防止重复发送数据到channel</span></span><br><span class="line">        lock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 异步定时器</span></span><br><span class="line">    <span class="keyword">if</span> async &#123;</span><br><span class="line">        <span class="comment">// 判断定时器是否需要触发执行函数f</span></span><br><span class="line">        t.maybeRunAsync()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;modify&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新timer字段</span></span><br><span class="line"></span><br><span class="line">    oldPeriod := t.period</span><br><span class="line">    t.period = period</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.f = f</span><br><span class="line">        t.arg = arg</span><br><span class="line">        t.seq = seq</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wake := <span class="literal">false</span></span><br><span class="line">    pending := t.when &gt; <span class="number">0</span></span><br><span class="line">    t.when = when</span><br><span class="line">    <span class="comment">// timer已经在最小堆中</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        t.state |= timerModified <span class="comment">// 已修改</span></span><br><span class="line">        <span class="comment">// timer已标记删除</span></span><br><span class="line">        <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">            t.ts.zombies.Add(<span class="number">-1</span>)    <span class="comment">// 计数器更新</span></span><br><span class="line">            t.state &amp;^= timerZombie <span class="comment">// 移除标志位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// minWhen更新</span></span><br><span class="line">        <span class="comment">// 最小堆为空 or when比minWhen小</span></span><br><span class="line">        <span class="keyword">if</span> min := t.ts.minWhenModified.Load(); min == <span class="number">0</span> || when &lt; min &#123;</span><br><span class="line">            <span class="comment">// 需要中断网络轮询</span></span><br><span class="line">            wake = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 纪录state</span></span><br><span class="line">            t.astate.Store(t.state)</span><br><span class="line">            <span class="comment">// 是否要用when替换minWhenModified</span></span><br><span class="line">            t.ts.updateMinWhenModified(when)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 判断是否需要把timer添加到最小堆、中断网络轮询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要把定时器放到timers.heap</span></span><br><span class="line">    add := t.needsAdd()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 版本计数器更新</span></span><br><span class="line">        t.seq++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正在发送数据到channel</span></span><br><span class="line">        <span class="keyword">if</span> oldPeriod == <span class="number">0</span> &amp;&amp; t.isSending.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 清空channel（t.arg）的buf缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> timerchandrain(t.hchan()) &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要把定时器放到timers.heap</span></span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line">        t.maybeAdd()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断网络轮询任务</span></span><br><span class="line">    <span class="keyword">if</span> wake &#123;</span><br><span class="line">        wakeNetPoller(when)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pending</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断定时器是否需要更新timer状态，执行函数f（异步定时器执行）</span></span><br><span class="line"><span class="comment">// timer为异步定时器调用（go1.23开始应该用不到了），目前只有modify和stop函数在使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeRunAsync() &#123;</span><br><span class="line">    <span class="comment">// mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// 1. timer不在最小堆</span></span><br><span class="line">    <span class="comment">// 2. 同步定时器（用来判断同步定时器？？？）</span></span><br><span class="line">    <span class="comment">// 3. 过期时刻大于0</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped == <span class="number">0</span> &amp;&amp; t.isChan &amp;&amp; t.when &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时刻，如果已过期</span></span><br><span class="line">        <span class="keyword">if</span> now := nanotime(); t.when &lt;= now &#123;</span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">                t.unlockAndRun(now)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 重新上锁</span></span><br><span class="line">            t.lock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line"><span class="comment">// 该函数不管是异步定时器还是同步定时器都会使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> unlockAndRun(now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;unlockAndRun&quot;</span>)</span><br><span class="line">    <span class="comment">// mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// 如果timer已经放到了ts最小堆上，ts也要加锁</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        assertLockHeld(&amp;t.ts.mu)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer已经被修改或被停止，异常</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;(timerModified|timerZombie) != <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新timer状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备被调用的函数数据</span></span><br><span class="line">    f := t.f</span><br><span class="line">    arg := t.arg</span><br><span class="line">    seq := t.seq</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> next <span class="type">int64</span></span><br><span class="line">    <span class="comment">// 超过过期时刻的纳秒数</span></span><br><span class="line">    delay := now - t.when</span><br><span class="line">    <span class="comment">// 周期性定时器</span></span><br><span class="line">    <span class="keyword">if</span> t.period &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 计算下一个过期时刻，这公式没明白原理</span></span><br><span class="line">        next = t.when + t.period*(<span class="number">1</span>+delay/t.period)</span><br><span class="line">        <span class="comment">// 溢出了，设置为最大值2^63-1</span></span><br><span class="line">        <span class="keyword">if</span> next &lt; <span class="number">0</span> &#123;</span><br><span class="line">            next = maxWhen</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一次性定时器</span></span><br><span class="line">        next = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ts := t.ts</span><br><span class="line">    t.when = next</span><br><span class="line">    <span class="comment">// timer已经在最小堆中</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 设置timerModified标志位</span></span><br><span class="line">        t.state |= timerModified</span><br><span class="line">        <span class="comment">// 如果是一次性定时器，标记删除</span></span><br><span class="line">        <span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 标记为删除</span></span><br><span class="line">            t.state |= timerZombie</span><br><span class="line">            <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">            t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line">        t.updateHeap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行函数f</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是异步还是同步定时器（go1.23开始默认是同步定时器）</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 同步定时器 and 一次性</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &amp;&amp; t.period == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 发送中，计数器加1（用于并发检测，后面会执行减1操作）</span></span><br><span class="line">        <span class="keyword">if</span> t.isSending.Add(<span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;too many concurrent timer firings&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前定时器已经放到了最小堆</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 计算heap元素数量并更新len字段，最后解锁</span></span><br><span class="line">        ts.unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &amp;&amp; ts.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Temporarily use the timer&#x27;s synctest group for the G running this timer.</span></span><br><span class="line">        gp := getg()</span><br><span class="line">        <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;unexpected syncgroup set&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        gp.syncGroup = ts.syncGroup</span><br><span class="line">        ts.syncGroup.changegstatus(gp, _Gdead, _Grunning)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        lock(&amp;t.sendLock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次性定时器</span></span><br><span class="line">        <span class="keyword">if</span> t.period == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 发送完毕，计数器减1</span></span><br><span class="line">            <span class="keyword">if</span> t.isSending.Add(<span class="number">-1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;mismatched isSending updates&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 版本不一样，不执行。加锁后double-check </span></span><br><span class="line">        <span class="keyword">if</span> t.seq != seq &#123;</span><br><span class="line">            f = <span class="function"><span class="keyword">func</span><span class="params">(any, <span class="type">uintptr</span>, <span class="type">int64</span>)</span></span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数f</span></span><br><span class="line">    f(arg, seq, delay)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        unlock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &amp;&amp; ts.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        gp := getg()</span><br><span class="line">        ts.syncGroup.changegstatus(gp, _Grunning, _Gdead)</span><br><span class="line">        gp.syncGroup = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前定时器已经放到了最小堆</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        ts.lock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否要用when替换minWhenModified</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> updateMinWhenModified(when <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// old == 0 =&gt; 第一次访问，替换</span></span><br><span class="line">    <span class="comment">// old &lt; when =&gt; 忽略 </span></span><br><span class="line">    <span class="comment">// old &gt; when =&gt; 替换</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := ts.minWhenModified.Load()</span><br><span class="line">        <span class="keyword">if</span> old != <span class="number">0</span> &amp;&amp; old &lt; when &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ts.minWhenModified.CompareAndSwap(old, when) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要把定时器放到timers.heap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> needsAdd() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// t.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// 1. timer不在最小堆</span></span><br><span class="line">    <span class="comment">// 2. 过期时刻大于0</span></span><br><span class="line">    <span class="comment">// 3. 异步定时器 or 在测试 or 有G阻塞在channel中</span></span><br><span class="line">    need := t.state&amp;timerHeaped == <span class="number">0</span> &amp;&amp; t.when &gt; <span class="number">0</span> &amp;&amp; (!t.isChan || t.isFake || t.blocked &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个trace都是debug用的，忽略</span></span><br><span class="line">    <span class="keyword">if</span> need &#123;</span><br><span class="line">        t.trace(<span class="string">&quot;needsAdd+&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.trace(<span class="string">&quot;needsAdd-&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> need</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空channel（t.arg）的buf缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerchandrain</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// channel数据为0</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    any := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// buf有数据？清空</span></span><br><span class="line">    <span class="keyword">for</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        any = <span class="literal">true</span></span><br><span class="line">        typedmemclr(c.elemtype, chanbuf(c, c.recvx))</span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount--</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeAdd() &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前P的timers最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保拿的是当前P</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="keyword">var</span> ts *timers</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        sg := getg().syncGroup</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;invalid timer: fake time but no syncgroup&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ts = &amp;sg.timers</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况</span></span><br><span class="line">        ts = &amp;mp.p.ptr().timers</span><br><span class="line">    &#125;</span><br><span class="line">    ts.lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 清理最小堆</span></span><br><span class="line">    <span class="comment">// 确保最小堆首尾都没有过期的timer</span></span><br><span class="line">    ts.cleanHead()</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;maybeAdd&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更新当前timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line"></span><br><span class="line">    when := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    wake := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="keyword">if</span> t.needsAdd() &#123;</span><br><span class="line">        <span class="comment">// 设置timerHeaped标志位</span></span><br><span class="line">        t.state |= timerHeaped</span><br><span class="line">        when = t.when</span><br><span class="line">        <span class="comment">// 获取最小堆的最小when，用于判断是否需要唤醒netpoller</span></span><br><span class="line">        wakeTime := ts.wakeTime()</span><br><span class="line">        <span class="comment">// 最小堆为空 or 当前timer过期时刻比最小堆的还小</span></span><br><span class="line">        wake = wakeTime == <span class="number">0</span> || when &lt; wakeTime</span><br><span class="line">        <span class="comment">// 把timer定时器加入到timers.heap最小堆中</span></span><br><span class="line">        ts.addHeap(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="comment">// 计算heap元素数量并更新len字段，最后解锁</span></span><br><span class="line">    ts.unlock()</span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断网络轮询任务</span></span><br><span class="line">    <span class="keyword">if</span> wake &#123;</span><br><span class="line">        wakeNetPoller(when)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保最小堆首尾都没有过期的timer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> cleanHead() &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;cleanHead&quot;</span>)</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 当前goroutine</span></span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小堆的最后一个元素开始向前扫描，如果timer已过期，则移除出最小堆</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 1. guard</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最小堆数据为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for循环会运行一段时间，因为持有锁，不会被抢占</span></span><br><span class="line">        <span class="comment">// 如果其他G要抢占，返回，稍后再清理</span></span><br><span class="line">        <span class="keyword">if</span> gp.preemptStop &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n := <span class="built_in">len</span>(ts.heap)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2. 尾部处理</span></span><br><span class="line">        <span class="comment">// 从最小堆的最后一个元素开始向前扫描，如果timer已过期，则移除出最小堆</span></span><br><span class="line">        <span class="keyword">if</span> t := ts.heap[n<span class="number">-1</span>].timer; t.astate.Load()&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">            t.lock()</span><br><span class="line">            <span class="comment">// double-check</span></span><br><span class="line">            <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 移除出heap前把状态清空</span></span><br><span class="line">                t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">                <span class="comment">// 表示从heap上移除</span></span><br><span class="line">                t.ts = <span class="literal">nil</span></span><br><span class="line">                <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">                ts.zombies.Add(<span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// 先用空的结构替换</span></span><br><span class="line">                ts.heap[n<span class="number">-1</span>] = timerWhen&#123;&#125;</span><br><span class="line">                <span class="comment">// 移除最后一个数据</span></span><br><span class="line">                ts.heap = ts.heap[:n<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">            t.unlock()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 头部处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最小堆中的最小timer</span></span><br><span class="line">        t := ts.heap[<span class="number">0</span>].timer</span><br><span class="line">        <span class="comment">// 不在同一个P上</span></span><br><span class="line">        <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad ts&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有被修改也没有标记删除，无须调整</span></span><br><span class="line">        <span class="keyword">if</span> t.astate.Load()&amp;(timerModified|timerZombie) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line">        updated := t.updateHeap()</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">if</span> !updated &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line"><span class="comment">// minWhenHeap = heap[0].when</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> updateMinWhenHeap() &#123;</span><br><span class="line">    <span class="comment">// mu加锁、STW</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// heap为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) == <span class="number">0</span> &#123;</span><br><span class="line">        ts.minWhenHeap.Store(<span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 最小堆中的最小when纪录到minWhenHeap字段</span></span><br><span class="line">        ts.minWhenHeap.Store(ts.heap[<span class="number">0</span>].when)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小堆的最小when，用于判断是否需要唤醒netpoller</span></span><br><span class="line"><span class="comment">// =&gt; min(minWhenHeap, minWhenModified)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> wakeTime() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 字段读取的顺序很关键，跟adjust函数存在并发竞态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了timerModified位的最小when</span></span><br><span class="line">    nextWhen := ts.minWhenModified.Load()</span><br><span class="line">    <span class="comment">// 最小when</span></span><br><span class="line">    when := ts.minWhenHeap.Load()</span><br><span class="line">    <span class="comment">// 最小堆为空 or nextWhen比最小when还要小</span></span><br><span class="line">    <span class="keyword">if</span> when == <span class="number">0</span> || (nextWhen != <span class="number">0</span> &amp;&amp; nextWhen &lt; when) &#123;</span><br><span class="line">        when = nextWhen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> when</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakeNetPoller</span><span class="params">(when <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 按道理，除非是第一次运行，不然这个时刻不应该为0，还没深入了解GMP调度，暂停分析</span></span><br><span class="line">    <span class="keyword">if</span> sched.lastpoll.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 预定结束时间</span></span><br><span class="line">        pollerPollUntil := sched.pollUntil.Load()</span><br><span class="line">        <span class="comment">// 当前没有网络轮询任务 or 当前的网络轮询还没有完成，可以中断当前轮询</span></span><br><span class="line">        <span class="keyword">if</span> pollerPollUntil == <span class="number">0</span> || pollerPollUntil &gt; when &#123;</span><br><span class="line">            <span class="comment">// 中断</span></span><br><span class="line">            netpollBreak()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">            wakep()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AfterFunc"><a href="#AfterFunc" class="headerlink" title="AfterFunc"></a>AfterFunc</h3><p>创建&#x2F;获取一次性定时器，与NewTimer的区别是使用了用户自定义函数，此外，该定时器是异步的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span></span>) *Timer &#123;</span><br><span class="line">    <span class="comment">// 异步定时器</span></span><br><span class="line">    <span class="keyword">return</span> (*Timer)(newTimer(when(d), <span class="number">0</span>, goFunc, f, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goFunc</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> arg.(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h3><p>创建定时器或重用当前G的定时器，把当前goroutine挂起休眠至少ns纳秒时间</p>
<ol>
<li>初始化g.timer或重用当前G的timer</li>
<li>计算过期时刻when，纪录到g.sleepWhen</li>
<li>调用modify更新定时器，将当前goroutine挂起等待唤醒</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeSleep</span><span class="params">(ns <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 时长不能为负</span></span><br><span class="line">    <span class="keyword">if</span> ns &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. g.timer设置</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    t := gp.timer</span><br><span class="line">    <span class="comment">// 确保当前goroutine的timer定时器不为nil</span></span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        t = <span class="built_in">new</span>(timer)</span><br><span class="line">        <span class="comment">// 纪录f/arg</span></span><br><span class="line">        t.init(goroutineReady, gp)</span><br><span class="line">        <span class="comment">// 测试，忽略</span></span><br><span class="line">        <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.isFake = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绑定</span></span><br><span class="line">        gp.timer = t</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. g.sleepWhen设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻-单调时钟</span></span><br><span class="line">    <span class="keyword">var</span> now <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> sg := gp.syncGroup; sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        now = sg.now</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标过期时刻</span></span><br><span class="line">    when := now + ns</span><br><span class="line">    <span class="keyword">if</span> when &lt; <span class="number">0</span> &#123;         <span class="comment">// 溢出</span></span><br><span class="line">        when = maxWhen     <span class="comment">// 设置为最大值2^63-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp.sleepWhen = when</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 挂起goroutine</span></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        resetForSleep(gp, <span class="literal">nil</span>)</span><br><span class="line">        <span class="comment">// 挂起休眠</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonSleep, traceBlockSleep, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 挂起休眠，挂起前调用resetForSleep</span></span><br><span class="line">        gopark(resetForSleep, <span class="literal">nil</span>, waitReasonSleep, traceBlockSleep, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能直接在timeSleep内部调用reset，G挂起前会有一个小的时间间隔，有竟态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetForSleep</span><span class="params">(gp *g, _ unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 调用modify函数更新when和period</span></span><br><span class="line">    gp.timer.reset(gp.sleepWhen, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="After-Tick"><a href="#After-Tick" class="headerlink" title="After &amp; Tick"></a>After &amp; Tick</h3><p>创建定时器，返回定时器的channel，属于NewTimer&#x2F;NewTicker函数的封装。go1.22及之前的版本中，如果在for循环使用After会申请大量内存，加剧GC压力</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time &#123;</span><br><span class="line">    <span class="keyword">return</span> NewTimer(d).C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tick</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time &#123;</span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NewTicker(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器相关"><a href="#定时器相关" class="headerlink" title="定时器相关"></a>定时器相关</h2><h3 id="停止定时器"><a href="#停止定时器" class="headerlink" title="停止定时器"></a>停止定时器</h3><p>停止定时器，因为定时器可能被其他P持有，只修改状态。具体逻辑如下</p>
<ol>
<li>如果是异步定时器，判断定时器是否需要触发执行函数f</li>
<li>定时器字段更新<ul>
<li>更新定时器状态state的timerZombie位</li>
<li>重置when</li>
<li>更新版本计数器</li>
<li>将状态state复制到astate上（到这里就解锁了）</li>
<li>如果是同步定时器，清空channel（t.arg）的buf缓冲区</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span></span> Stop() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="keyword">if</span> !t.initTimer &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: Stop called on uninitialized Timer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stopTimer(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span></span> Stop() &#123;</span><br><span class="line">    <span class="keyword">if</span> !t.initTicker &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    stopTimer((*Timer)(unsafe.Pointer(t)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTimer</span><span class="params">(t *timeTimer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;stop of synctest timer from outside bubble&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> stop() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是异步还是同步定时器（go1.23开始默认是同步定时器）</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        lock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;stop&quot;</span>)</span><br><span class="line">    <span class="comment">// 如果是异步定时器（go1.22及以前）</span></span><br><span class="line">    <span class="keyword">if</span> async &#123;</span><br><span class="line">        <span class="comment">// 判断定时器是否需要更新timer状态，执行函数f</span></span><br><span class="line">        t.maybeRunAsync()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// timer已经在最小堆中</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 设置timerModified标志位</span></span><br><span class="line">        t.state |= timerModified</span><br><span class="line">        <span class="comment">// timer无删除标记</span></span><br><span class="line">        <span class="keyword">if</span> t.state&amp;timerZombie == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 标记为删除</span></span><br><span class="line">            t.state |= timerZombie</span><br><span class="line">            <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">            t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pending := t.when &gt; <span class="number">0</span></span><br><span class="line">    <span class="comment">// 重置when</span></span><br><span class="line">    t.when = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 版本计数器更新</span></span><br><span class="line">        t.seq++</span><br><span class="line">        <span class="comment">// 一次性定时器 and 已经在调用函数f了</span></span><br><span class="line">        <span class="keyword">if</span> t.period == <span class="number">0</span> &amp;&amp; t.isSending.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        unlock(&amp;t.sendLock)</span><br><span class="line">        <span class="comment">// 清空channel（t.arg）的buf缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> timerchandrain(t.hchan()) &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pending</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重置定时器"><a href="#重置定时器" class="headerlink" title="重置定时器"></a>重置定时器</h3><p>重置定时器，本质是modify函数调用，更新timer状态、添加到最小堆、中断网络轮询。需要先调用Stop才能确保安全调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span></span> Reset(d Duration) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !t.initTimer &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: Reset called on uninitialized Timer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    w := when(d)</span><br><span class="line">    <span class="keyword">return</span> resetTimer(t, w, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span></span> Reset(d Duration) &#123;</span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;non-positive interval for Ticker.Reset&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !t.initTicker &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: Reset called on uninitialized Ticker&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resetTimer((*Timer)(unsafe.Pointer(t)), when(d), <span class="type">int64</span>(d))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetTimer</span><span class="params">(t *timeTimer, when, period <span class="type">int64</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;reset of synctest timer from outside bubble&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.reset(when, period)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> reset(when, period <span class="type">int64</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line">    <span class="keyword">return</span> t.modify(when, period, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小堆相关"><a href="#最小堆相关" class="headerlink" title="最小堆相关"></a>最小堆相关</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> updateHeap() (updated <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// mu加锁、STW</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;updateHeap&quot;</span>)</span><br><span class="line">    <span class="comment">// 最小堆</span></span><br><span class="line">    ts := t.ts</span><br><span class="line">    <span class="comment">// 最小堆为nil（没有初始化） or 当前定时器不是最小堆中最小的，异常</span></span><br><span class="line">    <span class="keyword">if</span> ts == <span class="literal">nil</span> || t != ts.heap[<span class="number">0</span>].timer &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// timer已标记删除</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 移除标志位</span></span><br><span class="line">        t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">        <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">        ts.zombies.Add(<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// 移除最小的timer</span></span><br><span class="line">        ts.deleteMin()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前定时器已被修改</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerModified != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 移除标志位</span></span><br><span class="line">        t.state &amp;^= timerModified</span><br><span class="line">        <span class="comment">// 更新when</span></span><br><span class="line">        ts.heap[<span class="number">0</span>].when = t.when</span><br><span class="line">        <span class="comment">// 调整最小堆，从根节点开始，一直向下交换最小的子节点</span></span><br><span class="line">        ts.siftDown(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">        ts.updateMinWhenHeap()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆重新排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> initHeap() &#123;</span><br><span class="line">    <span class="comment">// 0或1个元素，不用排序</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父节点idx =&gt; (len(heap)-1-1)/4</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">int</span>(<span class="type">uint</span>(<span class="built_in">len</span>(ts.heap)<span class="number">-1</span><span class="number">-1</span>) / timerHeapN); i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        ts.siftDown(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把timer定时器加入到timers.heap最小堆中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> addHeap(t *timer) &#123;</span><br><span class="line">    <span class="comment">// mu加锁、STW</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 确保netpoll已初始化（依赖）</span></span><br><span class="line">    <span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        netpollGenericInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer已经放到了P的timers上</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;ts set in timer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 纪录P的timers指针</span></span><br><span class="line">    t.ts = ts</span><br><span class="line">    <span class="comment">// 放到最小堆末尾</span></span><br><span class="line">    ts.heap = <span class="built_in">append</span>(ts.heap, timerWhen&#123;t, t.when&#125;)</span><br><span class="line">    <span class="comment">// 重新调整最小堆，写入timer时触发</span></span><br><span class="line">    ts.siftUp(<span class="built_in">len</span>(ts.heap) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 是同一个定时器</span></span><br><span class="line">    <span class="keyword">if</span> t == ts.heap[<span class="number">0</span>].timer &#123;</span><br><span class="line">        <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">        ts.updateMinWhenHeap()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新调整最小堆，写入timer时触发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> siftUp(i <span class="type">int</span>) &#123;</span><br><span class="line">    heap := ts.heap</span><br><span class="line">    <span class="comment">// 指针超过数组长度，异常</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(heap) &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂存当前节点</span></span><br><span class="line">    tw := heap[i]</span><br><span class="line">    when := tw.when</span><br><span class="line">    <span class="comment">// 异常值</span></span><br><span class="line">    <span class="keyword">if</span> when &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果父节点的值比当前节点的值要大，交换两者</span></span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 找父节点idx =&gt; p = (i-1) / 4</span></span><br><span class="line">        p := <span class="type">int</span>(<span class="type">uint</span>(i<span class="number">-1</span>) / timerHeapN)</span><br><span class="line">        <span class="comment">// 如果父节点的when大于等于当前节点的when，调整完毕，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> when &gt;= heap[p].when &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换父节点和当前节点</span></span><br><span class="line">        heap[i] = heap[p]</span><br><span class="line">        i = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> heap[i].timer != tw.timer &#123;</span><br><span class="line">        <span class="comment">// 一般排序完都要执行这步才对</span></span><br><span class="line">        heap[i] = tw</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新调整最小堆，移除timer时触发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> siftDown(i <span class="type">int</span>) &#123;</span><br><span class="line">    heap := ts.heap</span><br><span class="line">    <span class="comment">// 指针超过数组长度，异常</span></span><br><span class="line">    n := <span class="built_in">len</span>(heap)</span><br><span class="line">    <span class="keyword">if</span> i &gt;= n &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点idx超过数组长度</span></span><br><span class="line">    <span class="comment">// i*4+1 &gt;= n</span></span><br><span class="line">    <span class="keyword">if</span> i*timerHeapN+<span class="number">1</span> &gt;= n &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂存当前节点</span></span><br><span class="line">    tw := heap[i]</span><br><span class="line">    when := tw.when</span><br><span class="line">    <span class="comment">// 异常值</span></span><br><span class="line">    <span class="keyword">if</span> when &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果子节点的值比当前节点的值要小，交换两者</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 子节点left_idx =&gt; i*4+1</span></span><br><span class="line">        leftChild := i*timerHeapN + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> leftChild &gt;= n &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        w := when     <span class="comment">// 当前节点when</span></span><br><span class="line">        c := <span class="number">-1</span>        <span class="comment">// 节点索引</span></span><br><span class="line">        <span class="comment">// 找到子节点中最小的when</span></span><br><span class="line">        <span class="comment">// 每个节点存储最多4个数据</span></span><br><span class="line">        <span class="keyword">for</span> j, tw := <span class="keyword">range</span> heap[leftChild:min(leftChild+timerHeapN, n)] &#123;</span><br><span class="line">            <span class="keyword">if</span> tw.when &lt; w &#123;</span><br><span class="line">                w = tw.when</span><br><span class="line">                c = leftChild + j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到更小的when，退出</span></span><br><span class="line">        <span class="keyword">if</span> c &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了，交换父子节点</span></span><br><span class="line">        heap[i] = heap[c]</span><br><span class="line">        i = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> heap[i].timer != tw.timer &#123;</span><br><span class="line">        <span class="comment">// 一般排序完都要执行这步</span></span><br><span class="line">        heap[i] = tw</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除最小的timer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> deleteMin() &#123;</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 最小堆第一个</span></span><br><span class="line">    t := ts.heap[<span class="number">0</span>].timer</span><br><span class="line">    <span class="comment">// 不在同一个P上</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">        throw(<span class="string">&quot;wrong timers&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解除绑定</span></span><br><span class="line">    t.ts = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 跟最小堆最后一个元素交换</span></span><br><span class="line">    last := <span class="built_in">len</span>(ts.heap) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ts.heap[<span class="number">0</span>] = ts.heap[last]</span><br><span class="line">    &#125;</span><br><span class="line">    ts.heap[last] = timerWhen&#123;&#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    ts.heap = ts.heap[:last]</span><br><span class="line">    <span class="comment">// 重新调整最小堆</span></span><br><span class="line">    <span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ts.siftDown(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">    ts.updateMinWhenHeap()</span><br><span class="line">    <span class="comment">// 最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> last == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 将minWhen设置为0</span></span><br><span class="line">        ts.minWhenModified.Store(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="goroutine调度相关"><a href="#goroutine调度相关" class="headerlink" title="goroutine调度相关"></a>goroutine调度相关</h2><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>销毁P时，把最小堆里的timer全部迁移走</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把一个timers最小堆的timer搬到当前timers最小堆中。P销毁时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> take(src *timers) &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;take&quot;</span>)</span><br><span class="line">    <span class="comment">// STW</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line">    <span class="comment">// src最小堆不为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(src.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// STW 忽略顺序</span></span><br><span class="line">        <span class="keyword">for</span> _, tw := <span class="keyword">range</span> src.heap &#123;</span><br><span class="line">            t := tw.timer</span><br><span class="line">            <span class="comment">// 解除P绑定</span></span><br><span class="line">            t.ts = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">// timer已标记删除</span></span><br><span class="line">            <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 清理状态位（为什么要去修改它？？？）</span></span><br><span class="line">                t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 清理timerModified位</span></span><br><span class="line">                t.state &amp;^= timerModified</span><br><span class="line">                <span class="comment">// 把timer定时器加入到timers.heap最小堆中</span></span><br><span class="line">                ts.addHeap(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把整个最小堆清空了</span></span><br><span class="line">        src.heap = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 下面的统计数据也全部重置</span></span><br><span class="line">        src.zombies.Store(<span class="number">0</span>)</span><br><span class="line">        src.minWhenHeap.Store(<span class="number">0</span>)</span><br><span class="line">        src.minWhenModified.Store(<span class="number">0</span>)</span><br><span class="line">        src.<span class="built_in">len</span>.Store(<span class="number">0</span>)</span><br><span class="line">        ts.<span class="built_in">len</span>.Store(<span class="type">uint32</span>(<span class="built_in">len</span>(ts.heap)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行。调度时，寻找可运行的G时调用（findRunnable或stealWork）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> check(now <span class="type">int64</span>) (rnow, pollUntil <span class="type">int64</span>, ran <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;check&quot;</span>)</span><br><span class="line">    <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">    next := ts.wakeTime()</span><br><span class="line">    <span class="comment">// 最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> now, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记删除的timer数量</span></span><br><span class="line">    zombies := ts.zombies.Load()</span><br><span class="line">    <span class="keyword">if</span> zombies &lt; <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前P and 标记删除的timer数量超过总量的1/4</span></span><br><span class="line">    force := ts == &amp;getg().m.p.ptr().timers &amp;&amp; <span class="type">int</span>(zombies) &gt; <span class="type">int</span>(ts.<span class="built_in">len</span>.Load())/<span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// now小于最小when（下一个定时器还没准备好运行） and 非强制</span></span><br><span class="line">    <span class="keyword">if</span> now &lt; next &amp;&amp; !force &#123;</span><br><span class="line">        <span class="keyword">return</span> now, next, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的场景是：now大于等于最小when or 强制</span></span><br><span class="line"></span><br><span class="line">    ts.lock()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 清理最小堆，并重新排序（非强制）</span></span><br><span class="line">        <span class="comment">// 那么这里需要处理的场景就是now大于等于最小when（看了adjust代码感觉跟强制也没什么区别）</span></span><br><span class="line">        ts.adjust(now, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 清理后，heap不为空</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(ts.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 运行最小的timer，如果还没到时间就不执行</span></span><br><span class="line">            <span class="keyword">if</span> tw := ts.run(now); tw != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// -1或0表示最小堆为空，其他表示最小timer的运行时刻</span></span><br><span class="line">                <span class="keyword">if</span> tw &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    pollUntil = tw</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ran = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新检测</span></span><br><span class="line">        force = ts == &amp;getg().m.p.ptr().timers &amp;&amp; <span class="type">int</span>(ts.zombies.Load()) &gt; <span class="type">int</span>(ts.<span class="built_in">len</span>.Load())/<span class="number">4</span></span><br><span class="line">        <span class="keyword">if</span> force &#123;</span><br><span class="line">            <span class="comment">// 清理最小堆，并重新排序（强制）</span></span><br><span class="line">            ts.adjust(now, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ts.unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> now, pollUntil, ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清理最小堆，并重新排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> adjust(now <span class="type">int64</span>, force <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;adjust&quot;</span>)</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 非强制</span></span><br><span class="line">    <span class="keyword">if</span> !force &#123;</span><br><span class="line">        <span class="comment">// 设置了timerModified位的最小when</span></span><br><span class="line">        first := ts.minWhenModified.Load()</span><br><span class="line">        <span class="comment">// 最小堆为空 or now小于最小when（下一个定时器还没准备好运行）</span></span><br><span class="line">        <span class="keyword">if</span> first == <span class="number">0</span> || first &gt; now &#123;</span><br><span class="line">            <span class="comment">// debug用，忽略</span></span><br><span class="line">            <span class="keyword">if</span> verifyTimers &#123;</span><br><span class="line">                ts.verify()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">    <span class="comment">// minWhenHeap = min(minWhenHeap, minWhenModified)</span></span><br><span class="line">    ts.minWhenHeap.Store(ts.wakeTime())</span><br><span class="line">    <span class="comment">// minWhenModified = 0</span></span><br><span class="line">    ts.minWhenModified.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描整个最小堆</span></span><br><span class="line">    changed := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ts.heap); i++ &#123;</span><br><span class="line">        tw := &amp;ts.heap[i]</span><br><span class="line">        t := tw.timer</span><br><span class="line">        <span class="comment">// 不在同一个P上</span></span><br><span class="line">        <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad ts&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有被修改也没有标记删除，无须调整</span></span><br><span class="line">        <span class="keyword">if</span> t.astate.Load()&amp;(timerModified|timerZombie) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 加锁</span></span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> t.state&amp;timerHeaped == <span class="number">0</span>:         <span class="comment">// 异常状态</span></span><br><span class="line">            badTimer()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> t.state&amp;timerZombie != <span class="number">0</span>:         <span class="comment">// timer已标记删除</span></span><br><span class="line">            <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">            ts.zombies.Add(<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">// 移除标志位</span></span><br><span class="line">            t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">            <span class="comment">// 总数量</span></span><br><span class="line">            n := <span class="built_in">len</span>(ts.heap)</span><br><span class="line">            <span class="comment">// 当前timer跟最小堆的最后一个交换</span></span><br><span class="line">            ts.heap[i] = ts.heap[n<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// 先用空的结构替换</span></span><br><span class="line">            ts.heap[n<span class="number">-1</span>] = timerWhen&#123;&#125;</span><br><span class="line">            <span class="comment">// 移除最后一个数据</span></span><br><span class="line">            ts.heap = ts.heap[:n<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// 表示从heap上移除</span></span><br><span class="line">            t.ts = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">// 重新扫描当前位置的timer</span></span><br><span class="line">            i--</span><br><span class="line">            changed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> t.state&amp;timerModified != <span class="number">0</span>:    <span class="comment">// 已修改</span></span><br><span class="line">            <span class="comment">// 更新when</span></span><br><span class="line">            tw.when = t.when</span><br><span class="line">            <span class="comment">// 移除标志位</span></span><br><span class="line">            t.state &amp;^= timerModified</span><br><span class="line">            changed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        t.unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有调整过最小堆</span></span><br><span class="line">    <span class="keyword">if</span> changed &#123;</span><br><span class="line">        <span class="comment">// 最小堆重新排序</span></span><br><span class="line">        ts.initHeap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">    <span class="comment">// minWhenHeap = heap[0].when</span></span><br><span class="line">    ts.updateMinWhenHeap()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    <span class="keyword">if</span> verifyTimers &#123;</span><br><span class="line">        ts.verify()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证timers是最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> verify() &#123;</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 扫描最小堆</span></span><br><span class="line">    <span class="keyword">for</span> i, tw := <span class="keyword">range</span> ts.heap &#123;</span><br><span class="line">        <span class="comment">// 第一个timer，没有父节点</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点，p=(i-1)/4</span></span><br><span class="line">        p := <span class="type">int</span>(<span class="type">uint</span>(i<span class="number">-1</span>) / timerHeapN)</span><br><span class="line">        <span class="comment">// 子节点比父节点的值小，异常</span></span><br><span class="line">        <span class="keyword">if</span> tw.when &lt; ts.heap[p].when &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;bad timer heap at &quot;</span>, i, <span class="string">&quot;: &quot;</span>, p, <span class="string">&quot;: &quot;</span>, ts.heap[p].when, <span class="string">&quot;, &quot;</span>, i, <span class="string">&quot;: &quot;</span>, tw.when, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;bad timer heap&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// len字段验证</span></span><br><span class="line">    <span class="keyword">if</span> n := <span class="type">int</span>(ts.<span class="built_in">len</span>.Load()); <span class="built_in">len</span>(ts.heap) != n &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;timer heap len&quot;</span>, <span class="built_in">len</span>(ts.heap), <span class="string">&quot;!= atomic len&quot;</span>, n)</span><br><span class="line">        throw(<span class="string">&quot;bad timer heap len&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行最小的timer，如果还没到时间就不执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> run(now <span class="type">int64</span>) <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">Redo:</span><br><span class="line">    <span class="comment">// 最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个/最小timer</span></span><br><span class="line">    tw := ts.heap[<span class="number">0</span>]</span><br><span class="line">    t := tw.timer</span><br><span class="line">    <span class="comment">// 不在同一个P上，异常</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad ts&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer没有修改/标记删除 and when大于now（还没准备运行）</span></span><br><span class="line">    <span class="keyword">if</span> t.astate.Load()&amp;(timerModified|timerZombie) == <span class="number">0</span> &amp;&amp; tw.when &gt; now &#123;</span><br><span class="line">        <span class="keyword">return</span> tw.when</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line">    <span class="keyword">if</span> t.updateHeap() &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">goto</span> Redo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer不在最小堆 or 当前定时器已被修改</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped == <span class="number">0</span> || t.state&amp;timerModified != <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when大于now（还没准备运行）</span></span><br><span class="line">    <span class="keyword">if</span> t.when &gt; now &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">return</span> t.when</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">    t.unlockAndRun(now)</span><br><span class="line">    <span class="comment">// ts重新加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timeSleepUntil"><a href="#timeSleepUntil" class="headerlink" title="timeSleepUntil"></a>timeSleepUntil</h3><p>遍历所有P，找到全局最小的when。由sysmon、checkdead函数调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历所有P，找到全局最小的when</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeSleepUntil</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 最大值2^63-1</span></span><br><span class="line">    next := <span class="type">int64</span>(maxWhen)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保allp切片不会被更改</span></span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="comment">// 遍历所有P，获取在所有P中最小的when</span></span><br><span class="line">    <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 可能在扩容，还没有创建好新的P</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">        <span class="keyword">if</span> w := pp.timers.wakeTime(); w != <span class="number">0</span> &#123;</span><br><span class="line">            next = min(next, w)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="channel相关"><a href="#channel相关" class="headerlink" title="channel相关"></a>channel相关</h2><p>虽说是跟channel相关，实际上，在执行<code>&lt;-t.C</code>等待超时时，就会使用到下面的方法</p>
<h3 id="maybeRunChan"><a href="#maybeRunChan" class="headerlink" title="maybeRunChan"></a>maybeRunChan</h3><p>判断是否需要更新timer状态、执行函数f。具体逻辑如下</p>
<ol>
<li>不满足条件则返回<ul>
<li>timer已经放在最小堆上，那么过期后自动发送到channel</li>
<li>timer从未执行过</li>
<li>timer还未到触发时刻</li>
</ul>
</li>
<li>满足条件则更新timer状态、执行函数f</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line"><span class="comment">// 目前只有channel、select相关的代码在使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeRunChan() &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="keyword">var</span> timerGroup *synctestGroup</span><br><span class="line">        <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">            timerGroup = t.ts.syncGroup</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        sg := getg().syncGroup</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;synctest timer accessed from outside bubble&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> timerGroup != <span class="literal">nil</span> &amp;&amp; sg != timerGroup &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;timer moved between synctest bubbles&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果timer已经在最小堆中，过期后自动发送到channel</span></span><br><span class="line">    <span class="keyword">if</span> t.astate.Load()&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 当前时刻，单调时钟</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 加锁后double-check</span></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer从未执行过</span></span><br><span class="line">    <span class="comment">// 3. timer还未到触发时刻</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> || t.when == <span class="number">0</span> || t.when &gt; now &#123;</span><br><span class="line">        <span class="comment">// debug用，忽略</span></span><br><span class="line">        t.trace(<span class="string">&quot;maybeRunChan-&quot;</span>)</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;maybeRunChan+&quot;</span>)</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">        t.unlockAndRun(now)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="blockTimerChan-unblockTimerChan"><a href="#blockTimerChan-unblockTimerChan" class="headerlink" title="blockTimerChan &amp; unblockTimerChan"></a>blockTimerChan &amp; unblockTimerChan</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个10ms过期的定时器</span></span><br><span class="line">t := time.NewTimer(<span class="number">10</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待定时器过期信号</span></span><br><span class="line">&lt;-t.C</span><br></pre></td></tr></table></figure>

<p>上述示例代码，如果这个channel是属于一个定时器的，那么在G挂起前、唤醒后，需要修改定时器的state-状态、blocked-标记等。函数详细注释如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// G挂起休眠之前，将定时器标记为阻塞并加入最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;blockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer已标记删除</span></span><br><span class="line">    <span class="comment">// 3. 过期时刻大于0</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie != <span class="number">0</span> &amp;&amp; t.when &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t.state &amp;^= timerZombie    <span class="comment">// 移除标志位</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">-1</span>)    <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要把定时器放到最小堆</span></span><br><span class="line">    add := t.needsAdd()</span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line">        t.maybeAdd()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G唤醒后，将定时器标记为非阻塞、删除状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unblockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;unblockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器 or 计数器为0，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan || t.blocked == <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器为0 and timer已经在最小堆中 and timer无删除标记</span></span><br><span class="line">    <span class="keyword">if</span> t.blocked == <span class="number">0</span> &amp;&amp; t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 标记为删除</span></span><br><span class="line">        t.state |= timerZombie</span><br><span class="line">        <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器示例解析"><a href="#定时器示例解析" class="headerlink" title="定时器示例解析"></a>定时器示例解析</h2><ol>
<li>创建定时器</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.NewTimer(<span class="number">2</span> * time.Second) <span class="comment">// 调用NewTimer(2 * time.Second)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次创建timer，执行newTimer，此时不会触发任何其他函数操作，包括添加到最小堆等。</span></span><br><span class="line"><span class="comment">// timer数据初始化后，各字段数值如下</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//     |---------------------------------|</span></span><br><span class="line"><span class="comment">//     v                                 |</span></span><br><span class="line"><span class="comment">// timer.mu                         channel.timer</span></span><br><span class="line"><span class="comment">//      .f          =&gt; sendTime          ^</span></span><br><span class="line"><span class="comment">//      .arg        =&gt; *channel     -----|</span></span><br><span class="line"><span class="comment">//      .seq        =&gt; 1</span></span><br><span class="line"><span class="comment">//      .sendLock</span></span><br><span class="line"><span class="comment">//      .isChan     =&gt; true</span></span><br><span class="line"><span class="comment">//      .period     =&gt; 0</span></span><br><span class="line"><span class="comment">//      .when       =&gt; xyz</span></span><br><span class="line"><span class="comment">//      .state      =&gt; 0</span></span><br><span class="line"><span class="comment">//      .astate     =&gt; 0</span></span><br><span class="line"><span class="comment">//      .init       =&gt; true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当前G挂起等待</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;-t.C    <span class="comment">// 调用chanrecv函数，内部调用blockTimerChan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将timer放到最小堆</span></span><br><span class="line"><span class="comment">// timers.heap                        |---------------------------------|</span></span><br><span class="line"><span class="comment">//          |                         v                                 |</span></span><br><span class="line"><span class="comment">//  | timer0 | ... | timerx |  &lt;-- timer.mu                         channel.timer</span></span><br><span class="line"><span class="comment">//                                      .f          =&gt; sendTime          ^</span></span><br><span class="line"><span class="comment">//                                      .arg        =&gt; *channel     -----|</span></span><br><span class="line"><span class="comment">//                                      .seq        =&gt; 1</span></span><br><span class="line"><span class="comment">//                                      .sendLock</span></span><br><span class="line"><span class="comment">//                                      .isChan     =&gt; true</span></span><br><span class="line"><span class="comment">//                                      .period     =&gt; 0</span></span><br><span class="line"><span class="comment">//                                      .when       =&gt; xyz</span></span><br><span class="line"><span class="comment">//                                      .state      =&gt; 1</span></span><br><span class="line"><span class="comment">//                                      .astate     =&gt; 1(timerHeaped)</span></span><br><span class="line"><span class="comment">//                                      .init       =&gt; true</span></span><br><span class="line"><span class="comment">//                                      .blocked    =&gt; 1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定时器到期通知</li>
</ol>
<p>GMP调度执行findRunnable或stealWork，发现定时器过期，发送信号给channel，唤醒goroutine，流程如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sched -&gt; findRunnable -&gt; check -&gt; unlockAndRun -&gt; sendTime</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>当前G唤醒继续执行</li>
</ol>
<p>当前G唤醒后，调用unblockTimerChan</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行unblockTimerChan后，timer的数据状态大概如下</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//     |---------------------------------|</span></span><br><span class="line"><span class="comment">//     v                                 |</span></span><br><span class="line"><span class="comment">// timer.mu                         channel.timer</span></span><br><span class="line"><span class="comment">//      .f          =&gt; sendTime          ^</span></span><br><span class="line"><span class="comment">//      .arg        =&gt; *channel     -----|</span></span><br><span class="line"><span class="comment">//      .seq        =&gt; 1</span></span><br><span class="line"><span class="comment">//      .sendLock</span></span><br><span class="line"><span class="comment">//      .isChan     =&gt; true</span></span><br><span class="line"><span class="comment">//      .period     =&gt; 0</span></span><br><span class="line"><span class="comment">//      .when       =&gt; xyz(&lt;=now)</span></span><br><span class="line"><span class="comment">//      .state      =&gt; 0</span></span><br><span class="line"><span class="comment">//      .astate     =&gt; 5(timerHeaped|timerZombie)</span></span><br><span class="line"><span class="comment">//      .init       =&gt; true</span></span><br><span class="line"><span class="comment">//      .blocked    =&gt; 0</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://antonz.org/timer-reset/">Resetting timers in Go</a><br><a href="https://ggaaooppeenngg.github.io/zh-CN/2016/02/09/timer%E5%9C%A8go%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E7%B2%BE%E7%A1%AE/">timer 在 Golang 中可以有多精确？</a><br><a href="https://tonybai.com/2016/12/21/how-to-use-timer-reset-in-golang-correctly/">论golang Timer Reset方法使用的正确姿势</a><br><a href="https://www.youtube.com/watch?v=XJx0eTP-y9I">#74 time.Timer 源码分析 (Go 1.14) 【 Go 夜读 】</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>生成火焰图分析php代码</title>
    <url>/how-to-generate-php-flamegraphs/</url>
    <content><![CDATA[<p>flamegraph是一款可视化工具，用户分析程序堆栈调用，x轴堆栈轨迹，y轴堆栈深度，x轴长度越长，占用更多cpu时间。下面简单介绍如何使用xdebug以及flamegraph生成火焰图</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>配置xdebug参数</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">xdebug.trace_output_name</span> = xdebug.trace.%t.%s</span><br><span class="line"><span class="attr">xdebug.trace_enable_trigger</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.trace_output_dir</span> = /tmp</span><br><span class="line"><span class="attr">xdebug.trace_enable_trigger_value</span> = <span class="string">&quot;&lt;secret key&gt;&quot;</span></span><br><span class="line"><span class="attr">xdebug.trace_format</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>下载flamegraph，<code>git clone https://github.com/brendangregg/FlameGraph.git</code>，放置在任意位置</p>
<h2 id="flamegraph"><a href="#flamegraph" class="headerlink" title="flamegraph"></a>flamegraph</h2><p>获取堆栈数据</p>
<p>请求页面&#x2F;接口url，在url后面增加<code>?XDEBUG_TRACE=&lt;secret key&gt;</code>，获取php堆栈数据 <code>curl http://youdomain.com?XDEBUG_TRACE=&lt;secret key&gt;</code>，如果是命令行命令，则在php命令后使用参数<code>php -d xdebug.auto_trace=1</code></p>
<p>转换堆栈数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./stackcollapse-xdebug.php /tmp/xdebug.trace.1579703170._data_www_yii2_web_index_php.xt &gt; out.folded</span><br></pre></td></tr></table></figure>

<p>生成火焰图</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./flamegraph.pl out.folded &gt; out.svg</span><br></pre></td></tr></table></figure>

<p>示例</p>
<p><img src="/images/yii2-flamegraph-example.svg" alt="yii2 flamegraph example"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://daniellockyer.com/php-flame-graphs/">How to generate PHP Flamegraphs</a><br><a href="https://github.com/brendangregg/FlameGraph">Flame Graphs visualize profiled code</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>flamegraph</tag>
        <tag>profiling</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s config和secret配置教程</title>
    <url>/k8s-config-and-secret-setup-tutorial/</url>
    <content><![CDATA[<p>简单的配置管理，可以把信息写入文件放在项目里，然后打包发布，但这样会有信息泄露的安全风险，经常会看到谁谁谁把项目上传到github，然后公司数据库&#x2F;敏感密钥泄漏等。所以，现在的公司一般会自建发布平台，通过发布平台管理配置，流程：配置修改-&gt;审核-&gt;发布。了解到这背景，我们就知道config跟secret在整个软件开发过程中扮演的角色，接下来就学习如何配置config&#x2F;secret并使用</p>
<blockquote>
<p>当然，一般情况下，配置管理没有那么简单，要考虑多种环境如dev&#x2F;test&#x2F;release以及地区区分，操作需小心谨慎，一不小心就出现遗漏、错配，此外，还有多人开发时配置冲突等，这些都是开发过程中要注意的问题</p>
</blockquote>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>以下展示configMap的简单配置，必须字段apiVersion、kind、metadata、data&#x2F;binaryData。data可以是key-value键值对，也可以是文件名-文件内容，数据的大小不能超过1MB，具体可以查看官网api描述文档</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># game-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">game-demo</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># 1. key-value</span></span><br><span class="line">  <span class="attr">player_initial_lives:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">  <span class="attr">ui_properties_file_name:</span> <span class="string">&quot;user-interface.properties&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 2. filename-content</span></span><br><span class="line">  <span class="attr">game.properties:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    enemy.types=aliens,monsters</span></span><br><span class="line"><span class="string">    player.maximum-lives=5    </span></span><br><span class="line"><span class="string"></span>  <span class="attr">user-interface.properties:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    color.good=purple</span></span><br><span class="line"><span class="string">    color.bad=yellow</span></span><br><span class="line"><span class="string">    allow.textmode=true </span></span><br></pre></td></tr></table></figure>

<p>执行命令写入k8s，查看并验证配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入k8s</span></span><br><span class="line">kubectl apply -f game-demo.yam</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">kubectl get cm game-demo</span><br><span class="line"><span class="comment"># 查看config数据</span></span><br><span class="line">kubectl describe cm game-demo</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>有了配置信息，怎么搭配container使用？有4种使用方式可供参考</p>
<ol>
<li>在容器命令和参数内</li>
<li>容器的环境变量</li>
<li>在只读卷里面添加一个文件，让应用来读取</li>
<li>编写代码在 Pod 中运行，使用 Kubernetes API 来读取 ConfigMap</li>
</ol>
<p>以下启动一个pod，在启动时打印输出config信息，主要展示的是环境变量跟配置文件两种方式，也就是上面的2和3</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-demo-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">registry.noname.io:5000/alpine:3.20.1</span></span><br><span class="line">      <span class="attr">command:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">          echo $PLAYER_INITIAL_LIVES;</span></span><br><span class="line"><span class="string">          echo $UI_PROPERTIES_FILE_NAME;</span></span><br><span class="line"><span class="string">          ls -l /config/game.properties;</span></span><br><span class="line"><span class="string">          cat /config/game.properties;</span></span><br><span class="line"><span class="string">          ls -l /config/user-interface.properties;</span></span><br><span class="line"><span class="string">          cat /config/user-interface.properties;</span></span><br><span class="line"><span class="string"></span>      <span class="comment"># 方式2：configMap-&gt;环境变量</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="comment"># 定义环境变量</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PLAYER_INITIAL_LIVES</span>    <span class="comment"># 请注意这里和 ConfigMap 中的键名是不一样的</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">game-demo</span>           <span class="comment"># 这个值来自 ConfigMap</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">player_initial_lives</span> <span class="comment"># 需要取值的键</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">UI_PROPERTIES_FILE_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">game-demo</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">ui_properties_file_name</span></span><br><span class="line">      <span class="comment"># 方式3：configMap-&gt;文件</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">&quot;/config&quot;</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="comment"># 你可以在 Pod 级别设置卷，然后将其挂载到 Pod 内的容器中</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="comment"># ConfigMap的名字</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">game-demo</span></span><br><span class="line">      <span class="comment"># 指定key创建为path文件</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;game.properties&quot;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;game.properties&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;user-interface.properties&quot;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;user-interface.properties&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">kubectl apply -f configmap-demo-pod.yaml</span><br><span class="line"><span class="comment"># 查看configmap-demo-pod运行情况</span></span><br><span class="line">kubectl get pod | grep configmap-demo-pod</span><br><span class="line"><span class="comment"># pod是否有其他异常</span></span><br><span class="line">kubectl describe pod configmap-demo-pod</span><br><span class="line"><span class="comment"># 查看command输出日志</span></span><br><span class="line">kubectl logs configmap-demo-pod</span><br><span class="line"><span class="comment"># 清理config、pod</span></span><br><span class="line">kubectl delete -f game-demo.yaml</span><br><span class="line">kubectl delete -f configmap-demo-pod.yaml</span><br></pre></td></tr></table></figure>

<h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>secret的应用场景想到的只有数据库密码，如果真的要跟数据库其他配置分离也挺蛋疼的，以下简单展示如何使用</p>
<p>secret与config非常相似，有如下相同点</p>
<ol>
<li>key&#x2F;value 的形式</li>
<li>属于某个特定的 namespace</li>
<li>可以导出到环境变量</li>
<li>可以通过目录&#x2F;文件形式挂载 (支持挂载所有 key 和部分 key)</li>
</ol>
<p>不同点：</p>
<ol>
<li>secret 可以被 ServerAccount 关联 (使用)</li>
<li>secret 可以存储 register 的鉴权信息，用在 ImagePullSecret 参数中，用于拉取私有仓库的镜像</li>
<li>secret 支持 Base64 加密</li>
<li>secret 文件存储在 tmpfs 文件系统中，Pod删除后secret文件也会对应的删除</li>
</ol>
<p>配置secret</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dotfile-secret.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dotfile-secret</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">.secret-file:</span> <span class="string">dmFsdWUtMg0KDQo=</span></span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get secret dotfile-secret -o json | jq <span class="string">&#x27;.data | map_values(@base64d)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用secret，有以下几种方式</p>
<ol>
<li>作为挂载到一个或多个容器上的卷中的文件</li>
<li>作为容器的环境变量</li>
<li>由kubelet在为Pod拉取镜像时使用</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># secret-dotfiles-pod.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-dotfiles-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">dotfile-secret</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dotfile-test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">registry.noname.io:5000/alpine:3.20.1</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;-la&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;/etc/secret-volume&quot;</span></span><br><span class="line">      <span class="comment"># /etc/secret-volume/.secret-file</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">&quot;/etc/secret-volume&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">kubectl apply -f secret-dotfiles-pod.yaml</span><br><span class="line"><span class="comment"># 查看secret-dotfiles-pod运行情况</span></span><br><span class="line">kubectl get pod | grep secret-dotfiles-pod</span><br><span class="line"><span class="comment"># pod是否有其他异常</span></span><br><span class="line">kubectl describe pod secret-dotfiles-pod</span><br><span class="line"><span class="comment"># 查看command输出日志</span></span><br><span class="line">kubectl logs secret-dotfiles-pod</span><br><span class="line"><span class="comment"># 清理config、pod</span></span><br><span class="line">kubectl delete -f dotfile-secret.yaml</span><br><span class="line">kubectl delete -f secret-dotfiles-pod.yaml</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kubernetes.io/docs/concepts/configuration/configmap/">ConfigMaps</a><br><a href="https://kubernetes.io/docs/concepts/configuration/secret/">Secrets</a></p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s pv配置教程</title>
    <url>/k8s-pv-setup-tutorial/</url>
    <content><![CDATA[<p>在Kubernetes官网的学习教程：<a href="https://kubernetes.io/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/">wordpress</a>中，我尝试了手动创建pv并绑定pvc，但是每次申请pvc都要手动添加pv并绑定是一件很麻烦且很容易出错的事情，官方也早就意识到这个问题，提出了动态存储分配，只需要通过storageclass即可实现</p>
<p>本文使用了nfs作为集群存储用于实践，线上建议考虑使用ceph等分布式文件存储系统，nfs搭建教程参考：<a href="https://www.tecmint.com/install-nfs-server-on-ubuntu/">How to Install NFS Server and Client on Ubuntu 22.04</a></p>
<h2 id="安装nfs-provisioner"><a href="#安装nfs-provisioner" class="headerlink" title="安装nfs provisioner"></a>安装nfs provisioner</h2><ol>
<li>确认nfs服务器在集群节点中可以正常访问</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装客户端</span></span><br><span class="line"><span class="built_in">sudo</span> apt install nfs-common</span><br><span class="line"><span class="comment"># 执行命令挂载，确认可正常使用</span></span><br><span class="line"><span class="built_in">sudo</span> mount 192.168.0.105:/mnt/nfs_share /mnt/nfs_clientshare</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建一个目录如nfs-example，创建<code>kustomization.yaml</code>文件</li>
</ol>
<p>鉴于gfw的影响，建议下载github.com&#x2F;kubernetes-sigs&#x2F;nfs-subdir-external-provisioner仓库，并将deploy文件夹提取出来，里面主要是账户创建、角色绑定、命名空间、deployment等配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kustomization.yaml</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">nfs-provisioner</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="comment">#   - github.com/kubernetes-sigs/nfs-subdir-external-provisioner//deploy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./deploy</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建命名空间nfs-provisioner</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># namespace.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-provisioner</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="4">
<li>创建nfs deployment的patch，主要修改image地址、nfs信息，用于后续的合并</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># patch_nfs_details.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.noname.io:5000/sig-storage/nfs-subdir-external-provisioner:v4.0.2</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_SERVER</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&lt;YOUR_NFS_SERVER_IP&gt;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_PATH</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&lt;YOUR_NFS_SERVER_SHARE&gt;</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="string">&lt;YOUR_NFS_SERVER_IP&gt;</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&lt;YOUR_NFS_SERVER_SHARE&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>添加资源并发布</li>
</ol>
<p>汇总后的<code>kustomization.yaml</code>内容如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kustomization.yaml</span></span><br><span class="line">namespace: nfs-provisioner</span><br><span class="line">resources:</span><br><span class="line">  - ./deploy</span><br><span class="line">  - namespace.yaml</span><br><span class="line">patches:</span><br><span class="line">  - path: patch_nfs_details.yaml</span><br><span class="line">    target:</span><br><span class="line">      kind: Deployment</span><br><span class="line">      labelSelector: app=nfs-client-provisioner</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发布到集群中</span></span><br><span class="line">kubectl apply -k .</span><br><span class="line"><span class="comment"># 查看pod nfs-client-provisioner是否正常运行</span></span><br><span class="line">kubectl get pods -n nfs-provisioner</span><br></pre></td></tr></table></figure>

<p>到这里，基于nfs的动态存储分配基本可用</p>
<h2 id="wordpress实践"><a href="#wordpress实践" class="headerlink" title="wordpress实践"></a>wordpress实践</h2><p>从教程：<a href="https://kubernetes.io/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/">wordpress</a>下载相关yaml配置</p>
<p>修改<code>wordpress-deployment.yaml</code>以及<code>mysql-deployment.yaml</code>的pvc配置，在spec下添加<code>storageClassName: nfs-client</code></p>
<p>当然，如果不添加上述命令，可以将storageclass：nfs-client设置成默认，这样一来就不需要改任何配置了</p>
<h3 id="修改nfs-client为默认"><a href="#修改nfs-client为默认" class="headerlink" title="修改nfs-client为默认"></a>修改nfs-client为默认</h3><ol>
<li>通过patch修改</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch storageclass nfs-client -p <span class="string">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改storageclass的配置文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">storageclass.kubernetes.io/is-default-class:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>其他操作不再赘述，到这里就结束了</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol>
<li>chown: changing ownership of ‘&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;‘: Operation not permitted</li>
</ol>
<p>这是因为nfs需要添加<code>no_root_squash</code>权限，修改<code>/etc/exports</code>添加，这个权限太大，不适合线上使用</p>
<ol start="2">
<li>mount: &#x2F;mnt&#x2F;nfs_clientshare: bad option; for several filesystems (e.g. nfs, cifs) you might need a &#x2F;sbin&#x2F;mount.<type> helper program.</li>
</ol>
<p>节点没有安装nfs客户端导致的，安装nfs-common即可</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner">nfs-subdir-external-provisioner</a></p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在ubuntu服务器上管理Wi-Fi</title>
    <url>/how-to-manage-wifi-on-ubuntu-server/</url>
    <content><![CDATA[<p>当没有桌面时，ubuntu服务器该如何连接宽带、共享Wi-Fi热点，就像一台路由器一样运作，或者如何连接Wi-Fi，以下简单介绍这几个操作的过程</p>
<h2 id="连接宽带"><a href="#连接宽带" class="headerlink" title="连接宽带"></a>连接宽带</h2><h3 id="PPPOE方式"><a href="#PPPOE方式" class="headerlink" title="PPPOE方式"></a>PPPOE方式</h3><p>使用nmcli输入pppoe账号密码，这时会打开一个交互式的命令行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli con edit <span class="built_in">type</span> pppoe con-name <span class="string">&quot;Connection name&quot;</span></span><br></pre></td></tr></table></figure>

<p>输入保存宽带账户相关信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入账号名密码</span></span><br><span class="line"><span class="built_in">set</span> pppoe.username &lt;username&gt;</span><br><span class="line"><span class="built_in">set</span> pppoe.password &lt;password&gt;</span><br><span class="line"><span class="comment"># 保存并推出</span></span><br><span class="line">save</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<h2 id="连接Wi-Fi"><a href="#连接Wi-Fi" class="headerlink" title="连接Wi-Fi"></a>连接Wi-Fi</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有Wi-Fi热点</span></span><br><span class="line"><span class="built_in">sudo</span> nmcli dev wifi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接Wi-Fi热点</span></span><br><span class="line"><span class="built_in">sudo</span> nmcli dev wifi connect &lt;SSID&gt; &lt;password&gt;</span><br></pre></td></tr></table></figure>

<h2 id="共享Wi-Fi"><a href="#共享Wi-Fi" class="headerlink" title="共享Wi-Fi"></a>共享Wi-Fi</h2><p>禁用cloud-init</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&quot;echo &#x27;network: &#123;config: disabled&#125;&#x27; &gt; /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg&quot;</span></span><br></pre></td></tr></table></figure>

<p>创建Netplan配置</p>
<p><code>sudo vi /etc/netplan/10-my-config.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">renderer:</span> <span class="string">NetworkManager</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">eth0:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">optional:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wifis:</span></span><br><span class="line">    <span class="attr">wlan0:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">optional:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">access-points:</span></span><br><span class="line">        <span class="attr">&quot;Connection Name&quot;:</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">&quot;you wifi password&quot;</span></span><br><span class="line">          <span class="attr">mode:</span> <span class="string">ap</span>  <span class="comment"># 如果是作为客户端使用，移除这一行</span></span><br></pre></td></tr></table></figure>

<p>Netplan配置生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> netplan generate</span><br><span class="line"><span class="built_in">sudo</span> netplan apply</span><br></pre></td></tr></table></figure>

<p><a href="https://raspberrypi.stackexchange.com/questions/109425/ubuntu-server-18-wifi-hotspot-setup">Ubuntu Server 18 Wifi Hotspot setup</a></p>
]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>hotspot</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ubuntu系统monospace字体显示异常的问题</title>
    <url>/linux-monofonts-render-incorrectly/</url>
    <content><![CDATA[<p>很长的一段时间，被xubuntu下的一个monospace字体显示问题困扰着，在网上找了很多方法也没有解决问题，在一次误打误撞的情况下解决了，简单把自己问题的过程记录下来，希望给一些小伙伴们帮助</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>xubuntu下monospace在浏览器以及vscode下显示异常，具体如下图所示</p>
<p>浏览器chrome&#x2F;firefox下的monospace</p>
<p><img src="/images/monofont_display_incorrect_in_browser.png" alt="monofont display incorrect in browser"></p>
<p>vscode下的monospace</p>
<p><img src="/images/monofont_display_incorrect_in_vscode.png" alt="monofont display incorrect in vscode"></p>
<p>网上搜索结果大部分指示，是由于libfreetype6 2.8.1-2ubuntu2的一个bug导致，需要升级到最新的libfreetype2.9或者降级到libfreetype2.8.0，按照搜索的文档进行libfreetype的升级&#x2F;降级后，显示效果依旧，问题没有得到解决</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>在我放弃治疗后过了一段时间，突然想起，一直以来都忽略了验证linux的字体信息。首先，获取显示异常的字体font-family，如下图</p>
<p><img src="/images/browser_get_font_family.png" alt="browser get font family"></p>
<p>使用fc-match验证字体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fc-match monospace</span><br><span class="line">DejaVuSansMono.ttf: <span class="string">&quot;DejaVu Sans Mono&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match consolas</span><br><span class="line">DejaVuSansMono.ttf: <span class="string">&quot;DejaVu Sans Mono&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match Menlo</span><br><span class="line">DejaVuSans.ttf: <span class="string">&quot;DejaVu Sans&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match <span class="string">&quot;PingFang SC&quot;</span></span><br><span class="line">DejaVuSans.ttf: <span class="string">&quot;DejaVu Sans&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match <span class="string">&quot;Microsoft YaHei&quot;</span></span><br><span class="line">NotoSansCJK-Regular.ttc: <span class="string">&quot;Noto Sans CJK SC&quot;</span> <span class="string">&quot;Regular&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到Menlo、”PingFang SC”、”Microsoft YaHei”的实际字体跟monospace并不一致，抱着死马当活马医的心态，编辑字体配置文件<code>~/.config/fontconfig/fonts.conf</code>，内容如下，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;fonts.dtd&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>Menlo<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prefer</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>DejaVu Sans Mono<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>退出，重新登录，发现这个困扰了很久的问题终于解决，如下图</p>
<p><img src="/images/monofont_the_correct_view.png" alt="monofont the correct view"></p>
<p>vscode可以通过更改font-family恢复正常的显示效果</p>
<p><strong>注意</strong></p>
<p>ubuntu&#x2F;xubuntu、中文&#x2F;英文的系统默认的字体会有些许差异，以上的操作可能不一定生效，可以新增<code>~/.config/fontconfig/conf.d/00-menlo.conf</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;fonts.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span> <span class="attr">binding</span>=<span class="string">&quot;same&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Menlo<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">accept</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>DejaVu Sans Mono<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">accept</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/adobe/brackets/issues/14290">[Ubuntu 18.04 LTS] Font not rendering properly</a><br><a href="https://stackoverflow.com/questions/50114376/ubuntu-18-04-lts-font-not-rendering-properly">Ubuntu 18.04 LTS Font not rendering properly</a><br><a href="https://superuser.com/questions/930572/why-doesnt-fc-match-respect-my-match-and-edit-rule-for-courier-when-it-does-for">Why doesn’t fc-match respect my match and edit rule for Courier when it does for Consolas?</a></p>
]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>vscode</tag>
        <tag>monospace fonts</tag>
      </tags>
  </entry>
  <entry>
    <title>使用github pages搭建个人博客</title>
    <url>/personal-blog-using-github-pages/</url>
    <content><![CDATA[<p>简单介绍如何使用github pages服务以及hexo搭建一个免费的个人博客</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个空的仓库，名字固定格式为“username.github.io”，这个名字也是博客的访问的域名</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli           <span class="comment"># 安装hexo命令行工具</span></span><br><span class="line">hexo init blog                    <span class="comment"># 创建blog项目</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next <span class="comment"># 安装next主题，可选</span></span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git --save <span class="comment"># 安装github发布工具</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><p>修改_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础配置</span></span><br><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Y2k38&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">y2k38&#x27;s</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">y2k38</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># URL </span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://y2k38.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 博客主题配置</span></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment"># 可选，若没有安装next主题，则忽略</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># github部署配置</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/Y2k38/y2k38.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment"># 注意，分支固定位master</span></span><br></pre></td></tr></table></figure>

<h3 id="发布github"><a href="#发布github" class="headerlink" title="发布github"></a>发布github</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>完成</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="添加gitalk评论系统"><a href="#添加gitalk评论系统" class="headerlink" title="添加gitalk评论系统"></a>添加gitalk评论系统</h3><blockquote>
<p>[Deprecated] github要求校验方式改为personal access token，待gitalk作者及theme-next作者更新</p>
</blockquote>
<p>新建OAuth application获取id、secret，<a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p>
<p><img src="/images/register_a_new_OAuth_application.png" alt="new oauth app"></p>
<p>配置next主题 <code>themes/next/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># Demo: https://gitalk.github.io</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/gitalk/gitalk, https://github.com/emn178/js-md5</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">y2k38</span> <span class="comment"># GitHub repo owner</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">y2k38.github.io</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">xxxxxxxxxxxxxxxx</span> <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">yyyyyyyyyyyyyyyy</span> <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">Y2k38</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://pages.github.com/">GitHub Pages</a><br><a href="https://gist.github.com/btfak/18938572f5df000ebe06fbd1872e4e39">How to use Hexo and deploy to GitHub Pages</a><br><a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line">Creating a personal access token for the command line</a></p>
]]></content>
      <tags>
        <tag>github pages</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu上安装containerd和nerdctl</title>
    <url>/install-containerd-and-nerdctl-on-ubuntu24/</url>
    <content><![CDATA[<p>以<code>Ubuntu 24.04</code>为例，安装<code>nerdctl</code>以及<code>containerd</code></p>
<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><ul>
<li>安装uidmap</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install -y uidmap</span><br></pre></td></tr></table></figure>

<ul>
<li>AppArmor配置</li>
</ul>
<p>由于懒人安装方式跟单独安装方式bin目录不一致，配置内容会有些许差异，放在下面章节各自介绍</p>
<h3 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h3><ul>
<li><a href="https://github.com/containerd/nerdctl">nerdctl</a>（懒人安装下载nerdctl-full即可，该软件包已包含下方所列软件）</li>
<li><a href="https://github.com/containerd/containerd">containerd</a></li>
<li><a href="https://github.com/rootless-containers/rootlesskit">rootlesskit</a> &amp; <a href="https://github.com/rootless-containers/slirp4netns">slirp4netns</a></li>
<li><a href="https://github.com/moby/buildkit">buildkit</a></li>
<li><a href="https://github.com/containernetworking/cni">cni</a></li>
</ul>
<span id="more"></span>

<h2 id="懒人安装"><a href="#懒人安装" class="headerlink" title="懒人安装"></a>懒人安装</h2><p>解压缩<code>nerdctl-full-2.0.3-linux-amd64.tar.gz</code>到<code>~/.local</code>，并将<code>~/.local/bin</code>目录添加到<code>PATH</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxf nerdctl-full-2.0.3-linux-amd64.tar.gz -C ~/.local</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.local/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>看起来已完成安装，但还不行，当你执行<code>nerdctl</code>，这里将会看到一些报错，以下报错表示先需要安装运行rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nerdctl</span><br><span class="line"><span class="comment"># FATA[0000] rootless containerd not running? (hint: use `containerd-rootless-setuptool.sh install` to start rootless containerd): stat /run/user/1000/containerd-rootless: no such file or directory</span></span><br></pre></td></tr></table></figure>

<p>安装rootless containerd第一次尝试，以下报错是因为ubuntu 24.04加强了应用限制，需要通过AppArmor配置非特权用户命名空间应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br><span class="line"><span class="comment"># [INFO] Checking RootlessKit functionality</span></span><br><span class="line"><span class="comment"># [rootlesskit:parent] error: failed to start the child: fork/exec /proc/self/exe: operation not permitted</span></span><br><span class="line"><span class="comment"># [ERROR] RootlessKit failed, see the error messages and https://rootlesscontaine.rs/getting-started/common/ .</span></span><br></pre></td></tr></table></figure>

<p>配置apparmor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rootlesskit放在了~/.local/bin目录</span></span><br><span class="line">filename=$(<span class="built_in">echo</span> <span class="variable">$HOME</span>/.local/bin/rootlesskit | sed -e s@^/@@ -e s@/@.@g)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; ~/$&#123;filename&#125;</span></span><br><span class="line"><span class="string">abi &lt;abi/4.0&gt;,</span></span><br><span class="line"><span class="string">include &lt;tunables/global&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;$HOME/.local/bin/rootlesskit&quot; flags=(unconfined) &#123;</span></span><br><span class="line"><span class="string">  userns,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  include if exists &lt;local/$&#123;filename&#125;&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> ~/<span class="variable">$&#123;filename&#125;</span> /etc/apparmor.d/<span class="variable">$&#123;filename&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart apparmor.service</span><br></pre></td></tr></table></figure>

<p>安装并启动rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br><span class="line"></span><br><span class="line"><span class="comment"># [INFO] Checking RootlessKit functionality</span></span><br><span class="line"><span class="comment"># [INFO] Checking cgroup v2</span></span><br><span class="line"><span class="comment"># [INFO] Checking overlayfs</span></span><br><span class="line"><span class="comment"># [INFO] Requirements are satisfied</span></span><br><span class="line"><span class="comment"># [INFO] Creating &quot;/home/vagrant/.config/systemd/user/containerd.service&quot;</span></span><br><span class="line"><span class="comment"># [INFO] Starting systemd unit &quot;containerd.service&quot;</span></span><br><span class="line"><span class="comment"># + systemctl --user start containerd.service</span></span><br><span class="line"><span class="comment"># + sleep 3</span></span><br><span class="line"><span class="comment"># + systemctl --user --no-pager --full status containerd.service</span></span><br><span class="line"><span class="comment"># ● containerd.service - containerd (Rootless)</span></span><br><span class="line"><span class="comment">#      Loaded: loaded (/home/vagrant/.config/systemd/user/containerd.service; disabled; preset: enabled)</span></span><br><span class="line"><span class="comment">#      Active: active (running) since Sat 2025-02-08 09:10:49 CST; 3s ago</span></span><br><span class="line"><span class="comment">#    Main PID: 3535 (rootlesskit)</span></span><br><span class="line"><span class="comment">#       Tasks: 28</span></span><br><span class="line"><span class="comment">#      Memory: 15.2M (peak: 19.2M)</span></span><br><span class="line"><span class="comment">#         CPU: 287ms</span></span><br><span class="line"><span class="comment">#      CGroup: /user.slice/user-1000.slice/user@1000.service/app.slice/containerd.service</span></span><br><span class="line"><span class="comment">#              ├─3535 rootlesskit --state-dir=/run/user/1000/containerd-rootless --net=slirp4netns --mtu=65520 --slirp4netns-sandbox=auto --slirp4netns-seccomp=auto --disable-host-loopback --port-driver=builtin --copy-up=/etc --copy-up=/run --copy-up=/var/lib --propagation=rslave --detach-netns /home/vagrant/.local/bin/containerd-rootless.sh</span></span><br><span class="line"><span class="comment">#              ├─3553 /proc/self/exe --state-dir=/run/user/1000/containerd-rootless --net=slirp4netns --mtu=65520 --slirp4netns-sandbox=auto --slirp4netns-seccomp=auto --disable-host-loopback --port-driver=builtin --copy-up=/etc --copy-up=/run --copy-up=/var/lib --propagation=rslave --detach-netns /home/vagrant/.local/bin/containerd-rootless.sh</span></span><br><span class="line"><span class="comment">#              ├─3574 slirp4netns --mtu 65520 -r 3 --disable-host-loopback --enable-seccomp --userns-path=/proc/3553/ns/user --netns-type=path /proc/3553/root/run/user/1000/containerd-rootless/netns tap0</span></span><br><span class="line"><span class="comment">#              └─3582 containerd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684164811+08:00&quot; level=info msg=&quot;Start recovering state&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684269626+08:00&quot; level=info msg=serving... address=/run/containerd/containerd.sock</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684288884+08:00&quot; level=info msg=&quot;Start event monitor&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684345921+08:00&quot; level=info msg=&quot;Start cni network conf syncer for default&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684355097+08:00&quot; level=info msg=&quot;Start streaming server&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684362261+08:00&quot; level=info msg=&quot;Registered namespace \&quot;k8s.io\&quot; with NRI&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684406574+08:00&quot; level=info msg=&quot;runtime interface starting up...&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684412963+08:00&quot; level=info msg=&quot;starting plugins...&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684427341+08:00&quot; level=info msg=&quot;Synchronizing NRI (plugin) with current runtime state&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684492554+08:00&quot; level=info msg=&quot;containerd successfully booted in 0.037003s&quot;</span></span><br><span class="line"><span class="comment"># + systemctl --user enable containerd.service</span></span><br><span class="line"><span class="comment"># Created symlink /home/vagrant/.config/systemd/user/default.target.wants/containerd.service → /home/vagrant/.config/systemd/user/containerd.service.</span></span><br><span class="line"><span class="comment"># [INFO] Installed &quot;containerd.service&quot; successfully.</span></span><br><span class="line"><span class="comment"># [INFO] To control &quot;containerd.service&quot;, run: `systemctl --user (start|stop|restart) containerd.service`</span></span><br><span class="line"><span class="comment"># [INFO] To run &quot;containerd.service&quot; on system startup automatically, run: `sudo loginctl enable-linger vagrant`</span></span><br><span class="line"><span class="comment"># [INFO] ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># [INFO] Use `nerdctl` to connect to the rootless containerd.</span></span><br><span class="line"><span class="comment"># [INFO] You do NOT need to specify $CONTAINERD_ADDRESS explicitly.</span></span><br></pre></td></tr></table></figure>

<p>为<code>nerdctl build</code>安装并运行buildkit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nerdctl build</span></span><br><span class="line"><span class="comment"># ERRO[0000] `buildctl` needs to be installed and `buildkitd` needs to be running, see https://github.com/moby/buildkit , and `containerd-rootless-setuptool.sh install-buildkit` for OCI worker or `containerd-rootless-setuptool.sh install-buildkit-containerd` for containerd worker  error=&quot;failed to ping to host unix:///run/user/1000/buildkit-default/buildkitd.sock: exit status 1\nfailed to ping to host unix:///run/user/1000/buildkit/buildkitd.sock: exit status 1&quot;</span></span><br><span class="line"><span class="comment"># FATA[0000] no buildkit host is available, tried 2 candidates: failed to ping to host unix:///run/user/1000/buildkit-default/buildkitd.sock: exit status 1</span></span><br><span class="line"><span class="comment"># failed to ping to host unix:///run/user/1000/buildkit/buildkitd.sock: exit status 1</span></span><br><span class="line"></span><br><span class="line">containerd-rootless-setuptool.sh install-buildkit</span><br></pre></td></tr></table></figure>

<p>到这里，nerdctl以及containerd已经基本可用了</p>
<h2 id="单独安装"><a href="#单独安装" class="headerlink" title="单独安装"></a>单独安装</h2><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>安装containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxf /vagrant/containerd-2.0.2-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> ./bin/* /usr/local/bin/</span><br><span class="line"></span><br><span class="line">tree /usr/local/bin</span><br><span class="line"><span class="comment"># 输出如下所示</span></span><br><span class="line"><span class="comment"># /usr/local/bin</span></span><br><span class="line"><span class="comment"># ├── containerd</span></span><br><span class="line"><span class="comment"># ├── containerd-shim-runc-v2</span></span><br><span class="line"><span class="comment"># ├── containerd-stress</span></span><br><span class="line"><span class="comment"># └── ctr</span></span><br></pre></td></tr></table></figure>

<p>安装nerdctl</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装到/usr/local/bin/</span></span><br><span class="line"><span class="built_in">sudo</span> tar zxf nerdctl-2.0.3-linux-amd64.tar.gz -C /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">tree /usr/local/bin</span><br><span class="line"><span class="comment"># 输出如下所示</span></span><br><span class="line"><span class="comment"># /usr/local/bin</span></span><br><span class="line"><span class="comment"># ├── containerd</span></span><br><span class="line"><span class="comment"># ├── containerd-rootless-setuptool.sh</span></span><br><span class="line"><span class="comment"># ├── containerd-rootless.sh</span></span><br><span class="line"><span class="comment"># ├── containerd-shim-runc-v2</span></span><br><span class="line"><span class="comment"># ├── containerd-stress</span></span><br><span class="line"><span class="comment"># ├── ctr</span></span><br><span class="line"><span class="comment"># └── nerdctl</span></span><br></pre></td></tr></table></figure>

<p>安装rootlesskit以及slirp4netns</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装到/usr/local/bin/</span></span><br><span class="line"><span class="built_in">sudo</span> tar zxf rootlesskit-x86_64.tar.gz -C /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x slirp4netns</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> slirp4netns /usr/local/bin</span><br></pre></td></tr></table></figure>

<p>安装buildkit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxf buildkit-v0.19.0.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> ./bin/* /usr/local/bin/</span><br></pre></td></tr></table></figure>

<p>安装cni</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cni安装目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /opt/cni/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> tar zxf cni-plugins-linux-amd64-v1.6.2.tgz -C /opt/cni/bin/</span><br><span class="line"></span><br><span class="line">tree /opt/cni/bin</span><br><span class="line"><span class="comment"># /opt/cni/bin</span></span><br><span class="line"><span class="comment"># ├── LICENSE</span></span><br><span class="line"><span class="comment"># ├── README.md</span></span><br><span class="line"><span class="comment"># ├── bandwidth</span></span><br><span class="line"><span class="comment"># ├── bridge</span></span><br><span class="line"><span class="comment"># ├── dhcp</span></span><br><span class="line"><span class="comment"># ├── dummy</span></span><br><span class="line"><span class="comment"># ├── firewall</span></span><br><span class="line"><span class="comment"># ├── host-device</span></span><br><span class="line"><span class="comment"># ├── host-local</span></span><br><span class="line"><span class="comment"># ├── ipvlan</span></span><br><span class="line"><span class="comment"># ├── loopback</span></span><br><span class="line"><span class="comment"># ├── macvlan</span></span><br><span class="line"><span class="comment"># ├── portmap</span></span><br><span class="line"><span class="comment"># ├── ptp</span></span><br><span class="line"><span class="comment"># ├── sbr</span></span><br><span class="line"><span class="comment"># ├── static</span></span><br><span class="line"><span class="comment"># ├── tap</span></span><br><span class="line"><span class="comment"># ├── tuning</span></span><br><span class="line"><span class="comment"># ├── vlan</span></span><br><span class="line"><span class="comment"># └── vrf</span></span><br></pre></td></tr></table></figure>

<h3 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h3><p>执行<code>nerdctl</code>，报错需要安装运行rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nerdctl</span><br><span class="line"><span class="comment"># FATA[0000] rootless containerd not running? (hint: use `containerd-rootless-setuptool.sh install` to start rootless containerd): stat /run/user/1000/containerd-rootless: no such file or directory</span></span><br></pre></td></tr></table></figure>

<p>安装rootless containerd第一次尝试，报错表示需要配置AppArmor授权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br><span class="line"><span class="comment"># [INFO] Checking RootlessKit functionality</span></span><br><span class="line"><span class="comment"># [rootlesskit:parent] error: failed to start the child: fork/exec /proc/self/exe: operation not permitted</span></span><br><span class="line"><span class="comment"># [ERROR] RootlessKit failed, see the error messages and https://rootlesscontaine.rs/getting-started/common/ .</span></span><br></pre></td></tr></table></figure>

<p>配置apparmor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rootlesskit放在了/usr/local/bin目录</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOT | sudo tee &quot;/etc/apparmor.d/usr.local.bin.rootlesskit&quot;</span></span><br><span class="line"><span class="string">abi &lt;abi/4.0&gt;,</span></span><br><span class="line"><span class="string">include &lt;tunables/global&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/usr/local/bin/rootlesskit flags=(unconfined) &#123;</span></span><br><span class="line"><span class="string">  userns,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # Site-specific additions and overrides. See local/README for details.</span></span><br><span class="line"><span class="string">  include if exists &lt;local/usr.local.bin.rootlesskit&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOT</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart apparmor.service</span><br></pre></td></tr></table></figure>

<p>安装并启动rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br></pre></td></tr></table></figure>

<p>为<code>nerdctl build</code>安装并运行buildkit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install-buildkit</span><br></pre></td></tr></table></figure>

<p>完成安装！</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/containerd/nerdctl">nerdctl</a><br><a href="https://rootlesscontaine.rs/getting-started/common/">Common steps (Read first!)</a><br><a href="https://docs.docker.com/engine/security/rootless/">Rootless mode</a></p>
]]></content>
      <tags>
        <tag>containerd</tag>
        <tag>nerdctl</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - Part 1</title>
    <url>/php-extension-writing-part1/</url>
    <content><![CDATA[<p>在网上找到几篇基于PHP5的扩展开发的文章，有些古老，与PHP7不完全兼容，自己做了些简单的翻译、修改。</p>
<p>建议开发者先阅读<a href="http://www.phpinternalsbook.com/">PHP Internals Book</a>这份在线文档，里面对PHP做了比较全面的讲解。由于PHP扩展开发的资料比较少，也鲜有PHP开发者触及到这块，编写扩展时如果遇到问题，最好是先查找PHP源代码是否有相关的使用案例，再通过网上论坛、QQ等方式寻求帮助。</p>
<p>本文是PHP扩展开发系列的第一篇，主要介绍如何开发一个简单的PHP扩展、如何获取ini配置参数、如何配置全局变量</p>
<p>前期准备：</p>
<p>PHP编译选项加入<code>--enable-debug</code>以及<code>--enable-maintainer-zts</code>。<code>--enable-debug</code>生成额外的调试符号，并将优化等级设置为<code>-O0</code>，报告内存泄露等错误，使使用gdb进行debug时更为准确；<code>--enable-maintainer-zts</code>启用线程安全，开启<code>ZTS</code>宏定义，配置PHP为TSRM机制，用于编写调试多线程代码</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="扩展目录结构"><a href="#扩展目录结构" class="headerlink" title="扩展目录结构"></a>扩展目录结构</h3><p>你可能会使用PHP源代码自带的脚本<code>ext/ext_skel.php</code>生成扩展骨架，但这里选择极简方式创建一个扩展，最基本的扩展只需要三个文件：配置文件<code>config.m4</code>，头文件<code>php_test.h</code>，源文件<code>test.c</code></p>
<p><code>test</code>扩展目录结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php-7.4.1</span><br><span class="line">└── ext</span><br><span class="line">    └── <span class="built_in">test</span></span><br><span class="line">        ├── config.m4</span><br><span class="line">        ├── php_test.h</span><br><span class="line">        └── test.c</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnl 用于生成configure及其他文件</span><br><span class="line">dnl `dnl`开头的行为注释内容</span><br><span class="line">dnl 若扩展依赖外部库，使用--with，否则默认使用--enable</span><br><span class="line">PHP_ARG_ENABLE(test, whether to enable test support,</span><br><span class="line">[  --enable-test          Enable test support], no)</span><br><span class="line"></span><br><span class="line">if test &quot;$PHP_TEST&quot; != &quot;no&quot;; then</span><br><span class="line">  AC_DEFINE(HAVE_TEST, 1, [ Have test support ])</span><br><span class="line">  PHP_NEW_EXTENSION(test, test.c, $ext_shared)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>头文件默认格式为<code>php_extname.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PHP_TEST_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PHP_TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PHP扩展结构zend_module_entry */</span></span><br><span class="line"><span class="keyword">extern</span> zend_module_entry test_module_entry;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> phpext_test_ptr &amp;test_module_entry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* version扩展版本号 */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PHP_TEST_VERSION <span class="string">&quot;0.1.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义函数声明PHP_FUNCTION(your_function_name) */</span></span><br><span class="line">PHP_FUNCTION(test);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ZTS) &amp;&amp; defined(COMPILE_DL_TEST)</span></span><br><span class="line">ZEND_TSRMLS_CACHE_EXTERN()</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_CONFIG_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php_test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义函数注册，最终*test_functions注册到模块声明test_module_entry */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_functions[] = &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 注册`test`函数，格式为PHP_FE(func_name, arg_info)，arg_info声明参数信息，如是否是引用等，这里先忽略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PHP_FE(test, <span class="literal">NULL</span>)</span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块注册 */</span></span><br><span class="line">zend_module_entry test_module_entry = &#123;</span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,                    <span class="comment">/* 扩展名称 */</span></span><br><span class="line">    test_functions,            <span class="comment">/* 自定义函数注册 */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_MINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_RINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_RSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_MINFO */</span></span><br><span class="line">    PHP_TEST_VERSION,          <span class="comment">/* version */</span></span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数test */</span></span><br><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_STRING(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_DL_TEST</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ZTS</span></span><br><span class="line">ZEND_TSRMLS_CACHE_DEFINE()</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">ZEND_GET_MODULE(test)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line"><span class="comment"># 除非config.m4有改动，否则只执行以下命令</span></span><br><span class="line">make &amp;&amp; <span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在<code>php.ini</code>添加<code>extension=test.so</code>，执行脚本获取输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;echo test();&quot;</span> <span class="comment"># 输出：Hello World</span></span><br></pre></td></tr></table></figure>

<h2 id="INI参数"><a href="#INI参数" class="headerlink" title="INI参数"></a>INI参数</h2><p>Zend Engine提供了两种方式访问ini参数，以下是第一种较为简单的方式，第二种方式与全局变量搭配使用，后面介绍</p>
<p>我们在PHP的声明周期MINIT阶段注册ini参数，在<code>php_test.h</code>添加MINIT原型声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test模块初始化</span></span><br><span class="line">PHP_MINIT_FUNCTION(test);</span><br><span class="line"><span class="comment">// test模块关闭清理函数</span></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(test);</span><br></pre></td></tr></table></figure>

<p><code>test.c</code>做以下调整，注册MINIT，init参数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php_ini.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">zend_module_entry test_module_entry = &#123;</span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    test_functions,</span><br><span class="line">    PHP_MINIT(test),      <span class="comment">/* 注册MINIT */</span></span><br><span class="line">    PHP_MSHUTDOWN(test),  <span class="comment">/* 注册MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    PHP_TEST_VERSION,</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ini参数获取代码块</span></span><br><span class="line">PHP_INI_BEGIN()</span><br><span class="line">    <span class="comment">// ini参数test.foo声明</span></span><br><span class="line">    PHP_INI_ENTRY(<span class="string">&quot;test.foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, PHP_INI_ALL, <span class="literal">NULL</span>)</span><br><span class="line">PHP_INI_END();</span><br><span class="line"><span class="comment">// 以上宏等同于声明zend_ini_entry_def[]变量</span></span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    REGISTER_INI_ENTRIES();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    UNREGISTER_INI_ENTRIES();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_STRING(INI_STR(<span class="string">&quot;test.foo&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ini参数声明放置在<code>PHP_INI_BEGIN</code>、<code>PHP_INI_END</code>，参数声明使用宏<code>PHP_INI_ENTRY</code>，具体格式为<code>PHP_INI_ENTRY(param_name, default_val, access_mode_modifier, validator)</code></p>
<p><code>access_mode_modifier</code>决定ini参数可在什么地方被修改，主要有</p>
<ul>
<li>PHP_INI_ALL: 值可通过php.ini、.htaccess、ini_set修改</li>
<li>PHP_INI_SYSTEM: 只可通过php.ini修改</li>
<li>PHP_INI_PERDIR: 只可通过.htaccess修改</li>
</ul>
<p><code>validator</code>校验这里先忽略</p>
<p>ini参数值获取方式如下</p>
<table>
<thead>
<tr>
<th align="left">当前值local value</th>
<th align="left">默认值master value</th>
<th align="left">返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INI_STR</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">char *</td>
</tr>
<tr>
<td align="left">INI_INT</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">zend_long</td>
</tr>
<tr>
<td align="left">INI_FLT</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">INI_BOOL</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">zend_bool</td>
</tr>
</tbody></table>
<p>配置PHP，在<code>php.ini</code>添加<code>test.foo=helloworld</code>，执行脚本获取输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;echo test();&quot;</span> <span class="comment"># 输出：helloworld</span></span><br></pre></td></tr></table></figure>

<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>上面部分的ini参数获取代码有几个问题，第一，每次读取ini参数值时，都需要系统扫描ini设置表，并转换成相应的类型；第二，没有校验用户输入，这样用户使用<code>ini_set</code>可以设置任意数据</p>
<p>我们可以配置ini参数到全局变量，避免每次扫描ini设置表，在这之前，先看看如何使用全局变量编写一个计数器</p>
<p>头文件<code>php_test.h</code>添加全局变量声明，并定义一个宏来访问我们的全局变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;TSRM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line">ZEND_BEGIN_MODULE_GLOBALS(test)</span><br><span class="line">    <span class="type">long</span> counter;</span><br><span class="line">ZEND_END_MODULE_GLOBALS(test)</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 上面代码等同</span></span><br><span class="line"><span class="comment"> * typedef struct _zend_pib_globals &#123;</span></span><br><span class="line"><span class="comment"> *     long counter;</span></span><br><span class="line"><span class="comment"> * &#125; zend_test_globals;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 TEST_G - 全局变量访问 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TEST_G(v) TSRMG(test_globals_id, zend_test_globals *, v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TEST_G(v) (test_globals.v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请求初始化 */</span></span><br><span class="line">PHP_MINIT_FUNCTION(test);</span><br></pre></td></tr></table></figure>

<p>源文件初始化全局变量，MINIT只会在进程或线程创建时执行一次，而一个进程可以服务多个请求，我们需要计数器在每个请求开始时清零，需要RINIT函数清零counter</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化zend_test_globals */</span></span><br><span class="line">ZEND_DECLARE_MODULE_GLOBALS(test)</span><br><span class="line"><span class="comment">/* 等同于 zend_test_globals test_globals; */</span></span><br><span class="line"></span><br><span class="line">zend_module_entry test_module_entry = &#123;</span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    test_functions,</span><br><span class="line">    PHP_MINIT(test),</span><br><span class="line">    PHP_MSHUTDOWN(test),</span><br><span class="line">    PHP_RINIT(test),     <span class="comment">/* 注册请求初始化函数 */</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    PHP_TEST_VERSION,</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量初始化，仅在进程/线程创建时初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_init_globals</span><span class="params">(zend_test_globals *test_globals)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求初始化</span></span><br><span class="line">PHP_RINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 因一个进程可服务多个请求，我们需要每个请求都有独立的counter */</span></span><br><span class="line">    TEST_G(counter) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化</span></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 全局变量表注册 */</span></span><br><span class="line">    ZEND_INIT_MODULE_GLOBALS(test, php_test_init_globals, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    REGISTER_INI_ENTRIES();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行PHP脚本获取输出验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;test(); echo test();&quot;</span> <span class="comment"># 输出：2</span></span><br></pre></td></tr></table></figure>

<h2 id="INI注册全局变量"><a href="#INI注册全局变量" class="headerlink" title="INI注册全局变量"></a>INI注册全局变量</h2><p>有了上面的认识，在这里，将ini参数<code>test.direction</code>注册到全局变量，并添加validator校验</p>
<p>头文件添加参数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZEND_BEGIN_MODULE_GLOBALS(test)</span><br><span class="line">    <span class="type">long</span> counter;</span><br><span class="line">    zend_bool direction;</span><br><span class="line">ZEND_END_MODULE_GLOBALS(test)</span><br></pre></td></tr></table></figure>

<p>源文件修改为以下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_INI_BEGIN()</span><br><span class="line">    PHP_INI_ENTRY(<span class="string">&quot;test.foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, PHP_INI_ALL, <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">// STD_PHP_INI_ENTRY(name, default_value, modifiable, on_modify, property_name, struct_type, struct_ptr)</span></span><br><span class="line">    STD_PHP_INI_ENTRY(<span class="string">&quot;test.direction&quot;</span>, <span class="string">&quot;1&quot;</span>, PHP_INI_ALL, OnUpdateBool, direction, zend_test_globals, test_globals)</span><br><span class="line">PHP_INI_END();</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_init_globals</span><span class="params">(zend_test_globals *test_globals)</span> &#123;</span><br><span class="line">    <span class="comment">/* direction初始化，0|1 */</span></span><br><span class="line">    test_globals-&gt;direction = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TEST_G(direction)) &#123;</span><br><span class="line">        TEST_G(counter)++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TEST_G(counter)--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RETURN_LONG(TEST_G(counter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>STD_PHP_INI_ENTRY</code>可以使用更多参数，这里我们将参数写入全局变量<code>test_globals</code>。关联第四个参数<code>on_modify</code>校验输入值，如果成功，写入到全局变量，默认为<code>onUpdateLongGEZero</code>，其他的宏还有<code>OnUpdateLong</code>、<code>OnUpdateBool</code>、<code>OnUpdateReal</code>、<code>OnUpdateString</code>、<code>OnUpdateStringUnempty</code></p>
<p>配置PHP，在<code>php.ini</code>添加<code>test.direction=0</code>，执行脚本获取输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;echo test();&quot;</span> <span class="comment"># 输出：-1</span></span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/Y2k38/php_ext_tutorial">php_ext_tutorial</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://stackoverflow.com/questions/3632160/how-to-make-a-php-extension">How to make a PHP extension</a><br><a href="https://wiki.php.net/phpng-upgrading">Upgrading PHP extensions from PHP5 to NG</a><br><del><a href="https://devzone.zend.com/303/extension-writing-part-i-introduction-to-php-and-zend/">Extension Writing Part I: Introduction to PHP and Zend (已失效)</a></del><br><a href="https://github.com/bigbes/bigbes.github.io/wiki/Extension-Writing-Part-I:-Introduction-to-PHP-and-Zend">Extension Writing Part I: Introduction to PHP and Zend</a><br><a href="http://www.phpinternalsbook.com/">PHP Internals Book</a><br><a href="https://wiki.php.net/internals/references">References about Maintaining and Extending PHP</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - Part 2</title>
    <url>/php-extension-writing-part2/</url>
    <content><![CDATA[<p>PHP扩展开发第二章，主要介绍函数参数获取、zval数据类型、数组及数组遍历以及$GLOBALS全局变量访问</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>扩展自定义函数不需要声明形参，Zend Engine会给每个函数传递一个参数列表<code>zend_execute_data *execute_data</code>，函数参数通过宏块<code>ZEND_PARSE_PARAMETERS_START</code>、<code>ZEND_PARSE_PARAMETERS_END</code>获取，当然，旧的方法<code>zend_parse_parameters</code>也可以使用，只是会更麻烦点</p>
<p>下面示例函数将接收参数name以及打印的次数t_param并打印name</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数1</span></span><br><span class="line">    zend_string *name;</span><br><span class="line">    <span class="comment">// 参数2</span></span><br><span class="line">    zend_long t_param = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> times = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低可接收1个参数，最多2个</span></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name)</span><br><span class="line">        Z_PARAM_OPTIONAL</span><br><span class="line">        <span class="title function_">Z_PARAM_LONG</span><span class="params">(t_param)</span></span><br><span class="line">    <span class="title function_">ZEND_PARSE_PARAMETERS_END</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有传递默认值</span></span><br><span class="line">    <span class="keyword">if</span> (ZEND_NUM_ARGS() == <span class="number">2</span>) &#123;</span><br><span class="line">        times = (<span class="type">int</span>) (t_param &lt; <span class="number">1</span> ? <span class="number">1</span> : t_param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        php_printf(<span class="string">&quot;Hello %s&quot;</span>, ZSTR_VAL(name));</span><br><span class="line">    &#125;</span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用的有数据类型以及参数获取方法有下</p>
<table>
<thead>
<tr>
<th align="left">Variable Type</th>
<th align="left">Macro</th>
</tr>
</thead>
<tbody><tr>
<td align="left">zend_bool</td>
<td align="left">Z_PARAM_BOOL</td>
</tr>
<tr>
<td align="left">zend_long</td>
<td align="left">Z_PARAM_LONG</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Z_PARAM_DOUBLE</td>
</tr>
<tr>
<td align="left">zend_string *</td>
<td align="left">Z_PARAM_STR</td>
</tr>
<tr>
<td align="left">char *</td>
<td align="left">Z_PARAM_STRING</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_RESOURCE</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_ARRAY</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_OBJECT</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_ZVAL</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="ZVAL结构"><a href="#ZVAL结构" class="headerlink" title="ZVAL结构"></a>ZVAL结构</h2><p>PHP7的zval相对PHP5做了比较大的改动，zval、zend_string、zend_array重构，bool类型分成了true、false两种类型直接存储在(zval).u1.type_info等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// php7 zval变量结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">zend_value</span> &#123;</span></span><br><span class="line">    zend_long         lval;                <span class="comment">/* long value */</span></span><br><span class="line">    <span class="type">double</span>            dval;                <span class="comment">/* double value */</span></span><br><span class="line">    zend_refcounted  *counted;</span><br><span class="line">    zend_string      *str;</span><br><span class="line">    zend_array       *arr;</span><br><span class="line">    zend_object      *obj;</span><br><span class="line">    zend_resource    *res;</span><br><span class="line">    zend_reference   *ref;</span><br><span class="line">    zend_ast_ref     *ast;</span><br><span class="line">    zval             *zv;</span><br><span class="line">    <span class="type">void</span>             *ptr;</span><br><span class="line">    zend_class_entry *ce;</span><br><span class="line">    zend_function    *func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> w1;</span><br><span class="line">        <span class="type">uint32_t</span> w2;</span><br><span class="line">    &#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">    zend_value        value;            <span class="comment">/* value */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_3(</span><br><span class="line">                zend_uchar    type,            <span class="comment">/* active type */</span></span><br><span class="line">                zend_uchar    type_flags,</span><br><span class="line">                <span class="keyword">union</span> &#123;</span><br><span class="line">                    <span class="type">uint16_t</span>  extra;        <span class="comment">/* not further specified */</span></span><br><span class="line">                &#125; u)</span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="type">uint32_t</span> type_info;</span><br><span class="line">    &#125; u1;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line">        <span class="type">uint32_t</span>     cache_slot;           <span class="comment">/* cache slot (for RECV_INIT) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     opline_num;           <span class="comment">/* opline number (for FAST_CALL) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">        <span class="type">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">        <span class="type">uint32_t</span>     access_flags;         <span class="comment">/* class constant access flags */</span></span><br><span class="line">        <span class="type">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line">        <span class="type">uint32_t</span>     constant_flags;       <span class="comment">/* constant flags */</span></span><br><span class="line">        <span class="type">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>zval类型判断，一般情况下，如果参数与<code>Z_PARAM_*</code>的类型不一致，Zend Engine会进行转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收任意类型参数，最后输出其类型</span></span><br><span class="line">PHP_FUNCTION(test_type)</span><br><span class="line">&#123;</span><br><span class="line">    zval *uservar;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ZVAL(uservar);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (Z_TYPE_P(uservar)) &#123;</span><br><span class="line">        <span class="keyword">case</span> IS_NULL:</span><br><span class="line">            php_printf(<span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_TRUE:</span><br><span class="line">            php_printf(<span class="string">&quot;Boolean: TRUE&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_FALSE:</span><br><span class="line">            php_printf(<span class="string">&quot;Boolean: FALSE&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_LONG:</span><br><span class="line">            php_printf(<span class="string">&quot;Long: %ld&quot;</span>, Z_LVAL_P(uservar));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_DOUBLE:</span><br><span class="line">            php_printf(<span class="string">&quot;Double: %f&quot;</span>, Z_DVAL_P(uservar));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_STRING:</span><br><span class="line">            php_printf(<span class="string">&quot;String: &quot;</span>);</span><br><span class="line">            PHPWRITE(Z_STRVAL_P(uservar), Z_STRLEN_P (uservar));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_RESOURCE:</span><br><span class="line">            php_printf(<span class="string">&quot;Resource&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">            php_printf(<span class="string">&quot;Array&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">            php_printf(<span class="string">&quot;Object&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            php_printf(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印数组内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_again)</span><br><span class="line">&#123;</span><br><span class="line">    zval *zname;</span><br><span class="line">    </span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ZVAL(zname);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将改变原有参数类型</span></span><br><span class="line">    convert_to_string(zname);</span><br><span class="line">    php_printf(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">    PHPWRITE(Z_STRVAL_P(zname), Z_STRLEN_P(zname));</span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_to_*</code>会将参数转换成指定的类型，即改变原始参数类型、数据，在php代码中，原本以传参的形式传递的变量值会被修改。要解决这个问题，可以使用临时变量，也可以使用<code>convert_to_*_ex</code>，该类函数在转换类型前会先调用<code>SEPARATE_ZVAL_IF_NOT_REF</code>，避免修改原始变量</p>
<h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><p>PHP的数组用途非常广泛，类对象属性的存储也依赖数组，数组的底层实现结构为HashTable</p>
<p>下面函数创建一个数据并返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_array)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// $arr = [];</span></span><br><span class="line">    array_init(return_value);</span><br><span class="line">    <span class="comment">// $arr[3] = 123;</span></span><br><span class="line">    add_index_long(return_value, <span class="number">3</span>, <span class="number">123</span>);</span><br><span class="line">    <span class="comment">// $arr[] = &quot;example&quot;;</span></span><br><span class="line">    add_next_index_string(return_value, <span class="string">&quot;example&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *mystr = estrdup(<span class="string">&quot;five&quot;</span>);</span><br><span class="line">    add_next_index_string(return_value, mystr);</span><br><span class="line">    efree(mystr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $arr[&quot;pi&quot;] = 3.1415926;</span></span><br><span class="line">    add_assoc_double(return_value, <span class="string">&quot;pi&quot;</span>, <span class="number">3.1415926</span>);</span><br><span class="line">    </span><br><span class="line">    zval subarr;</span><br><span class="line">    array_init(&amp;subarr);</span><br><span class="line">    add_next_index_string(&amp;subarr, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    add_assoc_zval(return_value, <span class="string">&quot;subarr&quot;</span>, &amp;subarr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>add_next_index_*</code>添加元素进数组，由系统分配一个递增的数字key</li>
<li><code>add_index_*</code>添加元素进数组，由用户指定一个数字类型的key</li>
<li><code>add_assoc_*</code>添加元素进数组，由用户指定的字符串类型key</li>
</ul>
<p>注意：<code>add_assoc_*</code>非二进制安全</p>
<p>扩展函数返回值不使用<code>return</code>语句，配置<code>zval *return_value</code>即可，该变量由宏<code>PHP_FUNCTION</code>提供，返回值<code>RETURN_TRUE</code>也是通过设置<code>return_value</code>完成返回值赋值，默认设置为<code>IS_NULL</code>类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历并打印数组字符串值</span></span><br><span class="line">PHP_FUNCTION(test_array_strings)</span><br><span class="line">&#123;</span><br><span class="line">    zval *arr, *data;</span><br><span class="line">    HashTable *arr_hash;</span><br><span class="line">    HashPosition pointer;</span><br><span class="line">    <span class="type">int</span> array_count;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ARRAY(arr);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    arr_hash = Z_ARRVAL_P(arr);</span><br><span class="line">    array_count = zend_hash_num_elements(arr_hash);</span><br><span class="line"></span><br><span class="line">    php_printf(<span class="string">&quot;The array passed contains %d elements\n&quot;</span>, array_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 可使用宏ZEND_HASH_FOREACH_VAL、ZEND_HASH_FOREACH_END</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">        zend_hash_internal_pointer_reset_ex(arr_hash, &amp;pointer);</span><br><span class="line">        data = zend_hash_get_current_data_ex(arr_hash, &amp;pointer);</span><br><span class="line">        zend_hash_move_forward_ex(arr_hash, &amp;pointer)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// example 1</span></span><br><span class="line">        <span class="comment">// 如果是字符串就打印</span></span><br><span class="line">        <span class="comment">// if (Z_TYPE_P(data) == IS_STRING) &#123;</span></span><br><span class="line">        <span class="comment">//     PHPWRITE(Z_STRVAL_P(data), Z_STRLEN_P(data));</span></span><br><span class="line">        <span class="comment">//     php_printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// example 2</span></span><br><span class="line">        <span class="comment">// 将参数转为字符串打印</span></span><br><span class="line">        <span class="comment">// zval tmp;</span></span><br><span class="line">        <span class="comment">// tmp = *data;</span></span><br><span class="line">        <span class="comment">// zval_copy_ctor(&amp;tmp);</span></span><br><span class="line">        <span class="comment">// convert_to_string(&amp;tmp);</span></span><br><span class="line">        <span class="comment">// PHPWRITE(Z_STRVAL(tmp), Z_STRLEN(tmp));</span></span><br><span class="line">        <span class="comment">// php_printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// zval_dtor(&amp;tmp);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// example 3</span></span><br><span class="line">        <span class="comment">// 打印数组key以及value</span></span><br><span class="line">        <span class="type">int</span> keytype;</span><br><span class="line">        zend_string * str_index;</span><br><span class="line">        zend_ulong num_index;</span><br><span class="line"></span><br><span class="line">        keytype = zend_hash_get_current_key_ex(arr_hash, &amp;str_index, &amp;num_index, &amp;pointer);</span><br><span class="line">        <span class="keyword">if</span> (HASH_KEY_IS_STRING == keytype) &#123;</span><br><span class="line">            <span class="comment">// 字符串类型key</span></span><br><span class="line">            PHPWRITE(ZSTR_VAL(str_index), ZSTR_LEN(str_index));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HASH_KEY_IS_LONG == keytype) &#123;</span><br><span class="line">            <span class="comment">// 数字key</span></span><br><span class="line">            php_printf(<span class="string">&quot;%ld&quot;</span>, num_index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        php_printf(<span class="string">&quot; =&gt; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        zval tmp;</span><br><span class="line">        tmp = *data;</span><br><span class="line">        zval_copy_ctor(&amp;tmp);</span><br><span class="line">        convert_to_string(&amp;tmp);</span><br><span class="line">        PHPWRITE(Z_STRVAL(tmp), Z_STRLEN(tmp));</span><br><span class="line">        php_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        zval_dtor(&amp;tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zend_hash_get_current_key_ex</code>返回的类型有</p>
<ul>
<li><code>HASH_KEY_IS_LONG</code>：整型key</li>
<li><code>HASH_KEY_IS_STRING</code>：字符串型key</li>
<li><code>HASH_KEY_NON_EXISTENT</code>：遍历完整个数组，没有更多元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印数组val</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_array_walk</span><span class="params">(zval *pDest)</span></span><br><span class="line">&#123;</span><br><span class="line">    zval tmp;</span><br><span class="line"></span><br><span class="line">    tmp = *pDest;</span><br><span class="line">    zval_copy_ctor(&amp;tmp);</span><br><span class="line">    convert_to_string(&amp;tmp);</span><br><span class="line">    PHPWRITE(Z_STRVAL(tmp), Z_STRLEN(tmp));</span><br><span class="line">    php_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    zval_dtor(&amp;tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印prefix以及数组val</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_array_walk_arg</span><span class="params">(zval *pDest, <span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_printf(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span> *)argument);</span><br><span class="line">    test_array_walk(pDest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印prefix、数组val以及suffix</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_array_walk_args</span><span class="params">(zval *pDest, <span class="type">int</span> num_args, va_list args, zend_hash_key *hash_key)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_printf(<span class="string">&quot;%s&quot;</span>, va_arg(args, <span class="type">char</span> *));</span><br><span class="line">    test_array_walk(pDest);</span><br><span class="line">    php_printf(<span class="string">&quot;%s\n&quot;</span>, va_arg(args, <span class="type">char</span> *));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line">PHP_FUNCTION(test_array_walk)</span><br><span class="line">&#123;</span><br><span class="line">    zval *arr;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ARRAY(arr);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的遍历数组处理</span></span><br><span class="line">    zend_hash_apply(Z_ARRVAL_P(arr), (<span class="type">apply_func_t</span>) test_array_walk);</span><br><span class="line">    <span class="comment">// 遍历数组，带一个参数</span></span><br><span class="line">    zend_hash_apply_with_argument(Z_ARRVAL_P(arr), (<span class="type">apply_func_arg_t</span>) test_array_walk_arg, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历数组，带多个参数</span></span><br><span class="line">    zend_hash_apply_with_arguments(Z_ARRVAL_P(arr), (<span class="type">apply_func_args_t</span>) test_array_walk_args, <span class="number">2</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;Welcome to my extension!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>test_array_walk</code>类似<code>array_map</code>，<code>test_array_walk</code>简单遍历数组，<code>test_array_walk_arg</code>遍历数组，可接收一个任意类型的额外参数，下面代码中用作数组元素的前缀，<code>test_array_walk_args</code>遍历数组，可接收任意多个参数，下面代码中用作数组元素的前缀、后缀</p>
<p>返回值类型：</p>
<ul>
<li><code>ZEND_HASH_APPLY_KEEP</code>：维持原有元素，继续遍历数组剩余元素</li>
<li><code>ZEND_HASH_APPLY_REMOVE</code>：删除原有元素，继续遍历数组剩余元素</li>
<li><code>ZEND_HASH_APPLY_STOP</code>：维持原有元素，停止遍历数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回数组指定key的value</span></span><br><span class="line">PHP_FUNCTION(test_array_value)</span><br><span class="line">&#123;</span><br><span class="line">    zval *arr, *offset, *val;</span><br><span class="line">    <span class="type">char</span> * tmp;</span><br><span class="line">    zend_string *str_index = <span class="literal">NULL</span>;</span><br><span class="line">    zend_ulong num_index;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_ARRAY(arr);</span><br><span class="line">        Z_PARAM_ZVAL(offset);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对非integer/string的key进行转换</span></span><br><span class="line">    <span class="keyword">switch</span> (Z_TYPE_P(offset)) &#123;</span><br><span class="line">        <span class="keyword">case</span> IS_NULL:</span><br><span class="line">        <span class="keyword">case</span> IS_FALSE:</span><br><span class="line">            num_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_TRUE:</span><br><span class="line">            num_index = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_DOUBLE:</span><br><span class="line">            num_index = (<span class="type">long</span>) Z_DVAL_P(offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_LONG:</span><br><span class="line">        <span class="keyword">case</span> IS_RESOURCE:</span><br><span class="line">            num_index = Z_LVAL_P(offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_STRING:</span><br><span class="line">            str_index = zval_get_string(offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">            tmp = <span class="string">&quot;Array&quot;</span>;</span><br><span class="line">            str_index = zend_string_init(tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">            tmp = <span class="string">&quot;Object&quot;</span>;</span><br><span class="line">            str_index = zend_string_init(tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            tmp = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">            str_index = zend_string_init(tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str_index &amp;&amp; (val = zend_hash_find(Z_ARRVAL_P(arr), str_index)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!str_index &amp;&amp; (val = zend_hash_index_find(Z_ARRVAL_P(arr), num_index)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *return_value = *val;</span><br><span class="line">    zval_copy_ctor(return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PHP7中zval在栈分配，函数执行完清理，需要深入复制一份给return_value</p>
<h2 id="Symbol-Tables"><a href="#Symbol-Tables" class="headerlink" title="Symbol Tables"></a>Symbol Tables</h2><p>全局变量$GLOBALS的底层存储结构也是HashTable，存储在一个全局结构体Executor Globals(_zend_executor_globals)里，通过EG(symbol_table)访问相关数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问全局变量$GLOBALS</span></span><br><span class="line">PHP_FUNCTION(test_get_global_var)</span><br><span class="line">&#123;</span><br><span class="line">    zval *val;</span><br><span class="line">    zend_string *varname;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_STR(varname);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局变量符号表：EG(symbol_table)</span></span><br><span class="line">    <span class="keyword">if</span> ((val = zend_hash_find(&amp;EG(symbol_table), varname)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_NOTICE, <span class="string">&quot;Undefined variable: %s&quot;</span>, ZSTR_VAL(varname));</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *return_value = *val;</span><br><span class="line">    zval_copy_ctor(return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/Y2k38/php_ext_tutorial">php_ext_tutorial</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><del><a href="https://devzone.zend.com/317/extension-writing-part-ii-parameters-arrays-and-zvals/">Extension Writing Part II: Parameters, Arrays, and ZVALs (Unable To Access)</a></del><br><del><a href="https://devzone.zend.com/318/extension-writing-part-ii-parameters-arrays-and-zvals-continued/">Extension Writing Part II: Parameters, Arrays, and ZVALs [continued] (Unable To Access)</a></del><br><a href="https://github.com/bigbes/bigbes.github.io/wiki/Extension-Writing-Part-II:-Parameters,-Arrays,-and-ZVALs">Extension Writing Part II: Parameters, Arrays, and ZVALs</a><br><a href="https://wiki.php.net/phpng-upgrading">Upgrading PHP extensions from PHP5 to NG</a><br><a href="http://www.phpinternalsbook.com/">PHP Internals Book</a><br><a href="https://wiki.php.net/internals/references">References about Maintaining and Extending PHP</a><br><a href="https://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html">Internal value representation in PHP 7 - Part 1 </a><br><a href="https://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html">Internal value representation in PHP 7 - Part 2</a><br><a href="https://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html">PHP’s new hashtable implementation</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql安装配置</title>
    <url>/postgres-setup-example/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h3><p>系统是ubuntu 24.04 LTS，开机启动使用了systemd，所以先安装相关依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install libsystemd-dev</span><br></pre></td></tr></table></figure>

<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>官网推荐使用pre-packaged方式，稳定可靠，适合生产环境。不过我想用最新版，就直接用源码编译安装了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入源代码目录</span></span><br><span class="line"><span class="built_in">cd</span> postgresql-16.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定安装目录、设置支持systemd</span></span><br><span class="line">./configure --prefix=/usr/local/postgresql-16.4 --with-systemd --with-ssl=openssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 软连接，方便升级用</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/local/postgresql-16.4 /usr/local/pgsql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="built_in">sudo</span> adduser postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库数据存储目录，与app目录分离</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/lib/pgsql/data</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R postgres /var/lib/pgsql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到postgres用户</span></span><br><span class="line">su - postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库目录、启动实例</span></span><br><span class="line">/usr/local/pgsql/bin/initdb -D /var/lib/pgsql/data</span><br><span class="line">/usr/local/pgsql/bin/pg_ctl -D /var/lib/pgsql/data -l logfile start</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">/usr/local/pgsql/bin/psql</span><br><span class="line"><span class="comment"># 关闭实例</span></span><br><span class="line"><span class="comment"># /usr/local/pgsql/bin/pg_ctl -D /var/lib/pgsql/data/ -l logfile stop</span></span><br></pre></td></tr></table></figure>

<p>到这里，postgresql完成安装、初始化</p>
<span id="more"></span>

<h3 id="systemd配置"><a href="#systemd配置" class="headerlink" title="systemd配置"></a>systemd配置</h3><p>开机启动配置systemd，添加配置文件<code>/etc/systemd/system/postgresql.service</code>，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=PostgreSQL database server</span><br><span class="line">Documentation=man:postgres(1)</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">User=postgres</span><br><span class="line">ExecStart=/usr/local/pgsql/bin/postgres -D /var/lib/pgsql/data</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=mixed</span><br><span class="line">KillSignal=SIGINT</span><br><span class="line">TimeoutSec=infinity</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>使用systemd启动postgresql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl start postgresql</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> postgresql</span><br></pre></td></tr></table></figure>

<h2 id="pgsql配置"><a href="#pgsql配置" class="headerlink" title="pgsql配置"></a>pgsql配置</h2><p>以上完成pg安装，本地可以直接访问使用。接下来是配置数据库提供对外访问能力，如配置tcp监听地址、添加用户、配置权限等</p>
<p>进入pg的data数据存储目录，修改相关配置文件</p>
<h3 id="tcp配置"><a href="#tcp配置" class="headerlink" title="tcp配置"></a>tcp配置</h3><p>修改<code>postgresql.conf</code>文件，配置监听地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认localhost，改为&#x27;*&#x27;</span><br><span class="line">listen_addresses = &#x27;*&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="auth配置"><a href="#auth配置" class="headerlink" title="auth配置"></a>auth配置</h3><p>PS: pg的授权配置没有像mysql一样开箱即用，先简单配置下吧</p>
<p>修改<code>pg_hba.conf</code>文件，开放数据库&#x2F;用户对外访问权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class="line">host    blogdb          all             0.0.0.0/0               scram-sha-256</span><br><span class="line">host    blogdb          all             ::0/0                   scram-sha-256</span><br></pre></td></tr></table></figure>

<p>重启postgresql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start postgresql</span><br></pre></td></tr></table></figure>

<p>修改超级用户密码或者创建新角色并授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 修改postgres密码</span></span><br><span class="line"><span class="comment">-- alter user postgres password &#x27;your_password&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建新角色并授权</span></span><br><span class="line">\c blogdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> ROLE blog_read_only <span class="keyword">WITH</span> LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ROLE blog_read_write <span class="keyword">WITH</span> LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ROLE blog_admin <span class="keyword">WITH</span> LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> blog_read_only;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> blog_read_write;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> blog_admin;</span><br></pre></td></tr></table></figure>

<h2 id="curd-example"><a href="#curd-example" class="headerlink" title="curd example"></a>curd example</h2><p>完成了pg的安装配置，接下来就是写一个demo测试了，首先，找一个数据表导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取countries.csv数据</span></span><br><span class="line">curl <span class="string">&#x27;https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv&#x27;</span> \</span><br><span class="line">    --output ./countries.csv</span><br></pre></td></tr></table></figure>

<p>创建数据库blogdb，并导入countries.csv</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database blogdb;</span><br><span class="line">\c blogdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> countries (</span><br><span class="line">  id <span class="type">integer</span> <span class="keyword">primary</span> key generated always <span class="keyword">as</span> <span class="keyword">identity</span>,</span><br><span class="line">  name text <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">  alpha_2 <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  alpha_3 <span class="type">char</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  numeric_3 <span class="type">char</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  iso_3166_2 text <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  region text,</span><br><span class="line">  sub_region text,</span><br><span class="line">  intermediate_region text,</span><br><span class="line">  region_code <span class="type">char</span>(<span class="number">3</span>),</span><br><span class="line">  sub_region_code <span class="type">char</span>(<span class="number">3</span>),</span><br><span class="line">  intermediate_region_code <span class="type">char</span>(<span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">copy</span> countries (</span><br><span class="line">  name,</span><br><span class="line">  alpha_2,</span><br><span class="line">  alpha_3,</span><br><span class="line">  numeric_3,</span><br><span class="line">  iso_3166_2,</span><br><span class="line">  region,</span><br><span class="line">  sub_region,</span><br><span class="line">  intermediate_region,</span><br><span class="line">  region_code,</span><br><span class="line">  sub_region_code,</span><br><span class="line">  intermediate_region_code</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> <span class="string">&#x27;/var/lib/pgsql/data/countries.csv&#x27;</span></span><br><span class="line">delimiter <span class="string">&#x27;,&#x27;</span> csv header;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check that the data got loaded into the table ok.</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> countries limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Should say 249.</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> countries;</span><br></pre></td></tr></table></figure>

<p>使用golang写一个简单的app，查询countries数据，到这里完成!</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/jackc/pgx/v5&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	conn, err := pgx.Connect(ctx, <span class="string">&quot;postgres://postgres:your_password@192.168.33.10:5432/blogdb?sslmode=disable&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close(ctx)</span><br><span class="line"></span><br><span class="line">	rows, err := conn.Query(ctx, <span class="string">&quot;SELECT id, name FROM countries LIMIT 10&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		<span class="keyword">var</span> id <span class="type">int</span></span><br><span class="line">		<span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">		err = rows.Scan(&amp;id, &amp;name)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(id, <span class="string">&quot;-&quot;</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="开启ssl"><a href="#开启ssl" class="headerlink" title="开启ssl"></a>开启ssl</h3><p>如果想要在本地提前体验ssl加密配置的过程，那么按照下面的流程，先生成self-signed证书、私钥，最后修改配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入数据存储目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/pgsql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成self-signed ssl相关证书、私钥</span></span><br><span class="line">openssl req -new -x509 -days 365 -nodes -text -out server.crt \</span><br><span class="line">  -keyout server.key -subj <span class="string">&quot;/CN=dbhost.yourdomain.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除other、group的访问权限</span></span><br><span class="line"><span class="built_in">chmod</span> og-rwx server.key</span><br></pre></td></tr></table></figure>

<p>修改<code>postgresql.conf</code>文件，取消下面三行注释，需要保证证书放置在data目录，生产环境如果使用授权ca证书，修改的命令就不是ssl_cert_file以及ssl_key_file，按官网描述修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssl = on</span><br><span class="line">ssl_cert_file = &#x27;server.crt&#x27;</span><br><span class="line">ssl_key_file = &#x27;server.key&#x27;</span><br></pre></td></tr></table></figure>

<p>最后，demo里dsn移除<code>sslmode=disable</code>，然后重新运行验证</p>
]]></content>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - Part 3</title>
    <url>/php-extension-writing-part3/</url>
    <content><![CDATA[<p>本文将简单介绍资源类型、资源的创建、访问、销毁操作。不再建议使用资源类型，使用类更为合适</p>
<h2 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h2><p><code>zval</code>可以表示大部分的PHP数据类型，但有一样不能很好的表示其结构：指针。由于不透明的结构、无法使用传统运算符进行操作等，使得指针在PHP的表示变得困难。因此PHP用一个特殊的标记表示指针：资源，为了使资源标记具有意义，必须先注册到zend engine才能使用。</p>
<p>在头文件定义结构体<code>php_test_person</code>以及资源名称，放置在<code>#define</code>语句后，<code>PHP_MINIT_FUNCTION(test);</code>之前</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    zend_string *name;</span><br><span class="line">    zend_long age;</span><br><span class="line">&#125; php_test_person;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHP_TEST_PERSON_RES_NAME <span class="string">&quot;Person Data&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>源文件定义<code>le_*</code>全局变量，MINIT阶段注册，用于获取资源类型、字面意义名称、析构函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> le_test_person;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    le_test_person = zend_register_list_destructors_ex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="初始化资源"><a href="#初始化资源" class="headerlink" title="初始化资源"></a>初始化资源</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_new)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person * person;</span><br><span class="line">    zend_string * name;</span><br><span class="line">    zend_long age;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name);</span><br><span class="line">        Z_PARAM_LONG(age);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_WARNING, <span class="string">&quot;Nonsense age (%ld) given, person resource not created.&quot;</span>, age);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    person = emalloc(<span class="keyword">sizeof</span>(php_test_person));</span><br><span class="line">    person-&gt;name = zend_string_copy(name); <span class="comment">// estrndup + zend_string =&gt; zend_string_copy</span></span><br><span class="line">    person-&gt;age = age;</span><br><span class="line"></span><br><span class="line">    RETURN_RES(zend_register_resource(person, le_test_person));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数接收参数name以及age，参数进行校验通过后，申请一段内存空间并写入数据，<code>return_value</code>返回该资源。PHP不需要知道资源的具体内部表示，只需要获取该资源存储的指针以及资源类型</p>
<h2 id="函数接收资源参数"><a href="#函数接收资源参数" class="headerlink" title="函数接收资源参数"></a>函数接收资源参数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_greet)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person *person;</span><br><span class="line">    zval *zperson;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_RESOURCE(zperson);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    person = (php_test_person *) zend_fetch_resource_ex(zperson, PHP_TEST_PERSON_RES_NAME, le_test_person);</span><br><span class="line"></span><br><span class="line">    php_printf(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">    PHPWRITE(ZSTR_VAL(person-&gt;name), ZSTR_LEN(person-&gt;name));</span><br><span class="line">    php_printf(<span class="string">&quot;!\nAccording to my records, you are %ld years old.\n&quot;</span>, person-&gt;age);</span><br><span class="line"></span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ZEND_FETCH_RESOURCE</code>在PHP7中已被删除，目前获取资源的函数是<code>zend_fetch_resource</code>、<code>zend_fetch_resource_ex</code>。<code>zend_fetch_resource_ex</code>函数需要一个zval、字面意义名称、资源类型，返回一个指针。函数内部切记不要<code>free</code>该指针</p>
<h2 id="销毁资源"><a href="#销毁资源" class="headerlink" title="销毁资源"></a>销毁资源</h2><p>在PHP中使用<code>fopen</code>打开文件并获得一个资源句柄<code>$fp</code>，接下来<code>unset($fp)</code>时文件被关闭，即使没有使用<code>fclose</code>函数。其中的奥秘在<code>zend_register_list_destructors_ex</code>，该函数第一个参数为常规资源的析构函数，第二个为持久化资源的析构函数，当离开资源变量所在作用域时，自动调用清理&#x2F;析构函数，释放内存、关闭连接或执行其他清理操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">le_test_person = zend_register_list_destructors_ex(php_test_person_dtor, <span class="literal">NULL</span>, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_person_dtor</span><span class="params">(zend_resource *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_test_person *person = (php_test_person *) res-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (person) &#123;</span><br><span class="line">        <span class="keyword">if</span> (person-&gt;name) &#123;</span><br><span class="line">            zend_string_release(person-&gt;name); <span class="comment">// efree zend_string =&gt; zend_string_release</span></span><br><span class="line">        &#125;</span><br><span class="line">        efree(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强制销毁资源"><a href="#强制销毁资源" class="headerlink" title="强制销毁资源"></a>强制销毁资源</h2><p>使用<code>zend_list_delete</code>销毁资源，该函数可销毁任何资源类型变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_delete)</span><br><span class="line">&#123;</span><br><span class="line">    zval * zperson;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_RESOURCE(zperson);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    zend_list_delete(Z_RES_P(zperson));</span><br><span class="line"></span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="持久化资源"><a href="#持久化资源" class="headerlink" title="持久化资源"></a>持久化资源</h2><p>持久化资源与常规资源不同的地方在析构函数声明注册的位置，数据内存申请使用<code>pemalloc</code>代替<code>emalloc</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> le_test_person_persist;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    le_test_person = zend_register_list_destructors_ex(php_test_person_dtor, <span class="literal">NULL</span>, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line">    le_test_person_persist = zend_register_list_destructors_ex(<span class="literal">NULL</span>, php_test_person_persist_dtor, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，<code>php_test_person_dtor</code>会在请求结束后调用，<code>php_test_person_persist_dtor</code>在扩展shutdown阶段调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_person_persist_dtor</span><span class="params">(zend_resource *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_test_person *person = (php_test_person *) res-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (person) &#123;</span><br><span class="line">        <span class="keyword">if</span> (person-&gt;name) &#123;</span><br><span class="line">            zend_string_release(person-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">        pefree(person, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_pnew)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person * person;</span><br><span class="line">    zend_string * name;</span><br><span class="line">    zend_long age;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name);</span><br><span class="line">        Z_PARAM_LONG(age);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_WARNING, <span class="string">&quot;Nonsense age (%ld) given, person resource not created.&quot;</span>, age);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    person = pemalloc(<span class="keyword">sizeof</span>(php_test_person), <span class="number">1</span>);</span><br><span class="line">    person-&gt;name = zend_string_dup(name, <span class="number">1</span>);</span><br><span class="line">    person-&gt;age = age;</span><br><span class="line"></span><br><span class="line">    RETURN_RES(zend_register_resource(person, le_test_person_persist));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>test_person_pnew</code>与<code>test_person_new</code>仅在数据初始化、资源类型方面有差异</p>
<h2 id="查找已存在的持久化资源"><a href="#查找已存在的持久化资源" class="headerlink" title="查找已存在的持久化资源"></a>查找已存在的持久化资源</h2><p>为了可以重用持久化资源，需要将其保存在一个安全的地方，zend engine提供了一个executor global通过<code>EG(persistent_list)</code>访问，该变量类型为<code>HashTable</code></p>
<p>重新修改t<code>est_person_pnew</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_pnew2)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person * person;</span><br><span class="line">    <span class="type">char</span> * key_raw;</span><br><span class="line">    <span class="type">size_t</span> key_len;</span><br><span class="line">    zend_string * name, * key;</span><br><span class="line">    zend_long age;</span><br><span class="line">    zval * zperson = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name);</span><br><span class="line">        Z_PARAM_LONG(age);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_WARNING, <span class="string">&quot;Nonsense age (%ld) given, person resource not created.&quot;</span>, age);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key_len = spprintf(&amp;key_raw, <span class="number">0</span>, <span class="string">&quot;test_person_%s_%ld\n&quot;</span>, ZSTR_VAL(name), age);</span><br><span class="line">    key = zend_string_init(key_raw, key_len, <span class="number">1</span>);</span><br><span class="line">    efree(key_raw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((zperson = zend_hash_find(&amp;EG(persistent_list), key)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        person = (php_test_person *) zend_fetch_resource_ex(zperson, PHP_TEST_PERSON_RES_NAME, le_test_person_persist);</span><br><span class="line"></span><br><span class="line">        ZVAL_RES(return_value, zend_register_persistent_resource_ex(key, person, le_test_person_persist));</span><br><span class="line">        zend_string_release(key);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    person = pemalloc(<span class="keyword">sizeof</span>(php_test_person), <span class="number">1</span>);</span><br><span class="line">    person-&gt;name = zend_string_copy(name);</span><br><span class="line">    person-&gt;age = age;</span><br><span class="line"></span><br><span class="line">    ZVAL_RES(return_value, zend_register_persistent_resource_ex(key, person, le_test_person_persist));</span><br><span class="line">    zend_string_release(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>test_person_pnew2</code>先确定<code>EG(persistent_list)</code>是否已经存在，已存在则直接使用，不存在则申请内存初始化资源</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><del><a href="https://devzone.zend.com/446/extension-writing-part-iii-resources/">Extension Writing Part III: Resources</a></del><br><a href="https://github.com/bigbes/bigbes.github.io/wiki/Extension-Writing-Part-III:-Resources">Extension Writing Part III: Resources</a><br><a href="https://wiki.php.net/phpng-upgrading">Upgrading PHP extensions from PHP5 to NG</a><br><a href="http://www.phpinternalsbook.com/">PHP Internals Book</a><br><a href="https://wiki.php.net/internals/references">References about Maintaining and Extending PHP</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
      </tags>
  </entry>
  <entry>
    <title>swift模板移除头部注释</title>
    <url>/swift-file-template-remove-header-comment/</url>
    <content><![CDATA[<p>记录下如何移除swift文件的头部注释</p>
<p><strong>注意，zsh要在空格处添加反斜杠 \，否则无法生成正确的文件路径</strong></p>
<h2 id="清空模板注释内容（可选）"><a href="#清空模板注释内容（可选）" class="headerlink" title="清空模板注释内容（可选）"></a>清空模板注释内容（可选）</h2><p><strong>以下操作可以先备份文件</strong></p>
<p>修改<code>IDETemplateMacros.plist</code>文件，移除注释内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/Library/Developer/Xcode/UserData/IDETemplateMacros.plist</span><br></pre></td></tr></table></figure>

<p>找到<code>FILEHEADER</code>，将string的内容清空</p>
<h2 id="Swift-File"><a href="#Swift-File" class="headerlink" title="Swift File"></a>Swift File</h2><p>进入Xcode目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Library/Developer/Xcode/</span><br></pre></td></tr></table></figure>

<p>添加模板<code>No Comment Swift File.xctemplate</code>，该模板会展示在Xcode的文件目录列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p Templates/File Templates/MultiPlatform/Source/No Comment Swift File.xctemplate</span><br></pre></td></tr></table></figure>

<p>进入模板目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Templates/File Templates/MultiPlatform/Source/No Comment Swift File.xctemplate</span><br></pre></td></tr></table></figure>

<p>复制原swift file模板数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/MultiPlatform/Source/Swift File.xctemplate/* ./</span><br></pre></td></tr></table></figure>

<p>修改<code>___FILEBASENAME___.swift</code>，将第一行头部注释部分移除</p>
<span id="more"></span>

<h2 id="SwiftUI-View"><a href="#SwiftUI-View" class="headerlink" title="SwiftUI View"></a>SwiftUI View</h2><p>同上，进入Xcode目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Library/Developer/Xcode</span><br></pre></td></tr></table></figure>

<p>添加模板<code>No Comment SwiftUI View.xctemplate</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p Templates/File Templates/MultiPlatform/User Interface/No Comment SwiftUI View.xctemplate</span><br></pre></td></tr></table></figure>

<p>进入模板目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Templates/File Templates/MultiPlatform/User Interface/No Comment SwiftUI View.xctemplate</span><br></pre></td></tr></table></figure>

<p>复制原swiftui view模板数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/MultiPlatform/User Interface/SwiftUI View.xctemplate/* ./</span><br></pre></td></tr></table></figure>

<p>修改<code>___FILEBASENAME___.swift</code>，将第一行头部注释部分移除</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>重启Xcode（不是关闭打开xcode窗口，而是重启），cmd+N查看模板列表，完成！</p>
]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - 类</title>
    <url>/php-extension-writing-classes/</url>
    <content><![CDATA[<p>以下简单介绍如何在C语言层面使用PHP类</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>创建一个PHP对象，对象类似关联数组，对象之上可关联任意多个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(makeObject) &#123;</span><br><span class="line">    object_init(return_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加属性</span></span><br><span class="line">    zend_update_property_string(<span class="literal">NULL</span>, return_value, <span class="string">&quot;prop1&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;prop1&quot;</span>), <span class="string">&quot;val1&quot;</span>);</span><br><span class="line">    zend_update_property_long(<span class="literal">NULL</span>, return_value, <span class="string">&quot;prop2&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;prop2&quot;</span>), <span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数并打印结果<code>var_dump(makeObject());</code>，输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">object(stdClass)#1 (2) &#123;</span><br><span class="line">    [<span class="string">&quot;prop1&quot;</span>]=&gt;</span><br><span class="line">    string(3) <span class="string">&quot;val1&quot;</span></span><br><span class="line">    [<span class="string">&quot;prop2&quot;</span>]=&gt;</span><br><span class="line">    int(123)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>创建一个类模板</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class定义存储于zend_class_entry</span></span><br><span class="line">zend_class_entry *test_ce_myclass;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_methods[] = &#123;</span><br><span class="line">    <span class="comment">// 类方法使用宏指令PHP_ME</span></span><br><span class="line">    <span class="comment">// public function hello()</span></span><br><span class="line">    PHP_ME(MyClass, hello, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC)</span><br><span class="line">    <span class="comment">// 与函数定义相同</span></span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主菜，注册并加载类</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_init_myclass</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    zend_class_entry ce;</span><br><span class="line">    INIT_CLASS_ENTRY(ce, <span class="string">&quot;MyClass&quot;</span>, test_methods);</span><br><span class="line">    <span class="comment">// 注册MyClass类</span></span><br><span class="line">    test_ce_myclass = zend_register_internal_class(&amp;ce);</span><br><span class="line">    <span class="comment">// 添加属性/常量等</span></span><br><span class="line">    <span class="comment">// public $success = true;</span></span><br><span class="line">    zend_declare_property_bool(test_ce_myclass, <span class="string">&quot;success&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;success&quot;</span>)<span class="number">-1</span>, <span class="number">1</span>, ZEND_ACC_PUBLIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法hello</span></span><br><span class="line">PHP_METHOD(MyClass, hello)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_STRING(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，函数<code>test_init_myclass</code>的最后一个参数<code>ZEND_ACC_PUBLIC</code>为访问控制标记之一公共访问，常用的访问控制标记还有以下几个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZEND_ACC_STATIC</span><br><span class="line">ZEND_ACC_PUBLIC</span><br><span class="line">ZEND_ACC_PROTECTED</span><br><span class="line">ZEND_ACC_PRIVATE</span><br><span class="line">ZEND_ACC_CTOR</span><br><span class="line">ZEND_ACC_DTOR</span><br><span class="line">ZEND_ACC_DEPRECATED</span><br></pre></td></tr></table></figure>

<p>一个class定义注册相关逻辑已经完成，要在PHP中使用类MyClass还需要在模块初始化<code>MINIT</code>中添加运行<code>test_init_myclass</code>以加载类MyClass</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    test_init_myclass();</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译<code>test</code>模块并开启后，运行<code>var_dump(new MyClass());</code>，将得到以下类似输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">object(MyClass)#1 (1) &#123;</span><br><span class="line">    [<span class="string">&quot;success&quot;</span>]=&gt;</span><br><span class="line">    bool(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以直接在C层面初始化并生成一个实例化类对象，增加一个工厂方法<code>factory</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_methods[] = &#123;</span><br><span class="line">    PHP_ME(MyClass, hello, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC)</span><br><span class="line">    PHP_ME(MyClass, factory, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)</span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PHP_METHOD(MyClass, factory)</span><br><span class="line">&#123;</span><br><span class="line">    object_init_ex(return_value, test_ce_myclass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们可以使用<code>MyClass::factory()</code>获取一个新的MyClass对象</p>
<p>如果需要对MyClass进行一些操作，像在PHP使用构造方法，在test_methods里添加<code>__construct</code>，如此，PHP在<code>new MyClass()</code>将自动调用构造方法<code>__construct</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_methods[] = &#123;</span><br><span class="line">    <span class="comment">// ZEND_ACC_CTOR</span></span><br><span class="line">    PHP_ME(MyClass, __construct, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)</span><br><span class="line">    PHP_ME(MyClass, hello, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC)</span><br><span class="line">    PHP_ME(MyClass, factory, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)</span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PHP_METHOD(MyClass, __construct)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h2><p>上面，虽然对象在new时会自动调用<code>__construct</code>函数进行初始化，但<code>factory</code>不会自动调用构造函数，仅返回包含默认值的新对象，为此，我们需要在<code>factory</code>内调用构造方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zend_interfaces.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">PHP_METHOD(MyClass, factory)</span><br><span class="line">&#123;</span><br><span class="line">    zval *myzval;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ZVAL(myzval)</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    object_init_ex(return_value, test_ce_myclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zend_call_method，其他的还有</span></span><br><span class="line">    <span class="comment">// zend_call_method_with_0_params</span></span><br><span class="line">    <span class="comment">// zend_call_method_with_1_params</span></span><br><span class="line">    <span class="comment">// zend_call_method_with_2_params</span></span><br><span class="line">    <span class="comment">// ZEND_API zval* zend_call_method(zval *object_pp, zend_class_entry *obj_ce, zend_function **fn_proxy, const char *function_name, size_t function_name_len, zval *retval, int param_count, zval* arg1, zval* arg2);</span></span><br><span class="line">    zend_call_method(return_value, test_ce_myclass, <span class="literal">NULL</span>, <span class="string">&quot;__construct&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;__construct&quot;</span>)<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">1</span>, myzval, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>先前我们已经了解函数返回值<code>return_value</code>的使用，现在，我们来看如何在方法内访问<code>$this</code>，PHP提供<code>getThis()</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_METHOD(MyClass, __construct)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *msg;</span><br><span class="line">    <span class="type">size_t</span> msg_len;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_STRING(msg, msg_len)</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    zend_update_property_string(test_ce_myclass, getThis(), <span class="string">&quot;msg&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;msg&quot;</span>)<span class="number">-1</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关联结构体"><a href="#关联结构体" class="headerlink" title="关联结构体"></a>关联结构体</h2><p>我们构建一个结构体，这个结构体在PHP是无法访问的，但可以在扩展内访问对该结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还不是特别了解</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">test_struct</span> &#123;</span></span><br><span class="line">    zend_object <span class="built_in">std</span>;</span><br><span class="line">    <span class="type">int</span> unknown_id;</span><br><span class="line">    <span class="type">char</span> *unknown_str;</span><br><span class="line">&#125; test_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_object *<span class="title function_">create_test_struct</span><span class="params">(zend_class_entry *class_type)</span> &#123;</span><br><span class="line">    test_struct *intern;</span><br><span class="line"></span><br><span class="line">    intern = ecalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(test_struct) + zend_object_properties_size(class_type));</span><br><span class="line"></span><br><span class="line">    zend_object_std_init(&amp;intern-&gt;<span class="built_in">std</span>, class_type);</span><br><span class="line">    object_properties_init(&amp;intern-&gt;<span class="built_in">std</span>, class_type);</span><br><span class="line"></span><br><span class="line">    intern-&gt;<span class="built_in">std</span>.handlers = zend_get_std_object_handlers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;intern-&gt;<span class="built_in">std</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_test_struct</span><span class="params">(<span class="type">void</span> *object)</span> &#123;</span><br><span class="line">    test_struct *secrets = (test_struct*)object;</span><br><span class="line">    <span class="keyword">if</span> (secrets-&gt;unknown_str) &#123;</span><br><span class="line">        efree(secrets-&gt;unknown_str);</span><br><span class="line">    &#125;</span><br><span class="line">    efree(secrets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问结构体<code>test_struct</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_METHOD(MyClass, attachStruct) &#123;</span><br><span class="line">    test_struct *secrets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    secrets = (test_struct*)getThis();</span><br><span class="line"></span><br><span class="line">    RETURN_LONG(secrets-&gt;unknown_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>PHP的异常继承自<code>Exception</code>，所以下面除了新增一个异常类，还涉及了类的继承</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zend_exceptions.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">zend_class_entry *test_ce_exception;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_init_exception</span><span class="params">()</span> &#123;</span><br><span class="line">    zend_class_entry ce;</span><br><span class="line">    <span class="comment">// 设置第三个参数为NULL，继承Exception所有方法，无自定义行为</span></span><br><span class="line">    INIT_CLASS_ENTRY(ce, <span class="string">&quot;MyException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    test_ce_exception = zend_register_internal_class_ex(&amp;ce, (zend_class_entry*)zend_exception_get_default());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    test_init_myclass();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    test_init_exception();</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法&#x2F;函数中抛出异常</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_METHOD(MyClass, throwExcept) &#123;</span><br><span class="line">    zend_throw_exception(test_ce_exception, <span class="string">&quot;custom exception throw&quot;</span>, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/Y2k38/php_ext_tutorial">php_ext_tutorial</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/bigbes/bigbes.github.io/wiki/PHP-Extensions-Made-Eldrich:-Classes">PHP Extensions Made Eldrich: Classes</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
      </tags>
  </entry>
  <entry>
    <title>如何配置wireguard服务端及客户端</title>
    <url>/how-to-setup-wireguard-vpn-server/</url>
    <content><![CDATA[<p>从19年开始，ss流量已经能被gfw识别并屏蔽，原本打算切换到v2ray，但配置混淆需要域名反而会暴露出更多信息，此外，网上一篇文章指出v2ray开发者失联的同时一项v2ray流量识别的专利被注册，因此决定放弃v2ray并转向另一个被linus盛赞的wireguard。</p>
<p>wireguard是非常简单、现代化、快速的vpn，使用最新的加密技术，udp传输，支持ip漫游等。wireguard没有服务端、客户端的区分，每一台设备都是一个<code>peer</code>。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>添加wireguard的PPA源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:wireguard/wireguard</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install wireguard</span><br></pre></td></tr></table></figure>

<p>wireguard作为linux内核模块方式加载，内核更新wireguard也会自动重新编译，重启系统或使用<code>modprobe</code>开启模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe wireguard</span><br></pre></td></tr></table></figure>

<p>检查wireguard模块是否成功加载，成功输出与下面类似</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant@bionic:~$ lsmod | grep wireguard</span><br><span class="line">wireguard             221184  0</span><br><span class="line">ip6_udp_tunnel         16384  1 wireguard</span><br><span class="line">udp_tunnel             16384  1 wireguard</span><br></pre></td></tr></table></figure>

<h2 id="生成keys"><a href="#生成keys" class="headerlink" title="生成keys"></a>生成keys</h2><p>wireguard提供了两个命令行工具<code>wg</code>以及<code>wg-quick</code>，使用<code>wg</code>生成公钥和私钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> 077</span><br><span class="line">wg genkey | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/wireguard/privatekey | wg pubkey | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/wireguard/publickey</span><br></pre></td></tr></table></figure>

<p>类似ssh，需要为每台设备生成一对publickey&#x2F;privatekey</p>
<span id="more"></span>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>我们需要生成一个虚拟网卡，名称可以按个人喜好选择，这里选择用<code>wg0</code>，IP网段使用<code>10.10.0.1/24</code>，确保该网段没有被你的家庭或公司网络使用，编辑文件<code>/etc/wireguard/wg0.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">PrivateKey = &lt;your server private key here&gt;</span><br><span class="line">Address = 10.10.0.1/24</span><br><span class="line">Address = fd86:ea04:1111::1/64</span><br><span class="line">SaveConfig = true</span><br><span class="line">PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE; ip6tables -A FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o enp0s3 -j MASQUERADE; ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o enp0s3 -j MASQUERADE</span><br><span class="line">ListenPort = 51820</span><br></pre></td></tr></table></figure>

<p><code>PrivateKey</code>填上一步生成的私钥，填入你选择的<code>Address</code>，这里配置了两个IP4&#x2F;6的地址，<code>enp0s3</code>是你服务器主要的网络设备，使用<code>ifconfig</code>或<code>ip a</code>查看你的主设备名，<code>ListenPort</code>默认为51820，建议修改</p>
<p>要注意的是<code>SaveConfig</code>设置，wireguard配置后不需要<code>restart</code>或<code>reload</code>，使用<code>wg</code>命令添加<code>peer</code>即可立即生效。但是，这些操作都是直接写入到内存中而不是磁盘，因此如果你重启系统或服务，那么你就会失去添加的配置，所以这里设置为<code>true</code>，自动保存配置。但这个配置有时候也会让人非常困扰，你可能添加配置后重启服务，然后你发现添加的配置不见了，需要先停止服务再添加配置最后重启。</p>
<p>添加网络配置，使得内核可以正确路由我们的NAT流量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&#x27;cat &lt;&lt; EOF &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward=1</span></span><br><span class="line"><span class="string">net.ipv6.conf.all.forwarding=1</span></span><br><span class="line"><span class="string">EOF&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl -p</span><br></pre></td></tr></table></figure>

<p>运行命令，开启wg0设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wg-quick up wg0</span><br></pre></td></tr></table></figure>

<p>如果一切顺利，那么运行下面命令你将看到类似的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant@bionic:~$ <span class="built_in">sudo</span> wg</span><br><span class="line">interface: wg0</span><br><span class="line">  public key: Td4IBZg2s2bMSjewD0h4oBhlbaJteygxjT83xeM7uTY=</span><br><span class="line">  private key: (hidden)</span><br><span class="line">  listening port: 51820</span><br></pre></td></tr></table></figure>

<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>客户端配置与服务端类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">Address = 10.10.0.2/32</span><br><span class="line">Address = fd86:ea04:1111::2/128</span><br><span class="line">SaveConfig = true</span><br><span class="line">PrivateKey = &lt;your client private key here&gt;</span><br><span class="line">DNS = 8.8.8.8</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = &lt;your server public key here&gt;</span><br><span class="line">Endpoint = &lt;your server public ip&gt;:51820</span><br><span class="line">AllowedIPs = 0.0.0.0/0, ::/0</span><br></pre></td></tr></table></figure>

<p>填写服务器的publickey、ip、端口，配置<code>0.0.0.0/0, ::/0</code>将所有流量传输到服务端</p>
<p>在服务端添加客户端配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wg <span class="built_in">set</span> wg0 peer &lt;client-public-key&gt; allowed-ips 10.10.0.2/32,fd86:ea04:1111::2/128</span><br></pre></td></tr></table></figure>

<p>以上的操作针对的是linux系统，官方推出了可用的iOS&#x2F;MacOS&#x2F;Android&#x2F;Windows图形界面软件，其中有一个选项要注意的是<code>On-Demand</code>，有<code>Ethernet</code>和<code>Wi-Fi</code>选项，如果勾选，那么会在选中网络中会自动开启vpn</p>
<h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><p>如果你的系统使用systemd,如ubuntu，设置wireguard开机启动命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> wg-quick@wg0</span><br></pre></td></tr></table></figure>

<h2 id="开放防火墙"><a href="#开放防火墙" class="headerlink" title="开放防火墙"></a>开放防火墙</h2><h3 id="UFW"><a href="#UFW" class="headerlink" title="UFW"></a>UFW</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 51820/udp</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.wireguard.com/">WireGuard: fast, modern, secure VPN tunnel</a><br><a href="https://securityespresso.org/tutorials/2019/03/22/vpn-server-using-wireguard-on-ubuntu/">How to setup your own VPN server using WireGuard on Ubuntu</a><br><a href="https://medium.com/@aveek/setting-up-pihole-wireguard-vpn-server-and-client-ubuntu-server-fc88f3f38a0a">Setting Up PiHole, Wireguard VPN server and Client (Ubuntu Server)</a></p>
]]></content>
      <tags>
        <tag>wireguard</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL与PostgreSQL的使用区别</title>
    <url>/the-difference-between-mysql-and-postgresql-for-web-developer/</url>
    <content><![CDATA[<p>以<code>MySQL 9</code>以及<code>PostgreSQL 17</code>为例，从Web开发者的角度出发，列举两个数据库在使用方面的差异，仅介绍与CRUD依赖的操作，存储过程&#x2F;主从复制暂不介绍</p>
<h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h3 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h3><p><code>MySQL</code>创建管理员账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建mydb_admin管理员账户</span></span><br><span class="line"><span class="comment">-- 格式：`CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED WITH authentication_plugin BY &#x27;password&#x27;;`</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;mydb_admin&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> caching_sha2_password <span class="keyword">BY</span> <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 授权数据库/表访问权限</span></span><br><span class="line"><span class="comment">-- 格式：`GRANT PRIVILEGE ON database.table TO &#x27;username&#x27;@&#x27;host&#x27;;`</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;mydb_admin&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 如果不清楚有哪些权限，执行</span></span><br><span class="line"><span class="comment">-- SHOW PRIVILEGES;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 立即生效</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 查看账户列表核对</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.user;</span><br><span class="line"><span class="comment">-- SELECT * FROM mysql.user WHERE User=&#x27;mydb_admin&#x27; AND Host=&#x27;%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.查看账户授权</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;mydb_admin&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>创建管理员账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建mydb_admin管理员账户</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE mydb_admin LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 授权数据库/表访问权限（需要多条语句）</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="comment">-- 如果不想让账号访问其他db</span></span><br><span class="line"><span class="comment">-- REVOKE CONNECT ON DATABASE otherdb1 FROM PUBLIC;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 所有跟public相关的授权都需要先切换到指定数据库</span></span><br><span class="line">\c mydb</span><br><span class="line"><span class="comment">-- 授权public</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="comment">-- 后续所有变更自动授权（由super admin执行）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> SEQUENCES <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> FUNCTIONS <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 删除角色</span></span><br><span class="line"><span class="comment">-- DROP OWNED BY mydb_admin;</span></span><br><span class="line"><span class="comment">-- DROP ROLE mydb_admin;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>注意</strong></p>
<p><code>MySQL</code>通过上面配置即可对外提供访问，<code>PostgreSQL</code>还需要配置<code>pg_hba.conf</code>，此外，如果删除后重建mydb，需要重新授权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class="line"># host  all             all             0.0.0.0/32              scram-sha-256</span><br><span class="line">host    mydb mydb_admin 0.0.0.0/32 scram-sha-256</span><br><span class="line"># hostssl mydb mydb_admin 0.0.0.0/32 scram-sha-256</span><br></pre></td></tr></table></figure>

<h3 id="Web读写"><a href="#Web读写" class="headerlink" title="Web读写"></a>Web读写</h3><p><code>MySQL</code>创建CRUD账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建读写账户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;mydb_write&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> caching_sha2_password <span class="keyword">BY</span> <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;mydb_write&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建只读账户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;mydb_read&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> caching_sha2_password <span class="keyword">BY</span> <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;mydb_read&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>创建CRUD账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建读写账户</span></span><br><span class="line"><span class="comment">-- 创建角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE mydb_write_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色授权，只能连接mydb</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CONNECT</span> <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"><span class="comment">-- 所有跟public相关的授权都需要先切换到指定数据库</span></span><br><span class="line">\c mydb;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"><span class="comment">-- 后续所有变更自动授权（由super admin以及mydb_admin执行）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户并关联角色</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> mydb_write_user <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> mydb_write_role <span class="keyword">TO</span> mydb_write_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建只读账户</span></span><br><span class="line"><span class="comment">-- 创建角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE mydb_read_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CONNECT</span> <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"><span class="comment">-- 所有跟public相关的授权都需要先切换到指定数据库</span></span><br><span class="line">\c mydb;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"><span class="comment">-- 后续所有变更自动授权（由super admin以及mydb_admin执行）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户并关联角色</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> mydb_read_user <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> mydb_read_role <span class="keyword">TO</span> mydb_read_user;</span><br></pre></td></tr></table></figure>

<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h3><p><code>MySQL</code>建库操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 列出所有数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建mydb数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mydb;</span><br><span class="line"><span class="comment">-- 创建并设置charset</span></span><br><span class="line"><span class="comment">-- CREATE DATABASE mydb CHARACTER SET utf8mb4;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看建库sql</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 查看数据库列表核对</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.SCHEMATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 切换到mydb</span></span><br><span class="line">USE mydb;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>建库操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 列出所有数据库</span></span><br><span class="line">\l<span class="operator">+</span></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> datname <span class="keyword">FROM</span> pg_database;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建mydb数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 切换到mydb</span></span><br><span class="line">\c mydb</span><br></pre></td></tr></table></figure>

<h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p><code>MySQL</code>建表操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建数据表</span></span><br><span class="line"><span class="comment">-- 指定innodb、纪录备注、创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main(</span><br><span class="line">  `id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY COMMENT &quot;ID&quot;,</span><br><span class="line">  `order_number` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;order number&quot;,</span><br><span class="line">  `user_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;user id&quot;,</span><br><span class="line">  `product_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;product id&quot;,</span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(`order_number`),</span><br><span class="line">  INDEX `idx_user_id` (`user_id`)</span><br><span class="line">) ENGINE InnoDB <span class="keyword">DEFAULT</span> CHARSET utf8mb4 COMMENT &quot;order main&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单独创建索引示例如下</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX `idx_product_id` <span class="keyword">ON</span> `order_main`(`product_id`);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查看数据表列表核对</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="comment">-- SHOW TABLES LIKE &#x27;%order_main%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看建表语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>建表操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建数据表</span></span><br><span class="line"><span class="comment">-- 与关键字相同的字段需要使用双引号，不支持备注</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main(</span><br><span class="line">  &quot;id&quot; <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  &quot;order_number&quot; <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &quot;user_id&quot; <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &quot;product_id&quot; <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line">  <span class="keyword">UNIQUE</span>(&quot;order_number&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 非pk以及unique索引需要单独创建，名称需要区分数据表</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX &quot;order_main_idx_product_id&quot; <span class="keyword">ON</span> &quot;order_main&quot;(&quot;product_id&quot;);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查看数据表列表核对</span></span><br><span class="line">\dt<span class="operator">+</span></span><br><span class="line"><span class="comment">-- 列出所有数据库表</span></span><br><span class="line"><span class="comment">-- \dt *</span></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_catalog.pg_tables <span class="keyword">WHERE</span> schemaname <span class="operator">!=</span> <span class="string">&#x27;pg_catalog&#x27;</span> <span class="keyword">AND</span> schemaname <span class="operator">!=</span> <span class="string">&#x27;information_schema&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看数据表结构，不支持查看建表sql</span></span><br><span class="line">\d order_main</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="命令行显示优化"><a href="#命令行显示优化" class="headerlink" title="命令行显示优化"></a>命令行显示优化</h3><p><code>MySQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将;改为\G，以扩展模式输出</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main\G</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mysql 所有输出自带命令执行耗时时长，单位：秒</span></span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 当内容长度超过一行自动切换为扩展模式输出</span></span><br><span class="line">\x auto</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出sql命令执行使用的时间，单位：毫秒</span></span><br><span class="line">\timing <span class="keyword">on</span></span><br></pre></td></tr></table></figure>

<h3 id="导入-导出sql"><a href="#导入-导出sql" class="headerlink" title="导入&#x2F;导出sql"></a>导入&#x2F;导出sql</h3><p><code>MySQL</code>如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入</span></span><br><span class="line">mysql -h localhost -u mydb_admin -P 3306 -p mydb &lt; mydb.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出</span></span><br><span class="line">mysqldump -h localhost -u mydb_admin -P 3306 -p mydb album &gt; mydb.album.sql</span><br></pre></td></tr></table></figure>

<p>或者使用sql导入文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 文件需要放在指定目录</span></span><br><span class="line">SOURCE <span class="operator">/</span>tmp<span class="operator">/</span>mydb.album.sql</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入，非if not exists，有数据会报错</span></span><br><span class="line">psql -d mydb -f mydb.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出</span></span><br><span class="line">pg_dump -t public.album mydb &gt; mydb.album.sql</span><br></pre></td></tr></table></figure>

<h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p><code>MySQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看服务器相关配置</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看服务器与buffer_pool相关的配置</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%buffer_pool%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改max_connections</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_connections<span class="operator">=</span><span class="number">1024</span>;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看服务器相关配置</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ALL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看max_connections</span></span><br><span class="line"><span class="keyword">SHOW</span> max_connections;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看服务器以max开头的配置</span></span><br><span class="line"><span class="keyword">SELECT</span> name, setting <span class="keyword">FROM</span> pg_settings <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;max_%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改timezone</span></span><br><span class="line"><span class="keyword">SET</span> timezone<span class="operator">=</span><span class="string">&#x27;Asia/Hong_kong&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p><code>MySQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前活动过进程</span></span><br><span class="line"><span class="keyword">SHOW</span> PROCESSLIST;</span><br><span class="line"><span class="comment">-- SHOW FULL PROCESSLIST;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结束进程</span></span><br><span class="line">KILL _pid_;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前活动过进程</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_stat_activity;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结束进程</span></span><br><span class="line"><span class="keyword">SELECT</span> pg_cancel_backend(_pid_);</span><br><span class="line"><span class="keyword">SELECT</span> pg_terminate_backend(_pid_);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重新加载配置</span></span><br><span class="line"><span class="keyword">SELECT</span> pg_reload_conf();</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>postgresql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次xdebug异常</title>
    <url>/vagrant-xdebug-not-working/</url>
    <content><![CDATA[<p>工欲善其事必先利其器，xdebug是php开发的一个杀手级利器，vagrant是一款非常便捷的虚拟机管理工具，两者搭配有时会出现一些奇怪的问题，近期在重新配置开发环境时，出现xdebug连不上的异常情况，花了些时间才找到问题并解决，记录下解决问题的过程，希望能帮助到一些小伙伴</p>
<h2 id="问题及解决过程"><a href="#问题及解决过程" class="headerlink" title="问题及解决过程"></a>问题及解决过程</h2><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>xdebug配置后，客户端多次请求，vscode均无任何反应。检查服务端、客户端配置，确认没有差错；监测网络数据，只有初次请求数据，无结果返回</p>
<h3 id="客户端-服务器配置信息"><a href="#客户端-服务器配置信息" class="headerlink" title="客户端&#x2F;服务器配置信息"></a>客户端&#x2F;服务器配置信息</h3><p>服务器是vagrant + ubuntu 18.04 + PHP 7.4，客户端是Windows 10，编辑器是vscode</p>
<p>初始xdebug配置如下</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[xdebug]</span></span><br><span class="line"><span class="attr">xdebug.remote_enable</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.remote_autostart</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.remote_port</span> = <span class="number">9001</span></span><br><span class="line"><span class="attr">xdebug.remote_handler</span> = <span class="string">&quot;dbgp&quot;</span></span><br><span class="line"><span class="attr">xdebug.remote_mode</span> = req</span><br><span class="line"><span class="attr">xdebug.remote_connect_back</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.overload_var_dump</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>vscode配置launch.json如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Listen for XDebug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;php&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">9001</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pathMappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;/data/example&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\data\\example&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="开启xdebug日志监测"><a href="#开启xdebug日志监测" class="headerlink" title="开启xdebug日志监测"></a>开启xdebug日志监测</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">xdebug.remote_log</span>=/tmp/xdebug.log</span><br></pre></td></tr></table></figure>

<p>再次请求，获取日志数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[140114918627520] Log opened at 2019-09-04 11:49:00</span><br><span class="line">[140114918627520] I: Checking remote connect back address.</span><br><span class="line">[140114918627520] I: Checking header &#x27;HTTP_X_FORWARDED_FOR&#x27;.</span><br><span class="line">[140114918627520] I: Checking header &#x27;REMOTE_ADDR&#x27;.</span><br><span class="line">[140114918627520] I: Remote address found, connecting to 192.168.33.1:9001.</span><br><span class="line">[140114918627520] E: Time-out connecting to client (Waited: 200 ms). :-(</span><br><span class="line">[140114918627520] Log closed at 2019-09-04 11:49:00</span><br></pre></td></tr></table></figure>

<p>日志显示服务端有正常向客户端9001端口发起连接，但客户端无响应导致超时，检查客户端防火墙无异常</p>
<p>最后，在谷歌上找到一个类似的问题，发现问题与vagrant有关，具体问题描述见参考文档链接</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 移除 xdebug.remote_connect_back = 1</span></span><br><span class="line"><span class="comment">; 添加</span></span><br><span class="line"><span class="attr">xdebug.remote_host</span>=<span class="number">10.0</span>.<span class="number">2.2</span></span><br></pre></td></tr></table></figure>

<p>重启php-fpm，再次测试，vscode可连接xdebug，问题解决</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://danemacmillan.com/how-to-configure-xdebug-in-phpstorm-through-vagrant/">How to configure Xdebug in PhpStorm through Vagrant</a><br><a href="https://stackoverflow.com/questions/24831707/xdebug-time-out-connecting-to-client-using-phpstorm-7-1-3-vagrant-virtualbo">xdebug Time-out connecting to client</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>vagrant</tag>
        <tag>xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title>使用colima作为docker desktop的替代</title>
    <url>/use-colima-as-an-alternative-to-docker-mac/</url>
    <content><![CDATA[<p>简单介绍下macOS当前docker运行环境的最新选择：colima，一个开源产品，使用体验与vagrant类似，感觉非常不错</p>
<h2 id="colima"><a href="#colima" class="headerlink" title="colima"></a>colima</h2><p>根据<a href="https://github.com/abiosoft/colima">colima</a>官方仓库指导安装colima</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install colima</span><br></pre></td></tr></table></figure>

<p>colima默认的runtime是docker，因为k8s已经剥离了docker，只保留containerd，所以为了跟k8s保持一致，另外也不想再多安装一个软件，就选择了只用containerd</p>
<p>但如果你使用了docker compose，那么最好还是根据教程安装docker以及docker-compose</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像并创建vm</span></span><br><span class="line">colima start --cpu 1 --memory 2 --disk 50 --runtime containerd</span><br><span class="line"><span class="comment"># 这里还可以开启kubernetes支持</span></span><br><span class="line"><span class="comment"># colima start --cpu 4 --memory 8 --disk 100 --runtime containerd --kubernetes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看vm列表</span></span><br><span class="line">colima list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接vm</span></span><br><span class="line">colima ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装nerdctl用于支持containerd</span></span><br><span class="line">colima nerdctl install</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="nerdctl"><a href="#nerdctl" class="headerlink" title="nerdctl"></a>nerdctl</h2><p>nerdctl是containerd的非核心命令行管理工具，与docker命令完全兼容，<code>containerd + nerdctl = docker</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看docker镜像列表，相当于docker image ls</span></span><br><span class="line">nerdctl image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">nerdctl pull mysql:9.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建container</span></span><br><span class="line">nerdctl run --name mysql9 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=a123456 -d mysql:9.2 --character-set-server=utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看container列表</span></span><br><span class="line">nerdctl ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接container</span></span><br><span class="line">nerdctl <span class="built_in">exec</span> -it mysql9 bash</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/abiosoft/colima">colima</a><br><a href="https://github.com/containerd/nerdctl">nerdctl</a><br><a href="https://smallsharpsoftwaretools.com/tutorials/use-colima-to-run-docker-containers-on-macos/">Use Colima to Run Docker Containers on macOS</a></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>kubernetes</tag>
        <tag>containerd</tag>
        <tag>nerdctl</tag>
        <tag>macOS</tag>
        <tag>colima</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kubeadm部署k8s集群</title>
    <url>/use-kubeadm-to-deploy-k8s-cluster/</url>
    <content><![CDATA[<p>部署计划：先创建一台虚拟机vm1，安装docker以及k8s组件，然后克隆两台新的vm2&#x2F;vm3，组合成一个小型的k8s集群</p>
<h2 id="虚拟机准备"><a href="#虚拟机准备" class="headerlink" title="虚拟机准备"></a>虚拟机准备</h2><h3 id="创建vm1"><a href="#创建vm1" class="headerlink" title="创建vm1"></a>创建vm1</h3><p>创建虚拟机vm1，以下就不展示繁琐的系统安装过程了</p>
<p><img src="/images/kvm_create_vm1.png" alt="kvm create vm1"></p>
<h3 id="配置vm1"><a href="#配置vm1" class="headerlink" title="配置vm1"></a>配置vm1</h3><p>根据教程：<a href="/deploy-docker-and-registry-service/">安装docker并部署registry服务</a>安装好containerd，再执行下面的配置</p>
<h4 id="系统配置修改"><a href="#系统配置修改" class="headerlink" title="系统配置修改"></a>系统配置修改</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux 模块</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> modprobe overlay</span><br><span class="line"><span class="built_in">sudo</span> modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># lsmod | grep overlay</span></span><br><span class="line"><span class="comment"># lsmod | grep br_netfilter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络配置</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> sysctl --system</span><br><span class="line"></span><br><span class="line"><span class="comment"># sudo sysctl -a | grep net.ipv4.ip_forward</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h4><p>关闭swap并移除文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看swap文件位置</span></span><br><span class="line"><span class="built_in">sudo</span> swapon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭swap</span></span><br><span class="line"><span class="built_in">sudo</span> swapoff /swap.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除swap文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /swap.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动项注释</span></span><br><span class="line"><span class="built_in">sudo</span> vi /etc/fstab</span><br><span class="line"><span class="comment"># 删除或注释下面行</span></span><br><span class="line"><span class="comment">#/swap.img      none    swap    sw      0       0</span></span><br></pre></td></tr></table></figure>

<h4 id="registry证书导入"><a href="#registry证书导入" class="headerlink" title="registry证书导入"></a>registry证书导入</h4><p>私有registry使用self-signed证书，kubeadm拉取时会报错，故将证书添加到vm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 物理机拷贝证书到vm1</span></span><br><span class="line">scp noname.io.crt noname@192.168.122.11:/home/noname/</span><br><span class="line"></span><br><span class="line"><span class="comment"># vm1 复制到系统目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> noname.io.crt /usr/local/share/ca-certificates/</span><br><span class="line"><span class="built_in">sudo</span> update-ca-certificates</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker <span class="comment"># 可选</span></span><br></pre></td></tr></table></figure>

<h4 id="containerd设置"><a href="#containerd设置" class="headerlink" title="containerd设置"></a>containerd设置</h4><p>修改<code>/etc/containerd/config.toml</code>，设置cgroup driver为systemd，同时可以修改pause版本，version是必须的，否则不生效，缩进非必要，可以删除</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="section">[plugins]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span></span><br><span class="line">    <span class="attr">runtime_type</span> = <span class="string">&quot;io.containerd.runc.v2&quot;</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span></span><br><span class="line">      <span class="attr">SystemdCgroup</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span></span><br><span class="line">    <span class="attr">sandbox_image</span> = <span class="string">&quot;registry.noname.io:5000/pause:3.10&quot;</span> <span class="comment"># 默认是3.8，这里可以不修改</span></span><br></pre></td></tr></table></figure>

<p>重启containerd服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>

<p>执行命令输出生效中的配置，验证配置是否跟预期一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd config dump | grep SystemdCgroup</span><br></pre></td></tr></table></figure>

<h4 id="docker配置（可选）"><a href="#docker配置（可选）" class="headerlink" title="docker配置（可选）"></a>docker配置（可选）</h4><p>k8s与docker分手后，vm只需要一个containerd就够了，但如果你同时也安装了docker，也可以修改<code>/etc/docker/daemon.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;exec-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;native.cgroupdriver=systemd&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;registry.noname.io:5000&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启docker服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="镜像准备（可选）"><a href="#镜像准备（可选）" class="headerlink" title="镜像准备（可选）"></a>镜像准备（可选）</h4><p>为了避免kubeadm init长时间卡在镜像拉取上，可以先在物理机上通过proxy拉取到本地，再推送到私有registry，最后配置从私有registry拉取image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># k8s需要的镜像，可以通过kubeadm config images list打印</span></span><br><span class="line">docker pull registry.k8s.io/kube-apiserver:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/kube-controller-manager:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/kube-scheduler:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/kube-proxy:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/coredns/coredns:v1.11.1</span><br><span class="line">docker pull registry.k8s.io/pause:3.10</span><br><span class="line">docker pull registry.k8s.io/etcd:3.5.15-0</span><br><span class="line"><span class="comment"># cilium依赖的镜像</span></span><br><span class="line">docker pull quay.io/cilium/cilium:v1.15.6</span><br><span class="line">docker pull quay.io/cilium/operator-generic:v1.15.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新打tag</span></span><br><span class="line">docker tag registry.k8s.io/kube-apiserver:v1.31.0 registry.noname.io:5000/kube-apiserver:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/kube-controller-manager:v1.31.0 registry.noname.io:5000/kube-controller-manager:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/kube-scheduler:v1.31.0 registry.noname.io:5000/kube-scheduler:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/kube-proxy:v1.31.0 registry.noname.io:5000/kube-proxy:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/coredns/coredns:v1.11.1 registry.noname.io:5000/coredns:v1.11.1</span><br><span class="line">docker tag registry.k8s.io/pause:3.10 registry.noname.io:5000/pause:3.10</span><br><span class="line">docker tag registry.k8s.io/etcd:3.5.15-0 registry.noname.io:5000/etcd:3.5.15-0</span><br><span class="line">docker tag quay.io/cilium/cilium:v1.15.6 registry.noname.io:5000/cilium/cilium:v1.15.6</span><br><span class="line">docker tag quay.io/cilium/operator-generic:v1.15.6 registry.noname.io:5000/cilium/operator-generic:v1.15.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送至私有registry</span></span><br><span class="line">docker push registry.noname.io:5000/kube-apiserver:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/kube-controller-manager:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/kube-scheduler:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/kube-proxy:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/coredns:v1.11.1</span><br><span class="line">docker push registry.noname.io:5000/pause:3.10</span><br><span class="line">docker push registry.noname.io:5000/etcd:3.5.15-0</span><br><span class="line">docker push registry.noname.io:5000/cilium/cilium:v1.15.6</span><br><span class="line">docker push registry.noname.io:5000/cilium/operator-generic:v1.15.6</span><br></pre></td></tr></table></figure>

<p>在虚拟机vm1中使用critool导入镜像，示例如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看containerd镜像</span></span><br><span class="line"><span class="built_in">sudo</span> crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像到containerd</span></span><br><span class="line"><span class="built_in">sudo</span> crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock pull registry.noname.io:5000/quay.io/cilium/operator-generic:v1.15.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新打tag</span></span><br><span class="line"><span class="built_in">sudo</span> ctr --namespace=k8s.io image tag registry.noname.io:5000/quay.io/cilium/operator-generic:v1.15.6 quay.io/cilium/operator-generic:v1.15.6</span><br></pre></td></tr></table></figure>

<h2 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h2><h3 id="apt方式安装（推荐）"><a href="#apt方式安装（推荐）" class="headerlink" title="apt方式安装（推荐）"></a>apt方式安装（推荐）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">sudo</span> apt update -y &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y apt-transport-https ca-certificates curl gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先创建好目录，如果没有的话</span></span><br><span class="line"><span class="comment"># sudo mkdir -p -m 755 /etc/apt/keyrings</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># curl这里需要使用http_proxy/https_proxy</span></span><br><span class="line">curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.31/deb/Release.key | <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认会覆盖已存在的/etc/apt/sources.list.d/kubernetes.list</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.31/deb/ /&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一 安装最新版，同时会安装ebtables cri-tools kubernetes-cni组件</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二 指定版本</span></span><br><span class="line"><span class="comment"># sudo apt install -y kubelet=1.31.0* kubeadm=1.31.0* kubectl=1.31.0*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时检查下xzip ethtool socat conntrack net-tools这几个组件是否安装</span></span><br><span class="line"><span class="comment"># sudo apt install -y xzip ethtool socat conntrack net-tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定版本</span></span><br><span class="line"><span class="built_in">sudo</span> apt-mark hold kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure>

<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p><strong>重点</strong>：<code>/usr/local/bin</code>以及<code>/opt/cni/bin</code>这两个目录树以及所有文件要确保所有者是root，否则会导致部署失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制软件到vm</span></span><br><span class="line"><span class="comment"># cd Downloads/</span></span><br><span class="line">scp kube* kubelet.service 10-kubeadm.conf noname@192.168.122.11:/home/noname/   <span class="comment"># kubernetes相关</span></span><br><span class="line">scp crictl-v1.30.1-linux-amd64.tar.gz noname@192.168.122.11:/home/noname/       <span class="comment"># cri-tools</span></span><br><span class="line">scp cni-plugins-linux-amd64-v1.5.1.tgz noname@192.168.122.11:/home/noname/      <span class="comment"># kubernetes-cni</span></span><br><span class="line">scp cilium-linux-v0.16.13.tar.gz noname@192.168.122.11:/home/noname/            <span class="comment"># cilium</span></span><br><span class="line">scp helm-v3.15.3-linux-amd64.tar.gz noname@192.168.122.11:/home/noname/         <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubernetes-cni</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /opt/cni/bin</span><br><span class="line"><span class="built_in">sudo</span> tar -C /opt/cni/bin -xzf cni-plugins-linux-amd64-v1.5.1.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># cri-tools</span></span><br><span class="line"><span class="built_in">sudo</span> tar -C /usr/local/bin -xzf crictl-v1.31.1-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># cilium</span></span><br><span class="line"><span class="built_in">sudo</span> tar -C /usr/local/bin -xzf cilium-linux-v0.16.13.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># helm</span></span><br><span class="line">tar zxf helm-v3.15.3-linux-amd64.tar.gz &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">mv</span> linux-amd64/helm /usr/local/bin/ &amp;&amp; <span class="built_in">rm</span> -rf linux-amd64/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将kubeadm等组件放置到指定目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> kube* /usr/local/bin/ &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/kube*</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/lib/kubelet</span><br><span class="line"><span class="comment"># 修改配置文件中的bin目录并放置到指定位置</span></span><br><span class="line"><span class="built_in">cat</span> kubelet.service | sed <span class="string">&quot;s:/usr/bin:/usr/local/bin:g&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /usr/lib/systemd/system/kubelet.service</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line"><span class="comment"># 同上</span></span><br><span class="line"><span class="built_in">cat</span> 10-kubeadm.conf | sed <span class="string">&quot;s:/usr/bin:/usr/local/bin:g&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保所有者是root</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R root:root /opt/cni</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R root:root /usr/local/bin</span><br></pre></td></tr></table></figure>

<h2 id="克隆vm1"><a href="#克隆vm1" class="headerlink" title="克隆vm1"></a>克隆vm1</h2><p>以上初步准备安装好了k8s，现在还不能执行初始化部署，复制两个新的vm，避免每台机器都重复执行上面的操作，偷懒</p>
<p>新的vm需要确保跟旧的vm1不能有相同的MAC地址、hostname、product_uuid</p>
<h3 id="hostname重命名"><a href="#hostname重命名" class="headerlink" title="hostname重命名"></a>hostname重命名</h3><p>修改hostname</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> hostnamectl hostname vm1</span><br><span class="line"><span class="comment"># sudo hostnamectl hostname vm2</span></span><br><span class="line"><span class="comment"># sudo hostnamectl hostname vm3</span></span><br></pre></td></tr></table></figure>

<h3 id="重新生成machine-id"><a href="#重新生成machine-id" class="headerlink" title="重新生成machine-id"></a>重新生成machine-id</h3><p>dhcp获取IP时，依赖的是machine-id，如果三台机器的machine-id都一样，你会发现所有vm的IP地址都是一样的，会出现冲突，比如ssh突然断线</p>
<p>先关闭其他机器如vm1，使用同样ssh命令如<code>ssh noname@192.168.122.11</code>连接到新的vm2&#x2F;vm3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要确保/etc/machine-id与/var/lib/dbus/machine-id一致，软连接来的，只要改一个</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/machine-id</span><br><span class="line"><span class="built_in">sudo</span> dbus-uuidgen --ensure=/etc/machine-id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次确认下，确定三台机器的product_uuid都不一样</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/class/dmi/id/product_uuid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启机器</span></span><br><span class="line"><span class="built_in">sudo</span> reboot now</span><br></pre></td></tr></table></figure>

<h3 id="cockpit绑定MAC以及IP"><a href="#cockpit绑定MAC以及IP" class="headerlink" title="cockpit绑定MAC以及IP"></a>cockpit绑定MAC以及IP</h3><p>点击添加【静态主机条目】，绑定mac地址与ip地址，避免重启一次机器就变一次IP</p>
<p><img src="/images/bind_ip_and_mac.png" alt="bind ip and mac"></p>
<h3 id="hosts修改"><a href="#hosts修改" class="headerlink" title="hosts修改"></a>hosts修改</h3><p>往hosts添加三台vm的host映射，移除<code>127.0.0.1 vm1</code>字样的的记录</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">192.168.0.105 registry.noname.io</span><br><span class="line"></span><br><span class="line">192.168.122.11 vm1</span><br><span class="line">192.168.122.126 vm2</span><br><span class="line">192.168.122.235 vm3</span><br></pre></td></tr></table></figure>

<h2 id="部署k8s"><a href="#部署k8s" class="headerlink" title="部署k8s"></a>部署k8s</h2><p>好了，到这里就可以开始使用kubeadm初始化部署k8s集群了</p>
<h3 id="执行kubeadm-init"><a href="#执行kubeadm-init" class="headerlink" title="执行kubeadm init"></a>执行kubeadm init</h3><p>方法一，直接运行下面命令，比较适合简单的集群配置，不涉及太多配置修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm init --skip-phases addon/kube-proxy --apiserver-advertise-address 192.168.122.11 --node-name vm1 --image-repository registry.noname.io:5000</span><br></pre></td></tr></table></figure>

<p>方法二，通过命令导出默认配置内容，修改相关配置，最后指定config文件运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导出默认配置</span></span><br><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm_config.yaml</span><br></pre></td></tr></table></figure>

<p>把advertiseAddress、name、skipPhases、imageRepository等需要修改的地方全改了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">bootstrapTokens:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">system:bootstrappers:kubeadm:default-node-token</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">abcdef.0123456789abcdef</span></span><br><span class="line">  <span class="attr">ttl:</span> <span class="string">24h0m0s</span></span><br><span class="line">  <span class="attr">usages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">signing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">authentication</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line">  <span class="attr">advertiseAddress:</span> <span class="number">192.168</span><span class="number">.122</span><span class="number">.11</span></span><br><span class="line">  <span class="attr">bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line">  <span class="attr">criSocket:</span> <span class="string">unix:///var/run/containerd/containerd.sock</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vm1</span></span><br><span class="line">  <span class="attr">taints:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">skipPhases:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">addon/kube-proxy</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">timeoutForControlPlane:</span> <span class="string">4m0s</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">clusterName:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">controllerManager:</span> &#123;&#125;</span><br><span class="line"><span class="attr">dns:</span> &#123;&#125;</span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.noname.io:5000</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="number">1.31</span><span class="number">.0</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">dnsDomain:</span> <span class="string">cluster.local</span></span><br><span class="line">  <span class="attr">serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span></span><br><span class="line"><span class="attr">scheduler:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>dry-run验证kubeadm_config.yaml文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm init --config kubeadm_config.yaml --dry-run</span><br></pre></td></tr></table></figure>

<p>执行初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm init --config kubeadm_config.yaml</span><br></pre></td></tr></table></figure>

<p>正常情况下，只要没有中途退出报错，走到这里就是安装成功的第一步了。如果出现异常可以在初始化命令后面加<code>-v 5</code>打印更具体的报错信息，我也把遇到过的报错情况放到了最后的bug处理，接下来就是验证集群是否在正常工作了</p>
<p>PS：kubeadm提示可以在执行init命令前可以先拉取image，我试了一下<code>kubeadm config images pull</code>，发现init还是会去拉取image，上面就不在记录这个步骤</p>
<h3 id="集群状态验证"><a href="#集群状态验证" class="headerlink" title="集群状态验证"></a>集群状态验证</h3><p>配置bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<p>执行命令，验证集群的工作状态。<strong>注意</strong>：安装过程中如果有使用proxy会导致kubectl连接不上api server，导致超时，需要删除环境变量<code>unset http_proxy</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看6443端口的监听情况</span></span><br><span class="line"><span class="built_in">sudo</span> netstat -tnlp | grep 6443</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出集群状态</span></span><br><span class="line">kubectl cluster-info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有节点信息</span></span><br><span class="line">kubectl get nodes -o wide</span><br><span class="line">kubectl describe nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于现在还没有安装cilium cni，此时coredns应处于pending状态</span></span><br><span class="line">kubectl get pods -A -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有pod反复崩溃重启，查看相关日志</span></span><br><span class="line">kubectl logs &lt;pod名称&gt; -n &lt;namespace&gt; -p</span><br><span class="line">kubectl describe &lt;pod名称&gt; -n &lt;namespace&gt; -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过crictl查看container，操作类似docker</span></span><br><span class="line"><span class="built_in">sudo</span> crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock ps -a</span><br></pre></td></tr></table></figure>

<h3 id="安装cilium"><a href="#安装cilium" class="headerlink" title="安装cilium"></a>安装cilium</h3><p>下载cilium，安装到&#x2F;usr&#x2F;local&#x2F;bin&#x2F;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可能需要proxy</span></span><br><span class="line">curl -L --fail --remote-name-all https://github.com/cilium/cilium-cli/releases/download/v0.16.15/cilium-linux-amd64.tar.gz&#123;,.<span class="built_in">sha256sum</span>&#125;</span><br><span class="line"><span class="built_in">sha256sum</span> --check cilium-linux-amd64.tar.gz.sha256sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略目录操作了</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> cilium /usr/local/bin/</span><br></pre></td></tr></table></figure>

<p>cilium查看组件安装情况以及报错信息，这里可以根据输出拉取相关image推送到私有registry，cni目录需要保证所有者是root</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看cilium状态、错误</span></span><br><span class="line">cilium status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保/opt/cni目录的所有者是root</span></span><br><span class="line"><span class="comment"># sudo chown -R root:root /opt/cni</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群安装cilium</span></span><br><span class="line">cilium install</span><br><span class="line"><span class="comment"># 指定版本安装</span></span><br><span class="line"><span class="comment"># cilium install v1.15.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod是否准备就绪-running</span></span><br><span class="line">kubectl get pods -A -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点状态应变为-Ready</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<p>到这里集群的初始化就完成了，congratulations</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="单节点k8s"><a href="#单节点k8s" class="headerlink" title="单节点k8s"></a>单节点k8s</h4><p>如果你不想要组集群了，想使用单个节点，那么移除taint即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/control-plane-</span><br><span class="line"><span class="comment"># 这个taint未必存在</span></span><br><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>

<h4 id="配置proxy拉取镜像"><a href="#配置proxy拉取镜像" class="headerlink" title="配置proxy拉取镜像"></a>配置proxy拉取镜像</h4><p>如果你不想使用私有的registry，那么可以使用proxy，containerd的配置如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl set-environment HTTP_PROXY=192.168.0.105:8118</span><br><span class="line"><span class="built_in">sudo</span> systemctl set-environment HTTPS_PROXY=192.168.0.105:8118</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>

<p>然后，不论是直接执行<code>kubeadm init</code>还是<code>kubeadm config images pull</code>，拉取镜像都会通过proxy拉取</p>
<h4 id="Dashboard-UI"><a href="#Dashboard-UI" class="headerlink" title="Dashboard UI"></a>Dashboard UI</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>方法一：使用helm安装（官方推荐）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 kubernetes-dashboard 仓库</span></span><br><span class="line">helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/</span><br><span class="line"><span class="comment"># 使用 kubernetes-dashboard Chart 部署名为 `kubernetes-dashboard` 的 Helm Release</span></span><br><span class="line">helm upgrade --install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard --create-namespace --namespace kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>方法二：下载配置文件导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以下载后传送到vm</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>

<p>执行<code>kubectl get pods -A</code>，你会在kubernetes-dashboard命名空间下看到两个pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS      AGE     IP                NODE   NOMINATED NODE   READINESS GATES</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper-6b96ff7878-ct999   1/1     Running   0             6m57s   10.0.1.215        vm2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard-8696f5f494-8cx4d        1/1     Running   0             6m57s   10.0.1.62         vm2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>如果无法拉取image，可以在物理机下载后推送到私有registry</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull kubernetesui/dashboard:v2.7.0</span><br><span class="line">docker pull kubernetesui/metrics-scraper:v1.0.8</span><br></pre></td></tr></table></figure>

<h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>新建文件<code>dashboard-user.yaml</code>，创建用户、绑定角色，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: dashboard-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: dashboard-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: dashboard-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f dashboard-user.yaml</span><br></pre></td></tr></table></figure>

<h5 id="访问dashboard"><a href="#访问dashboard" class="headerlink" title="访问dashboard"></a>访问dashboard</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br><span class="line"><span class="comment"># 新版本限制死了只能在执行了kubectl proxy的机器上打开，没什么意义</span></span><br><span class="line"><span class="comment"># kubectl proxy --address 0.0.0.0 --accept-hosts &#x27;.*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取登陆的token</span></span><br><span class="line">kubectl -n kubernetes-dashboard create token dashboard-user</span><br><span class="line"></span><br><span class="line"><span class="comment"># 物理机建立ssh port forwarding</span></span><br><span class="line">ssh -L 8001:127.0.0.1:8001 noname@192.168.122.11</span><br></pre></td></tr></table></figure>

<p>在物理机浏览器打开dashboard页面：<a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a> ，输入token即可进入dashboard界面</p>
<h3 id="部署vm2-vm3"><a href="#部署vm2-vm3" class="headerlink" title="部署vm2&#x2F;vm3"></a>部署vm2&#x2F;vm3</h3><p>打印vm1的k8s token信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>

<p>在vm2&#x2F;vm3执行命令，加入集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm <span class="built_in">join</span> 192.168.122.11:6443 --token 1kf3mx.6omg1ycbi6xul19q \</span><br><span class="line">  --discovery-token-ca-cert-hash sha256:9a412686425ed09f8156ec63cb52e798a61cf8de85069be0e36ec023f806ea4f</span><br></pre></td></tr></table></figure>

<p>在vm1验证集群状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>

<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>以下列出几个简单的app部署教程，从简单到复杂</p>
<ol>
<li><a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">nginx-deployment</a></li>
</ol>
<p>该教程是最简单的deployment使用教程，提供的功能是一个简单的http服务器，对外输出静态html页面，pod只有一个nginx的container，不涉及多container交互、存储等，该教程是一个很好的入门切入点</p>
<ol start="2">
<li><a href="https://kubernetes.io/docs/tutorials/stateless-application/guestbook/">guestbook</a></li>
</ol>
<p>该教程会教你如何部署一个redis主从服务、php服务，最后创建一个可对外的service，简单的说，是教你多个container如何交互并提供对外访问能力（集群内），这里不涉及存储、ingress等。应用提供的功能可以理解为动态http服务器，php从redis读取数据输出html页面、写入数据到redis</p>
<ol start="3">
<li><a href="https://kubernetes.io/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/">wordpress</a></li>
</ol>
<p>该教程会教你如何创建持久卷保存数据，涉及mysql部署、wordpress部署、创建secret，到这里基本涵盖到平时大多数的使用场景了</p>
<p><strong>注意</strong>：由于该教程是基于minikube的，直接部署到自建的k8s集群会有很多问题，比如</p>
<ul>
<li>不支持LoadBalancer，我们需要删除掉wordpress-deployment.yaml文件service声明配置里的<code>type: LoadBalancer</code></li>
<li>缺少默认的storageclass，不支持动态制备，只能手动建立pv，然后在pvc关联pv，具体如下</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把下面这部分配置插入到wordpress-deployment.yaml的pvc声明前面</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/k8s/pv/mysql-pv</span></span><br><span class="line"><span class="comment"># 同时往pvc的spec部分添加下面这句话</span></span><br><span class="line"><span class="comment"># volumeName: mysql-pv</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 把下面这部分配置插入到mysql-deployment.yaml的pvc声明前面</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/k8s/pv/wp-pv</span></span><br><span class="line"><span class="comment"># 同时往pvc的spec部分添加下面这句话</span></span><br><span class="line"><span class="comment"># volumeName: wp-pv</span></span><br></pre></td></tr></table></figure>

<p>最后，在vm1节点执行命令创建端口转发</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 映射到vm1</span></span><br><span class="line">kubectl port-forward svc/wordpress 8888:80</span><br><span class="line"><span class="comment"># 映射到物理机</span></span><br><span class="line">ssh -L 8888:127.0.0.1:8888 noname@192.168.122.11</span><br></pre></td></tr></table></figure>

<p>done!</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>注意，按照以上教程安装的集群属于裸集群（bare-metal），默认不支持以下几个功能</p>
<ul>
<li>Load Balancer Service</li>
<li>Persistent Volume</li>
<li>Ingress&#x2F;Gateway</li>
</ul>
<p>如果你的角色是开发者，还是老老实实使用Minikube，避免耗费太多时间精力在集群运维上</p>
<p>另外，一个完整的运维系统不仅仅只是k8s，应当包含以下组件</p>
<ul>
<li>k8s，负责管理pod资源（cpu&#x2F;内存）、node资源</li>
<li>分布式文件系统，负责持久存储</li>
<li>gateway，负责控制外部流量对集群内服务的访问</li>
<li>elk，负责日志收集、分析、告警</li>
<li>jaeger&#x2F;prometheus，负责收集指标、链路分析、告警</li>
<li>ci&#x2F;cd系统，如gitlab，负责开发-发布系统流程</li>
<li>管理后台，负责应用管理、发布审核、记录审计信息等</li>
</ul>
<h3 id="bug处理"><a href="#bug处理" class="headerlink" title="bug处理"></a>bug处理</h3><ol>
<li><code>kubeadm init</code>执行后集群组件反复崩溃重启<code>CrashLoopBackOff</code>或者是卡在<code>kubelet-check</code>检查步骤</li>
</ol>
<p>该问题原因与下面的cilium报错原因一致，软件权限导致的。在最开始时我使用的是手动安装方式，软件都是解压缩复制到bin目录，没有注意到所有组件的owner不是root，这才导致了上面这个问题。虽然是一个很容易忽视的问题，但却让我花了很长时间去debug，太亏了</p>
<ol start="2">
<li>cilium安装报错<code>cp: cannot create regular file &#39;/hostbin/cilium-mount&#39;: Permission denied</code></li>
</ol>
<p>这是因为这个目录是我手动创建的，在执行apt安装前就存在，目录的owner不是root，需要确保虚拟机&#x2F;opt&#x2F;cni目录的所有者是root，执行<code>sudo chown -R root:root /opt/cni</code>解决，详细看：<a href="https://github.com/cilium/cilium/issues/23838">https://github.com/cilium/cilium/issues/23838</a></p>
<ol start="3">
<li>kubeadm join报错<code>&#39;/run/systemd/resolve/resolv.conf&#39;: No such file or directory</code></li>
</ol>
<p>从服务器我换了一个debian，毕竟线上服务器通常都不是同一类系统，而这次报错的服务器bookworm就没有安装<code>systemd-resolved</code>，下载安装即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install systemd-resolved</span><br></pre></td></tr></table></figure>

<p>上面debian的修改会引入另一个问题，就是vm无法连通外网了，发现是dhcp有异常，进而导致<code>ImagePullBackOff</code>，也不知道为什么不能直接读取本地的image，需要使用<code>systemd-networkd</code>才行，详细看问题描述<a href="https://garajau.com.br/2022/01/configure-networkd-debian">Configuring systemd-networkd on Debian</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line"><span class="built_in">mv</span> /etc/network/interfaces /etc/network/interfaces.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增systemd-dhcp配置</span></span><br><span class="line"><span class="built_in">sudo</span> vi /etc/systemd/network/dhcp.network</span><br></pre></td></tr></table></figure>

<p>dhcp.network文件内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">[Match]</span><br><span class="line">Name=en*</span><br><span class="line">   </span><br><span class="line">[Network]</span><br><span class="line">DHCP=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>设置开机启动并重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> systemd-networkd</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart systemd-networkd</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>nginx-deployment报错<code>ImagePullBackOff</code></li>
</ol>
<p>这个问题很奇怪，除了前面提到的网络问题，还可能是hash值不匹配</p>
<p>当时我改了<a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/controllers/nginx-deployment.yaml">nginx-deployment.yaml</a>里的镜像，而且确认本地已经拉取过来了，但部署时就一直报错，最后我在物理机重新拉取镜像时发现hash值居然对不上，最后重新打tag推送才解决</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">安装 kubeadm</a><br><a href="https://blog.radwell.codes/2022/07/single-node-kubernetes-cluster-via-kubeadm-on-ubuntu-22-04/">Simple Single-node Kubernetes Cluster via kubeadm on Ubuntu 22.04</a><br><a href="https://www.linuxtechi.com/install-kubernetes-cluster-on-debian/">How to Install Kubernetes Cluster on Debian 12 | 11</a><br><a href="https://izsk.me/2023/06/03/cilium-on-kubernetes-install/">cilium在kubernetes中的生产实践二(cilium部署)</a><br><a href="https://www.tutorialworks.com/difference-docker-containerd-runc-crio-oci/#:~:text=runc%20provides%20all%20of%20the,create%20and%20run%20container%20processes.">The differences between Docker, containerd, CRI-O and runc</a><br><a href="https://spacelift.io/blog/kubernetes-dashboard">Kubernetes Dashboard: Tutorial, Best Practices &amp; Alternatives</a><br><a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md">Creating sample user</a><br><a href="https://unix.stackexchange.com/questions/402999/is-it-ok-to-change-etc-machine-id">Is it OK to change &#x2F;etc&#x2F;machine-id?</a><br><a href="https://developer-friendly.blog/blog/2024/03/03/kubernetes-the-hard-way/">Kubernetes The Hard Way</a></p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
        <tag>kubeadm</tag>
      </tags>
  </entry>
</search>
