<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx配置HTTPS访问</title>
    <url>/configure-nginx-with-https/</url>
    <content><![CDATA[<p>简单介绍如何生成https服务所需要的证书、私钥以及部署，文档分别描述了开发时使用的self-signed证书以及线上使用的let’s encrypt免费证书的生成方法</p>
<h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><h3 id="创建证书以及私钥"><a href="#创建证书以及私钥" class="headerlink" title="创建证书以及私钥"></a>创建证书以及私钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>req:</strong> 指定X.509证书签名请求(CSR)管理</p>
</li>
<li><p><strong>-x509:</strong> 生成self-sigend证书</p>
</li>
<li><p><strong>-nodes:</strong> 不使用密码</p>
</li>
<li><p><strong>-days 365:</strong> 证书有效期</p>
</li>
<li><p><strong>-newkey rsa:2048:</strong> 生成证书的同时生成私钥，rsa加密算法，2048位</p>
</li>
<li><p><strong>-keyout:</strong> 私钥的存储路径</p>
</li>
<li><p><strong>-out:</strong> 证书的存储路径</p>
</li>
</ul>
<p>信息填写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Country Name (2 letter code) [AU]:US</span><br><span class="line">State or Province Name (full name) [Some-State]:New York</span><br><span class="line">Locality Name (eg, city) []:New York City</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:Bouncy Castles, Inc.</span><br><span class="line">Organizational Unit Name (eg, section) []:Ministry of Water Slides</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []: example.com (or server_IP_address)</span><br><span class="line">Email Address []:admin@your_domain.com</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/nginx/sites-enabled/example.com</span><br></pre></td></tr></table></figure>

<p>添加证书以及私钥</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/ssl/certs/nginx-selfsigned.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/ssl/private/nginx-selfsigned.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /var/www/example.com/html;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启nginx，完成</p>
<h2 id="正式证书"><a href="#正式证书" class="headerlink" title="正式证书"></a>正式证书</h2><h3 id="let’t-encrypt安装"><a href="#let’t-encrypt安装" class="headerlink" title="let’t encrypt安装"></a>let’t encrypt安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> git <span class="built_in">clone</span> https://github.com/letsencrypt/letsencrypt /usr/local/letsencrypt</span><br></pre></td></tr></table></figure>

<h3 id="生成证书以及私钥"><a href="#生成证书以及私钥" class="headerlink" title="生成证书以及私钥"></a>生成证书以及私钥</h3><p><strong>生成指定域名证书及密钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> -H /data/app/letsencrypt/letsencrypt-auto certonly --standalone -d www.example.com</span><br></pre></td></tr></table></figure>

<p>letsencrypt需要记录服务器ip，选择“Y”。打开新的命令行窗口，在指定的目录<code>.well-known</code>下创建文件并将指定的内容写入后，在原命令行窗口点击<code>enter</code>键结束</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Saving debug <span class="built_in">log</span> to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line">Plugins selected: Authenticator standalone, Installer None</span><br><span class="line">Obtaining a new certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">http-01 challenge <span class="keyword">for</span> www.example.com</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class="line">certificate. If you<span class="string">&#x27;re running certbot in manual mode on a machine that is not</span></span><br><span class="line"><span class="string">your server, please ensure you&#x27;</span>re okay with that.</span><br><span class="line"></span><br><span class="line">Are you OK with your IP being logged?</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es/(N)o: Y</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Create a file containing just this data:</span><br><span class="line"></span><br><span class="line">BxYgbmNBP0glztPgaevZwzwMSPy2Asd8LRzlyQNnax9.sAK0-w3-GGiCDaAreDXX1rxwm0qQfBfhb-4765BnzRZ</span><br><span class="line"></span><br><span class="line">And make it available on your web server at this URL:</span><br><span class="line"></span><br><span class="line">http://www.example.com/.well-known/acme-challenge/BxYgbmNBP0glztPgaevZwzwMSPy2Asd8LRzlyQNnax9</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Press Enter to Continue           <span class="comment"># 文件创建后再确认</span></span><br><span class="line">Waiting <span class="keyword">for</span> verification...</span><br><span class="line">Cleaning up challenges</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/www.example.com/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/www.example.com/privkey.pem</span><br><span class="line">   Your cert will expire on 2019-11-04. To obtain a new or tweaked</span><br><span class="line">   version of this certificate <span class="keyword">in</span> the future, simply run</span><br><span class="line">   letsencrypt-auto again. To non-interactively renew *all* of your</span><br><span class="line">   certificates, run <span class="string">&quot;letsencrypt-auto renew&quot;</span></span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let<span class="string">&#x27;s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">   Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure>

<p><strong>生成wildcard domain证书及密钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果嫌单个域名太麻烦，想配置wildcard证书，使用下面的命令</span></span><br><span class="line"><span class="built_in">sudo</span> -H /data/app/letsencrypt/letsencrypt-auto certonly --manual --preferred-challenges=dns -d *.example.com</span><br></pre></td></tr></table></figure>

<p>按提示添加dns记录后再点击<code>enter</code>结束</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Saving debug <span class="built_in">log</span> to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line">Plugins selected: Authenticator manual, Installer None</span><br><span class="line">Obtaining a new certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">dns-01 challenge <span class="keyword">for</span> example.com</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class="line">certificate. If you<span class="string">&#x27;re running certbot in manual mode on a machine that is not</span></span><br><span class="line"><span class="string">your server, please ensure you&#x27;</span>re okay with that.</span><br><span class="line"></span><br><span class="line">Are you OK with your IP being logged?</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es/(N)o: Y</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Please deploy a DNS TXT record under the name</span><br><span class="line">_acme-challenge.example.com with the following value:</span><br><span class="line"></span><br><span class="line">AhAGaqohVH8JMAS-jHkS5L_i2J4JCnglUJvY5n2S9qI</span><br><span class="line"></span><br><span class="line">Before continuing, verify the record is deployed.</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Press Enter to Continue           <span class="comment"># 需添加dns记录</span></span><br><span class="line">Waiting <span class="keyword">for</span> verification...</span><br><span class="line">Cleaning up challenges</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/example.com/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/example.com/privkey.pem</span><br><span class="line">   Your cert will expire on 2019-11-04. To obtain a new or tweaked</span><br><span class="line">   version of this certificate <span class="keyword">in</span> the future, simply run</span><br><span class="line">   letsencrypt-auto again. To non-interactively renew *all* of your</span><br><span class="line">   certificates, run <span class="string">&quot;letsencrypt-auto renew&quot;</span></span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let<span class="string">&#x27;s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">   Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure>

<h3 id="配置nginx-1"><a href="#配置nginx-1" class="headerlink" title="配置nginx"></a>配置nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/nginx/sites-enabled/example.com</span><br></pre></td></tr></table></figure>

<p>添加证书以及私钥</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /var/www/example.com/html;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启nginx，完成</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04">How To Create a Self-Signed SSL Certificate for Nginx in Ubuntu 18.04</a><br><a href="https://www.linode.com/docs/security/ssl/install-lets-encrypt-to-create-ssl-certificates/">Install Let’s Encrypt to Create SSL Certificates</a><br><a href="https://gist.github.com/cecilemuller/a26737699a7e70a7093d4dc115915de8">How to setup Let’s Encrypt for Nginx on Ubuntu 18.04 (including IPv6, HTTP&#x2F;2 and A+ SLL rating)</a><br><a href="https://certbot.eff.org/docs/using.html">Certbot User Guide</a><br><a href="http://manpages.ubuntu.com/manpages/xenial/man1/letsencrypt.1.html">letsencrypt man</a></p>
]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>ssl</tag>
        <tag>https</tag>
        <tag>let&#39;s enctypt</tag>
      </tags>
  </entry>
  <entry>
    <title>安装docker并部署registry服务</title>
    <url>/deploy-docker-and-registry-service/</url>
    <content><![CDATA[<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>当前仅展示apt方式安装，离线安装方式不展示</p>
<h3 id="清理历史残留"><a href="#清理历史残留" class="headerlink" title="清理历史残留"></a>清理历史残留</h3><p>如果系统有预装docker或者先前安装过，先卸载干净在安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 第一次安装时输出为空</span></span><br><span class="line"><span class="keyword">for</span> pkg <span class="keyword">in</span> docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; <span class="keyword">do</span> <span class="built_in">sudo</span> apt remove <span class="variable">$pkg</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果以前有安装过docker，相关数据可以删除掉</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h3 id="apt安装"><a href="#apt安装" class="headerlink" title="apt安装"></a>apt安装</h3><h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><p>由于docker被gfw屏蔽，访问时需要使用vpn，这里使用先前搭建的<a href="/deploy-shadowsocks-service">ss服务</a></p>
<p>新建<code>apt.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/apt/apt.conf</span><br></pre></td></tr></table></figure>

<p>添加proxy配置，默认源地址配置直连，如此后续配置docker源后，使用<code>apt update</code>便可直接访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquire::http::Proxy &quot;http://127.0.0.1:8118&quot;;</span><br><span class="line">Acquire::http::Proxy &#123;</span><br><span class="line">    archive.ubuntu.com DIRECT;</span><br><span class="line">    security.ubuntu.com DIRECT;</span><br><span class="line">    cn.archive.ubuntu.com DIRECT;</span><br><span class="line">    mirrors.tuna.tsinghua.edu.cn DIRECT;</span><br><span class="line">&#125;</span><br><span class="line">Acquire::https::Proxy &quot;http://127.0.0.1:8118&quot;;</span><br><span class="line">Acquire::https::Proxy &#123;</span><br><span class="line">    archive.ubuntu.com DIRECT;</span><br><span class="line">    security.ubuntu.com DIRECT;</span><br><span class="line">    cn.archive.ubuntu.com DIRECT;</span><br><span class="line">    mirrors.tuna.tsinghua.edu.cn DIRECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="配置源并安装"><a href="#配置源并安装" class="headerlink" title="配置源并安装"></a>配置源并安装</h4><p>按照docker官方教材安装docker，其中，下载<code>docker.asc</code>的命令做了一些修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add Docker&#x27;s official GPG key:</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install ca-certificates curl</span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br><span class="line"><span class="comment"># 配置proxy</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118;<span class="built_in">export</span> https_proxy=http://127.0.0.1:8118;</span><br><span class="line"><span class="comment"># 下载后在使用sudo搬到指定目录</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o docker.asc &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">mv</span> docker.asc /etc/apt/keyrings/docker.asc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.asc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the repository to Apt sources:</span></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是k8s部署，只需要containerd就够了</span></span><br><span class="line"><span class="built_in">sudo</span> apt install containerd.io docker-ce docker-ce-cli docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>

<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>将当前用户加入<code>docker</code>用户组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<h2 id="部署registry"><a href="#部署registry" class="headerlink" title="部署registry"></a>部署registry</h2><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>因为gfw的原因，docker hub的访问会时不时抽风，在使用docker pull前可以先配置代理，当前步骤可跳过</p>
<p>创建配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/systemd/system/docker.service.d/http-proxy.conf</span><br></pre></td></tr></table></figure>

<p>配置proxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://127.0.0.1:8118&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=http://127.0.0.1:8118&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=localhost,127.0.0.1,registry.noname.io&quot;</span><br></pre></td></tr></table></figure>

<p>重启并验证docker环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl show --property=Environment docker</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># Environment=HTTP_PROXY=http://127.0.0.1:8118 HTTPS_PROXY=http://127.0.0.1:8118 NO_PROXY=localhost,127.0.0.1,registry.noname.io</span></span><br></pre></td></tr></table></figure>

<h3 id="生成ssl证书"><a href="#生成ssl证书" class="headerlink" title="生成ssl证书"></a>生成ssl证书</h3><p>可以直接使用http，但后续k8s镜像的下载必须使用https，没有那么多耐心再去折腾，在这里先解决了，一劳永逸</p>
<p><code>/data/docker/</code>是我用于专门存放与registry相关的数据，包括certs以及后续docker push上来的镜像数据</p>
<p>下面命令关键的域名registry.noname.io要填好</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">  -newkey rsa:4096 -nodes -sha256 -keyout /data/docker/certs/noname.io.key \</span><br><span class="line">  -addext <span class="string">&quot;subjectAltName = DNS:registry.noname.io&quot;</span> \</span><br><span class="line">  -x509 -days 365 -out /data/docker/certs/noname.io.crt</span><br></pre></td></tr></table></figure>

<p>由此，https所需要的证书也就准备好了</p>
<h3 id="创建registry服务"><a href="#创建registry服务" class="headerlink" title="创建registry服务"></a>创建registry服务</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>将<code>/data/docker/certs</code>挂载到container的<code>/data/certs</code>目录</li>
<li><code>/data/docker/registry</code>挂载到container的<code>/var/lib/registry</code>目录，后续删除重建container时就保留下了image数据</li>
</ol>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>如果只是创建一个简单的可运行registry，直接运行docker run</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart always --name registry \</span><br><span class="line">  -v /data/docker/registry:/var/lib/registry \</span><br><span class="line">  -v /data/docker/certs:/data/certs \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_CERTIFICATE=/data/certs/noname.io.crt \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_KEY=/data/certs/noname.io.key \</span><br><span class="line">  registry:2.8.3</span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>如果涉及比较复杂的配置，像权限管理、接入s3文件系统、缓存配置、中继配置等，则使用配置文件方式比较好</p>
<p>创建registry配置文件，参考配置文件：<a href="https://github.com/distribution/distribution/blob/master/cmd/registry/config-example.yml">example YAML file</a>，修改后如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">:5000</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="attr">certificate:</span> <span class="string">/data/certs/noname.io.crt</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">/data/certs/noname.io.key</span></span><br></pre></td></tr></table></figure>

<p>运行docker run</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart always --name registry \</span><br><span class="line">  -v /data/docker/registry:/var/lib/registry \</span><br><span class="line">  -v /data/docker/certs:/data/certs \</span><br><span class="line">  -v /data/docker/config/config.yml:/etc/docker/registry/config.yml \</span><br><span class="line">  registry:2.8.3</span><br></pre></td></tr></table></figure>

<h3 id="修改系统配置"><a href="#修改系统配置" class="headerlink" title="修改系统配置"></a>修改系统配置</h3><h4 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/hosts</span><br></pre></td></tr></table></figure>

<p>添加私有registry的域名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">127.0.0.1 registry.noname.io</span><br></pre></td></tr></table></figure>

<h4 id="修改docker配置"><a href="#修改docker配置" class="headerlink" title="修改docker配置"></a>修改docker配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p><code>insecure-registries</code>需要添加registry的域名端口</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;exec-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;native.cgroupdriver=systemd&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;registry.noname.io:5000&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>如果要开放局域网内的访问，配置防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 5000/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure>

<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><p>访问registry接口，此时因为registry还没有任何image数据，输出为空</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://registry.noname.io:5000/v2/_catalog | jq .</span><br></pre></td></tr></table></figure>

<p>推送镜像测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag alpine:3.20.1 registry.noname.io:5000/alpine:3.20.1</span><br><span class="line">docker push registry.noname.io:5000/alpine:3.20.1</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu</a><br><a href="https://distribution.github.io/distribution/">Distribution Registry</a><br><a href="https://medium.com/@haminhsang1903/private-docker-registry-with-https-and-a-nginx-reverse-proxy-using-docker-compose-6c1335c5e820">Private Docker registry with HTTPS and a Nginx reverse proxy using Docker Compose</a></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title>安装kvm虚拟机</title>
    <url>/deploy-kvm-and-cockpit/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般情况下，日常开发我只使用vagrant跟virtualbox，但后面想搭建一个k8s环境学习，需要一个免费、高性能、便于管理的虚拟机管理软件</p>
<p>综合考虑了下现在市面上的虚拟机管理软件</p>
<ol>
<li>virtualbox 的磁盘性能太差，nat网络所有虚拟机都是同一个IP：10.0.2.15，其他方面也不考虑了</li>
<li>parallel desktop 太贵太黑心</li>
<li>vmware 价格也不便宜还很吃电脑资源</li>
<li>hyper-v 管理界面太难用，同时无法固定虚拟机IP</li>
</ol>
<p>最终我选择组装一台台式机，安装了ubuntu系统，并在上面安装使用kvm虚拟机</p>
<p>cpu是amd 7700，8核心16线程；32GB内存；暂时不需要用到显卡；PC在路由器做了MAC跟IP的绑定，方便使用ssh</p>
<p>由于virt-manager太难用，最后选择cockpit作为kvm虚拟机管理软件</p>
<h2 id="kvm安装"><a href="#kvm安装" class="headerlink" title="kvm安装"></a>kvm安装</h2><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><p>确认cpu开启虚拟化功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般是cpu的核心数量</span></span><br><span class="line">egrep -c <span class="string">&#x27;(vmx|svm)&#x27;</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<h3 id="安装kvm"><a href="#安装kvm" class="headerlink" title="安装kvm"></a>安装kvm</h3><p>安装kvm以及依赖软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install qemu-system-x86 libvirt-daemon-system virtinst \</span><br><span class="line">  virt-manager virt-viewer ovmf swtpm qemu-utils guestfs-tools \</span><br><span class="line">  libosinfo-bin tuned</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> libvirtd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line"><span class="built_in">sudo</span> virt-host-validate qemu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有使用window的需要，可以下载virtio</span></span><br><span class="line">wget https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.240-1/virtio-win-0.1.240.iso</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="安装后工作"><a href="#安装后工作" class="headerlink" title="安装后工作"></a>安装后工作</h3><p>将用户添加到kvm跟libvirt组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG kvm <span class="variable">$USER</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG libvirt <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<h2 id="cockpit安装"><a href="#cockpit安装" class="headerlink" title="cockpit安装"></a>cockpit安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install cockpit cockpit-machines</span><br></pre></td></tr></table></figure>

<p>防火墙配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 9090/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure>

<p>浏览器打开访问web管理页面 <a href="https://192.168.0.105:9090/">https://192.168.0.105:9090</a></p>
<p><img src="/images/kvm_with_cockpit.png" alt="kvm with cockpit preview"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.tecmint.com/install-qemu-kvm-ubuntu-create-virtual-machines/">How to Install QEMU&#x2F;KVM on Ubuntu to Create Virtual Machines</a><br><a href="https://www.tecmint.com/manage-kvm-virtual-machines-using-cockpit-web-console/">Managing KVM Virtual Machines with Cockpit Web Console in Linux</a><br><a href="https://github.com/bryansteiner/gpu-passthrough-tutorial">gpu-passthrough-tutorial</a></p>
]]></content>
      <tags>
        <tag>kvm</tag>
        <tag>cockpit</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建shadowsocks服务</title>
    <url>/deploy-shadowsocks-service/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于国内恶劣的网络环境，作为一名频繁访问外网的Web开发者，不得不自建一个VPN服务，以下简单介绍Shadowsocks的搭建过程。</p>
<p>单纯的ss流量会迅速被gfw识别到并屏蔽，因此使用ss时需要增加obfs用以混淆欺骗gfw，可以极大程度减小被屏蔽的风险。当然，如果你用的是比较出名的服务器供应商，如bandwagon的服务器，那么被屏蔽的机会也很大。</p>
<p>服务端使用的一键安装脚本twist由于开发者已经放弃维护长时间，目前只有参考作用，如果你有耐心，也可以自己修改后再使用，也就跟下面的服务端搭建教程一样。搞完是真的累，太渣了，太需要提高自己的编程水平，写一个一体化的软件包才行</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="twist脚本"><a href="#twist脚本" class="headerlink" title="twist脚本"></a>twist脚本</h3><p>服务端使用的是twist脚本，里面集成了Shadowsocks+simple-obfs+fail2ban以及相关依赖包，使用shell编写，感兴趣的可以看看源代码，下载地址如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/forestbat/Twist</span><br></pre></td></tr></table></figure>

<p>下载后，脚本添加执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x twist</span><br></pre></td></tr></table></figure>

<p>切换到root账户，twist执行需要</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="修改twist"><a href="#修改twist" class="headerlink" title="修改twist"></a>修改twist</h3><p>twist文件里面有一些软件需要删掉&#x2F;更换，有些则需要手动安装，先手动执行一遍twist脚本<code>./twist install</code>，确认有哪些错误，然后选择执行下面的命令</p>
<ol>
<li>修改<code>dependenciesinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不同的系统不一样，不要全改</span></span><br><span class="line"><span class="comment"># 1. 新增依赖包，如libcork-dev</span></span><br><span class="line"><span class="comment"># 2. 名称更换，如python-pip改为python3-pip</span></span><br><span class="line">apt install python3-dev python3-pip python3-setuptools python3-m2crypto libcork-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将pip改为pip3，可能需要使用pip安装m2crypto</span></span><br><span class="line">pip3 install qrcode</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改<code>sslibevinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># github的包命名改了，解压后变成了libsodium-stable</span></span><br><span class="line">tar zxf libsodium-<span class="variable">$&#123;libsodiumver&#125;</span>.tar.gz &amp;&amp; <span class="built_in">mv</span> libsodium-stable libsodium-<span class="variable">$&#123;libsodiumver&#125;</span></span><br></pre></td></tr></table></figure>

<p>或者删掉libsodium这段，直接手动编译安装，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/jedisct1/libsodium/releases/download/1.0.19-RELEASE/libsodium-1.0.19.tar.gz</span><br><span class="line">tar zxf libsodium-1.0.19.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libsodium-1.0.19</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改<code>sslibevinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 tar zxf $&#123;ssobfsver&#125;.tar.gz 这一行后面修改添加代码，因为obfs也有很长时间没有更新，导致在新的编译器下报错</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ssobfstag</span>&quot;</span> == <span class="string">&quot;v0.0.5&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="comment"># patch</span></span><br><span class="line">sed -i -e <span class="string">&quot;249s/$/ else &#123;result = OBFS_ERROR;&#125;/&quot;</span> /tmp/<span class="variable">$&#123;ssobfsver&#125;</span>/src/obfs_http.c</span><br><span class="line">sed -i -e <span class="string">&#x27;246d&#x27;</span> /tmp/<span class="variable">$&#123;ssobfsver&#125;</span>/src/obfs_http.c</span><br><span class="line"><span class="comment"># patch end</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改<code>sslibevinstallerr</code>、<code>sslibevinstall</code>函数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sslibevinstallerr函数如下</span></span><br><span class="line"><span class="comment"># 删掉mbedtls相关包，与libsodium类似，因为命名问题我直接绑定版本了</span></span><br><span class="line"><span class="built_in">rm</span> -rf libsodium-<span class="variable">$&#123;libsodiumver&#125;</span>.tar.gz libsodium-<span class="variable">$&#123;libsodiumver&#125;</span> <span class="variable">$&#123;mbedtlsver&#125;</span>.tar.gz <span class="variable">$&#123;mbedtlsver&#125;</span> <span class="variable">$&#123;sslibevver&#125;</span>.tar.gz <span class="variable">$sslibevver</span> <span class="variable">$&#123;ssobfsver&#125;</span>.tar.gz <span class="variable">$ssobfsver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sslibevinstall函数如下</span></span><br><span class="line"><span class="comment"># 搜索与mbedtlstag有关的代码段，修改绑定版本v2.28.1</span></span><br><span class="line"><span class="comment"># ldconfig</span></span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$mbedtlstag</span>&quot;</span> ] &amp;&amp; mbedtlstag=<span class="string">&quot;v2.28.1&quot;</span></span><br><span class="line">mbedtlsver=<span class="string">&quot;mbedtls-<span class="subst">$(echo $&#123;mbedtlstag&#125; | sed -e &#x27;s/^[a-zA-Z]//g&#x27;)</span>&quot;</span></span><br><span class="line">wget -t 3 -T 30 -nv -O <span class="variable">$&#123;mbedtlsver&#125;</span>.tar.gz https://github.com/Mbed-TLS/mbedtls/archive/refs/tags/<span class="variable">$&#123;mbedtlstag&#125;</span>.tar.gz</span><br><span class="line">[ <span class="string">&quot;$?&quot;</span> != <span class="string">&quot;0&quot;</span> ] &amp;&amp; sslibevinstallerr <span class="string">&quot;mbedtls-<span class="subst">$(echo $&#123;mbedtlstag&#125; | sed -e &#x27;s/^[a-zA-Z]//g&#x27;)</span>&quot;</span></span><br><span class="line">[ -d <span class="variable">$&#123;mbedtlsver&#125;</span> ] &amp;&amp; <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;mbedtlsver&#125;</span>&quot;</span></span><br><span class="line">tar zxf <span class="variable">$&#123;mbedtlsver&#125;</span>.tar.gz</span><br><span class="line"><span class="built_in">pushd</span> <span class="variable">$mbedtlsver</span></span><br><span class="line">make SHARED=1 CFLAGS=-fPIC <span class="string">&quot;-j<span class="subst">$((MAKECORES+1)</span>)&quot;</span> &amp;&amp; make DESTDIR=/usr install || sslibevinstallerr <span class="string">&quot;mbedtls-<span class="variable">$&#123;mbedtlstag&#125;</span> | sed -e &#x27;s/^[a-zA-Z]//g&#x27;&quot;</span> err</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line">ldconfig</span><br><span class="line"><span class="built_in">rm</span> -rf libsodium-<span class="variable">$&#123;libsodiumver&#125;</span>.tar.gz libsodium-<span class="variable">$&#123;libsodiumver&#125;</span> mbedtls-<span class="variable">$&#123;mbedtlsver&#125;</span>.tgz mbedtls-<span class="variable">$&#123;mbedtlsver&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="安装完毕"><a href="#安装完毕" class="headerlink" title="安装完毕"></a>安装完毕</h3><p>执行修改后的twist脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./twist install</span><br></pre></td></tr></table></figure>

<p>如果twist安装成功，此时命令行下将会展示ss服务的二维码以及url，手机端可以用小火箭扫描，桌面端可以复制url导入</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># obfs混淆ss流量；privoxy将http流量转换为socks5流量</span></span><br><span class="line"><span class="built_in">sudo</span> apt install shadowsocks-libev simple-obfs privoxy</span><br></pre></td></tr></table></figure>

<h3 id="ss配置"><a href="#ss配置" class="headerlink" title="ss配置"></a>ss配置</h3><p>修改ss配置，配置文件可以是<code>/etc/shadowsocks-libev/config.json</code>，也可以是<code>/etc/shadowsocks-libev/config-obfs.json</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure>

<p>按下方模板配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;server_ip&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span><span class="string">&quot;tcp_and_udp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span><span class="number">443</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span><span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;server_password&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">86400</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;xchacha20-ietf-poly1305&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugin&quot;</span><span class="punctuation">:</span><span class="string">&quot;obfs-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugin_opts&quot;</span><span class="punctuation">:</span><span class="string">&quot;obfs=tls;obfs-host=mzstatic.com;obfs-uri=/&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>执行下面的命令，确认软件可正常运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看输出确认无异常报错</span></span><br><span class="line"><span class="built_in">sudo</span> ss-local -c /etc/shadowsocks-libev/config.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1080端口</span></span><br><span class="line"><span class="built_in">sudo</span> netstat -tnlp | grep 1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发现ss服务未能正常启动，查看status信息</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status shadowsocks-libev.service</span><br></pre></td></tr></table></figure>

<p>修改<code>systemd</code>配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /usr/lib/systemd/system/shadowsocks-libev.service</span><br></pre></td></tr></table></figure>

<p>将<code>ss-server</code>改为<code>ss-local</code>，因为我们修改的是<code>shadowsocks-libev.service</code>，配置文件就是<code>config.json</code>，这里就不需要再修改什么</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  This file is part of shadowsocks-libev.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Shadowsocks-libev is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment">#  it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment">#  the Free Software Foundation; either version 3 of the License, or</span></span><br><span class="line"><span class="comment">#  (at your option) any later version.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  This file is default for Debian packaging. See also</span></span><br><span class="line"><span class="comment">#  /etc/default/shadowsocks-libev for environment variables.</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Shadowsocks-libev Default Client Service</span><br><span class="line"><span class="attr">Documentation</span>=man:shadowsocks-libev(<span class="number">8</span>)</span><br><span class="line"><span class="attr">After</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"><span class="attr">Wants</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">CapabilityBoundingSet</span>=CAP_NET_BIND_SERVICE</span><br><span class="line"><span class="attr">AmbientCapabilities</span>=CAP_NET_BIND_SERVICE</span><br><span class="line"><span class="attr">DynamicUser</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">EnvironmentFile</span>=/etc/default/shadowsocks-libev</span><br><span class="line"><span class="attr">LimitNOFILE</span>=<span class="number">32768</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/ss-local -c <span class="variable">$CONFFILE</span> <span class="variable">$DAEMON_ARGS</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p>重启ss服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart shadowsocks-libev</span><br></pre></td></tr></table></figure>

<h3 id="privoxy配置"><a href="#privoxy配置" class="headerlink" title="privoxy配置"></a>privoxy配置</h3><p>修改配置文件<code>/etc/privoxy/config</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/privoxy/config</span><br></pre></td></tr></table></figure>

<p>修改<code>listen-address</code>，因为有时我会将地址共享出来给局域网其他设备使用，所以我一般会将<code>127.0.0.1</code>改为<code>0.0.0.0</code>。在末尾添加<code>forward-socks5</code>指令，将所有<code>http</code>流量转发到<code>1080</code>端口</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">listen-address  0.0.0.0:8118</span><br><span class="line">forward-socks5   /               127.0.0.1:1080  .</span><br></pre></td></tr></table></figure>

<p>重启privoxy服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart privoxy</span><br></pre></td></tr></table></figure>

<p>防火墙开放8118端口访问（可选，如果没有打算给局域网内的其他机器使用就不要打开）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 8118/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure>

<h3 id="最后验证"><a href="#最后验证" class="headerlink" title="最后验证"></a>最后验证</h3><p>配置环境变量<code>http_proxy</code>以及<code>https_proxy</code>，访问外网地址，只要有html数据流输出即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118;<span class="built_in">export</span> https_proxy=http://127.0.0.1:8118;</span><br><span class="line"></span><br><span class="line">curl -i https://www.google.com/</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/forestbat/Twist">Twist脚本github地址</a><br><a href="https://winamp.top/228.html">Debian11下编译安装Shadowsocks-libev</a><br><a href="http://docs.lvrui.io/2016/12/12/Linux%E4%B8%AD%E4%BD%BF%E7%94%A8ShadowSocks-Privoxy%E4%BB%A3%E7%90%86/">Linux中使用ShadowSocks+Privoxy代理</a></p>
]]></content>
      <tags>
        <tag>shadowsocks</tag>
        <tag>obfs</tag>
        <tag>privoxy</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-channel</title>
    <url>/golang-series-channel/</url>
    <content><![CDATA[<p>channel-管道，是go语言中一种常见的goroutine的通信方式</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>示例1. 两个goroutine之间使用channel传递数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新goroutine</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    message &lt;- <span class="string">&quot;Hello from goroutine!&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前goroutine</span></span><br><span class="line">msg := &lt;-message</span><br><span class="line">fmt.Println(msg)</span><br></pre></td></tr></table></figure>

<p>示例2. 使用select同时监听多个goroutine的响应数据，实际上，业务代码中一般都是跟定时器搭配使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">    ch1 &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    ch2 &lt;- <span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received from ch1:&quot;</span>, msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received from ch2:&quot;</span>, msg2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// len，元素个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// cap，循环队列的长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指针，指向一个循环队列</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// 元素大小</span></span><br><span class="line">    synctest <span class="type">bool</span>           <span class="comment">// true if created in a synctest bubble</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 是否已关闭</span></span><br><span class="line">    timer    *timer         <span class="comment">// 定时器，双向绑定timer</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>           <span class="comment">// 写索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>           <span class="comment">// 读索引</span></span><br><span class="line">    recvq    waitq          <span class="comment">// 读队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// 写队列</span></span><br><span class="line">    lock     mutex          <span class="comment">// 锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向队列，sudog内部有prev和next指针</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog            <span class="comment">// head</span></span><br><span class="line">    last  *sudog            <span class="comment">// tail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h2><p>创建channel，具体逻辑如下</p>
<ol>
<li>guard，让错误尽早返回</li>
<li>计算创建channel所需的内存大小（header+buf）</li>
<li>创建channel、初始化字段数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">    elem := t.Elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保元素大小没有超过2^16=64KB</span></span><br><span class="line">    <span class="keyword">if</span> elem.Size_ &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.Align_ &gt; maxAlign &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果channel有buf缓冲区</span></span><br><span class="line">    <span class="comment">// 计算buf总大小=type_size*size</span></span><br><span class="line">    mem, overflow := math.MulUintptr(elem.Size_, <span class="type">uintptr</span>(size))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建channel</span></span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:          <span class="comment">// size=0或者type_size=0，无buf</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> !elem.Pointers():  <span class="comment">// 元素非指针类型，一次性为header和buf申请内存</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>:                <span class="comment">// 指针类型，分别为header和buf申请内存</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.elemsize = <span class="type">uint16</span>(elem.Size_)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">    <span class="comment">// synctest，忽略</span></span><br><span class="line">    <span class="keyword">if</span> getg().syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.synctest = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁优先级设置，见src/runtime/lockrank.go</span></span><br><span class="line">    lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.Size_, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取buf可写入的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanbuf</span><span class="params">(c *hchan, i <span class="type">uint</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="keyword">return</span> add(c.buf, <span class="type">uintptr</span>(i)*<span class="type">uintptr</span>(c.elemsize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">full</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 容量为0</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 有G在等待读数据</span></span><br><span class="line">        <span class="keyword">return</span> c.recvq.first == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容量不为0，确认队列是否已满</span></span><br><span class="line">    <span class="keyword">return</span> c.qcount == c.dataqsiz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 容量为0</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atomic.Loadp(unsafe.Pointer(&amp;c.sendq.first)) == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步timer（&lt;=go1.22)</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line">        c.timer.maybeRunChan()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容量不为0，确认队列是否为空</span></span><br><span class="line">    <span class="keyword">return</span> atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>如何发送数据到channel？当使用代码<code>c &lt;- x</code>时，系统将编译为对chansend1的调用；当使用select发送数据时，编译为对selectnbsend的调用；而这两个函数最终会调用chansend</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `c &lt;- x`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chansend(c, elem, <span class="literal">true</span>, sys.GetCallerPC())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select代码块</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//    select &#123;</span></span><br><span class="line"><span class="comment">//    case c &lt;- v:</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    default:</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 编译为如下代码</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    if selectnbsend(c, v) &#123;</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, sys.GetCallerPC())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chansend代码如下，具体逻辑为</p>
<ol>
<li>select场景，非阻塞<ul>
<li>如果channel  已关闭，异常</li>
<li>如果channel  未初始化或buf已满，发送失败，返回</li>
</ul>
</li>
<li>c &lt;- v场景，阻塞<ul>
<li>如果channel  未初始化或已关闭，异常</li>
</ul>
</li>
<li>共同逻辑<ul>
<li>加锁double-check，如果channel  已关闭，异常</li>
<li>如果已经有读G在等待，说明buf为空，把数据给队列的第一个读G并唤醒，返回</li>
<li>buf未满，写入下一个空位置，更新索引、计数器，返回</li>
<li>buf已满，非阻塞返回写入失败，阻塞则把当前G封装到sudog放进写队列，挂起等待</li>
<li>被唤醒后<ul>
<li>如果是因为channel  被关闭导致的唤醒，异常</li>
<li>数据已被读G拿走，清理收尾</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传递数据到channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 非阻塞-select</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;chansend: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞-select and channel未关闭 and buf已满</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 写入</span></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已关闭，异常</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经有读G在等待，说明buf为空，把数据给队列的第一个G并唤醒</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下场景：0 &lt;= buf_len &lt;= cap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf未满</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// 获取buf下一个可写入的地址</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        <span class="comment">// 写索引</span></span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素个数</span></span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf已满</span></span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="comment">// 加上上面的channel未关闭、buf已满，可以当作是double-check</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，挂起等待</span></span><br><span class="line">    <span class="comment">// Ps. 下面这交叉写看的好乱</span></span><br><span class="line">    gp := getg()                    <span class="comment">// 当前G</span></span><br><span class="line">    mysg := acquireSudog()          <span class="comment">// sudog</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span>            <span class="comment">// 纪录G在channel上阻塞的耗时</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    mysg.elem = ep                  <span class="comment">// x元素指针（c &lt;- x)</span></span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span>             <span class="comment">// ？</span></span><br><span class="line">    mysg.g = gp                     <span class="comment">// 把当前G放到sudog的g，双向绑定</span></span><br><span class="line">    mysg.isSelect = <span class="literal">false</span>           <span class="comment">// 非select操作</span></span><br><span class="line">    mysg.c = c                      <span class="comment">// channel</span></span><br><span class="line">    gp.waiting = mysg               <span class="comment">// 把sudog放到当前G的waiting，双向绑定</span></span><br><span class="line">    gp.param = <span class="literal">nil</span>                  <span class="comment">// 重置sudog指针</span></span><br><span class="line">    c.sendq.enqueue(mysg)           <span class="comment">// 把sudog放进队列</span></span><br><span class="line">    gp.parkingOnChan.Store(<span class="literal">true</span>)    <span class="comment">// 是否阻塞在channel</span></span><br><span class="line">    reason := waitReasonChanSend</span><br><span class="line">    <span class="keyword">if</span> c.synctest &#123;</span><br><span class="line">        reason = waitReasonSynctestChanSend</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起</span></span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), reason, traceBlockChanSend, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保x元素还活着</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向绑定异常</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span>                <span class="comment">// 当前G移除sudog绑定</span></span><br><span class="line">    gp.activeStackChans = <span class="literal">false</span>     <span class="comment">// 是否在等待channel操作</span></span><br><span class="line">    closed := !mysg.success         <span class="comment">// 关闭channel时设置为false，其他情况为true</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 纪录阻塞事件</span></span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span>                    <span class="comment">// 移除channel绑定</span></span><br><span class="line">    releaseSudog(mysg)              <span class="comment">// 删除sudog</span></span><br><span class="line">    <span class="comment">// 因为channel被关闭而导致的唤醒</span></span><br><span class="line">    <span class="keyword">if</span> closed &#123;、</span><br><span class="line">        <span class="comment">// 状态不匹配</span></span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已关闭channel不可写入</span></span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送元素value给读G并将其唤醒，buf为空才会走到这里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// synctest，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; sg.g.syncGroup != getg().syncGroup &#123;</span><br><span class="line">        unlockf()</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sg =&gt; 从recvq拿到的，ep =&gt; x元素指针（c &lt;- x)</span></span><br><span class="line">    <span class="comment">// y元素指针（y := &lt;- c)，如果是丢弃数值则不处理 =&gt; &lt;- c</span></span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep)</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读G</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    <span class="comment">// 纪录读sudog写到param</span></span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    sg.success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒读G</span></span><br><span class="line">    <span class="comment">// 将g放到本地队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// sg =&gt; 从recvq获取的</span></span><br><span class="line">    <span class="comment">// 元素指针</span></span><br><span class="line">    dst := sg.elem</span><br><span class="line">    typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.Size_)</span><br><span class="line">    <span class="comment">// 复制数据</span></span><br><span class="line">    memmove(dst, src, t.Size_)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine被挂起休眠之前调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanparkcommit</span><span class="params">(gp *g, chanLock unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    gp.activeStackChans = <span class="literal">true</span>      <span class="comment">// 是否在等待channel操作</span></span><br><span class="line">    gp.parkingOnChan.Store(<span class="literal">false</span>)   <span class="comment">// 是否阻塞在channel</span></span><br><span class="line">    unlock((*mutex)(chanLock))      <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把sudog放进队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *waitq)</span></span> enqueue(sgp *sudog) &#123;</span><br><span class="line">    sgp.next = <span class="literal">nil</span></span><br><span class="line">    x := q.last</span><br><span class="line">    <span class="comment">// 队列为空</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        sgp.prev = <span class="literal">nil</span></span><br><span class="line">        q.first = sgp</span><br><span class="line">        q.last = sgp</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    sgp.prev = x</span><br><span class="line">    x.next = sgp</span><br><span class="line">    q.last = sgp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把sudog移出队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *waitq)</span></span> dequeue() *sudog &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 从头部开始</span></span><br><span class="line">        sgp := q.first</span><br><span class="line">        <span class="comment">// 队列为空</span></span><br><span class="line">        <span class="keyword">if</span> sgp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// next</span></span><br><span class="line">        y := sgp.next</span><br><span class="line">        <span class="comment">// 队列只有一个数据</span></span><br><span class="line">        <span class="keyword">if</span> y == <span class="literal">nil</span> &#123;</span><br><span class="line">            q.first = <span class="literal">nil</span></span><br><span class="line">            q.last = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 队列有多个数据</span></span><br><span class="line">            y.prev = <span class="literal">nil</span></span><br><span class="line">            q.first = y</span><br><span class="line">            sgp.next = <span class="literal">nil</span> <span class="comment">// mark as removed (see dequeueSudoG)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了一个sudog，但还有一个问题需要判断</span></span><br><span class="line">        <span class="comment">// G被select唤醒时，可能还未被移出队列</span></span><br><span class="line">        <span class="keyword">if</span> sgp.isSelect &#123;</span><br><span class="line">            <span class="keyword">if</span> !sgp.g.selectDone.CompareAndSwap(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// We lost the race to wake this goroutine.</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sgp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>如何从channel接收数据？当使用代码<code>&lt;- c</code>时，系统将根据返回值编译为对chanrecv1或chanrecv2的调用；当使用select接收数据时，编译为对selectnbrecv的调用；而这三个函数最终会调用chanrecv</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `&lt;- c` 或 `y := &lt;- c`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `y, ok := &lt;- c`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">    _, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select代码块</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    select &#123;</span></span><br><span class="line"><span class="comment">//    case v, ok = &lt;-c:</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    default:</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 编译为如下代码</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    if selected, ok = selectnbrecv(&amp;v, c); selected &#123;</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chanrecv代码如下，具体逻辑为</p>
<ol>
<li>select场景，非阻塞<ul>
<li>如果  channel  未初始化或已关闭或buf为空，无数据，返回</li>
</ul>
</li>
<li>c &lt;- v场景，阻塞<ul>
<li>如果channel  未初始化，异常</li>
</ul>
</li>
<li>共同逻辑<ul>
<li>加锁double-check</li>
<li>如果channel  已关闭且buf为空，无数据，返回</li>
<li>如果已经有写G在等待，说明buf已满，读取队列的第一个写G并唤醒，返回</li>
<li>buf不为空，读循环队列，更新索引、计数器，返回</li>
<li>buf为空，非阻塞则返回读取失败，阻塞则把当前G封装到sudog放进读队列，挂起等待<ul>
<li>数据已从写G读到，清理收尾</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;chanrecv: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;receive on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步timer（&lt;=go1.22)</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line">        c.timer.maybeRunChan()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞 and buf为空</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line">        <span class="comment">// channel未关闭</span></span><br><span class="line">        <span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已关闭</span></span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="keyword">if</span> empty(c) &#123;</span><br><span class="line">            <span class="comment">// `y := &lt;- c` =&gt; ep不为nil，`&lt;- c` =&gt; ep为nil</span></span><br><span class="line">            <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">                typedmemclr(c.elemtype, ep)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 读取</span></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已关闭</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// buf为空</span></span><br><span class="line">        <span class="keyword">if</span> c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">            unlock(&amp;c.lock)</span><br><span class="line">            <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">                typedmemclr(c.elemtype, ep)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// channel已关闭但buf还有数据 0 &lt; buf_len &lt;= cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已经有写G在等待，说明buf已满，读取buf第一个数据，队列的第一个写G数据补上buf然后唤醒</span></span><br><span class="line">        <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">            recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// buf未满 0 &lt;= buf_len &lt; cap</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下场景：0 &lt;= buf_len &lt;= cap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf不为空</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取buf下一个可读取的地址</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemclr(c.elemtype, qp)</span><br><span class="line">        <span class="comment">// 读索引</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素个数</span></span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf为空</span></span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="comment">// 可以理解为加锁后的double-check</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，挂起等待</span></span><br><span class="line">    gp := getg()                    <span class="comment">// 当前G</span></span><br><span class="line">    mysg := acquireSudog()          <span class="comment">// 获取sudog</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span>            <span class="comment">// 纪录G在channel上阻塞的耗时</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    mysg.elem = ep                  <span class="comment">// y元素指针（y := &lt;- c)</span></span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span>             <span class="comment">// ？</span></span><br><span class="line">    gp.waiting = mysg               <span class="comment">// 把sudog放到当前G的waiting，双向绑定</span></span><br><span class="line">    mysg.g = gp                     <span class="comment">// 把当前G放到sudog的g，双向绑定</span></span><br><span class="line">    mysg.isSelect = <span class="literal">false</span>           <span class="comment">// 非select操作</span></span><br><span class="line">    mysg.c = c                      <span class="comment">// channel</span></span><br><span class="line">    gp.param = <span class="literal">nil</span>                  <span class="comment">// 重置sudog指针</span></span><br><span class="line">    c.recvq.enqueue(mysg)           <span class="comment">// 把sudog放进队列</span></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// G挂起休眠之前，将定时器标记为阻塞并加入最小堆</span></span><br><span class="line">        blockTimerChan(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp.parkingOnChan.Store(<span class="literal">true</span>)    <span class="comment">// 是否阻塞在channel</span></span><br><span class="line">    reason := waitReasonChanReceive</span><br><span class="line">    <span class="keyword">if</span> c.synctest &#123;</span><br><span class="line">        reason = waitReasonSynctestChanReceive</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起</span></span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), reason, traceBlockChanRecv, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向绑定异常</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// G唤醒后，将定时器标记为非阻塞、删除状态</span></span><br><span class="line">        unblockTimerChan(c)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span>                <span class="comment">// 当前G移除sudog绑定</span></span><br><span class="line">    gp.activeStackChans = <span class="literal">false</span>     <span class="comment">// 是否在等待channel操作</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 纪录阻塞事件</span></span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    success := mysg.success         <span class="comment">// 关闭channel时设置为false，其他情况为true</span></span><br><span class="line">    gp.param = <span class="literal">nil</span>                  <span class="comment">// 重置sudog指针</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span>                    <span class="comment">// 移除channel绑定</span></span><br><span class="line">    releaseSudog(mysg)              <span class="comment">// 释放sudog</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从写G读取元素value并将其唤醒，buf已满才会走到这里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// synctest，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; sg.g.syncGroup != getg().syncGroup &#123;</span><br><span class="line">        unlockf()</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;receive on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sg =&gt; 从sendq拿到的，ep =&gt; y元素指针（y := &lt;- c)</span></span><br><span class="line">    <span class="comment">// 无缓冲channel</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            recvDirect(c.elemtype, sg, ep)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有缓冲channel</span></span><br><span class="line">        <span class="comment">// buf已满</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="comment">// 把数组第一个可读元素复制给读G</span></span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把写G的数据复制到这个位置上，补充数组元素</span></span><br><span class="line">        typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">        <span class="comment">// 读索引</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写索引，既然buf已满，读跟写的位置自然一样</span></span><br><span class="line">        c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写G的数据已经复制到buf上了</span></span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 写G</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    <span class="comment">// 写G的sudog放到param</span></span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="comment">// 关闭channel时设置为false，其他情况为true</span></span><br><span class="line">    sg.success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒写G</span></span><br><span class="line">    <span class="comment">// 将g放到本地队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// sg =&gt; 从sendq获取的</span></span><br><span class="line">    <span class="comment">// 元素指针</span></span><br><span class="line">    src := sg.elem</span><br><span class="line">    typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.Size_)</span><br><span class="line">    memmove(dst, src, t.Size_)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h2><p>关闭channel  ，具体逻辑如下</p>
<ol>
<li>如果channel  未初始化或已关闭，异常</li>
<li>channel  设为已关闭closed&#x3D;1</li>
<li>收集并唤醒所有在读写队列的G（写G会抛出异常）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 已关闭，异常</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭channel</span></span><br><span class="line">    c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集所有在读写队列里的G</span></span><br><span class="line">    <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有读G</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.recvq.dequeue()</span><br><span class="line">        <span class="comment">// 没数据，退出</span></span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">            sg.elem = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = unsafe.Pointer(sg)</span><br><span class="line">        sg.success = <span class="literal">false</span></span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有写G</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.sendq.dequeue()</span><br><span class="line">        <span class="comment">// 没数据，退出</span></span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = unsafe.Pointer(sg)</span><br><span class="line">        sg.success = <span class="literal">false</span></span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有G</span></span><br><span class="line">    <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">        gp := glist.pop()</span><br><span class="line">        gp.schedlink = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 将g放到本地队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        goready(gp, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取channel-数据量"><a href="#获取channel-数据量" class="headerlink" title="获取channel  数据量"></a>获取channel  数据量</h2><p>当调用<code>len(c)</code>时，系统调用chanlen实现，具体逻辑如下</p>
<ol>
<li>未初始化的channel  数据量为0</li>
<li>如果是异步timer，返回qcount的数值</li>
<li>如果是同步timer，返回0</li>
<li>其他情况一律返回channel  字段qcount的数值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanlen</span><span class="params">(c *hchan)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// asynctimerchan=0 =&gt; 如果是go1.23版本及以后</span></span><br><span class="line">    <span class="comment">// asynctimerchan=1 =&gt; 如果是go1.22版本及以前</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 异步timer（&lt;=go1.22)</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &amp;&amp; async &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line">        c.timer.maybeRunChan()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步timer（&gt;=go1.23)，dirty hack，让timer的len一直为0</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &amp;&amp; !async &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(c.qcount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取channel-容量"><a href="#获取channel-容量" class="headerlink" title="获取channel  容量"></a>获取channel  容量</h2><p>当调用<code>cap(c)</code>时，系统调用chancap实现，具体逻辑如下</p>
<ol>
<li>未初始化的channel  容量为0</li>
<li>如果是异步timer，返回dataqsiz的数值</li>
<li>如果是同步timer，返回0</li>
<li>其他情况一律返回channel  字段dataqsiz的数值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chancap</span><span class="params">(c *hchan)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// asynctimerchan=0 =&gt; 如果是go1.23版本及以后</span></span><br><span class="line">        <span class="comment">// asynctimerchan=1 =&gt; 如果是go1.22版本及以前</span></span><br><span class="line">        async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> async &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">int</span>(c.dataqsiz)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同步timer（&gt;=go1.23)，dirty hack，让timer的cap一直为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(c.dataqsiz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器相关"><a href="#定时器相关" class="headerlink" title="定时器相关"></a>定时器相关</h2><h3 id="maybeRunChan"><a href="#maybeRunChan" class="headerlink" title="maybeRunChan"></a>maybeRunChan</h3><p>判断是否需要更新timer状态、执行函数f。具体逻辑如下</p>
<ol>
<li>不满足条件则返回<ul>
<li>timer已经放在最小堆上，那么过期后自动发送到channel</li>
<li>timer从未执行过</li>
<li>timer还未到触发时刻</li>
</ul>
</li>
<li>满足条件则更新timer状态、执行函数f</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeRunChan() &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="keyword">var</span> timerGroup *synctestGroup</span><br><span class="line">        <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">            timerGroup = t.ts.syncGroup</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        sg := getg().syncGroup</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;synctest timer accessed from outside bubble&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> timerGroup != <span class="literal">nil</span> &amp;&amp; sg != timerGroup &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;timer moved between synctest bubbles&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果timer已经在最小堆中，过期后自动发送到channel</span></span><br><span class="line">    <span class="keyword">if</span> t.astate.Load()&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 当前时刻，单调时钟</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 加锁后double-check</span></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer从未执行过</span></span><br><span class="line">    <span class="comment">// 3. timer还未到触发时刻</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> || t.when == <span class="number">0</span> || t.when &gt; now &#123;</span><br><span class="line">        <span class="comment">// debug用，忽略</span></span><br><span class="line">        t.trace(<span class="string">&quot;maybeRunChan-&quot;</span>)</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;maybeRunChan+&quot;</span>)</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">        t.unlockAndRun(now)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="blockTimerChan-unblockTimerChan"><a href="#blockTimerChan-unblockTimerChan" class="headerlink" title="blockTimerChan &amp; unblockTimerChan"></a>blockTimerChan &amp; unblockTimerChan</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个10ms过期的定时器</span></span><br><span class="line">t := time.NewTimer(<span class="number">10</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待定时器过期信号</span></span><br><span class="line">&lt;-t.C</span><br></pre></td></tr></table></figure>

<p>上述示例代码，如果这个channel是属于一个定时器的，那么在G挂起前、唤醒后，需要修改定时器的state-状态、blocked-标记等。函数详细注释如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// G挂起休眠之前，将定时器标记为阻塞并加入最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;blockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer已标记删除</span></span><br><span class="line">    <span class="comment">// 3. 过期时刻大于0</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie != <span class="number">0</span> &amp;&amp; t.when &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t.state &amp;^= timerZombie <span class="comment">// 移除标志位</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">-1</span>)    <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要把定时器放到timers.heap</span></span><br><span class="line">    add := t.needsAdd()</span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line">        t.maybeAdd()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G唤醒后，将定时器标记为非阻塞、删除状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unblockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;unblockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器 or 计数器为0，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan || t.blocked == <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器为0 and timer已经在最小堆中 and timer无删除标记</span></span><br><span class="line">    <span class="keyword">if</span> t.blocked == <span class="number">0</span> &amp;&amp; t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 标记为删除</span></span><br><span class="line">        t.state |= timerZombie</span><br><span class="line">        <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">6.4 Channel</a><br><a href="https://www.youtube.com/watch?v=KBZlN0izeiY">GopherCon 2017: Kavya Joshi - Understanding Channels</a><br><a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8">Diving Deep Into The Golang Channels.</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Map(HashTrieMap)</title>
    <url>/golang-series-hashtriemap/</url>
    <content><![CDATA[<p>从1.24版开始，sync.Map改用HashTrieMap重构，与之前的双map实现不同，HashTrieMap更像是一个B树，简单的示例图如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  root -&gt; | idx0    | idx1       | ... | idx15 |</span></span><br><span class="line"><span class="comment">//          | &amp;entry0 | &amp;indirect0 | ... | nil   |</span></span><br><span class="line"><span class="comment">//                          |</span></span><br><span class="line"><span class="comment">//                       children</span></span><br><span class="line"><span class="comment">//                          v</span></span><br><span class="line"><span class="comment">//                    | idx0 | idx1    | ... | idx15 |</span></span><br><span class="line"><span class="comment">//                    | nil  | &amp;entry1 | ... | nil   |</span></span><br></pre></td></tr></table></figure>

<p>使用哈希函数生成64位的哈希值，从高到低4位为一个idx，最多有16层，每个节点可容纳16个元素，最多可容纳16^16&#x3D;2^64个元素</p>
<p>当前go版本：1.24</p>
<blockquote>
<p>HashTrieMap的开关放在文件<code>src/internal/buildcfg/exp.go</code>的函数<code>ParseGOEXPERIMENT</code>中</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HashTrieMap[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    inited   atomic.Uint32                          <span class="comment">// 是否已初始化</span></span><br><span class="line">    initMu   Mutex                                  <span class="comment">// 锁，用于初始化</span></span><br><span class="line">    root     atomic.Pointer[indirect[K, V]]         <span class="comment">// 根节点</span></span><br><span class="line">    keyHash  hashFunc                               <span class="comment">// 哈希函数，用于key</span></span><br><span class="line">    valEqual equalFunc                              <span class="comment">// cmp函数，用于value</span></span><br><span class="line">    seed     <span class="type">uintptr</span>                                <span class="comment">// 哈希种子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部节点</span></span><br><span class="line"><span class="keyword">type</span> indirect[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    node[K, V]                                      <span class="comment">// isEntry=false</span></span><br><span class="line">    dead     atomic.Bool                            <span class="comment">// 是否被删除</span></span><br><span class="line">    mu       Mutex                                  <span class="comment">// 锁，用于children</span></span><br><span class="line">    parent   *indirect[K, V]                        <span class="comment">// 父节点指针</span></span><br><span class="line">    children [nChildren]atomic.Pointer[node[K, V]]  <span class="comment">// 16个子节点，指向indirect或entry</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点</span></span><br><span class="line"><span class="keyword">type</span> entry[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    node[K, V]                                      <span class="comment">// isEntry=true</span></span><br><span class="line">    overflow atomic.Pointer[entry[K, V]]            <span class="comment">// 指针，当两个entry哈希值相同时以链表方式存储</span></span><br><span class="line">    key      K                                      <span class="comment">// 键</span></span><br><span class="line">    value    V                                      <span class="comment">// 值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry和indirect的共有属性</span></span><br><span class="line"><span class="keyword">type</span> node[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    isEntry <span class="type">bool</span>                                    <span class="comment">// 判断是叶子节点还是内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>根据key获取value，具体逻辑如下</p>
<ol>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，即没找到，返回</li>
<li>如果子节点是叶子节点，搜索链表并返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Load(key K) (value V, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">    i := ht.root.Load()</span><br><span class="line">    <span class="comment">// hashShift=64 =&gt; 64/4=16，整个trie最多有16层</span></span><br><span class="line">    hashShift := <span class="number">8</span> * goarch.PtrSize</span><br><span class="line">    <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// hashShift-=4</span></span><br><span class="line">        hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">        n := i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask].Load()</span><br><span class="line">        <span class="comment">// 子节点为nil，返回空值</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> n.isEntry &#123;</span><br><span class="line">            <span class="comment">// 搜索链表</span></span><br><span class="line">            <span class="keyword">return</span> n.entry().lookup(key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// curr指针指向子节点</span></span><br><span class="line">        i = n.indirect()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> init() &#123;</span><br><span class="line">    <span class="keyword">if</span> ht.inited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 未初始化</span></span><br><span class="line">        ht.initSlow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> initSlow() &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    ht.initMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> ht.initMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="keyword">if</span> ht.inited.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 其他G在当前G等待时已经初始化了</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[K]V                               <span class="comment">// 临时map</span></span><br><span class="line">    mapType := abi.TypeOf(m).MapType()          <span class="comment">// 获取maptype</span></span><br><span class="line">    ht.root.Store(newIndirectNode[K, V](<span class="literal">nil</span>))   <span class="comment">// parent=nil</span></span><br><span class="line">    ht.keyHash = mapType.Hasher                 <span class="comment">// 复制map的哈希函数</span></span><br><span class="line">    ht.valEqual = mapType.Elem.Equal            <span class="comment">// 复制map的cmp函数</span></span><br><span class="line">    ht.seed = <span class="type">uintptr</span>(runtime_rand())           <span class="comment">// 生成哈希种子</span></span><br><span class="line"></span><br><span class="line">    ht.inited.Store(<span class="number">1</span>)                          <span class="comment">// inited设为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成内部节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newIndirectNode</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(parent *indirect[K, V])</span></span> *indirect[K, V] &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;indirect[K, V]&#123;node: node[K, V]&#123;isEntry: <span class="literal">false</span>&#125;, parent: parent&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表搜索key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry[K, V])</span></span> lookup(key K) (V, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &#123;</span><br><span class="line">            <span class="keyword">return</span> e.value, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>存储key&#x2F;value。本质就是Swap方法，但丢弃其返回值，具体看Swap</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Store(key K, old V) &#123;</span><br><span class="line">    _, _ = ht.Swap(key, old)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadOrStore"><a href="#LoadOrStore" class="headerlink" title="LoadOrStore"></a>LoadOrStore</h3><p>根据key获取value，获取失败则保存key&#x2F;value，具体逻辑如下</p>
<ol>
<li>Load<ul>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则返回</li>
</ul>
</li>
<li>Store<ul>
<li>纪录搜索中断位置的curr节点指针i和子节点指针slot、n</li>
<li>如果n为nil，直接写入children</li>
<li>如果n为叶子节点，放进链表，或者分裂后再存储进children</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> LoadOrStore(key K, value V) (result V, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i *indirect[K, V]                   <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">    <span class="keyword">var</span> hashShift <span class="type">uint</span>                      <span class="comment">// 用于计算idx</span></span><br><span class="line">    <span class="keyword">var</span> slot *atomic.Pointer[node[K, V]]    <span class="comment">// 子节点指针的指针</span></span><br><span class="line">    <span class="keyword">var</span> n *node[K, V]                       <span class="comment">// 子节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Load</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">        i = ht.root.Load()</span><br><span class="line">        <span class="comment">// hashShift=64 =&gt; 64/4=16，整个trie最多有16层</span></span><br><span class="line">        hashShift = <span class="number">8</span> * goarch.PtrSize</span><br><span class="line">        <span class="comment">// 当前循环是否已经找到写入点</span></span><br><span class="line">        haveInsertPoint := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// hashShift-=4</span></span><br><span class="line">            hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取子节点指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">            slot = &amp;i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask]</span><br><span class="line">            n = slot.Load()</span><br><span class="line">            <span class="comment">// 子节点为nil，可写入，结束循环</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">                haveInsertPoint = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> n.isEntry &#123;</span><br><span class="line">                <span class="comment">// 搜索链表 -&gt; Load</span></span><br><span class="line">                <span class="keyword">if</span> v, ok := n.entry().lookup(key); ok &#123;</span><br><span class="line">                    <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 叶子节点默认可写</span></span><br><span class="line">                haveInsertPoint = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = n.indirect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> !haveInsertPoint &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        i.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        n = slot.Load()</span><br><span class="line">        <span class="comment">// 子节点为nil或叶子节点 and 当前节点未删除</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nil</span> || n.isEntry) &amp;&amp; !i.dead.Load() &#123;</span><br><span class="line">            <span class="comment">// 确认可写入，slot查找结束</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Load失败，改为Store</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在for循环里已经加锁了</span></span><br><span class="line">    <span class="keyword">defer</span> i.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oldEntry *entry[K, V]</span><br><span class="line">    <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">        oldEntry = n.entry()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="keyword">if</span> v, ok := oldEntry.lookup(key); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建叶子节点</span></span><br><span class="line">    newEntry := newEntryNode(key, value)</span><br><span class="line">    <span class="comment">// 原子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> oldEntry == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接存储</span></span><br><span class="line">        slot.Store(&amp;newEntry.node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 原子节点为叶子节点</span></span><br><span class="line">        <span class="comment">// 放进链表，或者分裂后再存储进children</span></span><br><span class="line">        slot.Store(ht.expand(oldEntry, newEntry, hash, hashShift, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> expand(oldEntry, newEntry *entry[K, V], newHash <span class="type">uintptr</span>, hashShift <span class="type">uint</span>, parent *indirect[K, V]) *node[K, V] &#123;</span><br><span class="line">    <span class="comment">// 哈希碰撞</span></span><br><span class="line">    oldHash := ht.keyHash(unsafe.Pointer(&amp;oldEntry.key), ht.seed)</span><br><span class="line">    <span class="comment">// 1. 新旧哈希值相同</span></span><br><span class="line">    <span class="keyword">if</span> oldHash == newHash &#123;</span><br><span class="line">        <span class="comment">// 放进链表开头</span></span><br><span class="line">        newEntry.overflow.Store(oldEntry)</span><br><span class="line">        <span class="keyword">return</span> &amp;newEntry.node</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 新旧哈希值不同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建内部节点</span></span><br><span class="line">    newIndirect := newIndirectNode(parent)</span><br><span class="line">    <span class="comment">// 纪录父节点</span></span><br><span class="line">    top := newIndirect</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> hashShift == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while inserting&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hashShift-=4</span></span><br><span class="line">        hashShift -= nChildrenLog2</span><br><span class="line">        <span class="comment">// 从高到低，找到两个哈希值不同的4位</span></span><br><span class="line">        oi := (oldHash &gt;&gt; hashShift) &amp; nChildrenMask</span><br><span class="line">        ni := (newHash &gt;&gt; hashShift) &amp; nChildrenMask</span><br><span class="line">        <span class="comment">// idx不同</span></span><br><span class="line">        <span class="keyword">if</span> oi != ni &#123;</span><br><span class="line">            newIndirect.children[oi].Store(&amp;oldEntry.node)</span><br><span class="line">            newIndirect.children[ni].Store(&amp;newEntry.node)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// idx相同</span></span><br><span class="line">        <span class="comment">// 把oldEntry向下挪动一层</span></span><br><span class="line">        nextIndirect := newIndirectNode(newIndirect)</span><br><span class="line">        newIndirect.children[oi].Store(&amp;nextIndirect.node)</span><br><span class="line">        newIndirect = nextIndirect</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回top节点</span></span><br><span class="line">    <span class="keyword">return</span> &amp;top.node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntryNode</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(key K, value V)</span></span> *entry[K, V] &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;entry[K, V]&#123;</span><br><span class="line">        node:  node[K, V]&#123;isEntry: <span class="literal">true</span>&#125;,</span><br><span class="line">        key:   key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>删除指定key，具体看LoadAndDelete</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Delete(key K) &#123;</span><br><span class="line">    _, _ = ht.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadAndDelete"><a href="#LoadAndDelete" class="headerlink" title="LoadAndDelete"></a>LoadAndDelete</h3><p>根据key获取value并删除该key，具体逻辑如下</p>
<ol>
<li>Load<ul>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，返回</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则纪录起来</li>
</ul>
</li>
<li>Delete<ul>
<li>纪录子节点位置的curr节点指针i和子节点指针slot、n</li>
<li>如果删除key后，叶子节点链表不为空，回写并返回</li>
<li>如果删除key后，叶子节点链表为空，从curr开始往上搜索删除空的节点</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> LoadAndDelete(key K) (value V, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key和value查找子节点，返回curr节点指针i、子节点索引idx、子节点指针slot、n</span></span><br><span class="line">    i, hashShift, slot, n := ht.find(key, hash, <span class="literal">nil</span>, *<span class="built_in">new</span>(V))</span><br><span class="line">    <span class="comment">// 子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 子节点被删除</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">            i.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点获取并删除指定key，返回旧值v、链表头e、是否成功获取loaded</span></span><br><span class="line">    v, e, loaded := n.entry().loadAndDelete(key)</span><br><span class="line">    <span class="comment">// 获取key失败</span></span><br><span class="line">    <span class="keyword">if</span> !loaded &#123;</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除key后，链表不为空</span></span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 回写</span></span><br><span class="line">        slot.Store(&amp;e.node)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除key后，链表为空，把叶子节点也删掉</span></span><br><span class="line">    slot.Store(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从curr开始往上搜索删除空的节点</span></span><br><span class="line">    <span class="comment">// curr节点的父节点不为nil and curr节点没有子节点</span></span><br><span class="line">    <span class="keyword">for</span> i.parent != <span class="literal">nil</span> &amp;&amp; i.empty() &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> hashShift == <span class="number">8</span>*goarch.PtrSize &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hashShift+=4</span></span><br><span class="line">        hashShift += nChildrenLog2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在父节点删除curr节点</span></span><br><span class="line">        parent := i.parent</span><br><span class="line">        parent.mu.Lock()</span><br><span class="line">        i.dead.Store(<span class="literal">true</span>)</span><br><span class="line">        parent.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask].Store(<span class="literal">nil</span>)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        i = parent</span><br><span class="line">    &#125;</span><br><span class="line">    i.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key和value查找子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> find(key K, hash <span class="type">uintptr</span>, valEqual equalFunc, value V) (i *indirect[K, V], hashShift <span class="type">uint</span>, slot *atomic.Pointer[node[K, V]], n *node[K, V]) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">        i = ht.root.Load()</span><br><span class="line">        hashShift = <span class="number">8</span> * goarch.PtrSize <span class="comment">// 64</span></span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 找到i和n</span></span><br><span class="line">        <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// hashShift-=4</span></span><br><span class="line">            hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">            slot = &amp;i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask]</span><br><span class="line">            n = slot.Load()</span><br><span class="line">            <span class="comment">// 子节点为nil</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">                i = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> n.isEntry &#123;</span><br><span class="line">                <span class="comment">// 根据key和value比对搜索</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := n.entry().lookupWithValue(key, value, valEqual); !ok &#123;</span><br><span class="line">                    i = <span class="literal">nil</span></span><br><span class="line">                    n = <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到了</span></span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = n.indirect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">if</span> !found &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到了</span></span><br><span class="line"></span><br><span class="line">        i.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        n = slot.Load()</span><br><span class="line">        <span class="comment">// 当前节点未删除</span></span><br><span class="line">        <span class="keyword">if</span> !i.dead.Load() &amp;&amp; (n == <span class="literal">nil</span> || n.isEntry) &#123;</span><br><span class="line">            <span class="comment">// 不管现在子节点是什么状态</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新扫描</span></span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key和value比对搜索</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry[K, V])</span></span> lookupWithValue(key K, value V, valEqual equalFunc) (V, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 比对key和value</span></span><br><span class="line">        <span class="keyword">if</span> e.key == key &amp;&amp; (valEqual == <span class="literal">nil</span> || valEqual(unsafe.Pointer(&amp;e.value), abi.NoEscape(unsafe.Pointer(&amp;value)))) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.value, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> loadAndDelete(key K) (V, *entry[K, V], <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> head.value, head.overflow.Load(), <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &#123;</span><br><span class="line">            <span class="comment">// 移除当前节点 =&gt; 使prev指向next</span></span><br><span class="line">            i.Store(e.overflow.Load())</span><br><span class="line">            <span class="keyword">return</span> e.value, head, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回零值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">new</span>(V), head, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点是否有children</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *indirect[K, V])</span></span> empty() <span class="type">bool</span> &#123;</span><br><span class="line">    nc := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> i.children &#123;</span><br><span class="line">        <span class="keyword">if</span> i.children[j].Load() != <span class="literal">nil</span> &#123;</span><br><span class="line">            nc++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nc == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndDelete"><a href="#CompareAndDelete" class="headerlink" title="CompareAndDelete"></a>CompareAndDelete</h3><p>根据key和value搜索，如找到则删除该数据，具体逻辑如下</p>
<ol>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，返回</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则删除</li>
<li>如果删除key后，叶子节点链表不为空，回写并返回</li>
<li>如果删除key后，叶子节点链表为空，从curr开始往上搜索删除空的节点</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> CompareAndDelete(key K, old V) (deleted <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// value对比函数不能为空 =&gt; 类型无法比对</span></span><br><span class="line">    <span class="keyword">if</span> ht.valEqual == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;called CompareAndDelete when value is not of comparable type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key和value查找子节点，返回curr节点指针i、子节点索引idx、子节点指针slot、n</span></span><br><span class="line">    i, hashShift, slot, n := ht.find(key, hash, <span class="literal">nil</span>, *<span class="built_in">new</span>(V))</span><br><span class="line">    <span class="comment">// 子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 被删除</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">            i.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点比对并删除指定key/value，返回链表头e、是否成功删除deleted</span></span><br><span class="line">    e, deleted := n.entry().compareAndDelete(key, old, ht.valEqual)</span><br><span class="line">    <span class="comment">// 删除失败</span></span><br><span class="line">    <span class="keyword">if</span> !deleted &#123;</span><br><span class="line">        <span class="comment">// Nothing was actually deleted, which means the node is no longer there.</span></span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除key后，链表不为空</span></span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 回写</span></span><br><span class="line">        slot.Store(&amp;e.node)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除key后，链表为空，把叶子节点也删掉</span></span><br><span class="line">    slot.Store(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从curr开始往上搜索删除空的节点</span></span><br><span class="line">    <span class="comment">// curr节点的父节点不为nil and curr节点没有子节点</span></span><br><span class="line">    <span class="keyword">for</span> i.parent != <span class="literal">nil</span> &amp;&amp; i.empty() &#123;</span><br><span class="line">        <span class="keyword">if</span> hashShift == <span class="number">8</span>*goarch.PtrSize &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hashShift+=4</span></span><br><span class="line">        hashShift += nChildrenLog2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在父节点中删除当前节点</span></span><br><span class="line">        parent := i.parent</span><br><span class="line">        parent.mu.Lock()</span><br><span class="line">        i.dead.Store(<span class="literal">true</span>)</span><br><span class="line">        parent.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask].Store(<span class="literal">nil</span>)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        i = parent</span><br><span class="line">    &#125;</span><br><span class="line">    i.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> compareAndDelete(key K, value V, valEqual equalFunc) (*entry[K, V], <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;head.value), abi.NoEscape(unsafe.Pointer(&amp;value))) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.overflow.Load(), <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;e.value), abi.NoEscape(unsafe.Pointer(&amp;value))) &#123;</span><br><span class="line">            <span class="comment">// 移除当前节点 =&gt; prev指向next</span></span><br><span class="line">            i.Store(e.overflow.Load())</span><br><span class="line">            <span class="keyword">return</span> head, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>用新的value替换旧的value，具体逻辑如下</p>
<ol>
<li>查找可替换key的位置<ul>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点为nil或叶子节点，且当前节点未被删除，纪录位置信息，结束查找</li>
</ul>
</li>
<li>替换value<ul>
<li>如果子节点是叶子节点，在链表查找并替换value，替换成功回写并返回</li>
<li>如果子节点是nil<ul>
<li>如果slot为空，直接写入</li>
<li>如果slot不为空，放进链表，或者分裂后再存储进children</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Swap(key K, <span class="built_in">new</span> V) (previous V, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i *indirect[K, V]                   <span class="comment">// curr节点指针，从根节点开始</span></span><br><span class="line">    <span class="keyword">var</span> hashShift <span class="type">uint</span>                      <span class="comment">// 用于计算idx</span></span><br><span class="line">    <span class="keyword">var</span> slot *atomic.Pointer[node[K, V]]    <span class="comment">// 子节点指针的指针</span></span><br><span class="line">    <span class="keyword">var</span> n *node[K, V]                       <span class="comment">// 子节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 查找可替换key的位置</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">        i = ht.root.Load()</span><br><span class="line">        <span class="comment">// hashShift=64 =&gt; 64/4=16，整个trie最多有16层</span></span><br><span class="line">        hashShift = <span class="number">8</span> * goarch.PtrSize</span><br><span class="line">        <span class="comment">// 当前循环是否已经找到写入点</span></span><br><span class="line">        haveInsertPoint := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// hashShift-=4</span></span><br><span class="line">            hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取子节点指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">            slot = &amp;i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask]</span><br><span class="line">            n = slot.Load()</span><br><span class="line">            <span class="comment">// 子节点为nil或叶子节点，可替换，结束循环</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> || n.isEntry &#123;</span><br><span class="line">                haveInsertPoint = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = n.indirect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> !haveInsertPoint &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        i.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        n = slot.Load()</span><br><span class="line">        <span class="comment">// 子节点为nil或叶子节点 and 当前节点未删除</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nil</span> || n.isEntry) &amp;&amp; !i.dead.Load() &#123;</span><br><span class="line">            <span class="comment">// 确认可替换，slot查找结束</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 替换value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在for循环里已经加锁了</span></span><br><span class="line">    <span class="keyword">defer</span> i.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> zero V</span><br><span class="line">    <span class="keyword">var</span> oldEntry *entry[K, V]</span><br><span class="line">    <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 替换value</span></span><br><span class="line">        oldEntry = n.entry()</span><br><span class="line">        newEntry, old, swapped := oldEntry.swap(key, <span class="built_in">new</span>)</span><br><span class="line">        <span class="keyword">if</span> swapped &#123;</span><br><span class="line">            <span class="comment">// 替换成功，回写</span></span><br><span class="line">            slot.Store(&amp;newEntry.node)</span><br><span class="line">            <span class="keyword">return</span> old, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建叶子节点</span></span><br><span class="line">    newEntry := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">    <span class="comment">// 原子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> oldEntry == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接存储</span></span><br><span class="line">        slot.Store(&amp;newEntry.node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 原子节点为叶子节点</span></span><br><span class="line">        <span class="comment">// 放进链表，或者分裂后再存储进children</span></span><br><span class="line">        slot.Store(ht.expand(oldEntry, newEntry, hash, hashShift, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zero, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> swap(key K, <span class="built_in">new</span> V) (*entry[K, V], V, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &#123;</span><br><span class="line">        <span class="comment">// 替换entry</span></span><br><span class="line">        e := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">        <span class="keyword">if</span> chain := head.overflow.Load(); chain != <span class="literal">nil</span> &#123;</span><br><span class="line">            e.overflow.Store(chain)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e, head.value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &#123;</span><br><span class="line">            <span class="comment">// 替换当前节点</span></span><br><span class="line">            eNew := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">            eNew.overflow.Store(e.overflow.Load())</span><br><span class="line">            i.Store(eNew)</span><br><span class="line">            <span class="keyword">return</span> head, e.value, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回零值</span></span><br><span class="line">    <span class="keyword">var</span> zero V</span><br><span class="line">    <span class="keyword">return</span> head, zero, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h3><p>根据key和value搜索，如找到则用新的value替换旧的value，具体逻辑如下</p>
<ol>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，返回</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则替换</li>
<li>替换失败，直接返回；替换成功，回写并返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> CompareAndSwap(key K, old, <span class="built_in">new</span> V) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// value对比函数不能为空 =&gt; 类型无法比对</span></span><br><span class="line">    <span class="keyword">if</span> ht.valEqual == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;called CompareAndSwap when value is not of comparable type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key和value查找子节点，返回curr节点指针i、子节点索引idx、子节点指针slot、n</span></span><br><span class="line">    i, _, slot, n := ht.find(key, hash, ht.valEqual, old)</span><br><span class="line">    <span class="keyword">if</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点搜索并替换指定key/value，返回链表头e、是否成功交换swapped</span></span><br><span class="line">    e, swapped := n.entry().compareAndSwap(key, old, <span class="built_in">new</span>, ht.valEqual)</span><br><span class="line">    <span class="comment">// 替换失败</span></span><br><span class="line">    <span class="keyword">if</span> !swapped &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功，回写</span></span><br><span class="line">    slot.Store(&amp;e.node)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> compareAndSwap(key K, old, <span class="built_in">new</span> V, valEqual equalFunc) (*entry[K, V], <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;head.value), abi.NoEscape(unsafe.Pointer(&amp;old))) &#123;</span><br><span class="line">        e := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">        <span class="keyword">if</span> chain := head.overflow.Load(); chain != <span class="literal">nil</span> &#123;</span><br><span class="line">            e.overflow.Store(chain)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;e.value), abi.NoEscape(unsafe.Pointer(&amp;old))) &#123;</span><br><span class="line">            <span class="comment">// 替换当前节点</span></span><br><span class="line">            eNew := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">            eNew.overflow.Store(e.overflow.Load())</span><br><span class="line">            i.Store(eNew)</span><br><span class="line">            <span class="keyword">return</span> head, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>遍历整个HashTrieMap，逻辑如下</p>
<ol>
<li>从根节点开始遍历children</li>
<li>子节点为nil，跳过</li>
<li>子节点不是叶子节点，递归遍历children</li>
<li>子节点是叶子节点，遍历整个链表<ul>
<li>key&#x2F;value传递给用户自定义函数，失败中断整个遍历</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Range(yield <span class="function"><span class="keyword">func</span><span class="params">(K, V)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 遍历，从根节点开始</span></span><br><span class="line">    ht.iter(ht.root.Load(), yield)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> iter(i *indirect[K, V], yield <span class="function"><span class="keyword">func</span><span class="params">(key K, value V)</span></span> <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> i.children &#123;</span><br><span class="line">        n := i.children[j].Load()</span><br><span class="line">        <span class="comment">// 子节点为nil，继续下一个</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子节点不是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> !n.isEntry &#123;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="keyword">if</span> !ht.iter(n.indirect(), yield) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        e := n.entry()</span><br><span class="line">        <span class="comment">// 扫描整个链表</span></span><br><span class="line">        <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，中断遍历</span></span><br><span class="line">            <span class="keyword">if</span> !yield(e.key, e.value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            e = e.overflow.Load()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="All"><a href="#All" class="headerlink" title="All"></a>All</h3><p>封装Range方法并返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> All() <span class="function"><span class="keyword">func</span><span class="params">(yield <span class="keyword">func</span>(K, V)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 把Range方法封装在一个函数里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(yield <span class="keyword">func</span>(key K, value V)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">        ht.iter(ht.root.Load(), yield)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h3><p>清空整个HashTrieMap，直接用新的nil节点更新root</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Clear() &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接用新的节点替换root</span></span><br><span class="line">    ht.root.Store(newIndirectNode[K, V](<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-map</title>
    <url>/golang-series-map-noswiss/</url>
    <content><![CDATA[<p>map&#x2F;哈希表，是golang常用的数据结构之一，也充当set数据结构的存在，相对slice要复杂很多。从1.24开始，swiss table替代noswiss成为默认实现，swiss与noswiss区别在于，swiss使用开放地址法，noswiss使用拉链法</p>
<p>当前go版本：1.23</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// hmap -&gt; oldbuckets</span></span><br><span class="line"><span class="comment">//      -&gt; buckets         -&gt; bmap0(8个key/value对) </span></span><br><span class="line"><span class="comment">//                         -&gt; bmap1 -&gt; overflow0(bmapX) -&gt; overflow1(bmapZ)</span></span><br><span class="line"><span class="comment">//                         -&gt; ...  </span></span><br><span class="line"><span class="comment">//                         -&gt; bmapM -&gt; overflow0(bmapY)</span></span><br><span class="line"><span class="comment">//                         -&gt; bmapN</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      -&gt; extra.overflow  -&gt; bmapX(pre-alloc)</span></span><br><span class="line"><span class="comment">//                         -&gt; bmapY(pre-alloc)</span></span><br><span class="line"><span class="comment">//                         -&gt; ...</span></span><br><span class="line"><span class="comment">//                         -&gt; bmapZ(new-alloc)</span></span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure>

<p>map的数据结构如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span>              <span class="comment">// 元素数量-key/value对</span></span><br><span class="line">    flags     <span class="type">uint8</span>            <span class="comment">// 1-iter正在使用buckets字段 2-iter正在使用oldbuckets字段 4-正在写入 8-同等大小扩容</span></span><br><span class="line">    B         <span class="type">uint8</span>            <span class="comment">// buckets数量=(loadFactor * 2^B)</span></span><br><span class="line">    noverflow <span class="type">uint16</span>           <span class="comment">// 统计溢出buckets的数量，当B大于15时不是精确值</span></span><br><span class="line">    hash0     <span class="type">uint32</span>           <span class="comment">// 哈希种子，计算hash用</span></span><br><span class="line">    buckets    unsafe.Pointer  <span class="comment">// buckets数组</span></span><br><span class="line">    oldbuckets unsafe.Pointer  <span class="comment">// 旧buckets数组，扩容时用</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>         <span class="comment">// 下一个未疏散的bucket索引</span></span><br><span class="line">    clearSeq   <span class="type">uint64</span>          <span class="comment">// 执行过多少次clear</span></span><br><span class="line">    extra *mapextra            <span class="comment">// 可选字段，不是每个map都需要，同时也需要为gc考虑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key/value都不是指针才会使用下面几个字段</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap       <span class="comment">// 溢出buckets，buckets链接使用</span></span><br><span class="line">    oldoverflow *[]*bmap       <span class="comment">// 溢出buckets，oldbuckets链接使用，扩容时</span></span><br><span class="line">    nextOverflow *bmap         <span class="comment">// 下一个可用/未使用overflow的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket结构，可存储8个key/value对及其他数据，编译时自动补充其余结构，真实结构如下</span></span><br><span class="line"><span class="comment">//    A &quot;bucket&quot; is a &quot;struct&quot; &#123;</span></span><br><span class="line"><span class="comment">//          tophash [abi.MapBucketCount]uint8  // hash的高8位</span></span><br><span class="line"><span class="comment">//          keys [abi.MapBucketCount]keyType   // 所有key</span></span><br><span class="line"><span class="comment">//          elems [abi.MapBucketCount]elemType // 所有value</span></span><br><span class="line"><span class="comment">//          overflow *bucket // 下一个溢出桶指针</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">// 详细可见MapBucketType函数（src/cmd/compile/internal/reflectdata/reflect.go）</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// abi.MapBucketCount=8</span></span><br><span class="line">    <span class="comment">// 0-默认状态 1-已删除 2-疏散到x 3-疏散到y 4-不需要疏散 5-guard xyz(&gt;5)-正常tophash值</span></span><br><span class="line">    <span class="comment">// 状态转移如下：</span></span><br><span class="line">    <span class="comment">// 0/xyz -&gt; 2/3/4 =&gt; 如果所有bucket都疏散完毕，会一次性清空释放</span></span><br><span class="line">    <span class="comment">// 0/xyz -&gt; 1 删除 =&gt; 如果idx+1的状态是0，则向前寻找状态为1数据并改为0</span></span><br><span class="line">    tophash [abi.MapBucketCount]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面数据结构中中比较关键的是</p>
<ul>
<li><code>hmap</code> - header部份，var变量存储的也是这部份</li>
<li><code>buckets</code> - 指向一片连续内存区域，bucket数组</li>
<li><code>bmap</code> - bucket的具体实现，可以存储8个key&#x2F;value对，尾部overflow是溢出bucket的指针</li>
</ul>
<span id="more"></span>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>map的初始化方式有两种</p>
<ol>
<li>使用字面量创建map</li>
<li>使用关键字make创建</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(v1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// make关键字</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">v2[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">fmt.Println(v2)</span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量初始化调用的是maplit，具体看代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/walk/complit.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maplit</span><span class="params">(n *ir.CompLitExpr, m ir.Node, init *ir.Nodes)</span></span> &#123;</span><br><span class="line">    args := []ir.Node&#123;ir.TypeNode(n.Type()), ir.NewInt(base.Pos, n.Len+<span class="type">int64</span>(<span class="built_in">len</span>(n.List)))&#125;</span><br><span class="line">    a := typecheck.Expr(ir.NewCallExpr(base.Pos, ir.OMAKE, <span class="literal">nil</span>, args)).(*ir.MakeExpr)</span><br><span class="line">    a.RType = n.RType</span><br><span class="line">    a.SetEsc(n.Esc())</span><br><span class="line">    appendWalkStmt(init, ir.NewAssignStmt(base.Pos, m, a))</span><br><span class="line"></span><br><span class="line">    entries := n.List</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> entries &#123;</span><br><span class="line">        r := r.(*ir.KeyExpr)</span><br><span class="line">        <span class="keyword">if</span> !isStaticCompositeLiteral(r.Key) || !isStaticCompositeLiteral(r.Value) &#123;</span><br><span class="line">            base.Fatalf(<span class="string">&quot;maplit: entry is not a literal: %v&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(entries) &gt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// loop adding structure elements to map</span></span><br><span class="line">        <span class="comment">// for i = 0; i &lt; len(vstatk); i++ &#123;</span></span><br><span class="line">        <span class="comment">//    map[vstatk[i]] = vstate[i]</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，如果小于等于25个元素，直接赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>如果，大于25个元素，分key&#x2F;value两组，使用for循环进行赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstatk); i++ &#123;</span><br><span class="line">    <span class="keyword">map</span>[vstatk[i]] = vstate[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>当使用make关键字初始化map时，调用的是makemap，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">    <span class="comment">// 1. mem（连续内存区域大小） = 元素类型占用大小(type_size)*数量(hint)</span></span><br><span class="line">    <span class="comment">// 2. overflow（是否溢出） = !(type_size|hint &lt; 4GB or type_size=0 or hint &gt; uint_max/type_size)</span></span><br><span class="line">    mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.Bucket.Size_)</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">        hint = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize Hmap</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h = <span class="built_in">new</span>(hmap)</span><br><span class="line">    &#125;</span><br><span class="line">    h.hash0 = <span class="type">uint32</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算B的大小</span></span><br><span class="line">    <span class="comment">// hint &lt;= 8 ？=&gt; B = 0</span></span><br><span class="line">    B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 数据量大于8且已经超过80%的饱和度</span></span><br><span class="line">    <span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">        B++</span><br><span class="line">    &#125;</span><br><span class="line">    h.B = B</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// B!=0则申请内存创建buckets和overflow</span></span><br><span class="line">    <span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">        h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">            h.extra.nextOverflow = nextOverflow</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量超过8且超到80%的饱和度（13/16 =&gt; 81.25%）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 数量 &gt; 8 and 数量 &gt; (13*2^B/2)</span></span><br><span class="line">    <span class="keyword">return</span> count &gt; abi.MapBucketCount &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buckets、overflow等字段初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">    base := bucketShift(b) <span class="comment">// 2^b</span></span><br><span class="line">    nbuckets := base</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于等于2^4=16个元素时，多准备b-4个bucket用于overflow</span></span><br><span class="line">    <span class="comment">// 比如b=4时，共有16个元素，极端情况下都放在同一个bucket，那么需要一个额外的overflow</span></span><br><span class="line">    <span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">        nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">        sz := t.Bucket.Size_ * nbuckets</span><br><span class="line">        up := roundupsize(sz, !t.Bucket.Pointers()) <span class="comment">// 按tcmalloc规则向上取整</span></span><br><span class="line">        <span class="keyword">if</span> up != sz &#123;</span><br><span class="line">            nbuckets = up / t.Bucket.Size_</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新map</span></span><br><span class="line">    <span class="keyword">if</span> dirtyalloc == <span class="literal">nil</span> &#123;</span><br><span class="line">        buckets = newarray(t.Bucket, <span class="type">int</span>(nbuckets))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 清理dirtyalloc，一般用于mapclear</span></span><br><span class="line">        buckets = dirtyalloc</span><br><span class="line">        size := t.Bucket.Size_ * nbuckets</span><br><span class="line">        <span class="keyword">if</span> t.Bucket.Pointers() &#123;</span><br><span class="line">            memclrHasPointers(buckets, size)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memclrNoHeapPointers(buckets, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有overflow，计算nextOverflow指针</span></span><br><span class="line">    <span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">        nextOverflow = (*bmap)(add(buckets, base*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        last.setoverflow(t, (*bmap)(buckets)) <span class="comment">// 防止nil pointer，将其弄成环形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概的逻辑如下</p>
<ol>
<li>新生成hmap</li>
<li>初始状态修改<ul>
<li>hash种子初始化</li>
<li>计算B，如果hint&lt;&#x3D;8则B为0</li>
</ul>
</li>
<li>如果B!&#x3D;0，初始化buckets数组</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>hint超过BUCKETSIZE则放置在heap，否则放在stack</li>
<li>key与value最大为128个字节，超过这个值则会转成指针</li>
</ol>
<p>B的计算示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> <span class="number">50</span> &#123;</span><br><span class="line">    b := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> overLoadFactor(i, b) &#123;</span><br><span class="line">        b++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;hint=%d; b=%d\n&quot;</span>, i, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<table>
<thead>
<tr>
<th align="left">hint</th>
<th align="left">B</th>
<th align="left">bucket count</th>
<th align="left">capacity</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[0,8]</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">[9,13]</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">[14,26]</td>
<td align="left">2</td>
<td align="left">4</td>
<td align="left">32</td>
</tr>
<tr>
<td align="left">[27,52]</td>
<td align="left">3</td>
<td align="left">8</td>
<td align="left">64</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
</tbody></table>
<p>loadFactorNum&#x3D;13是一个关键数据，右边界&#x3D;13*2^(B-1)</p>
<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><h3 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h3><p>使用索引获取map的数值有两种</p>
<ol>
<li>仅接受一个参数</li>
<li>接受两个参数</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅接受一个参数</span></span><br><span class="line">v := h[key]</span><br><span class="line"><span class="comment">// 接受两个参数</span></span><br><span class="line">v, ok := h[key]</span><br></pre></td></tr></table></figure>

<p>当仅接受一个参数时，底层使用mapaccess1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := mapKeyError(t, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">    <span class="comment">// 2^b-1</span></span><br><span class="line">    m := bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，扩容中</span></span><br><span class="line">    <span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 不是同等大小扩容，mask丢弃一位</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上，计算并移动指针指向目标bucket，这里是oldbuckets</span></span><br><span class="line">        oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        <span class="comment">// 是否已疏散，否，数据还在原位</span></span><br><span class="line">        <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">            b = oldb</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">    <span class="comment">// 进入循环</span></span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对tophash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="comment">// index后面的索引位置都为空，退出循环</span></span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不是目标数据，继续比对下一个</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="comment">// bucket的key是指针</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两个key相等</span></span><br><span class="line">            <span class="keyword">if</span> t.Key.Equal(key, k) &#123;</span><br><span class="line">                <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="comment">// bucket的value是指针</span></span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    e = *((*unsafe.Pointer)(e))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到，返回0值</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当接受两个参数时，底层使用mapaccess2，其与mapaccess1只有返回值的不同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// mapaccess2与mapaccess1基本一致，只是返回值不同</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>]), <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里补充两个用到的函数注释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否已疏散</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuated</span><span class="params">(b *bmap)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    h := b.tophash[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 如果第一个tophash的值在(1,5)之间，说明这个bucket已经疏散了</span></span><br><span class="line">    <span class="keyword">return</span> h &gt; emptyOne &amp;&amp; h &lt; minTopHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">    <span class="comment">// 获取hash的高8位</span></span><br><span class="line">    top := <span class="type">uint8</span>(hash &gt;&gt; (goarch.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">    <span class="comment">// 异常处理，加上偏移值minTopHash=5，否则容易与预设值冲突导致误判</span></span><br><span class="line">    <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历访问"><a href="#遍历访问" class="headerlink" title="遍历访问"></a>遍历访问</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用for range遍历整个map时，依赖hiter、mapiterinit、mapiternext实现该操作，大概过程如下</p>
<ol>
<li>调用mapiterinit创建hiter</li>
<li>纪录指定map的状态信息<ul>
<li>复制指定map的状态属性</li>
<li>用随机数计算出一个bucket的索引和offset，用来无序化输出</li>
<li>返回第一个key&#x2F;value对</li>
</ul>
</li>
<li>调用mapiternext，获取并存储第一个key&#x2F;value地址</li>
<li>上层函数继续调用mapiternext，获取并存储下一个key&#x2F;value地址，或者主动终止循环</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go</span></span><br><span class="line"><span class="comment">// 纪录指定map状态</span></span><br><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    key         unsafe.Pointer <span class="comment">// key，为nil时表示结束</span></span><br><span class="line">    elem        unsafe.Pointer <span class="comment">// value</span></span><br><span class="line">    t           *maptype       <span class="comment">// 类型</span></span><br><span class="line">    h           *hmap          <span class="comment">// header</span></span><br><span class="line">    buckets     unsafe.Pointer <span class="comment">// bucket指针</span></span><br><span class="line">    bptr        *bmap          <span class="comment">// 当前bucket指针</span></span><br><span class="line">    overflow    *[]*bmap       <span class="comment">// 指向overflow</span></span><br><span class="line">    oldoverflow *[]*bmap       <span class="comment">// 指向oldoverflow</span></span><br><span class="line">    startBucket <span class="type">uintptr</span>        <span class="comment">// 初始bucket索引 -&gt; head</span></span><br><span class="line">    offset      <span class="type">uint8</span>          <span class="comment">// 初始偏移-用于tophash索引匹配</span></span><br><span class="line">    wrapped     <span class="type">bool</span>           <span class="comment">// rand_idx -&gt; max_idx(7) -&gt; min_idx(0) -&gt; rand_idx</span></span><br><span class="line">    B           <span class="type">uint8</span>          <span class="comment">// h.B</span></span><br><span class="line">    i           <span class="type">uint8</span>          <span class="comment">// tophash索引</span></span><br><span class="line">    bucket      <span class="type">uintptr</span>        <span class="comment">// 当前bucket索引 -&gt; curr</span></span><br><span class="line">    checkBucket <span class="type">uintptr</span>        <span class="comment">// 扩容中且未疏散指定bucket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建hiter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">    it.t = t</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iter大小异常？</span></span><br><span class="line">    <span class="keyword">if</span> unsafe.Sizeof(hiter&#123;&#125;)/goarch.PtrSize != <span class="number">12</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;hash_iter size incorrect&quot;</span>) <span class="comment">// see cmd/compile/internal/reflectdata/reflect.go</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指向map</span></span><br><span class="line">    it.h = h</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制map当前属性</span></span><br><span class="line">    it.B = h.B</span><br><span class="line">    it.buckets = h.buckets</span><br><span class="line">    <span class="keyword">if</span> !t.Bucket.Pointers() &#123;</span><br><span class="line">        h.createOverflow()</span><br><span class="line">        it.overflow = h.extra.overflow</span><br><span class="line">        it.oldoverflow = h.extra.oldoverflow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一个随机的bucket索引以及offset作为扫描的开始地址</span></span><br><span class="line">    r := <span class="type">uintptr</span>(rand())</span><br><span class="line">    <span class="comment">// 取低B位-&gt;bucket索引</span></span><br><span class="line">    it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 丢掉低B位后再取低3位作为offset</span></span><br><span class="line">    it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (abi.MapBucketCount - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// curr指向head</span></span><br><span class="line">    it.bucket = it.startBucket</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个iter</span></span><br><span class="line">    <span class="keyword">if</span> old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;</span><br><span class="line">        atomic.Or8(&amp;h.flags, iterator|oldIterator)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapiternext(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指向map</span></span><br><span class="line">    h := it.h</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t := it.t</span><br><span class="line">    <span class="comment">// curr索引</span></span><br><span class="line">    bucket := it.bucket</span><br><span class="line">    <span class="comment">// nil-初始值（第一次访问的时候）</span></span><br><span class="line">    b := it.bptr</span><br><span class="line">    <span class="comment">// 0-初始值（第一次访问的时候）</span></span><br><span class="line">    i := it.i</span><br><span class="line">    <span class="comment">// 0-初始值（第一次访问的时候）</span></span><br><span class="line">    checkBucket := it.checkBucket</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">    <span class="comment">// 开始/结束时</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 回到了最初的位置，终止</span></span><br><span class="line">        <span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line">            it.key = <span class="literal">nil</span> <span class="comment">// 表示终止</span></span><br><span class="line">            it.elem = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是扩容时创建的iter</span></span><br><span class="line">        <span class="keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;</span><br><span class="line">            <span class="comment">// 先看oldbuckets</span></span><br><span class="line">            oldbucket := bucket &amp; it.h.oldbucketmask()</span><br><span class="line">            b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            <span class="comment">// 还没疏散</span></span><br><span class="line">            <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">                checkBucket = bucket</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 已疏散</span></span><br><span class="line">                b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">                checkBucket = noCheck</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有发生扩容或者扩容前创建的iter</span></span><br><span class="line">            b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            checkBucket = noCheck</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针继续指向下一个bucket</span></span><br><span class="line">        bucket++</span><br><span class="line">        <span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">            bucket = <span class="number">0</span></span><br><span class="line">            it.wrapped = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tophash索引回到0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bucket以及overflow逐个元素扫描</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">        <span class="comment">// 因为有offset的原因，offi =&gt; offset -&gt; 7 -&gt; 0 -&gt; offset</span></span><br><span class="line">        offi := (i + it.offset) &amp; (abi.MapBucketCount - <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 该位置全新或已删除或已疏散</span></span><br><span class="line">        <span class="keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">        k := add(unsafe.Pointer(b), dataOffset+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">            k = *((*unsafe.Pointer)(k))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">        e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">        <span class="comment">// 双倍扩容且未疏散</span></span><br><span class="line">        <span class="keyword">if</span> checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="keyword">if</span> t.ReflexiveKey() || t.Key.Equal(k, k) &#123;</span><br><span class="line">                hash := t.Hasher(k, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">                <span class="comment">// iter以新index为准，如果疏散的目的index与新index不同，跳过</span></span><br><span class="line">                <span class="keyword">if</span> hash&amp;bucketMask(it.B) != checkBucket &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// NaN判断，同上，checkBucket最高位与tophash最低位比较，不相等则跳过，一切以新index为准</span></span><br><span class="line">                <span class="keyword">if</span> checkBucket&gt;&gt;(it.B<span class="number">-1</span>) != <span class="type">uintptr</span>(b.tophash[offi]&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前面已经排除了空值</span></span><br><span class="line">        <span class="comment">// 未疏散 or key!=key（NaN）</span></span><br><span class="line">        <span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||</span><br><span class="line">            !(t.ReflexiveKey() || t.Key.Equal(k, k)) &#123;</span><br><span class="line">            <span class="comment">// NaN无法被更新/删除，无需再判断是否为nil</span></span><br><span class="line">            it.key = k</span><br><span class="line">            <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                e = *((*unsafe.Pointer)(e))</span><br><span class="line">            &#125;</span><br><span class="line">            it.elem = e</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已疏散 用mapaccessK获取key/value</span></span><br><span class="line">            rk, re := mapaccessK(t, h, k)</span><br><span class="line">            <span class="keyword">if</span> rk == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">// key has been deleted</span></span><br><span class="line">            &#125;</span><br><span class="line">            it.key = rk</span><br><span class="line">            it.elem = re</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存iter状态</span></span><br><span class="line">        it.bucket = bucket</span><br><span class="line">        <span class="keyword">if</span> it.bptr != b &#123; <span class="comment">// avoid unnecessary write barrier; see issue 14921</span></span><br><span class="line">            it.bptr = b</span><br><span class="line">        &#125;</span><br><span class="line">        it.i = i + <span class="number">1</span></span><br><span class="line">        it.checkBucket = checkBucket</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描overflow</span></span><br><span class="line">    b = b.overflow(t)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时，根据key从新的bucket数组获取key/value地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccessK</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">    <span class="comment">// 2^b-1</span></span><br><span class="line">    m := bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，扩容中</span></span><br><span class="line">    <span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 不是同等大小扩容，mask丢弃一位</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上，计算并移动指针指向目标bucket，这里是oldbuckets</span></span><br><span class="line">        oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        <span class="comment">// 是否已疏散，否，数据还在原位</span></span><br><span class="line">        <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">            b = oldb</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对tophash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 当前位置以及后面位置都没有数据了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不是目标数据，继续比对下一个</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两个key相等</span></span><br><span class="line">            <span class="keyword">if</span> t.Key.Equal(key, k) &#123;</span><br><span class="line">                <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    e = *((*unsafe.Pointer)(e))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> k, e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">v1[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>系统调用mapassign实现map的赋值操作，大概逻辑如下</p>
<ol>
<li>确保map已经初始化</li>
<li>计算key的hash值</li>
<li>判断是否需要扩容？是，则先扩容</li>
<li>算出目标bucket的位置</li>
<li>判断是否在扩容中？是，则疏散旧bucket</li>
<li>扫描整个目标bucket，包括overflow，找到可写入的位置</li>
<li>返回value的指针，由上层更新数值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据key查找value并获得指向value的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 为nil，未初始化</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;assignment to entry in nil map&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置flag，防止同时写入</span></span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时B=0，延迟</span></span><br><span class="line">    <span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        h.buckets = newobject(t.Bucket) <span class="comment">// newarray(t.Bucket, 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 获取低B位hash值，用于计算桶索引</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，即为扩容中</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// 疏散指定bucket</span></span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inserti *<span class="type">uint8</span> <span class="comment">// tophash索引</span></span><br><span class="line">    <span class="keyword">var</span> insertk unsafe.Pointer <span class="comment">// key索引</span></span><br><span class="line">    <span class="keyword">var</span> elem unsafe.Pointer <span class="comment">// value索引</span></span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对hash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="comment">// 1. 没找到key</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 该位置全新或已删除 and index还没找到 -&gt; 找到一个空的位置</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">                    inserti = &amp;b.tophash[i]</span><br><span class="line">                    <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">                    insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                    <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">                    elem = add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 按上面的顺序来说，后面基本都是0，因此执行上面代码后，到这里就可以break了</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="comment">// index后面的索引位置都为空，退出循环</span></span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前位置不为空，寻找下一个可写入位置</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 找到一个key，至少tophash是相等的</span></span><br><span class="line">            <span class="comment">// 计算key索引 = 8+i*key_size</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="comment">// bucket的key是指针</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tophash相等但key值不相等，继续寻找下一个</span></span><br><span class="line">            <span class="keyword">if</span> !t.Key.Equal(key, k) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指针？数据需要更新？</span></span><br><span class="line">            <span class="keyword">if</span> t.NeedKeyUpdate() &#123;</span><br><span class="line">                typedmemmove(t.Key, k, key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算value索引 = 8+8*key_size+i*value_size</span></span><br><span class="line">            elem = add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            <span class="keyword">goto</span> done</span><br><span class="line">        &#125;</span><br><span class="line">        ovf := b.overflow(t)</span><br><span class="line">        <span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        b = ovf</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非扩容状态，但已经达到80%的饱和度或者数据非常稀疏</span></span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        hashGrow(t, h)</span><br><span class="line">        <span class="comment">// 扩容后，重新找位置</span></span><br><span class="line">        <span class="keyword">goto</span> again</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全满了，没有位置了</span></span><br><span class="line">    <span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从预申请获取或直接创建新的bucket，作为overflow bucket</span></span><br><span class="line">        newb := h.newoverflow(t, b)</span><br><span class="line">        <span class="comment">// overflow第一个位置</span></span><br><span class="line">        inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        elem = add(insertk, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">        kmem := newobject(t.Key)</span><br><span class="line">        *(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">        insertk = kmem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">        vmem := newobject(t.Elem)</span><br><span class="line">        *(*unsafe.Pointer)(elem) = vmem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把key拷贝到哈希表的key里</span></span><br><span class="line">    typedmemmove(t.Key, insertk, key)</span><br><span class="line">    <span class="comment">// tophash更新</span></span><br><span class="line">    *inserti = top</span><br><span class="line">    <span class="comment">// 总数量更新</span></span><br><span class="line">    h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// flag被修改了，异常</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除修改标记</span></span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">    <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">        elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回value位置的指针，上层代码会更新value</span></span><br><span class="line">    <span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疏散旧bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// todo ？ 保证当前是一次全新的扩容？</span></span><br><span class="line">    evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容中</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// 疏散</span></span><br><span class="line">        evacuate(t, h, h.nevacuate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疏散用，纪录bucket信息</span></span><br><span class="line"><span class="keyword">type</span> evacDst <span class="keyword">struct</span> &#123;</span><br><span class="line">    b *bmap          <span class="comment">// bucket指针</span></span><br><span class="line">    i <span class="type">int</span>            <span class="comment">// tophash地址</span></span><br><span class="line">    k unsafe.Pointer <span class="comment">// key地址</span></span><br><span class="line">    e unsafe.Pointer <span class="comment">// value地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 疏散旧bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket，这里是oldbuckets</span></span><br><span class="line">    b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    <span class="comment">// 2^(b-1) -&gt; oldbucket+1</span></span><br><span class="line">    newbit := h.noldbuckets()</span><br><span class="line">    <span class="comment">// 如果tophash[0]的值不在在(1,5)之间</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">        <span class="comment">// 将新的buckets分为x和y两部份</span></span><br><span class="line">        <span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">        <span class="comment">// 低地址部份</span></span><br><span class="line">        x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">        x.b = (*bmap)(add(h.buckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">        x.e = add(x.k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是双倍扩容</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="comment">// 高地址部份</span></span><br><span class="line">            y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">            y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">            y.e = add(y.k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描正常桶以及溢出桶，这里是oldbuckets</span></span><br><span class="line">        <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">            <span class="comment">// key基地址</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">            <span class="comment">// value基地址</span></span><br><span class="line">            e := add(k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            <span class="comment">// 每个桶可存储8个数据，搬空所有</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; abi.MapBucketCount; i, k, e = i+<span class="number">1</span>, add(k, <span class="type">uintptr</span>(t.KeySize)), add(e, <span class="type">uintptr</span>(t.ValueSize)) &#123;</span><br><span class="line">                top := b.tophash[i]</span><br><span class="line">                <span class="comment">// 该位置全新或已删除</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(top) &#123;</span><br><span class="line">                    <span class="comment">// 设置为4-不需要疏散</span></span><br><span class="line">                    b.tophash[i] = evacuatedEmpty</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不为0，但小于5，异常</span></span><br><span class="line">                <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不为0，还未疏散</span></span><br><span class="line">                k2 := k</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> useY <span class="type">uint8</span></span><br><span class="line">                <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">                    <span class="comment">// 计算hash值</span></span><br><span class="line">                    hash := t.Hasher(k2, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 有goroutine在遍历新的buckets</span></span><br><span class="line">                    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.ReflexiveKey() &amp;&amp; !t.Key.Equal(k2, k2) &#123;</span><br><span class="line">                        <span class="comment">// 浮点数，NaN != NaN，无法判断，拿top的最低位判断应该放在哪里</span></span><br><span class="line">                        useY = top &amp; <span class="number">1</span></span><br><span class="line">                        top = tophash(hash)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 根据hash&amp;B判断是否要放在高地址部份</span></span><br><span class="line">                        <span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">                            useY = <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 异常数值？</span></span><br><span class="line">                <span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY || evacuatedX^<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad evacuatedN&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置为2或3</span></span><br><span class="line">                b.tophash[i] = evacuatedX + useY</span><br><span class="line">                <span class="comment">// 疏散的目标地址</span></span><br><span class="line">                dst := &amp;xy[useY]</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 溢出了</span></span><br><span class="line">                <span class="keyword">if</span> dst.i == abi.MapBucketCount &#123;</span><br><span class="line">                    <span class="comment">// 链接overflow并使用第一个地址</span></span><br><span class="line">                    dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">                    dst.i = <span class="number">0</span></span><br><span class="line">                    dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">                    dst.e = add(dst.k, abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                &#125;</span><br><span class="line">                dst.b.tophash[dst.i&amp;(abi.MapBucketCount<span class="number">-1</span>)] = top</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.Key, dst.k, k) <span class="comment">// copy elem</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.Elem, dst.e, e)</span><br><span class="line">                &#125;</span><br><span class="line">                dst.i++</span><br><span class="line">                dst.k = add(dst.k, <span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                dst.e = add(dst.e, <span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 旧的bucket已经清空且无iter在使用</span></span><br><span class="line">        <span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.Bucket.Pointers() &#123;</span><br><span class="line">            b := add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.BucketSize))</span><br><span class="line">            ptr := add(b, dataOffset)</span><br><span class="line">            n := <span class="type">uintptr</span>(t.BucketSize) - dataOffset</span><br><span class="line">            <span class="comment">// 把key/value数据全部清空，方便gc做？</span></span><br><span class="line">            memclrHasPointers(ptr, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 惰性清理函数，不会每次都触发，只有oldbucket索引刚好跟nevacuate值相等才行</span></span><br><span class="line">    <span class="comment">// [0 1 2 3]共四个bucket</span></span><br><span class="line">    <span class="comment">// 当疏散了idx=2的bucket，此时nevacuate=0，不触发</span></span><br><span class="line">    <span class="comment">// 当疏散了idx=0的bucket时，与nevacuate相等，触发，将nevacuate指向1</span></span><br><span class="line">    <span class="comment">// 当nevacuate=4时，说明疏散了所有bucket，清理掉buckets数组，更新状态</span></span><br><span class="line">    <span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">        advanceEvacuationMark(h, t, newbit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否疏散完毕，是=&gt;清理oldbucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指向下一个bucket，不管有没有清理</span></span><br><span class="line">    h.nevacuate++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard，实际保证能nevacuate&lt;newbit即可</span></span><br><span class="line">    stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">    <span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">        stop = newbit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nevacuate指向下一个未清理的bucket索引</span></span><br><span class="line">    <span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">        h.nevacuate++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部疏散完毕</span></span><br><span class="line">    <span class="keyword">if</span> h.nevacuate == newbit &#123;</span><br><span class="line">        <span class="comment">// 删除oldbuckets</span></span><br><span class="line">        h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 删除oldoverflow</span></span><br><span class="line">        <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取消sameSizeGrow标记？</span></span><br><span class="line">        h.flags &amp;^= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请一个新的overflow bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> newoverflow(t *maptype, b *bmap) *bmap &#123;</span><br><span class="line">    <span class="keyword">var</span> ovf *bmap</span><br><span class="line">    <span class="comment">// 有预申请的overflow直接使用</span></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        ovf = h.extra.nextOverflow</span><br><span class="line">        <span class="comment">// next为nil，说明申请的overflow还有很多</span></span><br><span class="line">        <span class="keyword">if</span> ovf.overflow(t) == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 写上next指针，不然下一次没法用</span></span><br><span class="line">            h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), <span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用完了，bucket的overflow指针清空</span></span><br><span class="line">            ovf.setoverflow(t, <span class="literal">nil</span>)</span><br><span class="line">            h.extra.nextOverflow = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有预申请或者用完了预申请的</span></span><br><span class="line">        ovf = (*bmap)(newobject(t.Bucket))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// noverflow counter调整</span></span><br><span class="line">    <span class="comment">// &lt;16时noverflow是个精确值</span></span><br><span class="line">    <span class="comment">// &gt;=16时noverflow指数级衰减</span></span><br><span class="line">    h.incrnoverflow()</span><br><span class="line">    <span class="comment">// 不包含指针</span></span><br><span class="line">    <span class="keyword">if</span> !t.Bucket.Pointers() &#123;</span><br><span class="line">        <span class="comment">// 确保extra跟overflow已初始化</span></span><br><span class="line">        h.createOverflow()</span><br><span class="line">        <span class="comment">// 追加到末尾，超过容量还是会触发slice扩容</span></span><br><span class="line">        *h.extra.overflow = <span class="built_in">append</span>(*h.extra.overflow, ovf)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bucket的overflow指针指向ovf</span></span><br><span class="line">    b.setoverflow(t, ovf)</span><br><span class="line">    <span class="keyword">return</span> ovf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当map的元素数量超过8且达到80%的饱和度时，会触发扩容，扩容函数为hashGrow。</p>
<p><strong>注意</strong>：hashGrow只负责扩容，不负责疏散oldbucket，只有每次调用mapassign时才会去疏散旧的bucket</p>
<p>大概逻辑如下</p>
<ol>
<li>判断是双倍扩容还是同等大小扩容</li>
<li>将buckets数组搬到oldbuckets</li>
<li>更新hmap状态</li>
<li>有overflow？搬到oldoverflow并更新extra状态</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只管扩容，下一次写的时候才疏散对应的bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断是双倍扩容还是同等大小扩容</span></span><br><span class="line">    bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 未达到80%的饱和度，同等大小扩容</span></span><br><span class="line">    <span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">        bigger = <span class="number">0</span></span><br><span class="line">        h.flags |= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迁移旧的buckets</span></span><br><span class="line">    oldbuckets := h.buckets</span><br><span class="line">    <span class="comment">// 创建新的buckets</span></span><br><span class="line">    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除iterator/oldIterator标记</span></span><br><span class="line">    flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">    <span class="comment">// 加上oldIterator标记？</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= oldIterator</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    h.B += bigger</span><br><span class="line">    h.flags = flags</span><br><span class="line">    h.oldbuckets = oldbuckets</span><br><span class="line">    h.buckets = newbuckets</span><br><span class="line">    h.nevacuate = <span class="number">0</span></span><br><span class="line">    h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理overflow</span></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 异常状态</span></span><br><span class="line">        <span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;oldoverflow is not nil&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">        h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(v1, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当使用关键字delete删除指定key时，调用mapdelete，大概逻辑如下</p>
<ol>
<li>计算hash值，找到目标bucket</li>
<li>是否在扩容中？是，则疏散旧bucket</li>
<li>对比tophash和key，找到value的地址，清空tophash、key、value</li>
<li>idx+1位置的tophash都是0-默认值？从idx开始往前扫描，将所有tophash&#x3D;emptyOne改成0</li>
<li>更新map状态</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := mapKeyError(t, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    hash := t.Hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置flag，防止同时写入</span></span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取低B位hash值，用于计算桶索引</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// oldbuckets不为nil，即为扩容中</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// 疏散指定bucket</span></span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算并移动指针指向目标bucket</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">    bOrig := b</span><br><span class="line">    <span class="comment">// 获取hash高8位，优化查找</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">search:</span><br><span class="line">    <span class="comment">// 扫描正常桶以及溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 每个桶可存储8个数据，一个个比对hash</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">            <span class="comment">// 1. 没找到key</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 后面基本都是0，到这里就可以break了</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> search</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 找到一个key，至少tophash是相等的</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">            k2 := k</span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tophash相等但key值不相等，继续寻找下一个</span></span><br><span class="line">            <span class="keyword">if</span> !t.Key.Equal(key, k2) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Only clear key if there are pointers in it.</span></span><br><span class="line">            <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Key.Pointers() &#123;</span><br><span class="line">                memclrHasPointers(k, t.Key.Size_)</span><br><span class="line">            &#125;</span><br><span class="line">            e := add(unsafe.Pointer(b), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">            <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Elem.Pointers() &#123;</span><br><span class="line">                memclrHasPointers(e, t.Elem.Size_)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                memclrNoHeapPointers(e, t.Elem.Size_)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除了一个数据</span></span><br><span class="line">            b.tophash[i] = emptyOne</span><br><span class="line">            <span class="comment">// index=7，指向了bucket最后一个数据</span></span><br><span class="line">            <span class="keyword">if</span> i == abi.MapBucketCount<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="comment">// 还不是最终的数据，不处理</span></span><br><span class="line">                <span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">                    <span class="keyword">goto</span> notLast</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// index&lt;7 且 后续的元素也不为空，不处理</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">                    <span class="keyword">goto</span> notLast</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前以及前面tophash=emptyOne的tophash设置为0-默认值</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                b.tophash[i] = emptyRest</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">                        <span class="keyword">break</span> <span class="comment">// beginning of initial bucket, we&#x27;re done.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Find previous bucket, continue at its last entry.</span></span><br><span class="line">                    c := b</span><br><span class="line">                    <span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i = abi.MapBucketCount - <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i--</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        notLast:</span><br><span class="line">            h.count--</span><br><span class="line">            <span class="comment">// Reset the hash seed to make it more difficult for attackers to</span></span><br><span class="line">            <span class="comment">// repeatedly trigger hash collisions. See issue 25237.</span></span><br><span class="line">            <span class="keyword">if</span> h.count == <span class="number">0</span> &#123;</span><br><span class="line">                h.hash0 = <span class="type">uint32</span>(rand())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span> search</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常状态</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除标记</span></span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line">clear(v1)</span><br></pre></td></tr></table></figure>

<p>使用clear清理map的所有元素时，系统调用mapclear进行处理，大概逻辑如下</p>
<ol>
<li>循环将每一个bucket的tophash都设置为0，包括oldbuckets</li>
<li>重置map的所有状态、seed等</li>
<li>调用makeBucketArray，清理所有key&#x2F;value数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclear</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 未初始化/为空</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置flag，防止同时写入</span></span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark buckets empty, so existing iterators can be terminated, see issue #59411.</span></span><br><span class="line">    markBucketsEmpty := <span class="function"><span class="keyword">func</span><span class="params">(bucket unsafe.Pointer, mask <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt;= mask; i++ &#123;</span><br><span class="line">            b := (*bmap)(add(bucket, i*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">                <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">                    b.tophash[i] = emptyRest</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2^b-1</span></span><br><span class="line">    markBucketsEmpty(h.buckets, bucketMask(h.B))</span><br><span class="line">    <span class="keyword">if</span> oldBuckets := h.oldbuckets; oldBuckets != <span class="literal">nil</span> &#123;</span><br><span class="line">        markBucketsEmpty(oldBuckets, h.oldbucketmask())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩下的没什么好说的</span></span><br><span class="line">    h.flags &amp;^= sameSizeGrow</span><br><span class="line">    h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">    h.nevacuate = <span class="number">0</span></span><br><span class="line">    h.noverflow = <span class="number">0</span></span><br><span class="line">    h.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the hash seed to make it more difficult for attackers to</span></span><br><span class="line">    <span class="comment">// repeatedly trigger hash collisions. See issue 25237.</span></span><br><span class="line">    h.hash0 = <span class="type">uint32</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep the mapextra allocation but clear any extra information.</span></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">        *h.extra = mapextra&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// makeBucketArray clears the memory pointed to by h.buckets</span></span><br><span class="line">    <span class="comment">// and recovers any overflow buckets by generating them</span></span><br><span class="line">    <span class="comment">// as if h.buckets was newly alloced.</span></span><br><span class="line">    _, nextOverflow := makeBucketArray(t, h.B, h.buckets)</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// If overflow buckets are created then h.extra</span></span><br><span class="line">        <span class="comment">// will have been allocated during initial bucket creation.</span></span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下非克隆，只是复制了header</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = v1</span><br><span class="line"></span><br><span class="line"><span class="comment">// go 1.21</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = maps.Clone(v1)</span><br></pre></td></tr></table></figure>

<p>go 1.21增加了maps.Clone用于克隆整个map数据，系统调用mapclone2实现该操作，大概逻辑如下</p>
<ol>
<li>创建目标哈希表dst，复制源哈希表src的状态等相关数据</li>
<li>复制src的数据到dst<ul>
<li>如果B&#x3D;0且key&#x2F;value非指针，直接赋值一个bucket即可，复制完毕直接退出</li>
<li>如果dst.B&#x3D;src.B，1:1复制bucket数组</li>
<li>如果dst.B&lt;&#x3D;src.B，直接看代码吧</li>
</ul>
</li>
<li>src是否在扩容中？是，则复制src的oldbucket数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclone2</span><span class="params">(t *maptype, src *hmap)</span></span> *hmap &#123;</span><br><span class="line">    <span class="comment">// 数据量</span></span><br><span class="line">    hint := src.count</span><br><span class="line">    <span class="comment">// 已经达到80%的饱和度</span></span><br><span class="line">    <span class="keyword">if</span> overLoadFactor(hint, src.B) &#123;</span><br><span class="line">        <span class="comment">// 13*2^B/2 (why？)</span></span><br><span class="line">        hint = <span class="type">int</span>(loadFactorNum * (bucketShift(src.B) / loadFactorDen))</span><br><span class="line">    &#125;</span><br><span class="line">    dst := makemap(t, hint, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 共用hash seed</span></span><br><span class="line">    dst.hash0 = src.hash0</span><br><span class="line">    dst.nevacuate = <span class="number">0</span></span><br><span class="line">    <span class="comment">// flags不需要拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数量为0，不处理</span></span><br><span class="line">    <span class="keyword">if</span> src.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有goroutine在写入，不允许</span></span><br><span class="line">    <span class="keyword">if</span> src.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map clone and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b=0 and key跟value非指针</span></span><br><span class="line">    <span class="keyword">if</span> src.B == <span class="number">0</span> &amp;&amp; !(t.IndirectKey() &amp;&amp; t.NeedKeyUpdate()) &amp;&amp; !t.IndirectElem() &#123;</span><br><span class="line">        <span class="comment">// Quick copy for small maps.</span></span><br><span class="line">        dst.buckets = newobject(t.Bucket)</span><br><span class="line">        dst.count = src.count</span><br><span class="line">        typedmemmove(t.Bucket, dst.buckets, src.buckets)</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b=0 key或value为指针类型</span></span><br><span class="line">    <span class="keyword">if</span> dst.B == <span class="number">0</span> &#123;</span><br><span class="line">        dst.buckets = newobject(t.Bucket)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dst.B &lt;= src.B</span></span><br><span class="line">    dstArraySize := <span class="type">int</span>(bucketShift(dst.B))</span><br><span class="line">    srcArraySize := <span class="type">int</span>(bucketShift(src.B))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; dstArraySize; i++ &#123;</span><br><span class="line">        <span class="comment">// dst bucket指针</span></span><br><span class="line">        dstBmap := (*bmap)(add(dst.buckets, <span class="type">uintptr</span>(i*<span class="type">int</span>(t.BucketSize))))</span><br><span class="line">        pos := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; srcArraySize; j += dstArraySize &#123;</span><br><span class="line">            <span class="comment">// src bucket指针</span></span><br><span class="line">            <span class="comment">// 如果dst.B = src.B，1:1复制，否则多余部份wrapped写到dst前面几个bucket</span></span><br><span class="line">            srcBmap := (*bmap)(add(src.buckets, <span class="type">uintptr</span>((i+j)*<span class="type">int</span>(t.BucketSize))))</span><br><span class="line">            <span class="keyword">for</span> srcBmap != <span class="literal">nil</span> &#123;</span><br><span class="line">                dstBmap, pos = moveToBmap(t, dst, dstBmap, pos, srcBmap)</span><br><span class="line">                <span class="comment">// 包括overflow</span></span><br><span class="line">                srcBmap = srcBmap.overflow(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非扩容</span></span><br><span class="line">    <span class="keyword">if</span> src.oldbuckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面全是跟oldbuckets相关的</span></span><br><span class="line">    oldB := src.B</span><br><span class="line">    srcOldbuckets := src.oldbuckets</span><br><span class="line">    <span class="keyword">if</span> !src.sameSizeGrow() &#123;</span><br><span class="line">        oldB--</span><br><span class="line">    &#125;</span><br><span class="line">    oldSrcArraySize := <span class="type">int</span>(bucketShift(oldB))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; oldSrcArraySize; i++ &#123;</span><br><span class="line">        srcBmap := (*bmap)(add(srcOldbuckets, <span class="type">uintptr</span>(i*<span class="type">int</span>(t.BucketSize))))</span><br><span class="line">        <span class="comment">// 已疏散</span></span><br><span class="line">        <span class="keyword">if</span> evacuated(srcBmap) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// oldB比dst的B还要更大，按dst的B取hash的低位作为bucket索引</span></span><br><span class="line">        <span class="comment">// dst.B &lt;= src.B and dst.B &lt;= (src.B-1)</span></span><br><span class="line">        <span class="keyword">if</span> oldB &gt;= dst.B &#123; <span class="comment">// main bucket bits in dst is less than oldB bits in src</span></span><br><span class="line">            <span class="comment">// src.oldbuckets =&gt; dst.buckets</span></span><br><span class="line">            <span class="comment">// 索引按dst.B取低位</span></span><br><span class="line">            dstBmap := (*bmap)(add(dst.buckets, (<span class="type">uintptr</span>(i)&amp;bucketMask(dst.B))*<span class="type">uintptr</span>(t.BucketSize)))</span><br><span class="line">            <span class="keyword">for</span> dstBmap.overflow(t) != <span class="literal">nil</span> &#123;</span><br><span class="line">                dstBmap = dstBmap.overflow(t)</span><br><span class="line">            &#125;</span><br><span class="line">            pos := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> srcBmap != <span class="literal">nil</span> &#123;</span><br><span class="line">                dstBmap, pos = moveToBmap(t, dst, dstBmap, pos, srcBmap)</span><br><span class="line">                srcBmap = srcBmap.overflow(t)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// oldB &lt; dst.B (说明dst.B == src.B ?)</span></span><br><span class="line">        <span class="keyword">for</span> srcBmap != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// oldbuckets分成x/y两个部份疏散</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">                <span class="comment">// 该位置全新或已删除</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(srcBmap.tophash[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// // 有goroutine在写入，不允许</span></span><br><span class="line">                <span class="keyword">if</span> src.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">                    fatal(<span class="string">&quot;concurrent map clone and map write&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                srcK := add(unsafe.Pointer(srcBmap), dataOffset+i*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">                    srcK = *((*unsafe.Pointer)(srcK))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                srcEle := add(unsafe.Pointer(srcBmap), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+i*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">                <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">                    srcEle = *((*unsafe.Pointer)(srcEle))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到key在dst的位置，然后复制数据</span></span><br><span class="line">                dstEle := mapassign(t, dst, srcK)</span><br><span class="line">                typedmemmove(t.Elem, dstEle, srcEle)</span><br><span class="line">            &#125;</span><br><span class="line">            srcBmap = srcBmap.overflow(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveToBmap</span><span class="params">(t *maptype, h *hmap, dst *bmap, pos <span class="type">int</span>, src *bmap)</span></span> (*bmap, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// src的bucket数据复制到dst的bucket，overflow在上一层做处理</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; abi.MapBucketCount; i++ &#123;</span><br><span class="line">        <span class="comment">// src-该位置全新或已删除</span></span><br><span class="line">        <span class="keyword">if</span> isEmpty(src.tophash[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 索引 0-7</span></span><br><span class="line">        <span class="keyword">for</span> ; pos &lt; abi.MapBucketCount; pos++ &#123;</span><br><span class="line">            <span class="comment">// dst-找到一个可写入的位置</span></span><br><span class="line">            <span class="keyword">if</span> isEmpty(dst.tophash[pos]) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dst写满了，加一个overflow bucket</span></span><br><span class="line">        <span class="keyword">if</span> pos == abi.MapBucketCount &#123;</span><br><span class="line">            dst = h.newoverflow(t, dst)</span><br><span class="line">            pos = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srcK := add(unsafe.Pointer(src), dataOffset+<span class="type">uintptr</span>(i)*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        srcEle := add(unsafe.Pointer(src), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+<span class="type">uintptr</span>(i)*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line">        dstK := add(unsafe.Pointer(dst), dataOffset+<span class="type">uintptr</span>(pos)*<span class="type">uintptr</span>(t.KeySize))</span><br><span class="line">        dstEle := add(unsafe.Pointer(dst), dataOffset+abi.MapBucketCount*<span class="type">uintptr</span>(t.KeySize)+<span class="type">uintptr</span>(pos)*<span class="type">uintptr</span>(t.ValueSize))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制tophash</span></span><br><span class="line">        dst.tophash[pos] = src.tophash[i]</span><br><span class="line">        <span class="comment">// 复制key</span></span><br><span class="line">        <span class="keyword">if</span> t.IndirectKey() &#123;</span><br><span class="line">            srcK = *(*unsafe.Pointer)(srcK)</span><br><span class="line">            <span class="keyword">if</span> t.NeedKeyUpdate() &#123;</span><br><span class="line">                kStore := newobject(t.Key)</span><br><span class="line">                typedmemmove(t.Key, kStore, srcK)</span><br><span class="line">                srcK = kStore</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Note: if NeedKeyUpdate is false, then the memory</span></span><br><span class="line">            <span class="comment">// used to store the key is immutable, so we can share</span></span><br><span class="line">            <span class="comment">// it between the original map and its clone.</span></span><br><span class="line">            *(*unsafe.Pointer)(dstK) = srcK</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typedmemmove(t.Key, dstK, srcK)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制value</span></span><br><span class="line">        <span class="keyword">if</span> t.IndirectElem() &#123;</span><br><span class="line">            srcEle = *(*unsafe.Pointer)(srcEle)</span><br><span class="line">            eStore := newobject(t.Elem)</span><br><span class="line">            typedmemmove(t.Elem, eStore, srcEle)</span><br><span class="line">            *(*unsafe.Pointer)(dstEle) = eStore</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typedmemmove(t.Elem, dstEle, srcEle)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// counter更新</span></span><br><span class="line">        pos++</span><br><span class="line">        h.count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst, pos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">3.3 哈希表</a><br><a href="https://victoriametrics.com/blog/go-map/">Go Maps Explained: How Key-Value Pairs Are Actually Stored</a><br><a href="https://www.youtube.com/watch?v=Tl7mi9QmLns">GopherCon 2016: Keith Randall - Inside the Map Implementation</a><br><a href="https://docs.google.com/presentation/d/1CxamWsvHReswNZc7N2HMV7WPFqS8pvlPVZcDegdC_T4/edit#slide=id.g14067a566a_0_0">Inside the Map Implementation - Gophercon</a><br><a href="https://go101.org/article/container.html">Arrays, Slices and Maps in Go</a><br><a href="https://100go.co/28-maps-memory-leaks/">Maps and memory leaks</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-swiss map</title>
    <url>/golang-series-map-swiss/</url>
    <content><![CDATA[<p>map&#x2F;哈希表，是golang常用的数据结构之一，也充当set数据结构的存在，相对slice要复杂很多。从1.24开始，swiss table替代noswiss成为默认实现，swiss与noswiss区别在于，swiss使用开放地址法，noswiss使用拉链法</p>
<p>当前go版本：1.24</p>
<blockquote>
<p>swiss map的开关放在文件<code>src/internal/buildcfg/exp.go</code>的函数<code>ParseGOEXPERIMENT</code>中</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// table-groups是二维数组，算上slot的话是三维</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// map_header -&gt; table1 -&gt; group1(8个slot)</span></span><br><span class="line"><span class="comment">//                      -&gt; group2</span></span><br><span class="line"><span class="comment">//                      ...</span></span><br><span class="line"><span class="comment">//                      -&gt; group127</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//            -&gt; table2</span></span><br><span class="line"><span class="comment">//            -&gt; ...</span></span><br><span class="line"><span class="comment">//            -&gt; tableN</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当hint&lt;=8时，map_header直接指向一个group，全量扫描操作</span></span><br><span class="line"><span class="comment">// 当hint&gt;8 and hint&lt;=1024*7/8时，一个table，2~128个group</span></span><br><span class="line"><span class="comment">// 当hint&gt;1024*7/8时，多个table，多个group</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// hash高B位 - 用于定位table</span></span><br><span class="line"><span class="comment">// h1-hash高57位 - 用于定位group</span></span><br><span class="line"><span class="comment">// h2-hash低7位 - 用于匹配hash，类似tophash</span></span><br></pre></td></tr></table></figure>

<p>核心数据结构包括Map、table、groupsReference、groupReference，具体如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    used <span class="type">uint64</span>            <span class="comment">// 已用slot，当数据量&lt;=8时用来替换table的used使用</span></span><br><span class="line">    seed <span class="type">uintptr</span>           <span class="comment">// 哈希函数种子</span></span><br><span class="line">    dirPtr unsafe.Pointer  <span class="comment">// table数组指针/group指针</span></span><br><span class="line">    dirLen <span class="type">int</span>             <span class="comment">// table数组大小</span></span><br><span class="line">    globalDepth <span class="type">uint8</span>      <span class="comment">// log2(dirLen)（相当于旧版的B）</span></span><br><span class="line">    globalShift <span class="type">uint8</span>      <span class="comment">// 64-globalDepth，高B位用做table的索引</span></span><br><span class="line">    writing <span class="type">uint8</span>          <span class="comment">// 是否正在写入，乐观锁</span></span><br><span class="line">    clearSeq <span class="type">uint64</span>        <span class="comment">// 执行过多少次clear，扩容时，获取数据判断用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="keyword">type</span> table <span class="keyword">struct</span> &#123;</span><br><span class="line">    used <span class="type">uint16</span>            <span class="comment">// 已用slot，最多能写入1024*7/8=896个slot</span></span><br><span class="line">    capacity <span class="type">uint16</span>        <span class="comment">// slot容量 &lt;=1024（由hint算出，2的乘方向上取整）</span></span><br><span class="line">    growthLeft <span class="type">uint16</span>      <span class="comment">// 可用slot，与used相反，初始值最大为896</span></span><br><span class="line">    localDepth <span class="type">uint8</span>       <span class="comment">// &gt;globalDepth？分裂/遍历时使用</span></span><br><span class="line">    index <span class="type">int</span>              <span class="comment">// 上层directory数组中的index（-1-过期，作用类似localDepth）</span></span><br><span class="line">    groups groupsReference <span class="comment">// group数组，8个slot为一组，最多1024/8=128组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/group.go</span></span><br><span class="line"><span class="keyword">type</span> groupsReference <span class="keyword">struct</span> &#123;</span><br><span class="line">    data unsafe.Pointer    <span class="comment">// group数组，8个slot为一组，具体结构看下方</span></span><br><span class="line">    lengthMask <span class="type">uint64</span>      <span class="comment">// 长度固定为2^N，因此mask=2^N-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> groupReference <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 结构如下</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// type group struct &#123;</span></span><br><span class="line">    <span class="comment">//     ctrls ctrlGroup                    // 8个8bit的ctrl，共三种状态</span></span><br><span class="line">    <span class="comment">//     slots [abi.SwissMapGroupSlots]slot // 8个slot(key/value对)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 三种状态如下：</span></span><br><span class="line">    <span class="comment">//      empty: 1 0 0 0 0 0 0 0</span></span><br><span class="line">    <span class="comment">//    deleted: 1 1 1 1 1 1 1 0</span></span><br><span class="line">    <span class="comment">//       full: 0 h h h h h h h  // h represents the H2 hash bits</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// type slot struct &#123;</span></span><br><span class="line">    <span class="comment">//     key  typ.Key  // 键</span></span><br><span class="line">    <span class="comment">//     elem typ.Elem // 值</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    data unsafe.Pointer <span class="comment">// ctrls数组+slots数组</span></span><br><span class="line">    <span class="comment">// 内存布局如下（C语言开发者真的很喜欢这种内存布局啊）</span></span><br><span class="line">    <span class="comment">// | ctrls         | slots         |</span></span><br><span class="line">    <span class="comment">// |ctrl7|...|ctrl0|slot0|...|slot7|</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量初始化调用的是maplit，具体看代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/walk/complit.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maplit</span><span class="params">(n *ir.CompLitExpr, m ir.Node, init *ir.Nodes)</span></span> &#123;</span><br><span class="line">    args := []ir.Node&#123;ir.TypeNode(n.Type()), ir.NewInt(base.Pos, n.Len+<span class="type">int64</span>(<span class="built_in">len</span>(n.List)))&#125;</span><br><span class="line">    a := typecheck.Expr(ir.NewCallExpr(base.Pos, ir.OMAKE, <span class="literal">nil</span>, args)).(*ir.MakeExpr)</span><br><span class="line">    a.RType = n.RType</span><br><span class="line">    a.SetEsc(n.Esc())</span><br><span class="line">    appendWalkStmt(init, ir.NewAssignStmt(base.Pos, m, a))</span><br><span class="line"></span><br><span class="line">    entries := n.List</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> entries &#123;</span><br><span class="line">        r := r.(*ir.KeyExpr)</span><br><span class="line">        <span class="keyword">if</span> !isStaticCompositeLiteral(r.Key) || !isStaticCompositeLiteral(r.Value) &#123;</span><br><span class="line">            base.Fatalf(<span class="string">&quot;maplit: entry is not a literal: %v&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(entries) &gt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// loop adding structure elements to map</span></span><br><span class="line">        <span class="comment">// for i = 0; i &lt; len(vstatk); i++ &#123;</span></span><br><span class="line">        <span class="comment">//    map[vstatk[i]] = vstate[i]</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，如果小于等于25个元素，直接赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">&quot;1&quot;</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">&quot;3&quot;</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">&quot;5&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>如果，大于25个元素，分key&#x2F;value两组，使用for循环进行赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstatk); i++ &#123;</span><br><span class="line">    <span class="keyword">map</span>[vstatk[i]] = vstate[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>当使用make关键字初始化map时，调用的是makemap，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *abi.SwissMapType, hint <span class="type">int</span>, m *maps.Map)</span></span> *maps.Map &#123;</span><br><span class="line">    <span class="keyword">if</span> hint &lt; <span class="number">0</span> &#123;</span><br><span class="line">        hint = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maps.NewMap(t, <span class="type">uintptr</span>(hint), m, maxAlloc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMap</span><span class="params">(mt *abi.SwissMapType, hint <span class="type">uintptr</span>, m *Map, maxAlloc <span class="type">uintptr</span>)</span></span> *Map &#123;</span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> &#123;</span><br><span class="line">        m = <span class="built_in">new</span>(Map)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希种子</span></span><br><span class="line">    m.seed = <span class="type">uintptr</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hint&lt;=8</span></span><br><span class="line">    <span class="keyword">if</span> hint &lt;= abi.SwissMapGroupSlots &#123;</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// capacity = hint*8/7 =&gt; 每个group最多容纳7个slot，不能直接按hint计算group数量</span></span><br><span class="line">    targetCapacity := (hint * abi.SwissMapGroupSlots) / maxAvgGroupLoad</span><br><span class="line">    <span class="keyword">if</span> targetCapacity &lt; hint &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirSize = (capacity+1024-1)/1024 =&gt; table数量 =&gt; 一个table=128个group=1024个slot</span></span><br><span class="line">    dirSize := (<span class="type">uint64</span>(targetCapacity) + maxTableCapacity - <span class="number">1</span>) / maxTableCapacity</span><br><span class="line">    <span class="comment">// 2的乘方向上取整，如dirSize=40? =&gt; dirSize=64</span></span><br><span class="line">    dirSize, overflow := alignUpPow2(dirSize)</span><br><span class="line">    <span class="comment">// overflow?</span></span><br><span class="line">    <span class="keyword">if</span> overflow || dirSize &gt; <span class="type">uint64</span>(math.MaxUintptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reject hints that are obviously too large.</span></span><br><span class="line">    <span class="comment">// ngroup = dirSize*1024</span></span><br><span class="line">    groups, overflow := math.MulUintptr(<span class="type">uintptr</span>(dirSize), maxTableCapacity)</span><br><span class="line">    <span class="keyword">if</span> overflow &#123;</span><br><span class="line">        <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ngroup*GroupSize overflow?</span></span><br><span class="line">        mem, overflow := math.MulUintptr(groups, mt.GroupSize)</span><br><span class="line">        <span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">            <span class="keyword">return</span> m <span class="comment">// return an empty map.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// globalDepth = 二进制数dirSize末尾有多少个0 =&gt; 2^globalDepth=dirSize</span></span><br><span class="line">    m.globalDepth = <span class="type">uint8</span>(sys.TrailingZeros64(dirSize))</span><br><span class="line">    <span class="comment">// globalShift = 64-globalDepth</span></span><br><span class="line">    m.globalShift = depthToShift(m.globalDepth)</span><br><span class="line"></span><br><span class="line">    directory := <span class="built_in">make</span>([]*table, dirSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建table</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> directory &#123;</span><br><span class="line">        <span class="comment">// (type, a/b, i, d)</span></span><br><span class="line">        <span class="comment">// capacity = a/b &lt;= 1024</span></span><br><span class="line">        directory[i] = newTable(mt, <span class="type">uint64</span>(targetCapacity)/dirSize, i, m.globalDepth)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m.dirPtr = unsafe.Pointer(&amp;directory[<span class="number">0</span>])</span><br><span class="line">    m.dirLen = <span class="built_in">len</span>(directory) <span class="comment">// 为什么不能直接用dirSize？</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="comment">// 创建table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTable</span><span class="params">(typ *abi.SwissMapType, capacity <span class="type">uint64</span>, index <span class="type">int</span>, localDepth <span class="type">uint8</span>)</span></span> *table &#123;</span><br><span class="line">    <span class="comment">// capacity最小值为8</span></span><br><span class="line">    <span class="keyword">if</span> capacity &lt; abi.SwissMapGroupSlots &#123;</span><br><span class="line">        capacity = abi.SwissMapGroupSlots</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t := &amp;table&#123;</span><br><span class="line">        index:      index,      <span class="comment">// 上层directory数组中的index</span></span><br><span class="line">        localDepth: localDepth, <span class="comment">// &lt;= globalDepth</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;1024 =&gt; 异常</span></span><br><span class="line">    <span class="keyword">if</span> capacity &gt; maxTableCapacity &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;initial table capacity too large&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2的乘方向上取整</span></span><br><span class="line">    capacity, overflow := alignUpPow2(capacity)</span><br><span class="line">    <span class="keyword">if</span> overflow &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;rounded-up capacity overflows uint64&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建groups</span></span><br><span class="line">    t.reset(typ, <span class="type">uint16</span>(capacity))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要职责 =&gt; 创建groups</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> reset(typ *abi.SwissMapType, capacity <span class="type">uint16</span>) &#123;</span><br><span class="line">    <span class="comment">// 8个slot为一组，最多1024/8=128组</span></span><br><span class="line">    groupCount := <span class="type">uint64</span>(capacity) / abi.SwissMapGroupSlots</span><br><span class="line">    <span class="comment">// 创建groups</span></span><br><span class="line">    t.groups = newGroups(typ, groupCount)</span><br><span class="line">    t.capacity = capacity</span><br><span class="line">    <span class="comment">// 根据capacity重置growthLeft字段</span></span><br><span class="line">    t.resetGrowthLeft()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于for i, g := range t.groups </span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">        g := t.groups.group(typ, i)</span><br><span class="line">        <span class="comment">// 每组有8个slot，每个slot对应的ctrl都设置为empty =&gt; 0b10000000</span></span><br><span class="line">        g.ctrls().setEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置table的growthLeft字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> resetGrowthLeft() &#123;</span><br><span class="line">    <span class="keyword">var</span> growthLeft <span class="type">uint16</span></span><br><span class="line">    <span class="keyword">if</span> t.capacity == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 1. capacity不能为0</span></span><br><span class="line">        <span class="comment">// No real reason to support zero capacity table, since an</span></span><br><span class="line">        <span class="comment">// empty Map simply won&#x27;t have a table.</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;table must have positive capacity&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.capacity &lt;= abi.SwissMapGroupSlots &#123;</span><br><span class="line">        <span class="comment">// 2. capacity &lt;= 8</span></span><br><span class="line">        <span class="comment">// If the map fits in a single group then we&#x27;re able to fill all of</span></span><br><span class="line">        <span class="comment">// the slots except 1 (an empty slot is needed to terminate find</span></span><br><span class="line">        <span class="comment">// operations).</span></span><br><span class="line">        growthLeft = t.capacity - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. capacity &gt; 8</span></span><br><span class="line">        <span class="comment">// capacity*7 &lt; capacity？</span></span><br><span class="line">        <span class="keyword">if</span> t.capacity*maxAvgGroupLoad &lt; t.capacity &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;overflow&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// growthLeft = capacity*7/8</span></span><br><span class="line">        growthLeft = (t.capacity * maxAvgGroupLoad) / abi.SwissMapGroupSlots</span><br><span class="line">    &#125;</span><br><span class="line">    t.growthLeft = growthLeft</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/group.go</span></span><br><span class="line"><span class="comment">// length =&gt; 2^N</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGroups</span><span class="params">(typ *abi.SwissMapType, length <span class="type">uint64</span>)</span></span> groupsReference &#123;</span><br><span class="line">    <span class="keyword">return</span> groupsReference&#123;</span><br><span class="line">        data:       newarray(typ.Group, <span class="type">int</span>(length)), <span class="comment">// 申请一片内存</span></span><br><span class="line">        lengthMask: length - <span class="number">1</span>, <span class="comment">// 2^N-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// group=8*ctrl+8*slot</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *groupsReference)</span></span> group(typ *abi.SwissMapType, i <span class="type">uint64</span>) groupReference &#123;</span><br><span class="line">    offset := <span class="type">uintptr</span>(i) * typ.GroupSize</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> groupReference&#123;</span><br><span class="line">        data: unsafe.Pointer(<span class="type">uintptr</span>(g.data) + offset),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对旧版，新版的逻辑看起来会复杂一些，大概的逻辑如下</p>
<ol>
<li>如果hint的数量不超过8，生成map header返回</li>
<li>如果hint的数量超过8<ul>
<li>新版map只能容纳7&#x2F;8的数据量，因此需要根据公式<code>hint*8/7</code>重新计算容量</li>
<li>根据容量计算table数量、group数量，基本都是2的乘方向上取整</li>
<li>生成table数组、group数组</li>
<li>map header、table、group等参数初始化</li>
</ul>
</li>
</ol>
<p>globalDepth、globalShift一部份数据示例如下</p>
<table>
<thead>
<tr>
<th align="left">dirSize(10)</th>
<th align="left">dirSize(2)</th>
<th align="left">globalDepth</th>
<th align="left">globalShift</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">0001</td>
<td align="left">0</td>
<td align="left">64</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">0010</td>
<td align="left">1</td>
<td align="left">63</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">0100</td>
<td align="left">2</td>
<td align="left">62</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">1000</td>
<td align="left">3</td>
<td align="left">61</td>
</tr>
</tbody></table>
<p>其他：</p>
<ol>
<li>table数量、group数量固定为2的乘方</li>
<li>table最大容量&#x3D;1024个slot&#x3D;128个group</li>
<li>group最大容量&#x3D;8个slot</li>
</ol>
<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>swiss table使用二次探测法法用于定位group，而终止扫描依赖group的ctrls字段，只要该字段中有一个处于empty状态，立即终止扫描，具体通过probeSeq实现</p>
<p>使用的二次探测法公式为：<code>p(i) := (i^2 + i)/2 + hash (mod mask+1)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// quadratic probing - 二次探测法</span></span><br><span class="line"><span class="keyword">type</span> probeSeq <span class="keyword">struct</span> &#123;</span><br><span class="line">    mask   <span class="type">uint64</span> <span class="comment">// groups数组的索引的最大值=2^N-1</span></span><br><span class="line">    offset <span class="type">uint64</span> <span class="comment">// groups数组索引（取hash的低N位）</span></span><br><span class="line">    index  <span class="type">uint64</span> <span class="comment">// 扫描计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeProbeSeq</span><span class="params">(hash <span class="type">uintptr</span>, mask <span class="type">uint64</span>)</span></span> probeSeq &#123;</span><br><span class="line">    <span class="keyword">return</span> probeSeq&#123;</span><br><span class="line">        mask:   mask,</span><br><span class="line">        offset: <span class="type">uint64</span>(hash) &amp; mask,</span><br><span class="line">        index:  <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s probeSeq)</span></span> next() probeSeq &#123;</span><br><span class="line">    s.index++</span><br><span class="line">    <span class="comment">// 从offset的位置开始循环groups数组扫描</span></span><br><span class="line">    <span class="comment">// 保证不超过groups数组的最大索引</span></span><br><span class="line">    <span class="comment">// p(i) := (i^2 + i)/2 + hash (mod mask+1)</span></span><br><span class="line">    s.offset = (s.offset + s.index) &amp; s.mask</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>probeSeq的使用示例如下，其中offset是group的定位索引，看起来还是比较均匀的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">seq := makeProbeSeq(<span class="number">12345678</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, seq)</span><br><span class="line">    seq = seq.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:6 index:0&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:7 index:1&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:1 index:2&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:4 index:3&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:0 index:4&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:5 index:5&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:3 index:6&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:2 index:7&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:2 index:8&#125;</span></span><br><span class="line"><span class="comment">// &#123;mask:7 offset:3 index:9&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h3><p>使用索引获取map的数值有两种</p>
<ol>
<li>仅接受一个参数</li>
<li>接受两个参数</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅接受一个参数</span></span><br><span class="line">v := h[key]</span><br><span class="line"><span class="comment">// 接受两个参数</span></span><br><span class="line">v, ok := h[key]</span><br></pre></td></tr></table></figure>

<p>当仅接受一个参数时，底层使用runtime_mapaccess1，当接受两个参数时，底层使用runtime_mapaccess2，其与runtime_mapaccess1只有返回值的不同</p>
<p>这里的runtime_mapaccess1逻辑与Get方法相似，因此只介绍maps包的接口方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/maps/runtime_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_mapaccess1</span><span class="params">(typ *abi.SwissMapType, m *Map, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_mapaccess2</span><span class="params">(typ *abi.SwissMapType, m *Map, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Get(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m.getWithoutKey(typ, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回key、value指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> getWithKey(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 无数据</span></span><br><span class="line">    <span class="keyword">if</span> m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个table一个group，数据量&lt;8</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.getWithKeySmall(typ, hash, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">    idx := m.directoryIndex(hash)</span><br><span class="line">    <span class="comment">// 找到table再找group最后找slot</span></span><br><span class="line">    <span class="keyword">return</span> m.directoryAt(idx).getWithKey(typ, hash, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回value指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> getWithoutKey(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 无数据</span></span><br><span class="line">    <span class="keyword">if</span> m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个table一个group，数据量&lt;8</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        _, elem, ok := m.getWithKeySmall(typ, hash, key)</span><br><span class="line">        <span class="keyword">return</span> elem, ok</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">    idx := m.directoryIndex(hash)</span><br><span class="line">    <span class="comment">// 找到table再找group最后找slot</span></span><br><span class="line">    <span class="keyword">return</span> m.directoryAt(idx).getWithoutKey(typ, hash, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据量小于等于8时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> getWithKeySmall(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 只有一个table一个group</span></span><br><span class="line">    <span class="comment">// table.groups不是第一个字段也能cast？</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取哈希值低7位</span></span><br><span class="line">    h2 := <span class="type">uint8</span>(h2(hash))</span><br><span class="line">    <span class="comment">// data的前64位为ctrls</span></span><br><span class="line">    ctrls := *g.ctrls()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8个slot</span></span><br><span class="line">    <span class="comment">// |ctrl7|...|ctrl0|slot0|...|slot7|</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.SwissMapGroupSlots; i++ &#123;</span><br><span class="line">        <span class="comment">// ctrls从后往前扫描，但i从0开始</span></span><br><span class="line">        c := <span class="type">uint8</span>(ctrls)</span><br><span class="line">        ctrls &gt;&gt;= <span class="number">8</span></span><br><span class="line">        <span class="keyword">if</span> c != h2 &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slot从前往后扫描</span></span><br><span class="line">        <span class="comment">// key</span></span><br><span class="line">        slotKey := g.key(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value</span></span><br><span class="line">        <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slotKey, slotElem, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是table相关</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> getWithKey(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">        match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match不为0，至少找到一个（假阳性）</span></span><br><span class="line">        <span class="comment">// |ctrl7|...|ctrl0|slot0|...|slot7|</span></span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            <span class="comment">// 看样子同一个i会被用很多次</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">                slotElem := g.elem(typ, i)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slotKey, slotElem, <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">            match = match.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmpty将非empty的ctrl全部置为0，如果8个ctrl都有数据，如full或者deleted状态，那么match=0</span></span><br><span class="line">        match = g.ctrls().matchEmpty()</span><br><span class="line">        <span class="keyword">if</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Finding an empty slot means we&#x27;ve reached the end of</span></span><br><span class="line">            <span class="comment">// the probe sequence.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与getWithKey相同，只有返回值不同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> getWithoutKey(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历访问"><a href="#遍历访问" class="headerlink" title="遍历访问"></a>遍历访问</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用for range遍历整个map时，依赖Iter数据结构实现该操作，大概过程如下</p>
<ol>
<li>创建Iter，纪录map的快照信息、生成随机数作为table、slot的索引偏移</li>
<li>调用Next方法，获取并存储第一个key&#x2F;value地址</li>
<li>上层函数继续调用Next方法，获取并存储下一个key&#x2F;value地址，或者主动退出循环</li>
</ol>
<p>注意：如果发生了扩容，iter.tab的index显示是已过时，需要从旧的table获取key，从新的table获取新的key&#x2F;value</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Iter <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  unsafe.Pointer     <span class="comment">// key指针 为nil结束遍历</span></span><br><span class="line">    elem unsafe.Pointer     <span class="comment">// value指针</span></span><br><span class="line">    typ  *abi.SwissMapType  <span class="comment">// 类型</span></span><br><span class="line">    m    *Map               <span class="comment">// map指针</span></span><br><span class="line">    entryOffset <span class="type">uint64</span>      <span class="comment">// slot计数器的偏移量（随机）</span></span><br><span class="line">    dirOffset   <span class="type">uint64</span>      <span class="comment">// table索引初始偏移（随机） -&gt; head</span></span><br><span class="line">    clearSeq <span class="type">uint64</span>         <span class="comment">// 执行过多少次clear</span></span><br><span class="line">    globalDepth <span class="type">uint8</span>       <span class="comment">// log2(dirLen)（相当于以前的B）</span></span><br><span class="line">    dirIdx <span class="type">int</span>              <span class="comment">// table索引 -&gt; curr</span></span><br><span class="line">    tab *table              <span class="comment">// table指针，不同dirIdx可以指向同一个tab</span></span><br><span class="line">    group groupReference    <span class="comment">// group指针</span></span><br><span class="line">    entryIdx <span class="type">uint64</span>         <span class="comment">// 整个table的slot计数器 [0,1023]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapIterStart</span><span class="params">(t *abi.SwissMapType, m *maps.Map, it *maps.Iter)</span></span> &#123;</span><br><span class="line">    it.Init(t, m)</span><br><span class="line">    it.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> Init(typ *abi.SwissMapType, m *Map) &#123;</span><br><span class="line">    it.typ = typ</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> || m.used == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    dirIdx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> groupSmall groupReference</span><br><span class="line">    <span class="comment">// 只有一个table一个group，数据量&lt;8</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Use dirIdx == -1 as sentinel for small maps.</span></span><br><span class="line">        dirIdx = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">        groupSmall.data = m.dirPtr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it.m = m</span><br><span class="line">    it.entryOffset = rand()        <span class="comment">// slot索引初始偏移</span></span><br><span class="line">    it.dirOffset = rand()          <span class="comment">// table索引初始偏移</span></span><br><span class="line">    it.globalDepth = m.globalDepth <span class="comment">// 2^B个table</span></span><br><span class="line">    it.dirIdx = dirIdx             <span class="comment">// 0-默认 -1-small map</span></span><br><span class="line">    it.group = groupSmall          <span class="comment">// nil-默认 否则 small map</span></span><br><span class="line">    it.clearSeq = m.clearSeq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapIterNext</span><span class="params">(it *maps.Iter)</span></span> &#123;</span><br><span class="line">    it.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> Next() &#123;</span><br><span class="line">    <span class="comment">// 空map，直接终止</span></span><br><span class="line">    <span class="keyword">if</span> it.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        it.key = <span class="literal">nil</span></span><br><span class="line">        it.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> it.m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. small map ，单个group</span></span><br><span class="line">    <span class="keyword">if</span> it.dirIdx &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有slot，从entryOffset开始</span></span><br><span class="line">        <span class="keyword">for</span> ; it.entryIdx &lt; abi.SwissMapGroupSlots; it.entryIdx++ &#123;</span><br><span class="line">            k := <span class="type">uintptr</span>(it.entryIdx+it.entryOffset) % abi.SwissMapGroupSlots</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除的或空的slot？跳过（small map删除直接设置为empty）</span></span><br><span class="line">            <span class="keyword">if</span> (it.group.ctrls().get(k) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            key := it.group.key(it.typ, k)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            grown := it.m.dirLen &gt; <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">            <span class="comment">// 还在扩容中</span></span><br><span class="line">            <span class="keyword">if</span> grown &#123;</span><br><span class="line">                <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">                <span class="comment">// 从扩容后的map获取</span></span><br><span class="line">                newKey, newElem, ok := it.m.getWithKey(it.typ, key)</span><br><span class="line">                <span class="comment">// 找不到</span></span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">// key是NaN</span></span><br><span class="line">                    <span class="comment">// NaN无法被update/delete，只能clear，如果很幸运，没有clear过，那么可以从旧的table里拿到数据</span></span><br><span class="line">                    <span class="comment">// 详细可以看grownKeyElem注释</span></span><br><span class="line">                    <span class="keyword">if</span> it.clearSeq == it.m.clearSeq &amp;&amp; !it.typ.Key.Equal(key, key) &#123;</span><br><span class="line">                        elem = it.group.elem(it.typ, k)</span><br><span class="line">                        <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                            elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 被删除了</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 按新的key/value为准</span></span><br><span class="line">                    key = newKey</span><br><span class="line">                    elem = newElem</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有扩容</span></span><br><span class="line">                elem = it.group.elem(it.typ, k)</span><br><span class="line">                <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新iter，方便下次调用</span></span><br><span class="line">            it.entryIdx++  <span class="comment">// [0,1023]</span></span><br><span class="line">            it.key = key   <span class="comment">// 上层读取数据用</span></span><br><span class="line">            it.elem = elem <span class="comment">// 上层读取数据用</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经扫描完所有slot</span></span><br><span class="line">        it.key = <span class="literal">nil</span></span><br><span class="line">        it.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 常规map</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果map在iter的过程中分裂了</span></span><br><span class="line">    <span class="keyword">if</span> it.globalDepth != it.m.globalDepth &#123;</span><br><span class="line">        <span class="comment">// Consider:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Before:</span></span><br><span class="line">        <span class="comment">// - 0: *t1</span></span><br><span class="line">        <span class="comment">// - 1: *t2  &lt;- dirIdx</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// After:</span></span><br><span class="line">        <span class="comment">// - 0: *t1a (split)</span></span><br><span class="line">        <span class="comment">// - 1: *t1b (split)</span></span><br><span class="line">        <span class="comment">// - 2: *t2  &lt;- dirIdx</span></span><br><span class="line">        <span class="comment">// - 3: *t2</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// dirIdx*(2^分裂次数)即可指向正确的table</span></span><br><span class="line">        <span class="comment">// 具体公式如下</span></span><br><span class="line">        <span class="comment">// dirIdx := (it.dirIdx + it.dirOffset) % it.m.dirLen</span></span><br><span class="line">        <span class="comment">// 需要保证结果为正</span></span><br><span class="line">        orders := it.m.globalDepth - it.globalDepth <span class="comment">// 分裂次数</span></span><br><span class="line">        it.dirIdx &lt;&lt;= orders    <span class="comment">// 2^orders</span></span><br><span class="line">        it.dirOffset &lt;&lt;= orders</span><br><span class="line">        <span class="comment">// it.m.dirLen // 调整directory时已经调整了dirLen，这里不需要再处理</span></span><br><span class="line">        it.globalDepth = it.m.globalDepth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描所有table [0,dirLen]，当然nextDirIdx会根据分裂等情况调整table的索引</span></span><br><span class="line">    <span class="keyword">for</span> ; it.dirIdx &lt; it.m.dirLen; it.nextDirIdx() &#123;</span><br><span class="line">        <span class="comment">// table第一次扫描时</span></span><br><span class="line">        <span class="keyword">if</span> it.tab == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// local dirIdx</span></span><br><span class="line">            dirIdx := <span class="type">int</span>((<span class="type">uint64</span>(it.dirIdx) + it.dirOffset) &amp; <span class="type">uint64</span>(it.m.dirLen<span class="number">-1</span>))</span><br><span class="line">            <span class="comment">// 找到目标table</span></span><br><span class="line">            newTab := it.m.directoryAt(<span class="type">uintptr</span>(dirIdx))</span><br><span class="line">            <span class="comment">// 解决随机dirIdx可能引发的问题</span></span><br><span class="line">            <span class="comment">// 扩容/分裂后，两个dirIdx可能指向同一个table</span></span><br><span class="line">            <span class="keyword">if</span> newTab.index != dirIdx &#123;</span><br><span class="line">                diff := dirIdx - newTab.index</span><br><span class="line">                <span class="comment">// 调整dirOffset，使其能指向table的index</span></span><br><span class="line">                it.dirOffset -= <span class="type">uint64</span>(diff)</span><br><span class="line">                <span class="comment">// 以table的index为准</span></span><br><span class="line">                dirIdx = newTab.index</span><br><span class="line">            &#125;</span><br><span class="line">            it.tab = newTab</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        entryMask := <span class="type">uint64</span>(it.tab.capacity) - <span class="number">1</span></span><br><span class="line">        <span class="comment">// 全局计数器超过table的容量时，扫描下一个table</span></span><br><span class="line">        <span class="keyword">if</span> it.entryIdx &gt; entryMask &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 Fast path：只判断当前idx指向的ctrl，这要比匹配一组ctrls快</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// slot全局计数器</span></span><br><span class="line">        entryIdx := (it.entryIdx + it.entryOffset) &amp; entryMask</span><br><span class="line">        <span class="comment">// slot局部计数器-按8取模</span></span><br><span class="line">        slotIdx := <span class="type">uintptr</span>(entryIdx &amp; (abi.SwissMapGroupSlots - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slotIdx重新回到0 or 第一次遍历当前table</span></span><br><span class="line">        <span class="keyword">if</span> slotIdx == <span class="number">0</span> || it.group.data == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// groupIdx=entryIdx丢弃低3位 =&gt; [0,127]</span></span><br><span class="line">            groupIdx := entryIdx &gt;&gt; abi.SwissMapGroupSlotsBits</span><br><span class="line">            it.group = it.tab.groups.group(it.typ, groupIdx)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，table、group、slot的索引都已经确认了，只判断单个slot即可</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前slot是刚好是有值的，ctrl=full</span></span><br><span class="line">        <span class="keyword">if</span> (it.group.ctrls().get(slotIdx) &amp; ctrlEmpty) == <span class="number">0</span> &#123;</span><br><span class="line">            key := it.group.key(it.typ, slotIdx)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            grown := it.tab.index == <span class="number">-1</span></span><br><span class="line">            <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">            <span class="comment">// 扩容中</span></span><br><span class="line">            <span class="keyword">if</span> grown &#123;</span><br><span class="line">                <span class="comment">// 从新table拿数据，如果拿不到，确认是NaN还是已删除</span></span><br><span class="line">                newKey, newElem, ok := it.grownKeyElem(key, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">// 没找到，走slow path</span></span><br><span class="line">                    <span class="keyword">goto</span> next</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    key = newKey</span><br><span class="line">                    elem = newElem</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非扩容</span></span><br><span class="line">                elem = it.group.elem(it.typ, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 纪录key/value</span></span><br><span class="line">            it.entryIdx++</span><br><span class="line">            it.key = key</span><br><span class="line">            it.elem = elem</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    next:</span><br><span class="line">        <span class="comment">// 计数器+1</span></span><br><span class="line">        it.entryIdx++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 Slow path：批量匹配一组ctrl</span></span><br><span class="line">        <span class="comment">// 如果map比较稀疏效率会比较高</span></span><br><span class="line">        <span class="comment">// 如果是中等负载运行效果亦佳，如每个group有3-4个empty的slot</span></span><br><span class="line">        <span class="comment">// 遍历过程可能会发生删除等操作，需要double-check</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> groupMatch bitset</span><br><span class="line">        <span class="keyword">for</span> it.entryIdx &lt;= entryMask &#123;</span><br><span class="line">            <span class="comment">// slot全局计数器</span></span><br><span class="line">            entryIdx := (it.entryIdx + it.entryOffset) &amp; entryMask</span><br><span class="line">            <span class="comment">// slot局部计数器-按8取模</span></span><br><span class="line">            slotIdx := <span class="type">uintptr</span>(entryIdx &amp; (abi.SwissMapGroupSlots - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// slotIdx重新回到0 or 第一次遍历当前table</span></span><br><span class="line">            <span class="keyword">if</span> slotIdx == <span class="number">0</span> || it.group.data == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// groupIdx=entryIdx丢弃低3位 =&gt; [0,127]</span></span><br><span class="line">                groupIdx := entryIdx &gt;&gt; abi.SwissMapGroupSlotsBits</span><br><span class="line">                it.group = it.tab.groups.group(it.typ, groupIdx)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 刚开始 或者 上一轮没找到</span></span><br><span class="line">            <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 寻找ctrl=full状态的slot</span></span><br><span class="line">                groupMatch = it.group.ctrls().matchFull()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> slotIdx != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 把当前group的idx&lt;slotIdx的ctrl全部置为0，即丢弃掉</span></span><br><span class="line">                    <span class="comment">// 扫描过？or 随机？</span></span><br><span class="line">                    groupMatch = groupMatch.removeBelow(slotIdx)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有找到</span></span><br><span class="line">                <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 扫描下一个group</span></span><br><span class="line">                    it.entryIdx += abi.SwissMapGroupSlots - <span class="type">uint64</span>(slotIdx)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到一组数据了</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取第一个full slot</span></span><br><span class="line">                i := groupMatch.first()</span><br><span class="line">                <span class="comment">// 调整计数器，使其指向当前slot =&gt; slotIdx=i</span></span><br><span class="line">                it.entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">                <span class="comment">// 扫描了table全部数据了，扫描下一个table</span></span><br><span class="line">                <span class="comment">// idx roll over了，这个数据之前已经返回过了</span></span><br><span class="line">                <span class="keyword">if</span> it.entryIdx &gt; entryMask &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这句源代码应该是写重复了</span></span><br><span class="line">                entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">                slotIdx = i</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            key := it.group.key(it.typ, slotIdx)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            grown := it.tab.index == <span class="number">-1</span></span><br><span class="line">            <span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line">            <span class="comment">// 扩容/分裂后</span></span><br><span class="line">            <span class="keyword">if</span> grown &#123;</span><br><span class="line">                <span class="comment">// 从新table拿数据，如果拿不到，确认是NaN还是已删除</span></span><br><span class="line">                newKey, newElem, ok := it.grownKeyElem(key, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">// 没找到</span></span><br><span class="line">                    <span class="comment">// groupMatch末尾第一个1将会被置为0</span></span><br><span class="line">                    groupMatch = groupMatch.removeFirst()</span><br><span class="line">                    <span class="comment">// 当前组的slot扫描完了</span></span><br><span class="line">                    <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 指向下一个group开始位置</span></span><br><span class="line">                        it.entryIdx += abi.SwissMapGroupSlots - <span class="type">uint64</span>(slotIdx)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 下一个非空的slot的idx</span></span><br><span class="line">                    i := groupMatch.first()</span><br><span class="line">                    it.entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    key = newKey</span><br><span class="line">                    elem = newElem</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非扩容</span></span><br><span class="line">                elem = it.group.elem(it.typ, slotIdx)</span><br><span class="line">                <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// groupMatch末尾第一个1将会被置为0</span></span><br><span class="line">            groupMatch = groupMatch.removeFirst()</span><br><span class="line">            <span class="comment">// 当前组的slot扫描完了</span></span><br><span class="line">            <span class="keyword">if</span> groupMatch == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 指向下一个group开始位置</span></span><br><span class="line">                it.entryIdx += abi.SwissMapGroupSlots - <span class="type">uint64</span>(slotIdx)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一个非空的slot的idx</span></span><br><span class="line">                i := groupMatch.first()</span><br><span class="line">                it.entryIdx += <span class="type">uint64</span>(i - slotIdx)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it.key = key</span><br><span class="line">            it.elem = elem</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Continue to next table.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描完所有table，结束</span></span><br><span class="line">    it.key = <span class="literal">nil</span></span><br><span class="line">    it.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个dirIdx，原文已经详细介绍了原理，不再赘述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> nextDirIdx() &#123;</span><br><span class="line">    <span class="comment">// Consider this directory:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// - 0: *t1</span></span><br><span class="line">    <span class="comment">// - 1: *t1</span></span><br><span class="line">    <span class="comment">// - 2: *t2a</span></span><br><span class="line">    <span class="comment">// - 3: *t2b</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果随机的dirIdx指向1，调整为0，上层代码已处理</span></span><br><span class="line">    <span class="comment">// 如果dirIdx指向0，下一个dirIdx指向2，跳过1</span></span><br><span class="line">    <span class="comment">// 如果此时t1分裂了，而我们的tab指向是旧的t1而不是t1a、t1b，依然要指跳过1</span></span><br><span class="line">    entries := <span class="number">1</span> &lt;&lt; (it.m.globalDepth - it.tab.localDepth)</span><br><span class="line">    it.dirIdx += entries</span><br><span class="line">    it.tab = <span class="literal">nil</span></span><br><span class="line">    it.group = groupReference&#123;&#125;</span><br><span class="line">    it.entryIdx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从新table拿数据，如果拿不到，确认是NaN还是已删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iter)</span></span> grownKeyElem(key unsafe.Pointer, slotIdx <span class="type">uintptr</span>) (unsafe.Pointer, unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    newKey, newElem, ok := it.m.getWithKey(it.typ, key)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// Key has likely been deleted, and</span></span><br><span class="line">        <span class="comment">// should be skipped.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// One exception is keys that don&#x27;t</span></span><br><span class="line">        <span class="comment">// compare equal to themselves (e.g.,</span></span><br><span class="line">        <span class="comment">// NaN). These keys cannot be looked</span></span><br><span class="line">        <span class="comment">// up, so getWithKey will fail even if</span></span><br><span class="line">        <span class="comment">// the key exists.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// However, we are in luck because such</span></span><br><span class="line">        <span class="comment">// keys cannot be updated and they</span></span><br><span class="line">        <span class="comment">// cannot be deleted except with clear.</span></span><br><span class="line">        <span class="comment">// Thus if no clear has occurred, the</span></span><br><span class="line">        <span class="comment">// key/elem must still exist exactly as</span></span><br><span class="line">        <span class="comment">// in the old groups, so we can return</span></span><br><span class="line">        <span class="comment">// them from there.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// TODO(prattmic): Consider checking</span></span><br><span class="line">        <span class="comment">// clearSeq early. If a clear occurred,</span></span><br><span class="line">        <span class="comment">// Next could always return</span></span><br><span class="line">        <span class="comment">// immediately, as iteration doesn&#x27;t</span></span><br><span class="line">        <span class="comment">// need to return anything added after</span></span><br><span class="line">        <span class="comment">// clear.</span></span><br><span class="line">        <span class="keyword">if</span> it.clearSeq == it.m.clearSeq &amp;&amp; !it.typ.Key.Equal(key, key) &#123;</span><br><span class="line">            elem := it.group.elem(it.typ, slotIdx)</span><br><span class="line">            <span class="keyword">if</span> it.typ.IndirectElem() &#123;</span><br><span class="line">                elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> key, elem, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This entry doesn&#x27;t exist anymore.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newKey, newElem, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">v1[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>系统调用runtime_mapassign实现map的赋值操作，其代码逻辑与Put方法相似，大概逻辑如下</p>
<ol>
<li>如果是小map，扫描group，找到空位置返回地址</li>
<li>如果是常规大小的map，根据哈希值找到table，用二次探测法找到合适的group，最后找到空位置返回地址</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_mapassign</span><span class="params">(typ *abi.SwissMapType, m *Map, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Put(typ *abi.SwissMapType, key, elem unsafe.Pointer) &#123;</span><br><span class="line">    slotElem := m.PutSlot(typ, key)</span><br><span class="line">    typedmemmove(typ.Elem, slotElem, elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PutSlot returns a pointer to the element slot where an inserted element</span></span><br><span class="line"><span class="comment">// should be written.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PutSlot never returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> PutSlot(typ *abi.SwissMapType, key unsafe.Pointer) unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set writing after calling Hasher, since Hasher may panic, in which</span></span><br><span class="line">    <span class="comment">// case we have not actually done a write.</span></span><br><span class="line">    m.writing ^= <span class="number">1</span> <span class="comment">// toggle, see comment on writing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空的，原因有很多，这里初始化一个table一个group</span></span><br><span class="line">    <span class="keyword">if</span> m.dirPtr == <span class="literal">nil</span> &#123;</span><br><span class="line">        m.growToSmall(typ)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// used&lt;8</span></span><br><span class="line">        <span class="keyword">if</span> m.used &lt; abi.SwissMapGroupSlots &#123;</span><br><span class="line">            <span class="comment">// value指针</span></span><br><span class="line">            elem := m.putSlotSmall(typ, hash, key)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">            <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">                fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取消writing标志</span></span><br><span class="line">            m.writing ^= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> elem</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// used&gt;=8？扩容</span></span><br><span class="line">        <span class="comment">// 单个group到完整的table-groups结构</span></span><br><span class="line">        m.growToTable(typ)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirLen&gt;0 or used&gt;=8</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">        idx := m.directoryIndex(hash)</span><br><span class="line">        elem, ok := m.directoryAt(idx).PutSlot(typ, m, hash, key)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">        <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">            fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取消writing标志</span></span><br><span class="line">        m.writing ^= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// small map初始化group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> growToSmall(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 创建一个group</span></span><br><span class="line">    grp := newGroups(typ, <span class="number">1</span>)</span><br><span class="line">    m.dirPtr = grp.data</span><br><span class="line"></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个slot对应的ctrl都设置为empty =&gt; 0b10000000</span></span><br><span class="line">    g.ctrls().setEmpty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个group到完整的table-groups结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> growToTable(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 一个table，两个group</span></span><br><span class="line">    <span class="comment">// capacity=16 index=0 localDepth=0</span></span><br><span class="line">    tab := newTable(typ, <span class="number">2</span>*abi.SwissMapGroupSlots, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原先的group指针</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; abi.SwissMapGroupSlots; i++ &#123;</span><br><span class="line">        <span class="comment">// 空的不处理</span></span><br><span class="line">        <span class="keyword">if</span> (g.ctrls().get(i) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">            <span class="comment">// Empty</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key地址</span></span><br><span class="line">        key := g.key(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            key = *((*unsafe.Pointer)(key))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value地址</span></span><br><span class="line">        elem := g.elem(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">            elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key的hash</span></span><br><span class="line">        hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">        tab.uncheckedPutSlot(typ, hash, key, elem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个table</span></span><br><span class="line">    directory := <span class="built_in">make</span>([]*table, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    directory[<span class="number">0</span>] = tab</span><br><span class="line"></span><br><span class="line">    m.dirPtr = unsafe.Pointer(&amp;directory[<span class="number">0</span>])</span><br><span class="line">    m.dirLen = <span class="built_in">len</span>(directory)</span><br><span class="line"></span><br><span class="line">    m.globalDepth = <span class="number">0</span> <span class="comment">// 2^0=1</span></span><br><span class="line">    m.globalShift = depthToShift(m.globalDepth) <span class="comment">// 64-0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有一个table一个group时，或者说只有一个group时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> putSlotSmall(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">    match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已存在（假阳性）</span></span><br><span class="line">    <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个非空的slot</span></span><br><span class="line">        i := match.first()</span><br><span class="line"></span><br><span class="line">        slotKey := g.key(typ, i)</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">            <span class="keyword">if</span> typ.NeedKeyUpdate() &#123;</span><br><span class="line">                typedmemmove(typ.Key, slotKey, key)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回value的地址</span></span><br><span class="line">            <span class="keyword">return</span> slotElem</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">        match = match.removeFirst()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// matchEmptyOrDeleted将full状态的ctrl全部置为0，找到empty和deleted的slot</span></span><br><span class="line">    <span class="comment">// small map不能删除slot</span></span><br><span class="line">    match = g.ctrls().matchEmptyOrDeleted()</span><br><span class="line">    <span class="comment">// 8个slot都被使用了</span></span><br><span class="line">    <span class="keyword">if</span> match == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;small map with no empty slot (concurrent map writes?)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过上一步，empty跟delete标记的slot都被找出来了</span></span><br><span class="line">    i := match.first()</span><br><span class="line"></span><br><span class="line">    slotKey := g.key(typ, i)</span><br><span class="line">    <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">        kmem := newobject(typ.Key)</span><br><span class="line">        *(*unsafe.Pointer)(slotKey) = kmem</span><br><span class="line">        slotKey = kmem</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemmove(typ.Key, slotKey, key)</span><br><span class="line"></span><br><span class="line">    slotElem := g.elem(typ, i)</span><br><span class="line">    <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">        emem := newobject(typ.Elem)</span><br><span class="line">        *(*unsafe.Pointer)(slotElem) = emem</span><br><span class="line">        slotElem = emem</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctrl状态更新</span></span><br><span class="line">    g.ctrls().set(i, ctrl(h2(hash)))</span><br><span class="line">    <span class="comment">// 计数器更新，small map用的是map结构体的used</span></span><br><span class="line">    m.used++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slotElem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> PutSlot(typ *abi.SwissMapType, m *Map, hash <span class="type">uintptr</span>, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录第一个已删除slot的group指针和slot索引</span></span><br><span class="line">    <span class="keyword">var</span> firstDeletedGroup groupReference</span><br><span class="line">    <span class="keyword">var</span> firstDeletedSlot <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line">        <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">        match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match不为0，至少找到一个（假阳性）</span></span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            <span class="comment">// 看样子同一个i会被用很多次</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">                <span class="comment">// 更新key？</span></span><br><span class="line">                <span class="keyword">if</span> typ.NeedKeyUpdate() &#123;</span><br><span class="line">                    typedmemmove(typ.Key, slotKey, key)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// value</span></span><br><span class="line">                slotElem := g.elem(typ, i)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    slotElem = *((*unsafe.Pointer)(slotElem))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// debug时开启，忽略</span></span><br><span class="line">                t.checkInvariants(typ, m)</span><br><span class="line">                <span class="keyword">return</span> slotElem, <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">            match = match.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmptyOrDeleted将full状态的ctrl全部置为0，找到empty和deleted的slot</span></span><br><span class="line">        match = g.ctrls().matchEmptyOrDeleted()</span><br><span class="line">        <span class="comment">// 8个slot都被使用了，看是否在其他group</span></span><br><span class="line">        <span class="keyword">if</span> match == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// nothing but filled slots. Keep probing.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有空的或被删除的slot</span></span><br><span class="line">        i := match.first()</span><br><span class="line">        <span class="comment">// 该slot已删除，继续找其他group</span></span><br><span class="line">        <span class="comment">// todo 其他index都是已删除吗？为什么不继续找当前group</span></span><br><span class="line">        <span class="keyword">if</span> g.ctrls().get(i) == ctrlDeleted &#123;</span><br><span class="line">            <span class="comment">// 纪录group指针和slot的index</span></span><br><span class="line">            <span class="keyword">if</span> firstDeletedGroup.data == <span class="literal">nil</span> &#123;</span><br><span class="line">                firstDeletedGroup = g</span><br><span class="line">                firstDeletedSlot = i</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// empty代表探测的末尾，不用再找了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we found a deleted slot along the way, we can</span></span><br><span class="line">        <span class="comment">// replace it without consuming growthLeft.</span></span><br><span class="line">        <span class="keyword">if</span> firstDeletedGroup.data != <span class="literal">nil</span> &#123;</span><br><span class="line">            g = firstDeletedGroup</span><br><span class="line">            i = firstDeletedSlot</span><br><span class="line">            t.growthLeft++ <span class="comment">// will be decremented below to become a no-op.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is room left to grow, just insert the new entry.</span></span><br><span class="line">        <span class="keyword">if</span> t.growthLeft &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                kmem := newobject(typ.Key)</span><br><span class="line">                *(*unsafe.Pointer)(slotKey) = kmem</span><br><span class="line">                slotKey = kmem</span><br><span class="line">            &#125;</span><br><span class="line">            typedmemmove(typ.Key, slotKey, key)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                emem := newobject(typ.Elem)</span><br><span class="line">                *(*unsafe.Pointer)(slotElem) = emem</span><br><span class="line">                slotElem = emem</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// map/table/group状态更新</span></span><br><span class="line">            g.ctrls().set(i, ctrl(h2(hash)))</span><br><span class="line">            t.growthLeft--</span><br><span class="line">            t.used++</span><br><span class="line">            m.used++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// debug时开启，忽略</span></span><br><span class="line">            t.checkInvariants(typ, m)</span><br><span class="line">            <span class="keyword">return</span> slotElem, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// table扩容，如果超过限制的1024个slot，分裂并更新map</span></span><br><span class="line">        t.rehash(typ, m)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时用，复制旧的table的slot数据到新的table</span></span><br><span class="line"><span class="comment">// 1. growthLeft-- used++</span></span><br><span class="line"><span class="comment">// 2. 不能有已删除的slot</span></span><br><span class="line"><span class="comment">// 3. indirect的key和value可以直接复制，由调用者保证key/value数据不变</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> uncheckedPutSlot(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key, elem unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> t.growthLeft == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;invariant failed: growthLeft is unexpectedly 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmptyOrDeleted将full状态的ctrl全部置为0，找到empty和deleted的slot</span></span><br><span class="line">        match := g.ctrls().matchEmptyOrDeleted()</span><br><span class="line">        <span class="comment">// match不为0，至少找到一个</span></span><br><span class="line">        <span class="keyword">if</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(slotKey) = key</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                typedmemmove(typ.Key, slotKey, key)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制value</span></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                *(*unsafe.Pointer)(slotElem) = elem</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                typedmemmove(typ.Elem, slotElem, elem)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 状态更新</span></span><br><span class="line">            t.growthLeft--</span><br><span class="line">            t.used++</span><br><span class="line">            g.ctrls().set(i, ctrl(h2(hash)))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>map使用growthLeft作为可用的slot大小，该值一般为capacity*7&#x2F;8，最大值为896。每次写入都会消耗growthLeft，当growthLeft减少到0时，触发扩容，扩容函数为rehash</p>
<p>大概逻辑如下</p>
<ol>
<li>如果扩容后到容量没有超过单个table的容量限制<ul>
<li>创建双倍容量的新table，将旧table的数据拷贝到新的table</li>
<li>dirPtr按指定索引替换掉table指针</li>
</ul>
</li>
<li>如果扩容后容量超过单个table的容量限制<ul>
<li>创建两个容量为1024的table_a和table_b</li>
<li>按哈希值高B+1位疏散slot数据到新的table</li>
<li>疏散完毕后，双倍扩容dirPtr数组</li>
<li>重新调整dirPtr数组指针</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// table扩容，如果超过限制的1024个slot，分裂并更新map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> rehash(typ *abi.SwissMapType, m *Map) &#123;</span><br><span class="line">    <span class="comment">// 双倍容量</span></span><br><span class="line">    newCapacity := <span class="number">2</span> * t.capacity</span><br><span class="line">    <span class="comment">// 没有超过单个table的容量限制 -&gt; 扩容</span></span><br><span class="line">    <span class="keyword">if</span> newCapacity &lt;= maxTableCapacity &#123;</span><br><span class="line">        t.grow(typ, m, newCapacity)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过单个table容量限制 -&gt; 分裂</span></span><br><span class="line">    t.split(typ, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> grow(typ *abi.SwissMapType, m *Map, newCapacity <span class="type">uint16</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建table</span></span><br><span class="line">    newTable := newTable(typ, <span class="type">uint64</span>(newCapacity), t.index, t.localDepth)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里还能等于0？</span></span><br><span class="line">    <span class="keyword">if</span> t.capacity &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有group</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">            g := t.groups.group(typ, i)</span><br><span class="line">            <span class="comment">// 遍历所有slot</span></span><br><span class="line">            <span class="keyword">for</span> j := <span class="type">uintptr</span>(<span class="number">0</span>); j &lt; abi.SwissMapGroupSlots; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> (g.ctrls().get(j) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">                    <span class="comment">// Empty or deleted</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// key</span></span><br><span class="line">                key := g.key(typ, j)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                    key = *((*unsafe.Pointer)(key))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// value</span></span><br><span class="line">                elem := g.elem(typ, j)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// hash</span></span><br><span class="line">                hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 复制key和value到newTable</span></span><br><span class="line">                newTable.uncheckedPutSlot(typ, hash, key, elem)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug时开启，忽略</span></span><br><span class="line">    newTable.checkInvariants(typ, m)</span><br><span class="line">    <span class="comment">// dirPtr指定index关联newTable</span></span><br><span class="line">    m.replaceTable(newTable)</span><br><span class="line">    <span class="comment">// 旧的table标记为过期</span></span><br><span class="line">    t.index = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// table分裂</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    directory (globalDepth=2)</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="comment">//    | 00 | --\</span></span><br><span class="line"><span class="comment">//    +----+    +--&gt; table (localDepth=1)</span></span><br><span class="line"><span class="comment">//    | 01 | --/</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="comment">//    | 10 | ------&gt; table (localDepth=2)</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="comment">//    | 11 | ------&gt; table (localDepth=2)</span></span><br><span class="line"><span class="comment">//    +----+</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> split(typ *abi.SwissMapType, m *Map) &#123;</span><br><span class="line">    localDepth := t.localDepth</span><br><span class="line">    localDepth++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// capacity=1024 index=-1 localDepth=localDepth+1</span></span><br><span class="line">    <span class="comment">// 两个table设置为已过期</span></span><br><span class="line">    left := newTable(typ, maxTableCapacity, <span class="number">-1</span>, localDepth)</span><br><span class="line">    right := newTable(typ, maxTableCapacity, <span class="number">-1</span>, localDepth)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1&lt;&lt;(64-localDepth) 高(B+1)位所谓索引</span></span><br><span class="line">    <span class="comment">// origin_depth=1 index =&gt; [0,1]</span></span><br><span class="line">    <span class="comment">// current_depth=2 index =&gt; [0,1,2,3]</span></span><br><span class="line">    mask := localDepthMask(localDepth)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有group</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">        g := t.groups.group(typ, i)</span><br><span class="line">        <span class="comment">// 遍历所有slot</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="type">uintptr</span>(<span class="number">0</span>); j &lt; abi.SwissMapGroupSlots; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.ctrls().get(j) &amp; ctrlEmpty) == ctrlEmpty &#123;</span><br><span class="line">                <span class="comment">// Empty or deleted</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            key := g.key(typ, j)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                key = *((*unsafe.Pointer)(key))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// value</span></span><br><span class="line">            elem := g.elem(typ, j)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// hash</span></span><br><span class="line">            hash := typ.Hasher(key, m.seed)</span><br><span class="line">            <span class="keyword">var</span> newTable *table</span><br><span class="line">            <span class="comment">// 按hash新的bit进行分组</span></span><br><span class="line">            <span class="keyword">if</span> hash&amp;mask == <span class="number">0</span> &#123;</span><br><span class="line">                newTable = left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newTable = right</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 复制key和value到newTable</span></span><br><span class="line">            newTable.uncheckedPutSlot(typ, hash, key, elem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    m.installTableSplit(t, left, right)</span><br><span class="line">    <span class="comment">// 旧的table标记为过期</span></span><br><span class="line">    t.index = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据table的index，更新dirPtr数组的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> replaceTable(nt *table) &#123;</span><br><span class="line">    <span class="comment">// The number of entries that reference the same table doubles for each</span></span><br><span class="line">    <span class="comment">// time the globalDepth grows without the table splitting.</span></span><br><span class="line">    entries := <span class="number">1</span> &lt;&lt; (m.globalDepth - nt.localDepth)</span><br><span class="line">    <span class="comment">// 有分裂？更新多个dirPtr数组的table指针，没有分裂就会只有一个index</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; entries; i++ &#123;</span><br><span class="line">        <span class="comment">//m.directory[nt.index+i] = nt</span></span><br><span class="line">        m.directorySet(<span class="type">uintptr</span>(nt.index+i), nt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> installTableSplit(old, left, right *table) &#123;</span><br><span class="line">    <span class="comment">// table分裂了，dirPtr数组需要扩容</span></span><br><span class="line">    <span class="comment">// 第一个分裂的table</span></span><br><span class="line">    <span class="keyword">if</span> old.localDepth == m.globalDepth &#123;</span><br><span class="line">        <span class="comment">// 双倍扩容</span></span><br><span class="line">        newDir := <span class="built_in">make</span>([]*table, m.dirLen*<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> m.dirLen &#123;</span><br><span class="line">            t := m.directoryAt(<span class="type">uintptr</span>(i))</span><br><span class="line">            <span class="comment">// 指向同一个table</span></span><br><span class="line">            newDir[<span class="number">2</span>*i] = t</span><br><span class="line">            newDir[<span class="number">2</span>*i+<span class="number">1</span>] = t</span><br><span class="line">            <span class="comment">// t may already exist in multiple indicies. We should</span></span><br><span class="line">            <span class="comment">// only update t.index once. Since the index must</span></span><br><span class="line">            <span class="comment">// increase, seeing the original index means this must</span></span><br><span class="line">            <span class="comment">// be the first time we&#x27;ve encountered this table.</span></span><br><span class="line">            <span class="keyword">if</span> t.index == i &#123;</span><br><span class="line">                t.index = <span class="number">2</span> * i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m.globalDepth++</span><br><span class="line">        m.globalShift--</span><br><span class="line">        m.dirPtr = unsafe.Pointer(&amp;newDir[<span class="number">0</span>])</span><br><span class="line">        m.dirLen = <span class="built_in">len</span>(newDir)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// N.B. left and right may still consume multiple indicies if the</span></span><br><span class="line">    <span class="comment">// directory has grown multiple times since old was last split.</span></span><br><span class="line">    left.index = old.index</span><br><span class="line">    <span class="comment">// dirPtr指定index关联newTable</span></span><br><span class="line">    m.replaceTable(left)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他table可能分裂多次，导致localDepth远小于globalDepth，无法直接+1</span></span><br><span class="line">    entries := <span class="number">1</span> &lt;&lt; (m.globalDepth - left.localDepth)</span><br><span class="line">    right.index = left.index + entries</span><br><span class="line">    <span class="comment">// dirPtr指定index关联newTable</span></span><br><span class="line">    m.replaceTable(right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(v1, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当使用关键字delete删除指定key时，调用mapdelete，大概逻辑如下</p>
<ol>
<li>如果map的slot数量小于等于8，small map，直接扫描dirPtr指向的group，删除key&#x2F;value并将对应的ctrl改为empty</li>
<li>如果map的slot数量大于8，根据hash使用二次探测查找法定位table、group，找到目标slot<ul>
<li>如果该group是满数据的，将ctrl改为deleted</li>
<li>如果该group是有空位的，将ctrl改为empty</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *abi.SwissMapType, m *maps.Map, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    m.Delete(t, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(typ *abi.SwissMapType, key unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> || m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := mapKeyError(typ, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err) <span class="comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := typ.Hasher(key, m.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set writing after calling Hasher, since Hasher may panic, in which</span></span><br><span class="line">    <span class="comment">// case we have not actually done a write.</span></span><br><span class="line">    m.writing ^= <span class="number">1</span> <span class="comment">// toggle, see comment on writing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        m.deleteSmall(typ, hash, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算table的索引，取hash高B位</span></span><br><span class="line">        idx := m.directoryIndex(hash)</span><br><span class="line">        m.directoryAt(idx).Delete(typ, m, hash, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删光了？重置hash种子</span></span><br><span class="line">    <span class="keyword">if</span> m.used == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Reset the hash seed to make it more difficult for attackers</span></span><br><span class="line">        <span class="comment">// to repeatedly trigger hash collisions. See</span></span><br><span class="line">        <span class="comment">// https://go.dev/issue/25237.</span></span><br><span class="line">        m.seed = <span class="type">uintptr</span>(rand())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消writing标志</span></span><br><span class="line">    m.writing ^= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有一个table一个group时，或者说只有一个group时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> deleteSmall(typ *abi.SwissMapType, hash <span class="type">uintptr</span>, key unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">    match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到了（假阳性）</span></span><br><span class="line">    <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 按顺序比对ctrl</span></span><br><span class="line">        i := match.first()</span><br><span class="line">        slotKey := g.key(typ, i)</span><br><span class="line">        origSlotKey := slotKey</span><br><span class="line">        <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">            slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key比对成功</span></span><br><span class="line">        <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">            <span class="comment">// 计数器更新，small map用的是map结构体的used</span></span><br><span class="line">            m.used--</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key是一个指针，直接置为nil</span></span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                *(*unsafe.Pointer)(origSlotKey) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> typ.Key.Pointers() &#123;</span><br><span class="line">                <span class="comment">// key存储的是一个指针</span></span><br><span class="line">                <span class="comment">// Only bother clearing if there are pointers.</span></span><br><span class="line">                typedmemclr(typ.Key, slotKey)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            slotElem := g.elem(typ, i)</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                *(*unsafe.Pointer)(slotElem) = <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Unlike keys, always clear the elem (even if</span></span><br><span class="line">                <span class="comment">// it contains no pointers), as compound</span></span><br><span class="line">                <span class="comment">// assignment operations depend on cleared</span></span><br><span class="line">                <span class="comment">// deleted values. See</span></span><br><span class="line">                <span class="comment">// https://go.dev/issue/25936.</span></span><br><span class="line">                typedmemclr(typ.Elem, slotElem)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置为empty而不是deleted</span></span><br><span class="line">            <span class="comment">// We only have 1 group, so it is OK to immediately</span></span><br><span class="line">            <span class="comment">// reuse deleted slots.</span></span><br><span class="line">            g.ctrls().set(i, ctrlEmpty)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">        match = match.removeFirst()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> Delete(typ *abi.SwissMapType, m *Map, hash <span class="type">uintptr</span>, key unsafe.Pointer) &#123;</span><br><span class="line">    <span class="comment">// probeSeq</span></span><br><span class="line">    seq := makeProbeSeq(h1(hash), t.groups.lengthMask)</span><br><span class="line">    <span class="comment">// 二次探测查找</span></span><br><span class="line">    <span class="keyword">for</span> ; ; seq = seq.next() &#123;</span><br><span class="line">        <span class="comment">// 找到指定group</span></span><br><span class="line">        g := t.groups.group(typ, seq.offset)</span><br><span class="line">        <span class="comment">// 一次性比对8个ctrl，将成功匹配的ctrl挑出来</span></span><br><span class="line">        match := g.ctrls().matchH2(h2(hash))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了（假阳性）</span></span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个非0的ctrl的索引，根据match的末尾有多少个0算出</span></span><br><span class="line">            i := match.first()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key</span></span><br><span class="line">            slotKey := g.key(typ, i)</span><br><span class="line">            origSlotKey := slotKey</span><br><span class="line">            <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                slotKey = *((*unsafe.Pointer)(slotKey))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key比对成功</span></span><br><span class="line">            <span class="keyword">if</span> typ.Key.Equal(key, slotKey) &#123;</span><br><span class="line">                <span class="comment">// 计数器更新</span></span><br><span class="line">                t.used--</span><br><span class="line">                m.used--</span><br><span class="line"></span><br><span class="line">                <span class="comment">// key是一个指针，直接置为nil</span></span><br><span class="line">                <span class="keyword">if</span> typ.IndirectKey() &#123;</span><br><span class="line">                    <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                    *(*unsafe.Pointer)(origSlotKey) = <span class="literal">nil</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> typ.Key.Pointers() &#123;</span><br><span class="line">                    <span class="comment">// key存储的是一个指针</span></span><br><span class="line">                    <span class="comment">// Only bothing clear the key if there</span></span><br><span class="line">                    <span class="comment">// are pointers in it.</span></span><br><span class="line">                    typedmemclr(typ.Key, slotKey)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// value</span></span><br><span class="line">                slotElem := g.elem(typ, i)</span><br><span class="line">                <span class="keyword">if</span> typ.IndirectElem() &#123;</span><br><span class="line">                    <span class="comment">// Clearing the pointer is sufficient.</span></span><br><span class="line">                    *(*unsafe.Pointer)(slotElem) = <span class="literal">nil</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Unlike keys, always clear the elem (even if</span></span><br><span class="line">                    <span class="comment">// it contains no pointers), as compound</span></span><br><span class="line">                    <span class="comment">// assignment operations depend on cleared</span></span><br><span class="line">                    <span class="comment">// deleted values. See</span></span><br><span class="line">                    <span class="comment">// https://go.dev/issue/25936.</span></span><br><span class="line">                    typedmemclr(typ.Elem, slotElem)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// matchEmpty将非empty的ctrl全部置为0，如果8个ctrl都有数据，如full或者deleted状态，那么match=0</span></span><br><span class="line">                <span class="comment">// Only a full group can appear in the middle</span></span><br><span class="line">                <span class="comment">// of a probe sequence (a group with at least</span></span><br><span class="line">                <span class="comment">// one empty slot terminates probing). Once a</span></span><br><span class="line">                <span class="comment">// group becomes full, it stays full until</span></span><br><span class="line">                <span class="comment">// rehashing/resizing. So if the group isn&#x27;t</span></span><br><span class="line">                <span class="comment">// full now, we can simply remove the element.</span></span><br><span class="line">                <span class="comment">// Otherwise, we create a tombstone to mark the</span></span><br><span class="line">                <span class="comment">// slot as deleted.</span></span><br><span class="line">                <span class="keyword">if</span> g.ctrls().matchEmpty() != <span class="number">0</span> &#123;</span><br><span class="line">                    g.ctrls().set(i, ctrlEmpty)</span><br><span class="line">                    t.growthLeft++</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// tombstone</span></span><br><span class="line">                    g.ctrls().set(i, ctrlDeleted)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// debug时开启，忽略</span></span><br><span class="line">                t.checkInvariants(typ, m)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// match末尾第一个1将会被置为0</span></span><br><span class="line">            match = match.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// matchEmpty将非empty的ctrl全部置为0，如果8个ctrl都有数据，如full或者deleted状态，那么match=0</span></span><br><span class="line">        match = g.ctrls().matchEmpty()</span><br><span class="line">        <span class="keyword">if</span> match != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Finding an empty slot means we&#x27;ve reached the end of</span></span><br><span class="line">            <span class="comment">// the probe sequence.</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line">clear(v1)</span><br></pre></td></tr></table></figure>

<p>使用clear清理map的所有元素时，系统调用mapclear进行处理，大概逻辑如下</p>
<ol>
<li>如果是small map，直接清理掉group数据</li>
<li>如果是常规map，遍历table、group清理</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclear</span><span class="params">(t *abi.SwissMapType, m *maps.Map)</span></span> &#123;</span><br><span class="line">    m.Clear(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Clear(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> || m.Used() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing != <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    m.writing ^= <span class="number">1</span> <span class="comment">// toggle, see comment on writing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// small map</span></span><br><span class="line">    <span class="keyword">if</span> m.dirLen == <span class="number">0</span> &#123;</span><br><span class="line">        m.clearSmall(typ)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> lastTab *table</span><br><span class="line">        <span class="comment">// 遍历所有table</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> m.dirLen &#123;</span><br><span class="line">            t := m.directoryAt(<span class="type">uintptr</span>(i))</span><br><span class="line">            <span class="comment">// 分裂时，会指向同一个table</span></span><br><span class="line">            <span class="keyword">if</span> t == lastTab &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清理groups、重置table状态</span></span><br><span class="line">            t.Clear(typ)</span><br><span class="line">            lastTab = t</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置map状态</span></span><br><span class="line">        m.used = <span class="number">0</span></span><br><span class="line">        m.clearSeq++</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> shrink directory?</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置hash种子</span></span><br><span class="line">    <span class="comment">// Reset the hash seed to make it more difficult for attackers to</span></span><br><span class="line">    <span class="comment">// repeatedly trigger hash collisions. See https://go.dev/issue/25237.</span></span><br><span class="line">    m.seed = <span class="type">uintptr</span>(rand())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他goroutine在写入，异常</span></span><br><span class="line">    <span class="keyword">if</span> m.writing == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消writing标志</span></span><br><span class="line">    m.writing ^= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> clearSmall(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 直接拿map的dirPtr字段转换</span></span><br><span class="line">    g := groupReference&#123;</span><br><span class="line">        data: m.dirPtr,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    typedmemclr(typ.Group, g.data) <span class="comment">// slot数据</span></span><br><span class="line">    g.ctrls().setEmpty() <span class="comment">// ctrl状态</span></span><br><span class="line"></span><br><span class="line">    m.used = <span class="number">0</span></span><br><span class="line">    m.clearSeq++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/internal/runtime/maps/table.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *table)</span></span> Clear(typ *abi.SwissMapType) &#123;</span><br><span class="line">    <span class="comment">// 遍历所有group</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint64</span>(<span class="number">0</span>); i &lt;= t.groups.lengthMask; i++ &#123;</span><br><span class="line">        g := t.groups.group(typ, i)</span><br><span class="line">        typedmemclr(typ.Group, g.data) <span class="comment">// slot数据</span></span><br><span class="line">        g.ctrls().setEmpty() <span class="comment">// ctrl状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.used = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 根据capacity重置growthLeft字段</span></span><br><span class="line">    t.resetGrowthLeft()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下非克隆，只是复制了header</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = v1</span><br><span class="line"></span><br><span class="line"><span class="comment">// go 1.21</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = maps.Clone(v1)</span><br></pre></td></tr></table></figure>

<p>当使用maps.Clone复制数据时，系统使用mapclone2实现该操作，大概逻辑如下大概逻辑如下</p>
<ol>
<li>创建一个Iter</li>
<li>不断调用Next获取数据，写入新的map</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map_swiss.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapclone2</span><span class="params">(t *abi.SwissMapType, src *maps.Map)</span></span> *maps.Map &#123;</span><br><span class="line">    dst := makemap(t, <span class="type">int</span>(src.Used()), <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iter maps.Iter</span><br><span class="line">    iter.Init(t, src)</span><br><span class="line">    <span class="keyword">for</span> iter.Next(); iter.Key() != <span class="literal">nil</span>; iter.Next() &#123;</span><br><span class="line">        dst.Put(t, iter.Key(), iter.Elem())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-netpoll</title>
    <url>/golang-series-netpoll/</url>
    <content><![CDATA[<p>netpoll是golang用来处理网络I&#x2F;O事件的底层机制，主要通过操作系统的I&#x2F;O多路复用机制如Linux的epoll、BSD的kqueue、Windows的IOCP等来实现</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>核心的数据结构是pollDesc，用于存储与文件描述符相关的事件数据，一般被放入如epoll的epoll_event.data来传递信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">    _          sys.NotInHeap    <span class="comment">// 放置转换成interface&#123;&#125;时申请heap内存</span></span><br><span class="line">    link       *pollDesc        <span class="comment">// next指针，用于pollcache链表</span></span><br><span class="line">    fd         <span class="type">uintptr</span>          <span class="comment">// 文件描述符</span></span><br><span class="line">    fdseq      atomic.Uintptr   <span class="comment">// 计数器，类似时间戳，确保过期的消息不会被处理，只在获取/放回cache时改变</span></span><br><span class="line">    atomicInfo atomic.Uint32    <span class="comment">// 5个状态位+fdseq（这两个数据有位交叉冲突，没搞懂）</span></span><br><span class="line">    rg         atomic.Uintptr   <span class="comment">// 读状态，读G的地址也作为一种状态</span></span><br><span class="line">    wg         atomic.Uintptr   <span class="comment">// 写状态，写G的地址也作为一种状态</span></span><br><span class="line">    lock       mutex            <span class="comment">// 锁，保护下列字段</span></span><br><span class="line">    closing    <span class="type">bool</span>             <span class="comment">// 是否被移除出netpoll</span></span><br><span class="line">    rrun       <span class="type">bool</span>             <span class="comment">// rt-读定时器是否在运行</span></span><br><span class="line">    wrun       <span class="type">bool</span>             <span class="comment">// wt-写定时器是否在运行</span></span><br><span class="line">    user       <span class="type">uint32</span>           <span class="comment">// cookie，linux/bsd应该没用到</span></span><br><span class="line">    rseq       <span class="type">uintptr</span>          <span class="comment">// 读计数器，类似fdseq，只有获取/放回cache以及设置deadline时改变</span></span><br><span class="line">    rt         timer            <span class="comment">// 读定时器</span></span><br><span class="line">    rd         <span class="type">int64</span>            <span class="comment">// 读过期时刻，-1为已过期</span></span><br><span class="line">    wseq       <span class="type">uintptr</span>          <span class="comment">// 写计数器，类似fdseq，只有获取/放回cache以及设置deadline时改变</span></span><br><span class="line">    wt         timer            <span class="comment">// 写定时器</span></span><br><span class="line">    wd         <span class="type">int64</span>            <span class="comment">// 写过期时刻，-1为已过期</span></span><br><span class="line">    self       *pollDesc        <span class="comment">// 当前实例指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pollDesc缓存，重复使用，避免反复申请内存</span></span><br><span class="line"><span class="keyword">type</span> pollCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock  mutex                 <span class="comment">// 锁</span></span><br><span class="line">    first *pollDesc             <span class="comment">// 链表头部指针，pollDesc指针都从头部写入 new -&gt; old -&gt; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pollDesc部份字段讲解如下</p>
<ol>
<li><code>atomicInfo</code>是一个无符号32位整型数，每位用途如下</li>
</ol>
<table>
<thead>
<tr>
<th align="left">16bit</th>
<th align="left">11bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fdseq</td>
<td align="left">unused</td>
<td align="left">pollFDSeq</td>
<td align="left">pollExpiredWriteDeadline</td>
<td align="left">pollExpiredReadDeadline</td>
<td align="left">pollEventErr</td>
<td align="left">pollClosing</td>
</tr>
</tbody></table>
<p><em>注意</em>：fdseq占据20位数据，但在atomicInfo里，fdseq要向左移位16位，看起来是数据丢失了，没搞明白。同样有问题的还有taggedPointerPack</p>
<ol start="2">
<li><code>rg</code>和<code>wg</code>的状态列表如下</li>
</ol>
<table>
<thead>
<tr>
<th align="left">state_name</th>
<th align="left">state_val</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pdNil</td>
<td align="left">0</td>
<td align="left">默认值</td>
</tr>
<tr>
<td align="left">pdReady</td>
<td align="left">1</td>
<td align="left">io可读，下一个状态是pdNil</td>
</tr>
<tr>
<td align="left">pdWait</td>
<td align="left">2</td>
<td align="left">准备挂起，下一个状态是G pointer-挂起，pdReady-io可读，pdNil-超时&#x2F;关闭</td>
</tr>
<tr>
<td align="left">G pointer</td>
<td align="left">0xabc</td>
<td align="left">goroutine指针-挂起，下一个状态是pdReady-io可读，pdNil-超时&#x2F;关闭</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="netpoll初始化"><a href="#netpoll初始化" class="headerlink" title="netpoll初始化"></a>netpoll初始化</h2><p>初始化与netpoll有关的底层资源，如epoll实例、eventfd实例等，用sync.Once限制只执行一次。逻辑如下</p>
<ol>
<li>通用&#x2F;平台无关<ul>
<li>初始化锁，包括netpollInitLock、pollcache.lock</li>
<li>如果netpollInited为0，执行平台相关初始化，最后netpollInited设为1</li>
</ul>
</li>
<li>平台相关(linux-epoll)<ul>
<li>生成epoll实例</li>
<li>生成eventfd实例、封装epoll事件数据</li>
<li>将文件描述符eventfd和事件数据添加到epoll实例</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="comment">// src/runtime/netpoll.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    netpollInitLock mutex           <span class="comment">// netpoll初始化锁</span></span><br><span class="line">    netpollInited   atomic.Uint32   <span class="comment">// 判断netpoll是否已初始化</span></span><br><span class="line"></span><br><span class="line">    pollcache      pollCache        <span class="comment">// pollDesc链表</span></span><br><span class="line">    netpollWaiters atomic.Uint32    <span class="comment">// 挂起的goroutine数量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器链接为internal/poll.runtime_pollServerInit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollServerInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    netpollGenericInit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// netpoll初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollGenericInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        lockInit(&amp;netpollInitLock, lockRankNetpollInit)</span><br><span class="line">        lockInit(&amp;pollcache.lock, lockRankPollCache)</span><br><span class="line">        lock(&amp;netpollInitLock)</span><br><span class="line">        <span class="comment">// 加锁后double-check</span></span><br><span class="line">        <span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 调用平台相关实现，如linux-epoll</span></span><br><span class="line">            netpollinit()</span><br><span class="line">            <span class="comment">// 0 -&gt; 1（已初始化）</span></span><br><span class="line">            netpollInited.Store(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;netpollInitLock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台相关-linux/epoll</span></span><br><span class="line"><span class="comment">// src/runtime/netpoll_epoll.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    epfd           <span class="type">int32</span>         = <span class="number">-1</span> <span class="comment">// epoll实例</span></span><br><span class="line">    netpollEventFd <span class="type">uintptr</span>            <span class="comment">// eventfd实例</span></span><br><span class="line">    netpollWakeSig atomic.Uint32      <span class="comment">// 标志，防止重复调用netpollBreak</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> errno <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// 1. 创建epoll实例</span></span><br><span class="line">    <span class="comment">// EPOLL_CLOEXEC =&gt; 安全设置，fork()创建子进程或exec()执行新程序时，关闭epoll实例</span></span><br><span class="line">    epfd, errno = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: epollcreate failed with&quot;</span>, errno)</span><br><span class="line">        throw(<span class="string">&quot;runtime: netpollinit failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建eventfd实例</span></span><br><span class="line">    <span class="comment">// 2.1. 创建eventfd文件描述符</span></span><br><span class="line">    <span class="comment">// 0 =&gt; 计数器初始值，如果为0，epollWait时会阻塞住</span></span><br><span class="line">    <span class="comment">// EPOLL_CLOEXEC =&gt; 执行exec()时，关闭efd</span></span><br><span class="line">    <span class="comment">// EFD_NONBLOCK  =&gt; 非阻塞</span></span><br><span class="line">    efd, errno := syscall.Eventfd(<span class="number">0</span>, syscall.EFD_CLOEXEC|syscall.EFD_NONBLOCK)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: eventfd failed with&quot;</span>, -errno)</span><br><span class="line">        throw(<span class="string">&quot;runtime: eventfd failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2. 创建epoll事件</span></span><br><span class="line">    <span class="comment">// EPOLLIN =&gt; 可读时通知</span></span><br><span class="line">    <span class="comment">// 默认水平触发</span></span><br><span class="line">    ev := syscall.EpollEvent&#123;</span><br><span class="line">        Events: syscall.EPOLLIN,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 事件元数据绑定</span></span><br><span class="line">    <span class="comment">// efd指针存储在netpollEventFd，最后再存储于Data</span></span><br><span class="line">    *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.Data)) = &amp;netpollEventFd</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将eventfd文件描述符efd加入epoll实例epfd</span></span><br><span class="line">    errno = syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, efd, &amp;ev)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: epollctl failed with&quot;</span>, errno)</span><br><span class="line">        throw(<span class="string">&quot;runtime: epollctl failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    netpollEventFd = <span class="type">uintptr</span>(efd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll添加文件描述符"><a href="#netpoll添加文件描述符" class="headerlink" title="netpoll添加文件描述符"></a>netpoll添加文件描述符</h2><p>将一个文件描述符（FD）或网络连接添加到I&#x2F;O事件多路复用系统中，使其能够被监听，以便在该文件描述符上发生事件时被唤醒并进行相应处理。逻辑如下</p>
<ol>
<li>生成&#x2F;初始化事件元数据pd<ul>
<li>确保rg&#x2F;wg重置为pdNil</li>
<li>fdseq默认为1</li>
<li>更新atomicInfo错误标志</li>
<li>rd&#x2F;wd过期时刻设置为0，rseq&#x2F;wseq计数器更新</li>
<li>绑定self</li>
<li>重新更新atomicInfo</li>
</ul>
</li>
<li>将文件描述符、事件数据添加到epoll实例（平台相关）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> (*pollDesc, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 生成/初始化事件元数据</span></span><br><span class="line">    pd := pollcache.alloc()</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    wg := pd.wg.Load()</span><br><span class="line">    <span class="keyword">if</span> wg != pdNil &amp;&amp; wg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked write on free polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    rg := pd.rg.Load()</span><br><span class="line">    <span class="keyword">if</span> rg != pdNil &amp;&amp; rg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked read on free polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pd.fd = fd</span><br><span class="line">    <span class="keyword">if</span> pd.fdseq.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 修改fdseq，0-特殊用途，不能使用</span></span><br><span class="line">        pd.fdseq.Store(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pd.closing = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 更新atomicInfo错误标志</span></span><br><span class="line">    pd.setEventErr(<span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    pd.rseq++</span><br><span class="line">    pd.rg.Store(pdNil)</span><br><span class="line">    pd.rd = <span class="number">0</span></span><br><span class="line">    pd.wseq++</span><br><span class="line">    pd.wg.Store(pdNil)</span><br><span class="line">    pd.wd = <span class="number">0</span></span><br><span class="line">    pd.self = pd</span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将fd加入epoll实例（平台相关）</span></span><br><span class="line">    errno := netpollopen(fd, pd)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        pollcache.free(pd)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="type">int</span>(errno)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回事件元数据、错误代码</span></span><br><span class="line">    <span class="keyword">return</span> pd, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台相关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建epoll事件</span></span><br><span class="line">    <span class="comment">// 1.1. 参数解读如下</span></span><br><span class="line">    <span class="comment">// EPOLLIN      =&gt; 可读</span></span><br><span class="line">    <span class="comment">// EPOLLOUT     =&gt; 可写</span></span><br><span class="line">    <span class="comment">// EPOLLRDHUP   =&gt; 连接被对端关闭（tcp服务器）</span></span><br><span class="line">    <span class="comment">// EPOLLET      =&gt; 边缘触发模式</span></span><br><span class="line">    <span class="keyword">var</span> ev syscall.EpollEvent</span><br><span class="line">    ev.Events = syscall.EPOLLIN | syscall.EPOLLOUT | syscall.EPOLLRDHUP | syscall.EPOLLET</span><br><span class="line">    <span class="comment">// 1.2. 将事件元数据pd组装成带标签的指针</span></span><br><span class="line">    <span class="comment">// pd指针放高48位，fdseq放低19位，这里交叉的3个位没搞懂</span></span><br><span class="line">    tp := taggedPointerPack(unsafe.Pointer(pd), pd.fdseq.Load())</span><br><span class="line">    <span class="comment">// 1.3. 绑定</span></span><br><span class="line">    *(*taggedPointer)(unsafe.Pointer(&amp;ev.Data)) = tp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将文件描述符fd加入epfd实例</span></span><br><span class="line">    <span class="keyword">return</span> syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个可用的事件元数据pollDesc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> alloc() *pollDesc &#123;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 链表为空</span></span><br><span class="line">    <span class="keyword">if</span> c.first == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> pdSize = unsafe.Sizeof(pollDesc&#123;&#125;)</span><br><span class="line">        <span class="comment">// n=4096/280=14</span></span><br><span class="line">        n := pollBlockSize / pdSize</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            n = <span class="number">1</span> <span class="comment">// 最低为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次性申请14个pollDesc的内存</span></span><br><span class="line">        <span class="comment">// 注意：这里必须位于非GC内存区域，epoll/queue内部使用</span></span><br><span class="line">        mem := persistentalloc(n*pdSize, <span class="number">0</span>, &amp;memstats.other_sys)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">            pd := (*pollDesc)(add(mem, i*pdSize))</span><br><span class="line">            lockInit(&amp;pd.lock, lockRankPollDesc)</span><br><span class="line">            pd.rt.init(<span class="literal">nil</span>, <span class="literal">nil</span>) <span class="comment">// 读定时器初始化</span></span><br><span class="line">            pd.wt.init(<span class="literal">nil</span>, <span class="literal">nil</span>) <span class="comment">// 写定时器初始化</span></span><br><span class="line">            pd.link = c.first    <span class="comment">// 放到cache链表</span></span><br><span class="line">            c.first = pd</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿链表头部第一个pollDesc</span></span><br><span class="line">    pd := c.first</span><br><span class="line">    c.first = pd.link</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> pd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把事件元数据pollDesc放到pollCache，留待后续使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> free(pd *pollDesc) &#123;</span><br><span class="line">    <span class="comment">// pd不能被共享</span></span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fdseq++，确保pd状态不会被设置为ready</span></span><br><span class="line">    fdseq := pd.fdseq.Load()</span><br><span class="line">    fdseq = (fdseq + <span class="number">1</span>) &amp; (<span class="number">1</span>&lt;&lt;taggedPointerBits - <span class="number">1</span>) <span class="comment">// fdseq++，保留低19位</span></span><br><span class="line">    pd.fdseq.Store(fdseq)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line"></span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把pollDesc放回cache链表的头部</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    pd.link = c.first</span><br><span class="line">    c.first = pd</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新atomicInfo错误标志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> setEventErr(b <span class="type">bool</span>, seq <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// fdseq1 =&gt; 参数值，只保留低20位</span></span><br><span class="line">    mSeq := <span class="type">uint32</span>(seq &amp; pollFDSeqMask)</span><br><span class="line">    <span class="comment">// 获取atomicInfo</span></span><br><span class="line">    x := pd.atomicInfo.Load()</span><br><span class="line">    <span class="comment">// fdseq2 =&gt; 事件元数据存储，atomicInfo丢弃低16位后再保留低20位</span></span><br><span class="line">    xSeq := (x &gt;&gt; pollFDSeq) &amp; pollFDSeqMask</span><br><span class="line">    <span class="comment">// 两者不相等</span></span><br><span class="line">    <span class="keyword">if</span> seq != <span class="number">0</span> &amp;&amp; xSeq != mSeq &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新错误标志失败时重试</span></span><br><span class="line">    <span class="comment">// 1. atomicInfo的错误标志跟b不同，表示错误标志变更</span></span><br><span class="line">    <span class="comment">// 2. 取反错误标志失败</span></span><br><span class="line">    <span class="keyword">for</span> (x&amp;pollEventErr != <span class="number">0</span>) != b &amp;&amp; !pd.atomicInfo.CompareAndSwap(x, x^pollEventErr) &#123;</span><br><span class="line">        <span class="comment">// 逻辑同上，这里应为double-check</span></span><br><span class="line">        x = pd.atomicInfo.Load()</span><br><span class="line">        xSeq := (x &gt;&gt; pollFDSeq) &amp; pollFDSeqMask</span><br><span class="line">        <span class="keyword">if</span> seq != <span class="number">0</span> &amp;&amp; xSeq != mSeq &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新atomicInfo字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> publishInfo() &#123;</span><br><span class="line">    <span class="keyword">var</span> info <span class="type">uint32</span></span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123; <span class="comment">// fd被移除出netpoll</span></span><br><span class="line">        info |= pollClosing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.rd &lt; <span class="number">0</span> &#123;  <span class="comment">// 读过期时刻，-1为已过期</span></span><br><span class="line">        info |= pollExpiredReadDeadline</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.wd &lt; <span class="number">0</span> &#123;  <span class="comment">// 写过期时刻，-1为已过期</span></span><br><span class="line">        info |= pollExpiredWriteDeadline</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fdseq低20位放到info高16位，没搞懂</span></span><br><span class="line">    info |= <span class="type">uint32</span>(pd.fdseq.Load()&amp;pollFDSeqMask) &lt;&lt; pollFDSeq</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧info</span></span><br><span class="line">    x := pd.atomicInfo.Load()</span><br><span class="line">    <span class="comment">// 旧info的错误标志位纪录到新的info，然后替换</span></span><br><span class="line">    <span class="keyword">for</span> !pd.atomicInfo.CompareAndSwap(x, (x&amp;pollEventErr)|info) &#123;</span><br><span class="line">        x = pd.atomicInfo.Load()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll移除文件描述符"><a href="#netpoll移除文件描述符" class="headerlink" title="netpoll移除文件描述符"></a>netpoll移除文件描述符</h2><p>将不再需要监听的文件描述符或网络连接从事件轮询中移除，以释放资源并停止对该描述符的轮询。逻辑如下</p>
<ol>
<li>guard，确认无异常情况</li>
<li>调用平台相关实现，如epoll实例，删除目标文件描述符fd</li>
<li>事件元数据清理<ul>
<li>fdseq++，确保pd状态不会被设置为ready</li>
<li>更新atomicInfo字段</li>
<li>把pd事件元数据放到cache链表的头部</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="comment">// 彻底删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollClose</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要先调用poll_runtime_pollUnblock</span></span><br><span class="line">    <span class="keyword">if</span> !pd.closing &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: close polldesc w/o unblock&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写G/读G状态异常</span></span><br><span class="line">    wg := pd.wg.Load()</span><br><span class="line">    <span class="keyword">if</span> wg != pdNil &amp;&amp; wg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked write on closing polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    rg := pd.rg.Load()</span><br><span class="line">    <span class="keyword">if</span> rg != pdNil &amp;&amp; rg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked read on closing polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// epoll删除fd</span></span><br><span class="line">    netpollclose(pd.fd)</span><br><span class="line">    <span class="comment">// 把pollDesc放回cache链表</span></span><br><span class="line">    pollcache.free(pd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台相关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollclose</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ev syscall.EpollEvent</span><br><span class="line">    <span class="comment">// EPOLL_CTL_DEL =&gt; 删除</span></span><br><span class="line">    <span class="keyword">return</span> syscall.EpollCtl(epfd, syscall.EPOLL_CTL_DEL, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll轮询事件"><a href="#netpoll轮询事件" class="headerlink" title="netpoll轮询事件"></a>netpoll轮询事件</h2><p>通常由调度器触发，轮询所有的I&#x2F;O事件并唤醒相应的goroutine。与netpollBreak搭配使用，目前用在findRunnable、startTheWorldWithSema、pollWork、sysmon函数。具体逻辑如下</p>
<ol>
<li>计算等待事件waitms</li>
<li>调用syscall.EpollWait来等待事件<ul>
<li>异常情况中断轮询</li>
<li>被中断，重新执行</li>
</ul>
</li>
<li>遍历所有发生的事件<ul>
<li>如果Events为0，跳过</li>
<li>如果是eventfd事件，检查类型、读取事件数据并重置事件标志</li>
<li>其他事件<ul>
<li>检查事件类型是读&#x2F;写</li>
<li>通过fdseq和tag判断是否已处理</li>
<li>调用netpollready处理事件</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>参数delay的说明如下</p>
<table>
<thead>
<tr>
<th align="left">delay</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt;0</td>
<td align="left">永久阻塞</td>
</tr>
<tr>
<td align="left">&#x3D;0</td>
<td align="left">非阻塞，轮训</td>
</tr>
<tr>
<td align="left">&gt;0</td>
<td align="left">阻塞delay时长，单位ms</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平台相关，不通用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> (gList, <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保epoll已初始化</span></span><br><span class="line">    <span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gList&#123;&#125;, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算等待时间（epoll需要毫秒）</span></span><br><span class="line">    <span class="keyword">var</span> waitms <span class="type">int32</span></span><br><span class="line">    <span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;              <span class="comment">// 无限等待</span></span><br><span class="line">        waitms = <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> delay == <span class="number">0</span> &#123;      <span class="comment">// 立刻返回，非阻塞</span></span><br><span class="line">        waitms = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e6</span> &#123;     <span class="comment">// 等待 1 毫秒</span></span><br><span class="line">        waitms = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e15</span> &#123;    <span class="comment">// 转换为毫秒</span></span><br><span class="line">        waitms = <span class="type">int32</span>(delay / <span class="number">1e6</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 超过最大值1e15，设置1e9，约为11.5天</span></span><br><span class="line">        waitms = <span class="number">1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 128个事件</span></span><br><span class="line">    <span class="keyword">var</span> events [<span class="number">128</span>]syscall.EpollEvent</span><br><span class="line">retry:</span><br><span class="line">    n, errno := syscall.EpollWait(epfd, events[:], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> errno != _EINTR &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: epollwait on fd&quot;</span>, epfd, <span class="string">&quot;failed with&quot;</span>, errno)</span><br><span class="line">            throw(<span class="string">&quot;runtime: netpoll failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被中断，重新执行</span></span><br><span class="line">        <span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gList&#123;&#125;, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> retry</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 待执行的 goroutines 列表</span></span><br><span class="line">    <span class="keyword">var</span> toRun gList</span><br><span class="line">    <span class="comment">// 累计处理事件</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 遍历所有发生的事件</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        ev := events[i]</span><br><span class="line">        <span class="comment">// 跳过，一般不为0</span></span><br><span class="line">        <span class="keyword">if</span> ev.Events == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// eventfd</span></span><br><span class="line">        <span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.Data)) == &amp;netpollEventFd &#123;</span><br><span class="line">            <span class="comment">// 是否可读</span></span><br><span class="line">            <span class="keyword">if</span> ev.Events != syscall.EPOLLIN &#123;</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;runtime: netpoll: eventfd ready for&quot;</span>, ev.Events)</span><br><span class="line">                throw(<span class="string">&quot;runtime: netpoll: eventfd ready for something unexpected&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> delay != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 读取事件数据</span></span><br><span class="line">                <span class="keyword">var</span> one <span class="type">uint64</span></span><br><span class="line">                read(<span class="type">int32</span>(netpollEventFd), noescape(unsafe.Pointer(&amp;one)), <span class="type">int32</span>(unsafe.Sizeof(one)))</span><br><span class="line">                <span class="comment">// 重置</span></span><br><span class="line">                netpollWakeSig.Store(<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他fd</span></span><br><span class="line">        <span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line">        <span class="comment">// 可读</span></span><br><span class="line">        <span class="keyword">if</span> ev.Events&amp;(syscall.EPOLLIN|syscall.EPOLLRDHUP|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">            mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可写</span></span><br><span class="line">        <span class="keyword">if</span> ev.Events&amp;(syscall.EPOLLOUT|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">            mode += <span class="string">&#x27;w&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 获取pollDesc以及fdseq</span></span><br><span class="line">            tp := *(*taggedPointer)(unsafe.Pointer(&amp;ev.Data))</span><br><span class="line">            pd := (*pollDesc)(tp.pointer()) <span class="comment">// *pollDesc</span></span><br><span class="line">            tag := tp.tag()                 <span class="comment">// fdseq</span></span><br><span class="line">            <span class="comment">// 只在获取/放回cache时改变</span></span><br><span class="line">            <span class="comment">// 如果fdseq不同，那么可能是过期的或重复使用的*pollDesc</span></span><br><span class="line">            <span class="keyword">if</span> pd.fdseq.Load() == tag &#123;</span><br><span class="line">                <span class="comment">// 更新atomicInfo错误标志</span></span><br><span class="line">                pd.setEventErr(ev.Events == syscall.EPOLLERR, tag)</span><br><span class="line">                <span class="comment">// 调用netpollready处理事件</span></span><br><span class="line">                delta += netpollready(&amp;toRun, pd, mode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toRun, delta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒goroutine，数据已经可读/可写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> rg, wg *g</span><br><span class="line">    <span class="comment">// 1. 唤醒goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rg/wg状态修改</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">true</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将唤醒的goroutine放到toRun列表</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        toRun.push(rg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        toRun.push(wg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累计唤醒的goroutine数量</span></span><br><span class="line">    <span class="keyword">return</span> delta</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rg/wg状态修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollunblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, ioready <span class="type">bool</span>, delta *<span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">    <span class="comment">// 读G/写G</span></span><br><span class="line">    gpp := &amp;pd.rg</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        gpp = &amp;pd.wg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pdReady/G pointer -&gt; pdReady</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := gpp.Load()</span><br><span class="line">        <span class="comment">// 已经是pdReady状态</span></span><br><span class="line">        <span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断io是否可读/写，超时/取消由runtime_pollWait负责判断</span></span><br><span class="line">        <span class="keyword">if</span> old == pdNil &amp;&amp; !ioready &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">new</span> := pdNil        <span class="comment">// 解除等待</span></span><br><span class="line">        <span class="keyword">if</span> ioready &#123;</span><br><span class="line">            <span class="built_in">new</span> = pdReady   <span class="comment">// 读/写就绪</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">if</span> gpp.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> old == pdWait &#123;          <span class="comment">// pdWait</span></span><br><span class="line">                old = pdNil</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> old != pdNil &#123;    <span class="comment">// G pointer</span></span><br><span class="line">                *delta -= <span class="number">1</span>             <span class="comment">// 挂起数量减一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (*g)(unsafe.Pointer(old))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打破当前I-O轮询循环"><a href="#打破当前I-O轮询循环" class="headerlink" title="打破当前I&#x2F;O轮询循环"></a>打破当前I&#x2F;O轮询循环</h2><p>打破当前的I&#x2F;O轮询循环，使得正在等待I&#x2F;O事件的goroutine能够被唤醒。与netpoll方法搭配使用，目前用在findRunnable和wakeNetPoller函数。具体逻辑如下</p>
<ol>
<li>guard，放置重复调用netpollBreak</li>
<li>中断信号准备</li>
<li>更新eventfd计数器，此时计数器的值不为0，epollWait被中断</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 防重验证</span></span><br><span class="line">    <span class="comment">// 标志为1，表示有其他G在执行当前函数</span></span><br><span class="line">    <span class="keyword">if</span> !netpollWakeSig.CompareAndSwap(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 数据准备</span></span><br><span class="line">    <span class="comment">// 中断信号数据</span></span><br><span class="line">    <span class="keyword">var</span> one <span class="type">uint64</span> = <span class="number">1</span></span><br><span class="line">    oneSize := <span class="type">int32</span>(unsafe.Sizeof(one))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发出信号，中断netpoll方法</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 更新eventfd计数器，此时计数器的值不为0，epollWait被中断</span></span><br><span class="line">        n := write(netpollEventFd, noescape(unsafe.Pointer(&amp;one)), oneSize)</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        <span class="keyword">if</span> n == oneSize &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被中断</span></span><br><span class="line">        <span class="keyword">if</span> n == -_EINTR &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 资源暂时不可用，如写缓冲区满</span></span><br><span class="line">        <span class="keyword">if</span> n == -_EAGAIN &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他异常</span></span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: netpollBreak write failed with&quot;</span>, -n)</span><br><span class="line">        throw(<span class="string">&quot;runtime: netpollBreak write failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为将要挂起的G设置超时"><a href="#为将要挂起的G设置超时" class="headerlink" title="为将要挂起的G设置超时"></a>为将要挂起的G设置超时</h2><p>通常在调用poll_runtime_pollWait之前使用，设置一个具体的超时时间，确保挂起的I&#x2F;O操作能够在指定的时间内完成。具体逻辑如下</p>
<ol>
<li>guard，已被移除出netpoll不处理</li>
<li>计算读&#x2F;写定时器新过期时刻、更新atomicInfo状态</li>
<li>修改读&#x2F;写定时器</li>
<li>rg&#x2F;wg状态修改，如果有读G&#x2F;写G需要唤醒，则唤醒并更新netpollWaiters计数器</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="type">int64</span>, mode <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 已被移除出netpoll</span></span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123;</span><br><span class="line">        unlock(&amp;pd.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取读G/写G旧过期时刻</span></span><br><span class="line">    rd0, wd0 := pd.rd, pd.wd</span><br><span class="line">    <span class="comment">// 是否读写都设置同一个过期时刻</span></span><br><span class="line">    combo0 := rd0 &gt; <span class="number">0</span> &amp;&amp; rd0 == wd0</span><br><span class="line">    <span class="keyword">if</span> d &gt; <span class="number">0</span> &#123;</span><br><span class="line">        d += nanotime()     <span class="comment">// 获取过期时刻-单调时钟</span></span><br><span class="line">        <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            d = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>   <span class="comment">// 溢出时设为最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置读G/写G新过期时刻</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        pd.rd = d</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        pd.wd = d</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line"></span><br><span class="line">    combo := pd.rd &gt; <span class="number">0</span> &amp;&amp; pd.rd == pd.wd</span><br><span class="line">    <span class="comment">// 选择定时器过期时触发的函数</span></span><br><span class="line">    rtf := netpollReadDeadline</span><br><span class="line">    <span class="keyword">if</span> combo &#123;</span><br><span class="line">        rtf = netpollDeadline</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读/写过期定时器是否在运行</span></span><br><span class="line">    <span class="keyword">if</span> !pd.rrun &#123;</span><br><span class="line">        <span class="comment">// 没有运行rt</span></span><br><span class="line">        <span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间</span></span><br><span class="line">            pd.rt.modify(pd.rd, <span class="number">0</span>, rtf, pd.makeArg(), pd.rseq)</span><br><span class="line">            pd.rrun = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.rd != rd0 || combo != combo0 &#123;</span><br><span class="line">        <span class="comment">// 有运行rt，但现在过期时刻有修改</span></span><br><span class="line">        pd.rseq++ <span class="comment">// 版本更新</span></span><br><span class="line">        <span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间</span></span><br><span class="line">            pd.rt.modify(pd.rd, <span class="number">0</span>, rtf, pd.makeArg(), pd.rseq)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &lt;=0，已过期</span></span><br><span class="line">            pd.rt.stop()</span><br><span class="line">            pd.rrun = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !pd.wrun &#123;</span><br><span class="line">        <span class="comment">// 没有运行wt</span></span><br><span class="line">        <span class="keyword">if</span> pd.wd &gt; <span class="number">0</span> &amp;&amp; !combo &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间，且读/写过期时刻不同</span></span><br><span class="line">            pd.wt.modify(pd.wd, <span class="number">0</span>, netpollWriteDeadline, pd.makeArg(), pd.wseq)</span><br><span class="line">            pd.wrun = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.wd != wd0 || combo != combo0 &#123;</span><br><span class="line">        <span class="comment">// 有运行wt，但现在过期时刻有修改</span></span><br><span class="line">        pd.wseq++ <span class="comment">// 版本更新</span></span><br><span class="line">        <span class="keyword">if</span> pd.wd &gt; <span class="number">0</span> &amp;&amp; !combo &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间，且读/写过期时刻不同</span></span><br><span class="line">            pd.wt.modify(pd.wd, <span class="number">0</span>, netpollWriteDeadline, pd.makeArg(), pd.wseq)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &lt;=0，已过期</span></span><br><span class="line">            pd.wt.stop()</span><br><span class="line">            pd.wrun = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计唤醒的G数量</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> rg, wg *g</span><br><span class="line">    <span class="comment">// rg/wg状态修改，ioready为false，不一定有G被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> pd.rd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.wd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 唤醒读G/写G</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(rg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(wg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">    netpollAdjustWaiters(delta)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写定时器同时刻过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollDeadline</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读定时器过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollReadDeadline</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写定时器过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollWriteDeadline</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读/写定时器过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpolldeadlineimpl</span><span class="params">(pd *pollDesc, seq <span class="type">uintptr</span>, read, write <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 获取pollDesc当前版本的seq</span></span><br><span class="line">    currentSeq := pd.rseq</span><br><span class="line">    <span class="keyword">if</span> !read &#123;</span><br><span class="line">        <span class="comment">// 读写放rseq，只写放wseq</span></span><br><span class="line">        currentSeq = pd.wseq</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新旧版本号不一致，pd可能被重用或定时器reset</span></span><br><span class="line">    <span class="keyword">if</span> seq != currentSeq &#123;</span><br><span class="line">        unlock(&amp;pd.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计唤醒的G数量</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> rg *g</span><br><span class="line">    <span class="comment">// 读或读写</span></span><br><span class="line">    <span class="keyword">if</span> read &#123;</span><br><span class="line">        <span class="keyword">if</span> pd.rd &lt;= <span class="number">0</span> || !pd.rrun &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: inconsistent read deadline&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -1为已过期</span></span><br><span class="line">        pd.rd = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">        pd.publishInfo()</span><br><span class="line">        <span class="comment">// rg状态修改，ioready为false，不一定有goroutine被唤醒</span></span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> wg *g</span><br><span class="line">    <span class="keyword">if</span> write &#123;</span><br><span class="line">        <span class="keyword">if</span> pd.wd &lt;= <span class="number">0</span> || !pd.wrun &amp;&amp; !read &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: inconsistent write deadline&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -1为已过期</span></span><br><span class="line">        pd.wd = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">        pd.publishInfo()</span><br><span class="line">        <span class="comment">// wg状态修改，ioready为false，不一定有goroutine被唤醒</span></span><br><span class="line">        wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 唤醒读G/写G</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(rg, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(wg, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">    netpollAdjustWaiters(delta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollgoready</span><span class="params">(gp *g, traceskip <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将g放到本地队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    goready(gp, traceskip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollAdjustWaiters</span><span class="params">(delta <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> delta != <span class="number">0</span> &#123;</span><br><span class="line">        netpollWaiters.Add(delta)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> makeArg() (i any) &#123;</span><br><span class="line">    x := (*eface)(unsafe.Pointer(&amp;i))   <span class="comment">// 转换成interface&#123;&#125;</span></span><br><span class="line">    x._type = pdType                    <span class="comment">// 类型为pollDesc</span></span><br><span class="line">    x.data = unsafe.Pointer(&amp;pd.self)   <span class="comment">// 指向pollDesc实例</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重置当前G的状态"><a href="#重置当前G的状态" class="headerlink" title="重置当前G的状态"></a>重置当前G的状态</h2><p>不管是因为何种原因，如果当前G需要重新进入队列进行新的轮询，就需要调用该函数进行状态重置。在执行poll_runtime_pollWait之前设置。具体逻辑如下</p>
<ol>
<li>检测atomicInfo标志位，查看是否有异常</li>
<li>读G&#x2F;写G状态重置为pdNil</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollReset</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 查看atomicInfo是否有错误标志</span></span><br><span class="line">    errcode := netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">    <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">        <span class="keyword">return</span> errcode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读G/写G状态重置</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> &#123;</span><br><span class="line">        pd.rg.Store(pdNil)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        pd.wg.Store(pdNil)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看atomicInfo是否有错误标志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollcheckerr</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// atomicInfo</span></span><br><span class="line">    info := pd.info()</span><br><span class="line">    <span class="comment">// pollClosing标志位是否已设置</span></span><br><span class="line">    <span class="keyword">if</span> info.closing() &#123;</span><br><span class="line">        <span class="keyword">return</span> pollErrClosing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读过期或写过期</span></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; info.expiredReadDeadline()) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; info.expiredWriteDeadline()) &#123;</span><br><span class="line">        <span class="keyword">return</span> pollErrTimeout</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读发生错误，写错误在写时处理，有更详细的错误信息</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; info.eventErr() &#123;</span><br><span class="line">        <span class="keyword">return</span> pollErrNotPollable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="当前G挂起等待事件发生"><a href="#当前G挂起等待事件发生" class="headerlink" title="当前G挂起等待事件发生"></a>当前G挂起等待事件发生</h2><p>将当前goroutine挂起，并等待事件通知，与poll_runtime_pollUnblock搭配使用。具体逻辑如下</p>
<ol>
<li>检测atomicInfo标志位，查看是否有异常</li>
<li>尝试将rg或wg状态改为pdWait，准备挂起</li>
<li>调用gopark将当前goroutine挂起等待，挂起前将rg或wg状态改为goroutine指针</li>
<li>被唤醒后，把当前状态（已准备好还是超时）告知上层函数</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 查看atomicInfo是否有错误标志</span></span><br><span class="line">    errcode := netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">    <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">        <span class="keyword">return</span> errcode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要使用水平触发的系统</span></span><br><span class="line">    <span class="keyword">if</span> GOOS == <span class="string">&quot;solaris&quot;</span> || GOOS == <span class="string">&quot;illumos&quot;</span> || GOOS == <span class="string">&quot;aix&quot;</span> || GOOS == <span class="string">&quot;wasip1&quot;</span> &#123;</span><br><span class="line">        netpollarm(pd, mode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前goroutine挂起休眠，唤醒后，rg/wg可读/写返回true</span></span><br><span class="line">    <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        errcode = netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">        <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">            <span class="keyword">return</span> errcode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, waitio <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 根据mode选择读G/写G</span></span><br><span class="line">    gpp := &amp;pd.rg</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        gpp = &amp;pd.wg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为pdWait状态</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 已经ready，返回</span></span><br><span class="line">        <span class="comment">// pdReady -&gt; pdNil</span></span><br><span class="line">        <span class="keyword">if</span> gpp.CompareAndSwap(pdReady, pdNil) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进入等待</span></span><br><span class="line">        <span class="comment">// pdNil -&gt; pdWait</span></span><br><span class="line">        <span class="keyword">if</span> gpp.CompareAndSwap(pdNil, pdWait) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常情况</span></span><br><span class="line">        <span class="keyword">if</span> v := gpp.Load(); v != pdReady &amp;&amp; v != pdNil &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: double wait&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pdWait or atomicInfo没有错误标志</span></span><br><span class="line">    <span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == pollNoError &#123;</span><br><span class="line">        <span class="comment">// 挂起等待，pdWait -&gt; goroutine指针，netpollWaiters++</span></span><br><span class="line">        gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceBlockNet, <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态设为pdNil</span></span><br><span class="line">    old := gpp.Swap(pdNil)</span><br><span class="line">    <span class="comment">// 如果old是goroutine的指针</span></span><br><span class="line">    <span class="keyword">if</span> old &gt; pdWait &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: corrupted polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起前处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblockcommit</span><span class="params">(gp *g, gpp unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// pdWait -&gt; goroutine指针</span></span><br><span class="line">    r := atomic.Casuintptr((*<span class="type">uintptr</span>)(gpp), pdWait, <span class="type">uintptr</span>(unsafe.Pointer(gp)))</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">    <span class="keyword">if</span> r &#123;</span><br><span class="line">        <span class="comment">// 计数器+1 =&gt; netpollWaiters++</span></span><br><span class="line">        netpollAdjustWaiters(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件发生唤醒挂起的G"><a href="#事件发生唤醒挂起的G" class="headerlink" title="事件发生唤醒挂起的G"></a>事件发生唤醒挂起的G</h2><p>事件发生时，唤醒被挂起等待的goroutine，与poll_runtime_pollWait搭配使用。具体逻辑如下</p>
<ol>
<li>guard，确保不会反复unblock已被移除出netpoll的pollDesc</li>
<li>事件元数据pollDesc更新<ul>
<li>计数器、atomicInfo、rg&#x2F;wg、读&#x2F;写定时器状态更新</li>
</ul>
</li>
<li>唤醒读G&#x2F;写G，并更新netpollWaiters计数器</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollUnblock</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 已被移除出netpoll</span></span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: unblock on closing polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pd.closing = <span class="literal">true</span></span><br><span class="line">    pd.rseq++</span><br><span class="line">    pd.wseq++</span><br><span class="line">    <span class="keyword">var</span> rg, wg *g</span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line">    <span class="comment">// 累计唤醒的G数量</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// rg/wg状态修改</span></span><br><span class="line">    rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    <span class="comment">// 停止读/写定时器</span></span><br><span class="line">    <span class="keyword">if</span> pd.rrun &#123;</span><br><span class="line">        pd.rt.stop()</span><br><span class="line">        pd.rrun = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.wrun &#123;</span><br><span class="line">        pd.wt.stop()</span><br><span class="line">        pd.wrun = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 唤醒读G/写G</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(rg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(wg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">    netpollAdjustWaiters(delta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://copyconstruct.medium.com/the-method-to-epolls-madness-d9d2d6378642">The method to epoll’s madness</a><br><a href="https://www.sobyte.net/post/2021-09/golang-netpoll/">golang netpoll Explained</a><br><a href="https://juejin.cn/post/6989608237226000391">Linux fd 系列 — eventfd 是什么？</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-slice</title>
    <url>/golang-series-slice/</url>
    <content><![CDATA[<p>slice&#x2F;切片-动态数组，golang常用的数据结构之一，相对于数组，slice可以追加元素，在容量不足时自动扩容</p>
<p>当前go版本：1.24</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>slice数据结构如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li><code>array</code> - 指向一片连续内存区域的第一个元素</li>
<li><code>len</code> - 已有元素数量</li>
<li><code>cap</code> - 可容纳元素总数量</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>slice初始化方式有三种</p>
<ol>
<li>使用字面量创建新切片</li>
<li>使用关键字make创建切片</li>
<li>通过下标获取数组或切片的一部份</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// len=3 cap=3</span></span><br><span class="line"><span class="keyword">var</span> v1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// len=10 cap=10</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>) <span class="comment">// var v2 = make([]int, 0, 10)</span></span><br><span class="line"><span class="comment">// len=4 cap=9</span></span><br><span class="line"><span class="keyword">var</span> v3 = v2[<span class="number">1</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>使用<code>ssa</code>包打印<code>var v1 = []int&#123;1, 2, 3&#125;</code>，得到结果如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t0 = new [3]int (slicelit)                                      *[3]int</span><br><span class="line">t1 = &amp;t0[0:int]                                                    *int</span><br><span class="line">*t1 = 1:int</span><br><span class="line">t2 = &amp;t0[1:int]                                                    *int</span><br><span class="line">*t2 = 2:int</span><br><span class="line">t3 = &amp;t0[2:int]                                                    *int</span><br><span class="line">*t3 = 3:int</span><br><span class="line">t4 = slice t0[:]   </span><br></pre></td></tr></table></figure>

<ol>
<li>根据字面量的数量创建一个数组t0</li>
<li>初始化数组元素t1&#x2F;t2&#x2F;t3</li>
<li>在t0基础上创建一个切片t4</li>
</ol>
<p><code>src/cmd/compile/internal/walk/complit.go</code>slicelit</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>使用<code>ssa</code>包打印<code>var v2 = make([]int, 10)</code>，得到结果如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t0 = new [10]int (makeslice)                                   *[10]int</span><br><span class="line">t1 = slice t0[:10:int]                                            []int</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个数组t0</li>
<li>在t0基础上创建一个切片t1</li>
</ol>
<p><code>makeslice</code>源代码如下，做了一些精简</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// 1. mem（连续内存区域大小） = 元素类型占用大小(type_size)*容量大小(cap)</span></span><br><span class="line">    <span class="comment">// 2. overflow（是否溢出） = !(type_size|cap &lt; 4GB or type_size=0 or cap &gt; uint_max/type_size)</span></span><br><span class="line">    mem, overflow := math.MulUintptr(et.Size_, <span class="type">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">        mem, overflow := math.MulUintptr(et.Size_, <span class="type">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">        <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            panicmakeslicelen()</span><br><span class="line">        &#125;</span><br><span class="line">        panicmakeslicecap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v2 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> v3 = v2[<span class="number">1</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>使用<code>ssa</code>包打印上述代码，得到结果如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t0 = new [10]int (makeslice)                                   *[10]int</span><br><span class="line">t1 = slice t0[:10:int]                                            []int</span><br><span class="line">t2 = slice t1[1:int:5:int]                                        []int</span><br></pre></td></tr></table></figure>

<ol>
<li>使用关键字make创建一个切片t1</li>
<li>在上一步基础上，创建一个切片t2，指定下标left&#x3D;1 right&#x3D;5</li>
</ol>
<h2 id="追加和扩容"><a href="#追加和扩容" class="headerlink" title="追加和扩容"></a>追加和扩容</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">v1 = <span class="built_in">append</span>(v1, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>slice使用<code>append</code>关键字实现追加操作，当数据量超过底层cap大小时，触发扩容，扩容代码精简后如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(oldPtr unsafe.Pointer, newLen, oldCap, num <span class="type">int</span>, et *_type)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 根据当前cap以及新len计算新cap</span></span><br><span class="line">    newcap := nextslicecap(newLen, oldCap)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line">    <span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line">    noscan := !et.Pointers() <span class="comment">// 指针？</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="comment">// ... （优化）</span></span><br><span class="line">    <span class="comment">// 以下是通用操作</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(oldLen) * et.Size_</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(newLen) * et.Size_</span><br><span class="line">        capmem, overflow = math.MulUintptr(et.Size_, <span class="type">uintptr</span>(newcap))</span><br><span class="line">        capmem = roundupsize(capmem, noscan)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / et.Size_)</span><br><span class="line">        capmem = <span class="type">uintptr</span>(newcap) * et.Size_</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextslicecap</span><span class="params">(newLen, oldCap <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 双倍cap仍然小于newLen，直接返回newLen</span></span><br><span class="line">    newcap := oldCap</span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> newLen &gt; doublecap &#123;</span><br><span class="line">        <span class="keyword">return</span> newLen</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 双倍cap小于512，返回双倍cap</span></span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">    <span class="keyword">if</span> oldCap &lt; threshold &#123;</span><br><span class="line">        <span class="keyword">return</span> doublecap</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 计算公式：x = 5/4*x + 192，直到x&gt;=newLen</span></span><br><span class="line">        newcap += (newcap + <span class="number">3</span>*threshold) &gt;&gt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">uint</span>(newcap) &gt;= <span class="type">uint</span>(newLen) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出？</span></span><br><span class="line">    <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newLen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newcap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在1.18版本，Keith Randall对slice的growth factor进行了调整，使其增长更为平滑，详细见提交：<code>https://github.com/golang/go/blob/2dda92ff6f9f07eeb110ecbf0fc2d7a0ddd27f9d/src/runtime/slice.go</code></p>
<p>不同cap对应的扩容因子如下</p>
<table>
<thead>
<tr>
<th align="left">starting cap</th>
<th align="left">growth factor</th>
</tr>
</thead>
<tbody><tr>
<td align="left">256</td>
<td align="left">2.0</td>
</tr>
<tr>
<td align="left">512</td>
<td align="left">1.63</td>
</tr>
<tr>
<td align="left">1024</td>
<td align="left">1.44</td>
</tr>
<tr>
<td align="left">2048</td>
<td align="left">1.35</td>
</tr>
<tr>
<td align="left">4096</td>
<td align="left">1.30</td>
</tr>
</tbody></table>
<h2 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h2><p>切片的拷贝也归类于appendSlice，具体在<code>src/cmd/compile/internal/walk/assign.go:appendSlice</code>。</p>
<p>这里的copy可能与我们预期不一样，并不是浅层或深层拷贝，是拷贝与目标dst的len长度一致的数据，与容量cap无关</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 []<span class="type">int</span> <span class="comment">// or `var v2 = make([]int, 0, 3)`</span></span><br><span class="line"><span class="built_in">copy</span>(v2, v1) <span class="comment">// v2仍然是空切片</span></span><br></pre></td></tr></table></figure>

<p>slicecopy函数具体如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(toPtr unsafe.Pointer, toLen <span class="type">int</span>, fromPtr unsafe.Pointer, fromLen <span class="type">int</span>, width <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// fromLen和toLen都为0，不处理</span></span><br><span class="line">    <span class="keyword">if</span> fromLen == <span class="number">0</span> || toLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n=min(fromLen, toLen)</span></span><br><span class="line">    n := fromLen</span><br><span class="line">    <span class="keyword">if</span> toLen &lt; n &#123;</span><br><span class="line">        n = toLen</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// type_size大小为0</span></span><br><span class="line">    <span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size := <span class="type">uintptr</span>(n) * width</span><br><span class="line">    <span class="comment">// copy</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span> &#123;</span><br><span class="line">        *(*<span class="type">byte</span>)(toPtr) = *(*<span class="type">byte</span>)(fromPtr)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memmove(toPtr, fromPtr, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://gist.github.com/Integralist/22ced4b4700df1e6cbec88c1074c8b2d">1. Memory Allocation Summary.md</a><br><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/">3.2 切片</a><br><a href="https://pkg.go.dev/golang.org/x/tools/go/ssa#example-package-BuildPackage">ssa</a><br><a href="https://go.dev/blog/slices-intro">Go Slices: usage and internals</a><br><a href="https://go101.org/article/container.html">Arrays, Slices and Maps in Go</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-程序运行流程及GMP模型</title>
    <url>/golang-series-bootstrap-and-gmp-model/</url>
    <content><![CDATA[<p>本文仅介绍程序运行流程以及GMP如何寻找g并运行，其他如抢占、死锁、信号处理、profiling等内容不打算深入。当前go版本：1.24</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>先讲几个概念</p>
<p><strong>进程、线程、协程</strong></p>
<ol>
<li>进程：程序的一个实例，也是操作系统的一个task，操作系统的资源分配最小单位</li>
<li>线程：一种概念，操作系统调度的最小单位，一个进程可以包含多个线程，线程之间共享内存、文件描述符等资源。不同操作系统的实现并不一致，linux下进程与线程的结构都是task_structure，也就是说他们是一样的，不同线程之间用指针指向同一份资源如内存空间实现共享。</li>
<li>协程：也称为用户态线程，由应用程序自行实现&#x2F;调度，一般情况下是协作式的，由开发者决定task何时让出cpu，go支持抢占式调度</li>
</ol>
<p><strong>线程与协程的映射模型</strong></p>
<ol>
<li>1:1模型，每个用户线程对应一个内核线程，如在c中pthread创建的线程，此时也可以理解为用户态线程就是内核态线程</li>
<li>1:N模型，一个内核线程对应多个用户线程，无法充分利用多核的并行性，现已淘汰</li>
<li>M:N模型，多个用户线程对应多个内核线程，实现较复杂，使用者较少，go是其中一个</li>
</ol>
<p><strong>GMP模型</strong></p>
<p>go早期的M:N模型遇到一些性能问题，如锁竞争激烈、线程创建&#x2F;销毁频繁、CPU缓存失效等，为了解决这些问题引入了P。在GMP模型中</p>
<ol>
<li>G-goroutine，用户态线程</li>
<li>M-machine，系统线程相关</li>
<li>P-processor，缓存、调度上下文等，其数量一般与CPU核心数量一致。P的出现使得调度变得本地化，避免全局锁竞争，提升了CPU缓存命中率等，最终使得go的并发调度更加高效</li>
</ol>
<h2 id="go程序的运行流程"><a href="#go程序的运行流程" class="headerlink" title="go程序的运行流程"></a>go程序的运行流程</h2><p>go程序启动时的入口是<code>_rt0_amd64</code>，该函数是汇编代码，具体如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// src/runtime/asm_amd64.s</span><br><span class="line">// 系统入口点</span><br><span class="line">TEXT _rt0_amd64(SB),NOSPLIT,$-8</span><br><span class="line">    MOVQ    0(SP), DI    // argc</span><br><span class="line">    LEAQ    8(SP), SI    // argv</span><br><span class="line">    JMP    runtime·rt0_go(SB)</span><br></pre></td></tr></table></figure>

<p><code>runtime·rt0_go</code>也是汇编代码，比较长，主要逻辑如下</p>
<ol>
<li>g0、m0双向绑定（g0、m0是全局变量，静态编译，因此指针已知，放在src&#x2F;runtime&#x2F;proc.go）</li>
<li>runtime·args      - 复制命令行参数（args函数放在src&#x2F;runtime&#x2F;runtime1.go）</li>
<li>runtime·osinit    - 系统初始化（osinit函数放在src&#x2F;runtime&#x2F;os_linux.go）</li>
<li>runtime·schedinit - 调度器初始化（schedinit函数放在src&#x2F;runtime&#x2F;proc.go）</li>
<li>runtime·mainPC    - 纪录runtime·main的地址（main函数放在src&#x2F;runtime&#x2F;proc.go，其内部调用main_main，也就是用户自己编写的main函数）</li>
<li>runtime·newproc   - 创建G用于运行runtime·main，放到p的runq里，等待调度</li>
<li>runtime·mstart    - 运行runtime·mstart（汇编函数，实际调用的是runtime·mstart0，放在src&#x2F;runtime&#x2F;proc.go，内部进行栈初始化、信号注册等，最后运行调度函数schedule）</li>
</ol>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="G-goroutine"><a href="#G-goroutine" class="headerlink" title="G - goroutine"></a>G - goroutine</h3><p>goroutine的数据结构如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="comment">// macOS下共440字节，虽然结构比较大，但GMP调度场景下使用的字段并不多</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 栈相关</span></span><br><span class="line">    stack             stack                       <span class="comment">// 最小为2KB，最大为1GB</span></span><br><span class="line">    stackguard0       <span class="type">uintptr</span>                     <span class="comment">// 用于正常函数调用时检查</span></span><br><span class="line">    stackguard1       <span class="type">uintptr</span>                     <span class="comment">// 用于调度恢复执行时检查</span></span><br><span class="line"></span><br><span class="line">    _panic            *_panic                     <span class="comment">// panic链</span></span><br><span class="line">    _defer            *_defer                     <span class="comment">// defer链</span></span><br><span class="line">    m                 *m                          <span class="comment">// 当前m</span></span><br><span class="line">    sched             gobuf                       <span class="comment">// 上下文如pc、sp等信息</span></span><br><span class="line">    syscallsp         <span class="type">uintptr</span>                     <span class="comment">// 系统调用时用</span></span><br><span class="line">    syscallpc         <span class="type">uintptr</span>                     <span class="comment">// 系统调用时用</span></span><br><span class="line">    syscallbp         <span class="type">uintptr</span>                     <span class="comment">// 系统调用时用</span></span><br><span class="line">    stktopsp          <span class="type">uintptr</span>                     <span class="comment">// 栈顶sp</span></span><br><span class="line"></span><br><span class="line">    param             unsafe.Pointer              <span class="comment">// 通用指针，存储sudog等</span></span><br><span class="line">    atomicstatus      atomic.Uint32               <span class="comment">// 状态，用的比较多，具体看后面列表</span></span><br><span class="line">    stackLock         <span class="type">uint32</span>                      <span class="comment">//</span></span><br><span class="line">    goid              <span class="type">uint64</span>                      <span class="comment">// 全局唯一id，从p获取，如果p没有，从sched获取</span></span><br><span class="line">    schedlink         guintptr                    <span class="comment">// next指针，下一个g，用于全局队列</span></span><br><span class="line">    waitsince         <span class="type">int64</span>                       <span class="comment">// 等待时刻</span></span><br><span class="line">    waitreason        waitReason                  <span class="comment">// 挂起原因</span></span><br><span class="line"></span><br><span class="line">    preempt           <span class="type">bool</span>                        <span class="comment">// 抢占标志</span></span><br><span class="line">    preemptStop       <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line">    preemptShrink     <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    asyncSafePoint    <span class="type">bool</span>                        <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    paniconfault      <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line">    gcscandone        <span class="type">bool</span>                        <span class="comment">// 是否已经完成栈扫描</span></span><br><span class="line">    throwsplit        <span class="type">bool</span>                        <span class="comment">// 是否允许栈分裂/扩容</span></span><br><span class="line"></span><br><span class="line">    activeStackChans  <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    parkingOnChan     atomic.Bool                 <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    inMarkAssist      <span class="type">bool</span>                        <span class="comment">// 是否需要协助GC标记</span></span><br><span class="line">    coroexit          <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    raceignore        <span class="type">int8</span>                        <span class="comment">//</span></span><br><span class="line">    nocgocallback     <span class="type">bool</span>                        <span class="comment">//</span></span><br><span class="line">    tracking          <span class="type">bool</span>                        <span class="comment">// trackingSeq%8 == 0</span></span><br><span class="line">    trackingSeq       <span class="type">uint8</span>                       <span class="comment">// 计数器，初始为一个随机数</span></span><br><span class="line">    trackingStamp     <span class="type">int64</span>                       <span class="comment">// 开始时刻（计算_Gwaiting、_Grunnable阶段耗时）</span></span><br><span class="line">    runnableTime      <span class="type">int64</span>                       <span class="comment">// _Grunnable总耗时</span></span><br><span class="line">    lockedm           muintptr                    <span class="comment">// m，锁定时用</span></span><br><span class="line">    fipsIndicator     <span class="type">uint8</span>                       <span class="comment">//</span></span><br><span class="line">    sig               <span class="type">uint32</span>                      <span class="comment">//</span></span><br><span class="line">    writebuf          []<span class="type">byte</span>                      <span class="comment">//</span></span><br><span class="line">    sigcode0          <span class="type">uintptr</span>                     <span class="comment">//</span></span><br><span class="line">    sigcode1          <span class="type">uintptr</span>                     <span class="comment">//</span></span><br><span class="line">    sigpc             <span class="type">uintptr</span>                     <span class="comment">//</span></span><br><span class="line">    parentGoid        <span class="type">uint64</span>                      <span class="comment">// 父g的goid</span></span><br><span class="line">    gopc              <span class="type">uintptr</span>                     <span class="comment">// 父g的pc</span></span><br><span class="line">    ancestors         *[]ancestorInfo             <span class="comment">// 父g的指针放到一个列表</span></span><br><span class="line">    startpc           <span class="type">uintptr</span>                     <span class="comment">// G的函数，=fn.fn</span></span><br><span class="line">    racectx           <span class="type">uintptr</span>                     <span class="comment">// 冲突检测相关</span></span><br><span class="line">    waiting           *sudog                      <span class="comment">// sudog指针，channel、select用</span></span><br><span class="line">    cgoCtxt           []<span class="type">uintptr</span>                   <span class="comment">//</span></span><br><span class="line">    labels            unsafe.Pointer              <span class="comment">// g为user类型时，父子共享</span></span><br><span class="line">    timer             *timer                      <span class="comment">// 定时器，time.Sleep用</span></span><br><span class="line">    sleepWhen         <span class="type">int64</span>                       <span class="comment">// 定时器，超时时间</span></span><br><span class="line">    selectDone        atomic.Uint32               <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    goroutineProfiled goroutineProfileStateHolder <span class="comment">// 新g需要标记不需要profile</span></span><br><span class="line"></span><br><span class="line">    coroarg           *coro                       <span class="comment">//</span></span><br><span class="line">    syncGroup         *synctestGroup              <span class="comment">// 测试相关，g为user类型时，父子共享</span></span><br><span class="line">    </span><br><span class="line">    trace             gTraceState                 <span class="comment">// trace相关数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GC Assist额度，或称为GC助攻积分，字节数。该值为负数时需要协助GC扫描，避免STW过长</span></span><br><span class="line">    gcAssistBytes     <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g0，全局变量，只有第一个g0是编译期间生成的，其他g0在创建m绑定p时动态生成。不可被抢占</span></span><br><span class="line"><span class="keyword">var</span> g0 g</span><br></pre></td></tr></table></figure>

<p><strong>类型</strong></p>
<p><code>user</code>：大部分的g都是user类型，执行用户代码<br><code>sys</code> ：大部分runtime开头的函数等都是sys类型，除了少部分如runtime.main外</p>
<p><strong>状态列表</strong></p>
<table>
<thead>
<tr>
<th align="left">status_name</th>
<th align="left">status_value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_Gidle</td>
<td align="left">0x00</td>
<td align="left">G已创建但未初始化</td>
</tr>
<tr>
<td align="left">_Grunnable</td>
<td align="left">0x01</td>
<td align="left">G放在runq，还未运行，未拥有stack</td>
</tr>
<tr>
<td align="left">_Grunning</td>
<td align="left">0x02</td>
<td align="left">G正在运行用户代码，拥有stack，已绑定M、P，不在runq</td>
</tr>
<tr>
<td align="left">_Gsyscall</td>
<td align="left">0x03</td>
<td align="left">G在执行系统调用（内核态），未运行用户代码，已绑定M，不在runq</td>
</tr>
<tr>
<td align="left">_Gwaiting</td>
<td align="left">0x04</td>
<td align="left">G阻塞中，未运行用户代码，未拥有stack，不在runq</td>
</tr>
<tr>
<td align="left">_Gmoribund_unused</td>
<td align="left">0x05</td>
<td align="left">此状态未被使用</td>
</tr>
<tr>
<td align="left">_Gdead</td>
<td align="left">0x06</td>
<td align="left">墓碑，G被M剥离并存储于free链表，或从free链表获取绑定中</td>
</tr>
<tr>
<td align="left">_Genqueue_unused</td>
<td align="left">0x07</td>
<td align="left">此状态未被使用</td>
</tr>
<tr>
<td align="left">_Gcopystack</td>
<td align="left">0x08</td>
<td align="left">迁移stack中，未运行用户代码，不在runq</td>
</tr>
<tr>
<td align="left">_Gpreempted</td>
<td align="left">0x09</td>
<td align="left">G被抢占，类似_Gwaiting</td>
</tr>
<tr>
<td align="left">_Gscan</td>
<td align="left">0x1000</td>
<td align="left">GC在扫描stack，未运行用户代码，拥有stack，可以组合上述其他标记</td>
</tr>
<tr>
<td align="left">_Gscanrunnable</td>
<td align="left">0x1001</td>
<td align="left">同_Gscan+_Grunnable</td>
</tr>
<tr>
<td align="left">_Gscanrunning</td>
<td align="left">0x1002</td>
<td align="left">同_Gscan+_Grunning</td>
</tr>
<tr>
<td align="left">_Gscansyscall</td>
<td align="left">0x1003</td>
<td align="left">同_Gscan+_Gsyscall</td>
</tr>
<tr>
<td align="left">_Gscanwaiting</td>
<td align="left">0x1004</td>
<td align="left">同_Gscan+_Gwaiting</td>
</tr>
<tr>
<td align="left">_Gscanpreempted</td>
<td align="left">0x1009</td>
<td align="left">同_Gscan+_Gpreempted</td>
</tr>
</tbody></table>
<p><strong>栈初始大小</strong></p>
<p>普通g的栈大小初始为2KB，非固定大小，可扩容，最大1GB。当然，初始栈大小也不是一成不变的，系统在GC时计算平均栈大小并更新变量。g0的栈大小因系统而异，如下</p>
<table>
<thead>
<tr>
<th align="left">OS</th>
<th align="left">是否系统分配 (<code>mStackIsSystemAllocated</code>)</th>
<th align="left"><code>g0</code> 栈大小</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Linux</td>
<td align="left">❌（Go 运行时自己分配）</td>
<td align="left">16KB</td>
</tr>
<tr>
<td align="left">macOS</td>
<td align="left">✅（系统分配）</td>
<td align="left">2MB</td>
</tr>
<tr>
<td align="left">iOS</td>
<td align="left">✅（系统分配）</td>
<td align="left">2MB</td>
</tr>
<tr>
<td align="left">Windows</td>
<td align="left">✅（系统分配）</td>
<td align="left">1MB</td>
</tr>
<tr>
<td align="left">Solaris</td>
<td align="left">✅（系统分配）</td>
<td align="left">8MB（可能）</td>
</tr>
<tr>
<td align="left">OpenBSD</td>
<td align="left">部分情况 ✅（mips64 除外）</td>
<td align="left">未知，可能 8MB</td>
</tr>
</tbody></table>
<h3 id="M-machine"><a href="#M-machine" class="headerlink" title="M - machine"></a>M - machine</h3><p>线程相关数据结构m如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// macOS下共1912字节</span></span><br><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0                   *g                            <span class="comment">// g0，调度用</span></span><br><span class="line">    morebuf              gobuf                         <span class="comment">//</span></span><br><span class="line">    divmod               <span class="type">uint32</span>                        <span class="comment">//</span></span><br><span class="line">    _                    <span class="type">uint32</span>                        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    procid               <span class="type">uint64</span>                        <span class="comment">// 线程ID，由系统提供</span></span><br><span class="line">    gsignal              *g                            <span class="comment">// g，信号处理用，32KB的栈</span></span><br><span class="line">    goSigStack           gsignalStack                  <span class="comment">//</span></span><br><span class="line">    sigmask              sigset                        <span class="comment">// 信号掩码</span></span><br><span class="line">    tls                  [tlsSlots]<span class="type">uintptr</span>             <span class="comment">//</span></span><br><span class="line">    mstartfn             <span class="function"><span class="keyword">func</span><span class="params">()</span></span>                        <span class="comment">// 线程启动时调用</span></span><br><span class="line">    curg                 *g                            <span class="comment">// 当前g，user/sys类型</span></span><br><span class="line">    caughtsig            guintptr                      <span class="comment">//</span></span><br><span class="line">    p                    puintptr                      <span class="comment">// 当前p</span></span><br><span class="line">    nextp                puintptr                      <span class="comment">// 获取的p先绑定在这个字段</span></span><br><span class="line">    oldp                 puintptr                      <span class="comment">// m、p取消绑定时纪录</span></span><br><span class="line">    id                   <span class="type">int64</span>                         <span class="comment">// 全局唯一ID，由mReserveID提供</span></span><br><span class="line">    mallocing            <span class="type">int32</span>                         <span class="comment">//</span></span><br><span class="line">    throwing             throwType                     <span class="comment">//</span></span><br><span class="line">    preemptoff           <span class="type">string</span>                        <span class="comment">// 阻止抢占的标志，调试、特殊场景用</span></span><br><span class="line">    locks                <span class="type">int32</span>                         <span class="comment">// 计数器，阻止抢占</span></span><br><span class="line">    dying                <span class="type">int32</span>                         <span class="comment">//</span></span><br><span class="line">    profilehz            <span class="type">int32</span>                         <span class="comment">//</span></span><br><span class="line">    spinning             <span class="type">bool</span>                          <span class="comment">// 自旋寻找工作中</span></span><br><span class="line">    blocked              <span class="type">bool</span>                          <span class="comment">// 阻塞状态，跟park字段搭配使用</span></span><br><span class="line">    newSigstack          <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    printlock            <span class="type">int8</span>                          <span class="comment">//</span></span><br><span class="line">    incgo                <span class="type">bool</span>                          <span class="comment">// 是否是c创建的</span></span><br><span class="line">    isextra              <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    isExtraInC           <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    isExtraInSig         <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    freeWait             atomic.Uint32                 <span class="comment">// 销毁状态</span></span><br><span class="line">    needextram           <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    g0StackAccurate      <span class="type">bool</span>                          <span class="comment">//</span></span><br><span class="line">    traceback            <span class="type">uint8</span>                         <span class="comment">//</span></span><br><span class="line">    ncgocall             <span class="type">uint64</span>                        <span class="comment">//</span></span><br><span class="line">    ncgo                 <span class="type">int32</span>                         <span class="comment">//</span></span><br><span class="line">    cgoCallersUse        atomic.Uint32                 <span class="comment">//</span></span><br><span class="line">    cgoCallers           *cgoCallers                   <span class="comment">//</span></span><br><span class="line">    park                 note                          <span class="comment">// semaphore</span></span><br><span class="line">    alllink              *m                            <span class="comment">// next指针，用于allm链表</span></span><br><span class="line">    schedlink            muintptr                      <span class="comment">// next指针，用于空闲链表</span></span><br><span class="line">    lockedg              guintptr                      <span class="comment">// 被锁住的g</span></span><br><span class="line">    createstack          [<span class="number">32</span>]<span class="type">uintptr</span>                   <span class="comment">//</span></span><br><span class="line">    lockedExt            <span class="type">uint32</span>                        <span class="comment">//</span></span><br><span class="line">    lockedInt            <span class="type">uint32</span>                        <span class="comment">// 是否锁定m，cgo用</span></span><br><span class="line">    mWaitList            mWaitList                     <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    mLockProfile         mLockProfile                  <span class="comment">// profile相关</span></span><br><span class="line">    profStack            []<span class="type">uintptr</span>                     <span class="comment">// profile相关</span></span><br><span class="line"></span><br><span class="line">    waitunlockf          <span class="function"><span class="keyword">func</span><span class="params">(*g, unsafe.Pointer)</span></span> <span class="type">bool</span> <span class="comment">// 解锁函数</span></span><br><span class="line">    waitlock             unsafe.Pointer                <span class="comment">// 解锁函数参数</span></span><br><span class="line">    waitTraceSkip        <span class="type">int</span>                           <span class="comment">// skip数量</span></span><br><span class="line">    waitTraceBlockReason traceBlockReason              <span class="comment">// 挂起原因-trace用</span></span><br><span class="line">    </span><br><span class="line">    syscalltick          <span class="type">uint32</span>                        <span class="comment">//</span></span><br><span class="line">    freelink             *m                            <span class="comment">// next指针，freem链表</span></span><br><span class="line">    trace                mTraceState                   <span class="comment">// trace相关数据</span></span><br><span class="line">    </span><br><span class="line">    libcall              libcall                       <span class="comment">//</span></span><br><span class="line">    libcallpc            <span class="type">uintptr</span>                       <span class="comment">//</span></span><br><span class="line">    libcallsp            <span class="type">uintptr</span>                       <span class="comment">//</span></span><br><span class="line">    libcallg             guintptr                      <span class="comment">//</span></span><br><span class="line">    winsyscall           winlibcall                    <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    vdsoSP               <span class="type">uintptr</span>                       <span class="comment">//</span></span><br><span class="line">    vdsoPC               <span class="type">uintptr</span>                       <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    preemptGen           atomic.Uint32                 <span class="comment">// 计数器，统计抢占次数</span></span><br><span class="line">    </span><br><span class="line">    signalPending        atomic.Uint32                 <span class="comment">// 待执行抢占</span></span><br><span class="line">    </span><br><span class="line">    pcvalueCache         pcvalueCache                  <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    dlogPerM                                           <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    mOS                                                <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    chacha8              chacha8rand.State             <span class="comment">// 随机数种子</span></span><br><span class="line">    cheaprand            <span class="type">uint64</span>                        <span class="comment">// 随机数</span></span><br><span class="line">    </span><br><span class="line">    locksHeldLen         <span class="type">int</span>                           <span class="comment">//</span></span><br><span class="line">    locksHeld            [<span class="number">10</span>]heldLockInfo              <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对齐</span></span><br><span class="line">    _                    [goexperiment.SpinbitMutexInt * <span class="number">700</span> * (<span class="number">2</span> - goarch.PtrSize/<span class="number">4</span>)]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m0，全局变量。与g0不同，m0只有一个</span></span><br><span class="line"><span class="keyword">var</span> m0 m</span><br></pre></td></tr></table></figure>

<p><strong>抢占标志</strong></p>
<p>m结构体有3个字段用于抢占判断，他们的作用和差异如下</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
<th>如何影响抢占</th>
<th>主要用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>lockedInt</code></strong></td>
<td>是否锁定 M</td>
<td><code>lockedInt &gt; 0</code> 时，该 M 不能被调度出去</td>
<td><code>LockOSThread()</code>，用于绑定线程（如 CGo 调用）</td>
</tr>
<tr>
<td><strong><code>locks</code></strong></td>
<td>M 持有的锁计数</td>
<td><code>locks &gt; 0</code> 时，调度器不会抢占 Goroutine</td>
<td>运行时内部锁（GC 期间、关键代码）</td>
</tr>
<tr>
<td><strong><code>preemptoff</code></strong></td>
<td>阻止抢占的标志</td>
<td><code>preemptoff</code> 非空时，M 不能被抢占</td>
<td>调试、特殊场景防止调度</td>
</tr>
</tbody></table>
<h3 id="P-processor"><a href="#P-processor" class="headerlink" title="P - processor"></a>P - processor</h3><p>processor-局部化缓存、元数据等。数量一般与CPU核心数一致，除几个特殊的m，其他m都需要获取绑定一个p才能执行用户代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// macOS下共8952字节</span></span><br><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    id           <span class="type">int32</span>                     <span class="comment">// 数组索引，[0,gomaxprocs-1]</span></span><br><span class="line">    status       <span class="type">uint32</span>                    <span class="comment">// 状态</span></span><br><span class="line">    link         puintptr                  <span class="comment">// next指针</span></span><br><span class="line">    schedtick    <span class="type">uint32</span>                    <span class="comment">// 调度计数器</span></span><br><span class="line">    syscalltick  <span class="type">uint32</span>                    <span class="comment">// syscall计次数</span></span><br><span class="line">    sysmontick   sysmontick                <span class="comment">// sysmon调度次数</span></span><br><span class="line">    m            muintptr                  <span class="comment">// 当前m</span></span><br><span class="line">    mcache       *mcache                   <span class="comment">// mcache内存分配器</span></span><br><span class="line">    pcache       pageCache                 <span class="comment">// 页缓存</span></span><br><span class="line">    raceprocctx  <span class="type">uintptr</span>                   <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    deferpool    []*_defer                 <span class="comment">// defer列表，基于deferpoolbuf的切片</span></span><br><span class="line">    deferpoolbuf [<span class="number">32</span>]*_defer               <span class="comment">// defer列表，固定数组</span></span><br><span class="line">    </span><br><span class="line">    goidcache    <span class="type">uint64</span>                    <span class="comment">// 起始goid</span></span><br><span class="line">    goidcacheend <span class="type">uint64</span>                    <span class="comment">// 结束goid，用完后向sched.goidgen一次性申请16个id</span></span><br><span class="line">    </span><br><span class="line">    runqhead     <span class="type">uint32</span>                    <span class="comment">// 本地队列头部g索引</span></span><br><span class="line">    runqtail     <span class="type">uint32</span>                    <span class="comment">// 本地队列尾部g索引</span></span><br><span class="line">    runq         [<span class="number">256</span>]guintptr             <span class="comment">// 本地队列</span></span><br><span class="line">    runnext      guintptr                  <span class="comment">// 本地队列头部g，优化，可被p偷取</span></span><br><span class="line">    </span><br><span class="line">    gFree        <span class="keyword">struct</span> &#123;                  <span class="comment">// 本地g空闲链表</span></span><br><span class="line">        gList                              <span class="comment">// 链表头</span></span><br><span class="line">        n     <span class="type">int32</span>                        <span class="comment">// 数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sudogcache []*sudog                    <span class="comment">// sudog列表，基于sudogbuf的切片</span></span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog                 <span class="comment">// sudog列表，固定数组</span></span><br><span class="line">    </span><br><span class="line">    mspancache <span class="keyword">struct</span> &#123;                    <span class="comment">// mspan缓存</span></span><br><span class="line">        <span class="built_in">len</span> <span class="type">int</span>                            <span class="comment">// 数量</span></span><br><span class="line">        buf [<span class="number">128</span>]*mspan                    <span class="comment">// 指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pinnerCache           *pinner          <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    trace                 pTraceState      <span class="comment">// trace相关数据</span></span><br><span class="line">    </span><br><span class="line">    palloc                persistentAlloc  <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    gcAssistTime          <span class="type">int64</span>            <span class="comment">// GC助攻耗时</span></span><br><span class="line">    gcFractionalMarkTime  <span class="type">int64</span>            <span class="comment">// fractional模式下的标记耗时</span></span><br><span class="line"></span><br><span class="line">    limiterEvent          limiterEvent     <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    gcMarkWorkerMode      gcMarkWorkerMode <span class="comment">// GC标记线程的工作模式</span></span><br><span class="line">    gcMarkWorkerStartTime <span class="type">int64</span>            <span class="comment">// GC标记线程的执行开始时刻</span></span><br><span class="line">    gcw                   gcWork           <span class="comment">// GC wbuf缓冲区（灰色队列）</span></span><br><span class="line">    wbBuf                 wbBuf            <span class="comment">// 写屏障缓冲区</span></span><br><span class="line"></span><br><span class="line">    runSafePointFn        <span class="type">uint32</span>           <span class="comment">// GC标志是否需要执行safePointFn</span></span><br><span class="line">    </span><br><span class="line">    statsSeq              atomic.Uint32    <span class="comment">// 计数器，奇数表示p正在写入stats</span></span><br><span class="line"></span><br><span class="line">    timers                timers           <span class="comment">// 定时器列表，每次执行调度时判断是否有g超时</span></span><br><span class="line"></span><br><span class="line">    maxStackScanDelta     <span class="type">int64</span>            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    scannedStackSize      <span class="type">uint64</span>           <span class="comment">// 累计扫描栈大小</span></span><br><span class="line">    scannedStacks         <span class="type">uint64</span>           <span class="comment">// 累计扫描栈数量</span></span><br><span class="line"></span><br><span class="line">    preempt               <span class="type">bool</span>             <span class="comment">// 是否抢占</span></span><br><span class="line"></span><br><span class="line">    gcStopTime            <span class="type">int64</span>            <span class="comment">// 因为GC导致的暂停的时刻</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>状态列表</strong></p>
<table>
<thead>
<tr>
<th align="left">status_name</th>
<th align="left">status_value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_Pidle</td>
<td align="left">0</td>
<td align="left">空闲，未运行用户代码，runq为空。默认状态</td>
</tr>
<tr>
<td align="left">_Prunning</td>
<td align="left">1</td>
<td align="left">运行中，P被M绑定，正在运行用户代码</td>
</tr>
<tr>
<td align="left">_Psyscall</td>
<td align="left">2</td>
<td align="left">正在执行系统调用，未运行用户代码，可被其他M偷取，类似_Pidle</td>
</tr>
<tr>
<td align="left">_Pgcstop</td>
<td align="left">3</td>
<td align="left">被M（STW）停止并拥有，当前M挂起。初始状态</td>
</tr>
<tr>
<td align="left">_Pdead</td>
<td align="left">4</td>
<td align="left">不在使用，剥离所有资源（GOMAXPROCS缩容）</td>
</tr>
</tbody></table>
<h3 id="schedt-调度器"><a href="#schedt-调度器" class="headerlink" title="schedt - 调度器"></a>schedt - 调度器</h3><p>schedt-调度器，纪录全局调度资源等，访问需要加锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// macOS下共6824字节</span></span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    goidgen      atomic.Uint64             <span class="comment">// goid全局计数器</span></span><br><span class="line">    lastpoll     atomic.Int64              <span class="comment">// 纪录上一次执行netpoll的时刻，0-正在轮询</span></span><br><span class="line">    pollUntil    atomic.Int64              <span class="comment">// netpoll轮询截止时刻</span></span><br><span class="line">    </span><br><span class="line">    lock         mutex                     <span class="comment">// 锁</span></span><br><span class="line">    </span><br><span class="line">    midle        muintptr                  <span class="comment">// 空闲m链表</span></span><br><span class="line">    nmidle       <span class="type">int32</span>                     <span class="comment">// 空闲m数量</span></span><br><span class="line">    nmidlelocked <span class="type">int32</span>                     <span class="comment">// 空闲的locked的m数量</span></span><br><span class="line">    mnext        <span class="type">int64</span>                     <span class="comment">// 累计m总量/自增id</span></span><br><span class="line">    maxmcount    <span class="type">int32</span>                     <span class="comment">// 最大可用线程数量，默认为10000</span></span><br><span class="line">    nmsys        <span class="type">int32</span>                     <span class="comment">// sys类型m数量</span></span><br><span class="line">    nmfreed      <span class="type">int64</span>                     <span class="comment">// 累计释放m数量</span></span><br><span class="line">    </span><br><span class="line">    ngsys        atomic.Int32              <span class="comment">// 系统G的数量</span></span><br><span class="line">    </span><br><span class="line">    pidle        puintptr                  <span class="comment">// 空闲p链表</span></span><br><span class="line">    npidle       atomic.Int32              <span class="comment">// 空闲p数量</span></span><br><span class="line">    nmspinning   atomic.Int32              <span class="comment">// 自旋的m的数量</span></span><br><span class="line">    needspinning atomic.Uint32             <span class="comment">// 需要某个m自旋放弃p</span></span><br><span class="line">    </span><br><span class="line">    runq         gQueue                    <span class="comment">// 状态为_Grunnable的g</span></span><br><span class="line">    runqsize     <span class="type">int32</span>                     <span class="comment">// 状态为_Grunnable的g数量</span></span><br><span class="line">    </span><br><span class="line">    disable      <span class="keyword">struct</span> &#123;                  <span class="comment">// </span></span><br><span class="line">        user     <span class="type">bool</span>                      <span class="comment">// 是否禁止user类型的g运行</span></span><br><span class="line">        runnable gQueue                    <span class="comment">// user字段为false时，user类型的g都阻塞在这里</span></span><br><span class="line">        n        <span class="type">int32</span>                     <span class="comment">// 总数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    gFree <span class="keyword">struct</span> &#123;                         <span class="comment">// 全局gFree链表</span></span><br><span class="line">        lock    mutex                      <span class="comment">// 锁</span></span><br><span class="line">        stack   gList                      <span class="comment">// 有栈的g</span></span><br><span class="line">        noStack gList                      <span class="comment">// 无栈的g</span></span><br><span class="line">        n       <span class="type">int32</span>                      <span class="comment">// 总数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sudoglock                mutex         <span class="comment">// sudog锁，用于sudogcache</span></span><br><span class="line">    sudogcache               *sudog        <span class="comment">// 全局sudog链表</span></span><br><span class="line">    </span><br><span class="line">    deferlock                mutex         <span class="comment">// 锁，保护deferpool</span></span><br><span class="line">    deferpool                *_defer       <span class="comment">// defer队列</span></span><br><span class="line">    </span><br><span class="line">    freem                    *m            <span class="comment">// free链表</span></span><br><span class="line">    </span><br><span class="line">    gcwaiting                atomic.Bool   <span class="comment">// STW信号，当前p需要释放到空闲队列</span></span><br><span class="line">    stopwait                 <span class="type">int32</span>         <span class="comment">// 待_Pgcstop的p数量</span></span><br><span class="line">    stopnote                 note          <span class="comment">// semaphore，存储执行GC的m</span></span><br><span class="line">    sysmonwait               atomic.Bool   <span class="comment">// true-sysmon挂起休眠了</span></span><br><span class="line">    sysmonnote               note          <span class="comment">// semaphore，sysmon挂起在这里</span></span><br><span class="line">    </span><br><span class="line">    safePointFn              <span class="function"><span class="keyword">func</span><span class="params">(*p)</span></span>      <span class="comment">// 到达安全点时执行的函数</span></span><br><span class="line">    safePointWait            <span class="type">int32</span>         <span class="comment">// 同p的数量，检查全部p是否都已执行safePointFn</span></span><br><span class="line">    safePointNote            note          <span class="comment">// semaphore，存储执行GC的m</span></span><br><span class="line">    </span><br><span class="line">    profilehz                <span class="type">int32</span>         <span class="comment">// profiler</span></span><br><span class="line">    </span><br><span class="line">    procresizetime           <span class="type">int64</span>         <span class="comment">// 调整p数量的时刻</span></span><br><span class="line">    totaltime                <span class="type">int64</span>         <span class="comment">// 调整p时，纪录所有核心的运行时长</span></span><br><span class="line">    </span><br><span class="line">    sysmonlock               mutex         <span class="comment">// 锁，用于sysmon</span></span><br><span class="line">    </span><br><span class="line">    timeToRun                timeHistogram <span class="comment">// 累计所有处于_Grunnable状态的g的时长</span></span><br><span class="line">    </span><br><span class="line">    idleTime                 atomic.Int64  <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    totalMutexWaitTime       atomic.Int64  <span class="comment">// 累计所有处于_Gwaiting状态的g的时长</span></span><br><span class="line">    </span><br><span class="line">    stwStoppingTimeGC        timeHistogram <span class="comment">//</span></span><br><span class="line">    stwStoppingTimeOther     timeHistogram <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    stwTotalTimeGC           timeHistogram <span class="comment">//</span></span><br><span class="line">    stwTotalTimeOther        timeHistogram <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    totalRuntimeLockWaitTime atomic.Int64  <span class="comment">// 纪录总等待耗时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="schedinit-调度器初始化"><a href="#schedinit-调度器初始化" class="headerlink" title="schedinit - 调度器初始化"></a>schedinit - 调度器初始化</h2><p>有点长，还是直接看注释吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器锁初始化</span></span><br><span class="line">    lockInit(&amp;sched.lock, lockRankSched)</span><br><span class="line">    lockInit(&amp;sched.sysmonlock, lockRankSysmon)</span><br><span class="line">    lockInit(&amp;sched.deferlock, lockRankDefer)</span><br><span class="line">    lockInit(&amp;sched.sudoglock, lockRankSudog)</span><br><span class="line">    <span class="comment">// 全局变量锁初始化</span></span><br><span class="line">    lockInit(&amp;deadlock, lockRankDeadlock)</span><br><span class="line">    lockInit(&amp;paniclk, lockRankPanic)</span><br><span class="line">    lockInit(&amp;allglock, lockRankAllg)</span><br><span class="line">    lockInit(&amp;allpLock, lockRankAllp)</span><br><span class="line">    lockInit(&amp;reflectOffs.lock, lockRankReflectOffs)</span><br><span class="line">    lockInit(&amp;finlock, lockRankFin)</span><br><span class="line">    lockInit(&amp;cpuprof.lock, lockRankCpuprof)</span><br><span class="line">    <span class="comment">// allocm函数内使用</span></span><br><span class="line">    allocmLock.init(lockRankAllocmR, lockRankAllocmRInternal, lockRankAllocmW)</span><br><span class="line">    <span class="comment">// 执行系统调用exec、clone时使用</span></span><br><span class="line">    execLock.init(lockRankExecR, lockRankExecRInternal, lockRankExecW)</span><br><span class="line">    <span class="comment">// trace锁初始化</span></span><br><span class="line">    traceLockInit()</span><br><span class="line">    <span class="comment">// memstats锁初始化</span></span><br><span class="line">    lockInit(&amp;memstats.heapStats.noPLock, lockRankLeafRank)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证m数据结构的大小</span></span><br><span class="line">    lockVerifyMSize()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g0（m为m0）</span></span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制能创建的线程数量为10000</span></span><br><span class="line">    sched.maxmcount = <span class="number">10000</span></span><br><span class="line">    <span class="comment">// 文件描述符，用于panic时输出到指定文件</span></span><br><span class="line">    crashFD.Store(^<span class="type">uintptr</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止整个世界，空函数（staticlockranking默认为false）</span></span><br><span class="line">    worldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ticks纪录当前时刻和CPU时钟</span></span><br><span class="line">    ticks.init()</span><br><span class="line">    <span class="comment">// 插件、动态库元数据校验</span></span><br><span class="line">    moduledataverify()</span><br><span class="line">    <span class="comment">// 栈相关，全局stackpool和stackLarge初始化</span></span><br><span class="line">    stackinit()</span><br><span class="line">    <span class="comment">// malloc初始化</span></span><br><span class="line">    mallocinit()</span><br><span class="line">    <span class="comment">// 解析GODEBUG合并到默认值</span></span><br><span class="line">    godebug := getGodebugEarly()</span><br><span class="line">    <span class="comment">// 根据环境变量初始化CPU，要求在alginit前调用</span></span><br><span class="line">    cpuinit(godebug)</span><br><span class="line">    <span class="comment">// 全局随机状态初始化，要求在alginit、mcommoninit前调用</span></span><br><span class="line">    randinit()</span><br><span class="line">    <span class="comment">// 哈希计算相关初始化</span></span><br><span class="line">    alginit()</span><br><span class="line">    <span class="comment">// 到这里就能正常使用maps、hash、rand了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// m通用初始化</span></span><br><span class="line">    mcommoninit(gp.m, <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 插件、动态库初始化，到这里activeModules可用</span></span><br><span class="line">    modulesinit()</span><br><span class="line">    <span class="comment">// 初始化类型信息，用于reflect和GC（依赖activeModules）</span></span><br><span class="line">    typelinksinit()</span><br><span class="line">    <span class="comment">// 接口表初始化，使用activeModules（依赖activeModules）</span></span><br><span class="line">    itabsinit()</span><br><span class="line">    <span class="comment">// 栈对象初始化，要求在GC开启前完成</span></span><br><span class="line">    stkobjinit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前线程信号掩码到m.sigmask（平台相关）</span></span><br><span class="line">    sigsave(&amp;gp.m.sigmask)</span><br><span class="line">    initSigmask = gp.m.sigmask</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制命令行参数</span></span><br><span class="line">    goargs()</span><br><span class="line">    <span class="comment">// 复制环境变量</span></span><br><span class="line">    goenvs()</span><br><span class="line">    <span class="comment">// GOTRACEBACK相关环境变量解析（平台相关）</span></span><br><span class="line">    secure()</span><br><span class="line">    <span class="comment">// 检查stdin、stdout、stderr是否有效（平台相关）</span></span><br><span class="line">    checkfds()</span><br><span class="line">    <span class="comment">// debug、godebug解析设置</span></span><br><span class="line">    parsedebugvars()</span><br><span class="line">    <span class="comment">// GC初始化</span></span><br><span class="line">    gcinit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于崩溃时纪录栈信息</span></span><br><span class="line">    <span class="comment">// 16KB的栈</span></span><br><span class="line">    gcrash.stack = stackalloc(<span class="number">16384</span>)</span><br><span class="line">    <span class="comment">// stackguard0（用于正常函数调用时检查）</span></span><br><span class="line">    gcrash.stackguard0 = gcrash.stack.lo + <span class="number">1000</span></span><br><span class="line">    <span class="comment">// stackguard1（用于调度恢复执行时检查）</span></span><br><span class="line">    gcrash.stackguard1 = gcrash.stack.lo + <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认为false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> disableMemoryProfiling &#123;</span><br><span class="line">        <span class="comment">// 如果禁用heap profiling</span></span><br><span class="line">        <span class="comment">// parsedebugvars会覆盖MemProfileRate值，没关系，以disableMemoryProfiling设置为准</span></span><br><span class="line">        MemProfileRate = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存剖析调用栈初始化</span></span><br><span class="line">    <span class="comment">// mcommoninit在parsedebugvars前运行，需要重新初始化</span></span><br><span class="line">    mProfStackInit(gp.m)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// lastpoll纪录当前时刻</span></span><br><span class="line">    sched.lastpoll.Store(nanotime())</span><br><span class="line">    <span class="comment">// osinit时已纪录到全局变量ncpu</span></span><br><span class="line">    procs := ncpu</span><br><span class="line">    <span class="comment">// 以GOMAXPROCS为准</span></span><br><span class="line">    <span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        procs = n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据数量n扩容/缩容p</span></span><br><span class="line">    <span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 世界开始运行，空函数（staticlockranking默认为false）</span></span><br><span class="line">    worldStarted()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下情况一般不应该发生</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// go的版本号为空</span></span><br><span class="line">    <span class="keyword">if</span> buildVersion == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        buildVersion = <span class="string">&quot;unknown&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(modinfo) == <span class="number">1</span> &#123;</span><br><span class="line">        modinfo = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建g负责运行main函数"><a href="#创建g负责运行main函数" class="headerlink" title="创建g负责运行main函数"></a>创建g负责运行main函数</h2><h3 id="newproc-创建goroutine"><a href="#newproc-创建goroutine" class="headerlink" title="newproc - 创建goroutine"></a>newproc - 创建goroutine</h3><p>调用newproc创建新的g用于运行runtime.main，不会立即执行，而是放入p的本地队列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器将go关键字编译为newproc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(fn *funcval)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    pc := sys.GetCallerPC()</span><br><span class="line">    <span class="comment">// 切换到g0执行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 创建goroutine，此时状态已为_Grunnable或_Gwaiting</span></span><br><span class="line">        newg := newproc1(fn, gp, pc, <span class="literal">false</span>, waitReasonZero)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p</span></span><br><span class="line">        pp := getg().m.p.ptr()</span><br><span class="line">        <span class="comment">// 把g放到本地队列头部</span></span><br><span class="line">        runqput(pp, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// runtime.main已运行</span></span><br><span class="line">        <span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">            <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">            wakep()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, callergp *g, callerpc <span class="type">uintptr</span>, parked <span class="type">bool</span>, waitreason waitReason)</span></span> *g &#123;</span><br><span class="line">    <span class="comment">// 函数不能为nil</span></span><br><span class="line">    <span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m，禁止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// 从本地gFree获取一个g</span></span><br><span class="line">    newg := gfget(pp)</span><br><span class="line">    <span class="comment">// 获取失败</span></span><br><span class="line">    <span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 创建g、分配栈（初始为2KB，GC时更新为平均值）</span></span><br><span class="line">        newg = malg(stackMin)</span><br><span class="line">        <span class="comment">// 从_Gidle状态改为_Gdead，避免Gc扫描</span></span><br><span class="line">        casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">        <span class="comment">// 把g放到allgs切片</span></span><br><span class="line">        allgadd(newg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈检查</span></span><br><span class="line">    <span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;newproc1: newg missing stack&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态检查</span></span><br><span class="line">    <span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">        throw(<span class="string">&quot;newproc1: new g is not Gdead&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// totalSize=4*8+0=32</span></span><br><span class="line">    totalSize := <span class="type">uintptr</span>(<span class="number">4</span>*goarch.PtrSize + sys.MinFrameSize)</span><br><span class="line">    <span class="comment">// 内存对齐，totalSize=32</span></span><br><span class="line">    totalSize = alignUp(totalSize, sys.StackAlign)</span><br><span class="line">    <span class="comment">// sp=stack.hi-32</span></span><br><span class="line">    sp := newg.stack.hi - totalSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// usesLR默认为false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> usesLR &#123;</span><br><span class="line">        <span class="comment">// 调用者LR设为0</span></span><br><span class="line">        *(*<span class="type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 空函数，忽略</span></span><br><span class="line">        prepGoExitFrame(sp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arm64，先忽略</span></span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;arm64&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 调用者FP设为0</span></span><br><span class="line">        *(*<span class="type">uintptr</span>)(unsafe.Pointer(sp - goarch.PtrSize)) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sched重置清零</span></span><br><span class="line">    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 纪录/更新g的相关信息</span></span><br><span class="line"></span><br><span class="line">    newg.sched.sp = sp</span><br><span class="line">    newg.stktopsp = sp</span><br><span class="line">    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum</span><br><span class="line">    newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">    <span class="comment">// 调整fn、寄存器等信息</span></span><br><span class="line">    gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">    newg.parentGoid = callergp.goid</span><br><span class="line">    newg.gopc = callerpc</span><br><span class="line">    <span class="comment">// 为nil（tracebackancestors默认为0）</span></span><br><span class="line">    newg.ancestors = saveAncestors(callergp)</span><br><span class="line">    newg.startpc = fn.fn</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断g是否是sys类型，一般runtime.*的都是，除了少部分如runtime.main等</span></span><br><span class="line">    <span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// sys类型</span></span><br><span class="line">        <span class="comment">// 计数器+=1</span></span><br><span class="line">        sched.ngsys.Add(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// user类型</span></span><br><span class="line">        <span class="comment">// 测试相关，忽略</span></span><br><span class="line">        newg.syncGroup = callergp.syncGroup</span><br><span class="line">        <span class="comment">// g</span></span><br><span class="line">        <span class="keyword">if</span> mp.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">            newg.labels = mp.curg.labels</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PProf已启动</span></span><br><span class="line">        <span class="keyword">if</span> goroutineProfile.active &#123;</span><br><span class="line">            <span class="comment">// goroutineProfiled=2</span></span><br><span class="line">            newg.goroutineProfiled.Store(goroutineProfileSatisfied)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断g是否要进行跟踪统计</span></span><br><span class="line">    <span class="comment">// trackingSeq=随机数</span></span><br><span class="line">    newg.trackingSeq = <span class="type">uint8</span>(cheaprand())</span><br><span class="line">    <span class="comment">// trackingSeq%8 == 0（1/8的概率？）</span></span><br><span class="line">    <span class="keyword">if</span> newg.trackingSeq%gTrackingPeriod == <span class="number">0</span> &#123;</span><br><span class="line">        newg.tracking = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计到maxStackScan，有p的话，先暂存到p</span></span><br><span class="line">    gcController.addScannableStack(pp, <span class="type">int64</span>(newg.stack.hi-newg.stack.lo))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认_Grunnable，如果parked为true，则_Gwaiting</span></span><br><span class="line">    <span class="keyword">var</span> status <span class="type">uint32</span> = _Grunnable</span><br><span class="line">    <span class="keyword">if</span> parked &#123;</span><br><span class="line">        status = _Gwaiting</span><br><span class="line">        <span class="comment">// _Gwaiting时reason不能为空</span></span><br><span class="line">        newg.waitreason = waitreason</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// goid，每个p一次性从sched申请16个</span></span><br><span class="line">    <span class="keyword">if</span> pp.goidcache == pp.goidcacheend &#123;</span><br><span class="line">        <span class="comment">// 调度器goidgen+=16。如果goidgen为0，则goidcache=16</span></span><br><span class="line">        pp.goidcache = sched.goidgen.Add(_GoidCacheBatch)</span><br><span class="line">        <span class="comment">// 如果此时goidcache为16，操作后值为1</span></span><br><span class="line">        pp.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">        <span class="comment">// 结束goid</span></span><br><span class="line">        pp.goidcacheend = pp.goidcache + _GoidCacheBatch</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// goid</span></span><br><span class="line">    newg.goid = pp.goidcache</span><br><span class="line">    <span class="comment">// 从_Gdead状态改为_Grunnable或_Gwaiting</span></span><br><span class="line">    casgstatus(newg, _Gdead, status)</span><br><span class="line">    <span class="comment">// 当前p的起始goid向后挪动一位（被消耗一位）</span></span><br><span class="line">    pp.goidcache++</span><br><span class="line">    <span class="comment">// trace相关纪录数据等清空</span></span><br><span class="line">    newg.trace.reset()</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建g、分配栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">malg</span><span class="params">(stacksize <span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">    newg := <span class="built_in">new</span>(g)</span><br><span class="line">    <span class="keyword">if</span> stacksize &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// =round2(0+stacksize)</span></span><br><span class="line">        stacksize = round2(stackSystem + stacksize)</span><br><span class="line">        <span class="comment">// 创建栈</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 创建栈，暂不讨论</span></span><br><span class="line">            newg.stack = stackalloc(<span class="type">uint32</span>(stacksize))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// stackguard0（用于正常函数调用时检查）=stack.lo+928 （Ps. 2KB瞬间少了一半）</span></span><br><span class="line">        newg.stackguard0 = newg.stack.lo + stackGuard</span><br><span class="line">        <span class="comment">// stackguard1（用于调度恢复执行时检查）= ^uintptr(0)</span></span><br><span class="line">        newg.stackguard1 = ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// lo指向的位置设置为0</span></span><br><span class="line">        *(*<span class="type">uintptr</span>)(unsafe.Pointer(newg.stack.lo)) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runtime-main-程序入口"><a href="#runtime-main-程序入口" class="headerlink" title="runtime.main - 程序入口"></a>runtime.main - 程序入口</h3><p>main函数有两个，一个是跟底层运行时相关的runtime.main，另一个是用户编写的main.main。runtime.main内部负责运行时相关初始化，如执行所有包的init函数、开启GC、cgo初始化等，最后调用main.main</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当前g绑定的m</span></span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冲突检测相关，忽略</span></span><br><span class="line">    mp.g0.racectx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64位系统，栈最大为1GB</span></span><br><span class="line">    <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">        maxstacksize = <span class="number">1000000000</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maxstacksize = <span class="number">250000000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2GB</span></span><br><span class="line">    maxstackceiling = <span class="number">2</span> * maxstacksize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局变量，用以标志允许newproc创建运行M</span></span><br><span class="line">    mainStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了wasm，其他平台默认开启sysmon</span></span><br><span class="line">    <span class="keyword">if</span> haveSysmon &#123;</span><br><span class="line">        <span class="comment">// 汇编，切换到g0运行</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 清理freem链表，创建并初始化m，locked或cgo类型的m由模板线程延迟创建，其他类型则立即调用平台相关函数创建线程</span></span><br><span class="line">            <span class="comment">// sysmon负责轮询netpoll、抢占超时的g、回收阻塞在syscall的p</span></span><br><span class="line">            newm(sysmon, <span class="literal">nil</span>, <span class="number">-1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向绑定，防抢占</span></span><br><span class="line">    <span class="comment">// 当前g、m纪录到m.lockedg、g.lockedm字段</span></span><br><span class="line">    lockOSThread()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望当前m就是m0</span></span><br><span class="line">    <span class="keyword">if</span> mp != &amp;m0 &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime.main not on m0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻-单调时钟</span></span><br><span class="line">    runtimeInitTime = nanotime()</span><br><span class="line">    <span class="keyword">if</span> runtimeInitTime == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;nanotime returning zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启trace</span></span><br><span class="line">    <span class="keyword">if</span> debug.inittrace != <span class="number">0</span> &#123;</span><br><span class="line">        inittrace.id = getg().goid</span><br><span class="line">        inittrace.active = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行runtime相关的init函数，必须放在defer之前</span></span><br><span class="line">    doInit(runtime_inittasks)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面会设置为false，如果期间有任何panic，defer内unlock</span></span><br><span class="line">    needUnlock := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> needUnlock &#123;</span><br><span class="line">            <span class="comment">// 重置m.lockedg、g.lockedm字段</span></span><br><span class="line">            unlockOSThread()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行sweeper、scavenger（GC）</span></span><br><span class="line">    gcenable()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cgo使用，判断main是否完成相关初始化操作</span></span><br><span class="line">    main_init_done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cgo初始化</span></span><br><span class="line">    <span class="keyword">if</span> iscgo &#123;</span><br><span class="line">        <span class="keyword">if</span> _cgo_pthread_key_created == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;_cgo_pthread_key_created missing&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;_cgo_thread_start missing&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> GOOS != <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> _cgo_setenv == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;_cgo_setenv missing&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> _cgo_unsetenv == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;_cgo_unsetenv missing&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _cgo_notify_runtime_init_done == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;_cgo_notify_runtime_init_done missing&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> set_crosscall2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;set_crosscall2 missing&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        set_crosscall2()</span><br><span class="line"></span><br><span class="line">        startTemplateThread()</span><br><span class="line">        cgocall(_cgo_notify_runtime_init_done, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行模块相关的init函数</span></span><br><span class="line">    <span class="keyword">for</span> m := &amp;firstmoduledata; m != <span class="literal">nil</span>; m = m.next &#123;</span><br><span class="line">        doInit(m.inittasks)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭trace</span></span><br><span class="line">    inittrace.active = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cgo完成初始化</span></span><br><span class="line">    <span class="built_in">close</span>(main_init_done)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里没有panic，就不需要用defer来unlock了</span></span><br><span class="line">    needUnlock = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 重置m.lockedg、g.lockedm字段</span></span><br><span class="line">    unlockOSThread()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有main函数但不需要执行</span></span><br><span class="line">    <span class="comment">// 动态库（c-archive/c-shared）</span></span><br><span class="line">    <span class="keyword">if</span> isarchive || islibrary &#123;</span><br><span class="line">        <span class="comment">// wasm只有一个M</span></span><br><span class="line">        <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里阻塞，不应该返回</span></span><br><span class="line">            pause(sys.GetCallerSP() - <span class="number">16</span>)</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main.main函数，需要linker在运行时确定地址</span></span><br><span class="line">    fn := main_main</span><br><span class="line">    <span class="comment">// 执行main.main函数</span></span><br><span class="line">    fn()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有G发生panic，打印trace然后退出</span></span><br><span class="line">    <span class="comment">// runningPanicDefers会在panic+1，recovery时-1</span></span><br><span class="line">    <span class="keyword">if</span> runningPanicDefers.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 防止运行时间过长</span></span><br><span class="line">        <span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line">            <span class="keyword">if</span> runningPanicDefers.Load() == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同协程yield关键字，当前g让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">            Gosched()</span><br><span class="line">            <span class="comment">// 被重新调度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遇到无法recover的panic时，panicking不为0</span></span><br><span class="line">    <span class="keyword">if</span> panicking.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 当前g让出CPU，g0执行调度运行其他g</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonPanicWait, traceBlockForever, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// panic了，运行hooks</span></span><br><span class="line">    runExitHooks(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编代码runtime·exit</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x *<span class="type">int32</span></span><br><span class="line">        *x = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime·mstart-运行调度函数"><a href="#runtime·mstart-运行调度函数" class="headerlink" title="runtime·mstart - 运行调度函数"></a>runtime·mstart - 运行调度函数</h2><p>runtime·mstart为汇编函数，函数内调用runtime·mstart0</p>
<h3 id="mstart0"><a href="#mstart0" class="headerlink" title="mstart0"></a>mstart0</h3><p>mstart0主要进行栈初始化、信号注册等，最后运行调度函数schedule</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// g0分配栈，m0进行信号处理初始化、执行mstartfn，寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart0</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否未分配，可能是由操作系统直接分配的栈</span></span><br><span class="line">    osStack := gp.stack.lo == <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> osStack &#123;</span><br><span class="line">        size := gp.stack.hi</span><br><span class="line">        <span class="comment">// 如果没有栈，设置大小为16KB</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 16384*1 =&gt; 16KB</span></span><br><span class="line">            size = <span class="number">16384</span> * sys.StackGuardMultiplier</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈顶</span></span><br><span class="line">        gp.stack.hi = <span class="type">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">        <span class="comment">// 栈底（预留1KB？）</span></span><br><span class="line">        gp.stack.lo = gp.stack.hi - size + <span class="number">1024</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// stackguard0（用于正常函数调用时检查）=stack.lo+928</span></span><br><span class="line">    gp.stackguard0 = gp.stack.lo + stackGuard</span><br><span class="line">    <span class="comment">// stackguard1（用于调度恢复执行时检查）=stack.lo+928</span></span><br><span class="line">    gp.stackguard1 = gp.stackguard0</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号处理初始化、执行mstartfn，寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    mstart1()</span><br><span class="line">    <span class="comment">// 这里执行后不会返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果栈由系统分配（linux为false，由go分配）</span></span><br><span class="line">    <span class="keyword">if</span> mStackIsSystemAllocated() &#123;</span><br><span class="line">        osStack = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m线程退出</span></span><br><span class="line">    mexit(osStack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理初始化、执行mstartfn，寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望当前g是g0</span></span><br><span class="line">    <span class="keyword">if</span> gp != gp.m.g0 &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad runtime·mstart&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寄存器相关</span></span><br><span class="line">    gp.sched.g = guintptr(unsafe.Pointer(gp))</span><br><span class="line">    gp.sched.pc = sys.GetCallerPC()</span><br><span class="line">    gp.sched.sp = sys.GetCallerSP()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编代码，amd64为空函数</span></span><br><span class="line">    asminit()</span><br><span class="line">    <span class="comment">// 信号处理初始化（平台相关）、纪录procid</span></span><br><span class="line">    minit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是m0</span></span><br><span class="line">    <span class="keyword">if</span> gp.m == &amp;m0 &#123;</span><br><span class="line">        <span class="comment">// 信号处理初始化（平台相关），如果是cgo，生成一定数量的extraM，</span></span><br><span class="line">        mstartm0()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dataindependenttiming默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debug.dataindependenttiming == <span class="number">1</span> &#123;</span><br><span class="line">        sys.EnableDIT()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fn := gp.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 执行mstartfn</span></span><br><span class="line">        <span class="comment">// 主要有sysmon/templateThread/用户自定义这几类函数</span></span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非m0（从代码看，只有m0才会运行该函数才对）</span></span><br><span class="line">    <span class="keyword">if</span> gp.m != &amp;m0 &#123;</span><br><span class="line">        <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">        acquirep(gp.m.nextp.ptr())</span><br><span class="line">        <span class="comment">// 重置nextp</span></span><br><span class="line">        gp.m.nextp = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="schedule-调度函数"><a href="#schedule-调度函数" class="headerlink" title="schedule - 调度函数"></a>schedule - 调度函数</h3><ol>
<li>寻找g<ol>
<li>如果lockedg有数据<ul>
<li>让出p并挂起休眠，直到lockedg状态变为可运行，被唤醒后绑定一个p返回</li>
<li>lockedg调整状态等数据，和m双向绑定，最后切换到lockedg的上下文执行（该函数永不返回）</li>
</ul>
</li>
<li>执行findRunnable寻找可运行的g</li>
<li>GC开始到标记结束这个过程只允许sys类型的g运行<ul>
<li>如果检查是user类型的g，回到开头重新findRunnable寻找</li>
</ul>
</li>
</ol>
</li>
<li>p获取、与m绑定<ol>
<li>如果当前m自旋中<ul>
<li>重置m.spinning，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</li>
</ul>
</li>
<li>如果g是GCworker或tracereader<ul>
<li>从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</li>
</ul>
</li>
<li>如果g.lockedm有数据<ul>
<li>m让出p给lockedm并唤醒，把当前m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</li>
<li>回到开头重新findRunnable寻找</li>
</ul>
</li>
</ol>
</li>
<li>g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m已加锁</span></span><br><span class="line">    <span class="keyword">if</span> mp.locks != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;schedule: holding locks&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.lockedg有数据</span></span><br><span class="line">    <span class="keyword">if</span> mp.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// m让出p并挂起休眠，直到lockedg状态变为可运行，被唤醒后绑定一个p返回</span></span><br><span class="line">        stoplockedm()</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lockedg调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line">        execute(mp.lockedg.ptr(), <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cgo</span></span><br><span class="line">    <span class="keyword">if</span> mp.incgo &#123;</span><br><span class="line">        throw(<span class="string">&quot;schedule: in cgo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// 非抢占</span></span><br><span class="line">    pp.preempt = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋中（runq应该为空） and (runnext有数据（这是访问优化） or runq不为空)</span></span><br><span class="line">    <span class="comment">// 需要在checkTimers之前判断，因为其会把g放到runq</span></span><br><span class="line">    <span class="keyword">if</span> mp.spinning &amp;&amp; (pp.runnext != <span class="number">0</span> || pp.runqhead != pp.runqtail) &#123;</span><br><span class="line">        throw(<span class="string">&quot;schedule: spinning with local work&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找可运行的g</span></span><br><span class="line">    gp, inheritTime, tryWakeP := findRunnable()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dontfreezetheworld默认为0。debug时为1，此时若panic则不会打断所有g运行</span></span><br><span class="line">    <span class="keyword">if</span> debug.dontfreezetheworld &gt; <span class="number">0</span> &amp;&amp; freezing.Load() &#123;</span><br><span class="line">        lock(&amp;deadlock)</span><br><span class="line">        lock(&amp;deadlock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m自旋中（runq应该为空）</span></span><br><span class="line">    <span class="keyword">if</span> mp.spinning &#123;</span><br><span class="line">        <span class="comment">// 重置m.spinning，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        resetspinning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC时只有sys类型的g允许运行</span></span><br><span class="line">    <span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="comment">// GC开始到标记结束这个过程只允许sys类型的g运行</span></span><br><span class="line">        <span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// GC运行中</span></span><br><span class="line">            <span class="comment">// 放进disable.runnable队列</span></span><br><span class="line">            sched.disable.runnable.pushBack(gp)</span><br><span class="line">            <span class="comment">// 计数器+1</span></span><br><span class="line">            sched.disable.n++</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有在g是GCworker或tracereader时才为true</span></span><br><span class="line">    <span class="keyword">if</span> tryWakeP &#123;</span><br><span class="line">        <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        wakep()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g.lockedm有数据</span></span><br><span class="line">    <span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 让出p给lockedm并唤醒，把当前m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">        startlockedm(gp)</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pprof相关</span></span><br><span class="line">    <span class="keyword">if</span> goroutineProfile.active &#123;</span><br><span class="line">        <span class="comment">// 记录Goroutine运行的采样数据</span></span><br><span class="line">        tryRecordGoroutineProfile(gp, <span class="literal">nil</span>, osyield)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m双向绑定</span></span><br><span class="line">    mp.curg = gp</span><br><span class="line">    gp.m = mp</span><br><span class="line">    <span class="comment">// 从_Grunnable状态改为_Grunning</span></span><br><span class="line">    casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">    <span class="comment">// 重置waitsince</span></span><br><span class="line">    gp.waitsince = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 非抢占</span></span><br><span class="line">    gp.preempt = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// stack.lo+928</span></span><br><span class="line">    gp.stackguard0 = gp.stack.lo + stackGuard</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否继承当前时间切片</span></span><br><span class="line">    <span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line">        <span class="comment">// 不继承，schedtick+=1</span></span><br><span class="line">        mp.p.ptr().schedtick++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m相关</span></span><br><span class="line">    hz := sched.profilehz</span><br><span class="line">    <span class="keyword">if</span> mp.profilehz != hz &#123;</span><br><span class="line">        <span class="comment">// 平台相关</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        setThreadCPUProfiler(hz)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，从 gp.sched 加载调度上下文，并执行</span></span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="findRunnable-寻找可运行的g"><a href="#findRunnable-寻找可运行的g" class="headerlink" title="findRunnable - 寻找可运行的g"></a>findRunnable - 寻找可运行的g</h3><p>逻辑比较复杂，大概如下</p>
<ol>
<li>如果遇到GC启动-STW，m释放p挂起休眠，被唤醒后重试</li>
<li>读取本地队列前尝试其他数据源<ol>
<li>在GC标志停止阶段，执行安全点函数<ul>
<li>如果所有的p都执行了安全点函数，则唤醒GC线程</li>
</ul>
</li>
<li>定时器p.timers检查<ul>
<li>清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行</li>
</ul>
</li>
<li>如果trace reader有g，返回该g</li>
<li>如果GC正在运行，从gcBgMarkWorkerPool获取一个g（dedicated&#x2F;fractional类型），符合条件则返回</li>
<li>每执行61次schedtick-调度，从全局队列获取一个g返回</li>
<li>符合条件则运行finalizer、cgo，不讨论</li>
</ol>
</li>
<li>本地队列不为空时，从本地队列拿一个g返回</li>
<li>全局队列不为空时，则拿走1&#x2F;gomaxprocs数量的g，返回第一个g</li>
<li>本地队列、全局队列都没有数据<ol>
<li>符合条件则执行netpoll轮询（非阻塞），把过期的g放入本地&#x2F;全局队列，返回第一个g</li>
<li>m自旋从其他p偷取g，成功返回第一个g，失败则回到开头重试</li>
<li>如果GC正在运行，从gcBgMarkWorkerPool获取一个g（idle类型），符合条件则返回</li>
<li>wasm相关，不讨论</li>
</ol>
</li>
<li>偷也没偷到，实在没事做，把p放回空闲队列，调度器加锁，double-check<ol>
<li>STW或GC标记停止阶段，返回开头重试</li>
<li>全局队列不为空，拿走1&#x2F;gomaxprocs数量的g，返回第一个g</li>
<li>检查到调度器通知一个m进入自旋，当前m选择自旋，返回开头重试</li>
<li>取消p与m的绑定，把p放回空闲队列<ul>
<li>如果m在自旋，取消自旋<ul>
<li>再次检查全局队列，如果全局队列不为空，拿走1&#x2F;gomaxprocs数量的g，返回第一个g</li>
<li>从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</li>
<li>尝试从空闲链表拿走一个p，成功则绑定m和p，返回开头重试</li>
<li>如果GC已启动且有空闲的标记g，获取p和g，绑定m和p，返回g</li>
</ul>
</li>
<li>符合条件则执行netpoll轮询（阻塞）<ul>
<li>从空闲链表拿一个p，把过期的g放入本地&#x2F;全局队列，有p则返回第一个g，无则回到开头重试</li>
</ul>
</li>
<li>如果netpoll已经被轮询，检查到有更早的过期时刻，则中断轮询</li>
</ul>
</li>
<li>把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回开头重试</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRunnable</span><span class="params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="type">bool</span>) &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// STW，当前p释放到空闲队列</span></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting.Load() &#123;</span><br><span class="line">        <span class="comment">// 更新p、调度器状态，把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">        gcstopm()</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC标记停止阶段需要执行safePointFn</span></span><br><span class="line">    <span class="keyword">if</span> pp.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 执行safePointFn，如果是最后一个p，则唤醒safePointNote</span></span><br><span class="line">        runSafePointFn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器p.timers检查</span></span><br><span class="line">    <span class="comment">// 清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行</span></span><br><span class="line">    now, pollUntil, _ := pp.timers.check(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trace相关</span></span><br><span class="line">    <span class="keyword">if</span> traceEnabled() || traceShuttingDown() &#123;</span><br><span class="line">        gp := traceReader()</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            trace := traceAcquire()</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">if</span> trace.ok() &#123;</span><br><span class="line">                trace.GoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">                traceRelease(trace)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动（gcStart时为true）</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 从gcBgMarkWorkerPool获取一个g，符合条件则返回</span></span><br><span class="line">        gp, tnow := gcController.findRunnableGCWorker(pp, now)</span><br><span class="line">        <span class="comment">// 拿到了</span></span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没拿到</span></span><br><span class="line">        now = tnow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从全局队列拿g</span></span><br><span class="line">    <span class="comment">// 每61个schedtick and 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> pp.schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 从全局队列获取一批p放到本地队列，返回第一个g</span></span><br><span class="line">        gp := globrunqget(pp, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 拿到了</span></span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没拿到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finalizer</span></span><br><span class="line">    <span class="keyword">if</span> fingStatus.Load()&amp;(fingWait|fingWake) == fingWait|fingWake &#123;</span><br><span class="line">        <span class="comment">// 尝试从fing拿走g</span></span><br><span class="line">        <span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 将g放到p.runq队列头部，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">            ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cgo，忽略</span></span><br><span class="line">    <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 汇编，执行cgo调用</span></span><br><span class="line">        asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地队列拿一个G</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，本地队列为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 从全局队列获取一批p放到本地队列，返回第一个g</span></span><br><span class="line">        gp := globrunqget(pp, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 拿到了</span></span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没拿到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，全局队列为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// netpoll相关</span></span><br><span class="line">    <span class="comment">// netpoll已初始化 and 挂起的g数量不为0 and 当前没有进行netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; netpollAnyWaiters() &amp;&amp; sched.lastpoll.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 平台相关</span></span><br><span class="line">        <span class="comment">// 执行epollWait检查，0-没有数据立即返回</span></span><br><span class="line">        <span class="keyword">if</span> list, delta := netpoll(<span class="number">0</span>); !list.empty() &#123;</span><br><span class="line">            <span class="comment">// G列表里拿一个</span></span><br><span class="line">            gp := list.pop()</span><br><span class="line">            <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">            netpollAdjustWaiters(delta)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，netpoll也没有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 满足条件的话，m自旋然后从其他p偷取g</span></span><br><span class="line">    <span class="comment">// m自旋中 or 双倍自旋m的数量没有超过忙碌中的p数量</span></span><br><span class="line">    <span class="keyword">if</span> mp.spinning || <span class="number">2</span>*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load() &#123;</span><br><span class="line">        <span class="comment">// m未自旋</span></span><br><span class="line">        <span class="keyword">if</span> !mp.spinning &#123;</span><br><span class="line">            <span class="comment">// 状态、计数器更新</span></span><br><span class="line">            <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">            mp.becomeSpinning()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从所有其他p偷取g</span></span><br><span class="line">        gp, inheritTime, tnow, w, newWork := stealWork(now)</span><br><span class="line">        <span class="comment">// 偷取成功</span></span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 偷取失败</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可能有新的timer或GC需要运行</span></span><br><span class="line">        <span class="keyword">if</span> newWork &#123;</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前时刻</span></span><br><span class="line">        now = tnow</span><br><span class="line">        <span class="comment">// w也是pollUntil</span></span><br><span class="line">        <span class="comment">// pollUntil = min(pollUntil, w)</span></span><br><span class="line">        <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">            pollUntil = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，没有找到G，没事做</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. GC已启动（gcStart时为true）</span></span><br><span class="line">    <span class="comment">// 2. 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）</span></span><br><span class="line">    <span class="comment">// 3. 空闲标记线程数量加1成功（未超限）</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(pp) &amp;&amp; gcController.addIdleMarkWorker() &#123;</span><br><span class="line">        <span class="comment">// 从gcBgMarkWorkerPool获取一个g</span></span><br><span class="line">        node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">        <span class="comment">// 有数据</span></span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// gcMarkWorkerMode=3</span></span><br><span class="line">            pp.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">            <span class="comment">// g</span></span><br><span class="line">            gp := node.gp.ptr()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 恢复状态，idleMarkWorkers计数器减1</span></span><br><span class="line">        gcController.removeIdleMarkWorker()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// beforeIdle只在wasm有返回数据</span></span><br><span class="line">    gp, otherReady := beforeIdle(now, pollUntil)</span><br><span class="line">    <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> otherReady &#123;</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，真的没任何事情做，把P放到idle</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取快照allp、idlepMask、timerpMask</span></span><br><span class="line">    allpSnapshot := allp <span class="comment">// 所有p</span></span><br><span class="line">    idlepMaskSnapshot := idlepMask <span class="comment">// 标记哪些P是空闲的</span></span><br><span class="line">    timerpMaskSnapshot := timerpMask <span class="comment">// 标记哪些P有timer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 以下有一部分是加锁后的double-check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// STW，当前p释放到空闲队列 or GC标记停止阶段需要执行safePointFn</span></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting.Load() || pp.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 从全局队列获取一批p放到本地队列，返回第一个g</span></span><br><span class="line">        gp := globrunqget(pp, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m未自旋 and 调度器通知让其中一个m让出p</span></span><br><span class="line">    <span class="keyword">if</span> !mp.spinning &amp;&amp; sched.needspinning.Load() == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 状态、计数器更新</span></span><br><span class="line">        <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">        mp.becomeSpinning()</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">    <span class="keyword">if</span> releasep() != pp &#123;</span><br><span class="line">        throw(<span class="string">&quot;findrunnable: wrong p&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把p放进空闲链表</span></span><br><span class="line">    now = pidleput(pp, now)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录，用于恢复状态</span></span><br><span class="line">    wasSpinning := mp.spinning</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m自旋中</span></span><br><span class="line">    <span class="keyword">if</span> mp.spinning &#123;</span><br><span class="line">        <span class="comment">// 重置spinning</span></span><br><span class="line">        mp.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 复原，nmspinning-=1</span></span><br><span class="line">        <span class="keyword">if</span> sched.nmspinning.Add(<span class="number">-1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 小于0，异常</span></span><br><span class="line">            throw(<span class="string">&quot;findrunnable: negative nmspinning&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 全局队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">            pp, _ := pidlegetSpinning(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 拿到p！</span></span><br><span class="line">            <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 从全局队列获取一批p放到本地队列，返回第一个g</span></span><br><span class="line">                gp := globrunqget(pp, <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 状态异常</span></span><br><span class="line">                <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;global runq empty with non-zero runqsize&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">                acquirep(pp)</span><br><span class="line">                <span class="comment">// 状态、计数器更新</span></span><br><span class="line">                <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">                mp.becomeSpinning()</span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局队列为空 or 没有拿到p</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要有一个p是忙碌的，从剩余空闲p中拿走一个（可能拿不到）</span></span><br><span class="line">        pp := checkRunqsNoP(allpSnapshot, idlepMaskSnapshot)</span><br><span class="line">        <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">            acquirep(pp)</span><br><span class="line">            <span class="comment">// 状态、计数器更新</span></span><br><span class="line">            <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">            mp.becomeSpinning()</span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果GC已启动且有空闲的标记g，获取p和g</span></span><br><span class="line">        pp, gp := checkIdleGCNoP()</span><br><span class="line">        <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">            acquirep(pp)</span><br><span class="line">            <span class="comment">// 状态、计数器更新</span></span><br><span class="line">            <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">            mp.becomeSpinning()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// gcMarkWorkerMode=3</span></span><br><span class="line">            pp.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后</span></span><br><span class="line">        <span class="comment">// 找到所有p中的最小pollUntil</span></span><br><span class="line">        pollUntil = checkTimersNoP(allpSnapshot, timerpMaskSnapshot, pollUntil)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// netpoll相关</span></span><br><span class="line">    <span class="comment">// netpoll已初始化 and (挂起的g数量不为0 or 过期时刻不为0) and 当前没有执行netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; (netpollAnyWaiters() || pollUntil != <span class="number">0</span>) &amp;&amp; sched.lastpoll.Swap(<span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 纪录pollUntil</span></span><br><span class="line">        sched.pollUntil.Store(pollUntil)</span><br><span class="line">        <span class="comment">// netpoll不能有p</span></span><br><span class="line">        <span class="keyword">if</span> mp.p != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;findrunnable: netpoll with p&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自旋在上面已经判断过了</span></span><br><span class="line">        <span class="keyword">if</span> mp.spinning &#123;</span><br><span class="line">            throw(<span class="string">&quot;findrunnable: netpoll with spinning&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞时长</span></span><br><span class="line">        <span class="comment">// -1为永久阻塞</span></span><br><span class="line">        delay := <span class="type">int64</span>(<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// 过期时刻不为0</span></span><br><span class="line">        <span class="keyword">if</span> pollUntil != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 当前时刻</span></span><br><span class="line">            <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">                now = nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 过期时刻到当前时刻的时长/时差</span></span><br><span class="line">            delay = pollUntil - now</span><br><span class="line">            <span class="comment">// 已过期</span></span><br><span class="line">            <span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 0为非阻塞</span></span><br><span class="line">                delay = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// faketime，忽略</span></span><br><span class="line">        <span class="keyword">if</span> faketime != <span class="number">0</span> &#123;</span><br><span class="line">            delay = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// netpoll轮询，根据delay判断是否要阻塞，获得G列表及数量</span></span><br><span class="line">        list, delta := netpoll(delay)</span><br><span class="line">        <span class="comment">// 重新读取当前时刻</span></span><br><span class="line">        now = nanotime()</span><br><span class="line">        <span class="comment">// 已经从netpoll回来，pollUntil重置为0</span></span><br><span class="line">        sched.pollUntil.Store(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 纪录上一次执行netpoll的时刻</span></span><br><span class="line">        sched.lastpoll.Store(now)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// faketime，忽略</span></span><br><span class="line">        <span class="keyword">if</span> faketime != <span class="number">0</span> &amp;&amp; list.empty() &#123;</span><br><span class="line">            stopm()</span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 从空闲链表拿一个p</span></span><br><span class="line">        pp, _ := pidleget(now)</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 没拿到p</span></span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">            netpollAdjustWaiters(delta)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">            acquirep(pp)</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            <span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">                <span class="comment">// G列表里拿一个</span></span><br><span class="line">                gp := list.pop()</span><br><span class="line">                <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">                injectglist(&amp;list)</span><br><span class="line">                <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">                netpollAdjustWaiters(delta)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">                casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 先前为自旋状态</span></span><br><span class="line">            <span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">                <span class="comment">// 状态、计数器更新</span></span><br><span class="line">                <span class="comment">// spinning=true nmspinning+=1 needspinning=0</span></span><br><span class="line">                mp.becomeSpinning()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> pollUntil != <span class="number">0</span> &amp;&amp; netpollinited() &#123; <span class="comment">// 说明正在执行netpoll轮询</span></span><br><span class="line">        pollerPollUntil := sched.pollUntil.Load()</span><br><span class="line">        <span class="comment">// 轮询完毕 or 有更早过期的事件</span></span><br><span class="line">        <span class="keyword">if</span> pollerPollUntil == <span class="number">0</span> || pollerPollUntil &gt; pollUntil &#123;</span><br><span class="line">            <span class="comment">// 中断netpoll轮询</span></span><br><span class="line">            netpollBreak()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">    stopm()</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试</span></span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里基本结束，下面是一些依赖的函数</p>
<h2 id="相关依赖函数"><a href="#相关依赖函数" class="headerlink" title="相关依赖函数"></a>相关依赖函数</h2><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>newproc、malg，不在重复</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p _panic</span><br><span class="line">    p.goexit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行defer</span></span><br><span class="line">    p.start(sys.GetCallerPC(), unsafe.Pointer(sys.GetCallerSP()))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fn, ok := p.nextDefer()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    goexit1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放回本地gFree，重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行goexit0函数</span></span><br><span class="line">    <span class="comment">// 将g放回本地gFree，重新寻找并运行可运行的g（永不返回）</span></span><br><span class="line">    mcall(goexit0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放回本地gFree，重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// g重置状态、取消与m的双向绑定后放到本地gFree，如果有locked的m，则切换到g0调度执行</span></span><br><span class="line">    gdestroy(gp)</span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g重置状态、取消与m的双向绑定后放到本地gFree，如果有locked的m，则切换到g0调度执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gdestroy</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// m</span></span><br><span class="line">    mp := getg().m</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Gdead</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计到maxStackScan，有p的话，先暂存到p</span></span><br><span class="line">    gcController.addScannableStack(pp, -<span class="type">int64</span>(gp.stack.hi-gp.stack.lo))</span><br><span class="line">    <span class="comment">// 判断g是否是sys类型，一般runtime.*的都是，除了少部分如runtime.main等</span></span><br><span class="line">    <span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// ngsys-=1</span></span><br><span class="line">        sched.ngsys.Add(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// g取消m绑定</span></span><br><span class="line">    gp.m = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 是否有lockedm</span></span><br><span class="line">    locked := gp.lockedm != <span class="number">0</span></span><br><span class="line">    <span class="comment">// locked字段重置</span></span><br><span class="line">    gp.lockedm = <span class="number">0</span></span><br><span class="line">    mp.lockedg = <span class="number">0</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    gp.preemptStop = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    gp.paniconfault = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    gp._defer = <span class="literal">nil</span></span><br><span class="line">    gp._panic = <span class="literal">nil</span></span><br><span class="line">    gp.writebuf = <span class="literal">nil</span></span><br><span class="line">    gp.waitreason = waitReasonZero</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    gp.labels = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 定时器</span></span><br><span class="line">    gp.timer = <span class="literal">nil</span></span><br><span class="line">    gp.syncGroup = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动（gcStart时为true） and 额度还有剩余</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 把g的额度累计到全局额度bgScanCredit</span></span><br><span class="line">        <span class="comment">// 转换参数</span></span><br><span class="line">        assistWorkPerByte := gcController.assistWorkPerByte.Load()</span><br><span class="line">        <span class="comment">// 字节转换成额度</span></span><br><span class="line">        scanCredit := <span class="type">int64</span>(assistWorkPerByte * <span class="type">float64</span>(gp.gcAssistBytes))</span><br><span class="line">        <span class="comment">// 累计到全局额度bgScanCredit</span></span><br><span class="line">        gcController.bgScanCredit.Add(scanCredit)</span><br><span class="line">        <span class="comment">// 重置为0</span></span><br><span class="line">        gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wasm</span></span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 把g放到本地gFree</span></span><br><span class="line">        gfput(pp, gp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有locked的m and lockedInt计数器不为0</span></span><br><span class="line">    <span class="keyword">if</span> locked &amp;&amp; mp.lockedInt != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: mp.lockedInt = &quot;</span>, mp.lockedInt, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> mp.isextra &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime.Goexit called in a thread that was not created by the Go runtime&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        throw(<span class="string">&quot;exited a goroutine internally locked to the OS thread&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把g放到本地gFree</span></span><br><span class="line">    gfput(pp, gp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有locked的m</span></span><br><span class="line">    <span class="keyword">if</span> locked &#123;</span><br><span class="line">        <span class="comment">// 非plan9，返回mstart释放p并退出线程</span></span><br><span class="line">        <span class="keyword">if</span> GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 汇编，从 g0.sched 加载调度上下文，并执行</span></span><br><span class="line">            gogo(&amp;mp.g0.sched)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// plan9，清零</span></span><br><span class="line">            mp.lockedExt = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gFree-空闲链表"><a href="#gFree-空闲链表" class="headerlink" title="gFree - 空闲链表"></a>gFree - 空闲链表</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把g放到本地gFree，如果gFree数量超过64，只保留32个g，剩下的放到全局gFree</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gfput</span><span class="params">(pp *p, gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态，判断是否是_Gdead</span></span><br><span class="line">    <span class="keyword">if</span> readgstatus(gp) != _Gdead &#123;</span><br><span class="line">        throw(<span class="string">&quot;gfput: bad status (not Gdead)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈大小</span></span><br><span class="line">    stksize := gp.stack.hi - gp.stack.lo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过2KB</span></span><br><span class="line">    <span class="keyword">if</span> stksize != <span class="type">uintptr</span>(startingStackSize) &#123;</span><br><span class="line">        <span class="comment">// 释放栈</span></span><br><span class="line">        stackfree(gp.stack)</span><br><span class="line">        gp.stack.lo = <span class="number">0</span></span><br><span class="line">        gp.stack.hi = <span class="number">0</span></span><br><span class="line">        gp.stackguard0 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到本地gFree</span></span><br><span class="line">    pp.gFree.push(gp)</span><br><span class="line">    <span class="comment">// 计数器+=1</span></span><br><span class="line">    pp.gFree.n++</span><br><span class="line">    <span class="comment">// 如果本地gFree数量超过64</span></span><br><span class="line">    <span class="keyword">if</span> pp.gFree.n &gt;= <span class="number">64</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            inc      <span class="type">int32</span></span><br><span class="line">            stackQ   gQueue</span><br><span class="line">            noStackQ gQueue</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 保留最多32个数据</span></span><br><span class="line">        <span class="keyword">for</span> pp.gFree.n &gt;= <span class="number">32</span> &#123;</span><br><span class="line">            <span class="comment">// g</span></span><br><span class="line">            gp := pp.gFree.pop()</span><br><span class="line">            <span class="comment">// 计数器-=1</span></span><br><span class="line">            pp.gFree.n--</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 未分配，无栈</span></span><br><span class="line">                noStackQ.push(gp)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有栈</span></span><br><span class="line">                stackQ.push(gp)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计数器+=1</span></span><br><span class="line">            inc++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全局gFree加锁</span></span><br><span class="line">        lock(&amp;sched.gFree.lock)</span><br><span class="line">        <span class="comment">// 无栈</span></span><br><span class="line">        sched.gFree.noStack.pushAll(noStackQ)</span><br><span class="line">        <span class="comment">// 有栈</span></span><br><span class="line">        sched.gFree.stack.pushAll(stackQ)</span><br><span class="line">        sched.gFree.n += inc</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.gFree.lock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从本地gFree获取一个g，如果本地gFree为空，从全局gFree一次性拿最多32个到本地</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gfget</span><span class="params">(pp *p)</span></span> *g &#123;</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 本地gFree列表为空 and 全局gFree列表不为空</span></span><br><span class="line">    <span class="keyword">if</span> pp.gFree.empty() &amp;&amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) &#123;</span><br><span class="line">        <span class="comment">// 全局gFree加锁</span></span><br><span class="line">        lock(&amp;sched.gFree.lock)</span><br><span class="line">        <span class="comment">// 填充32个数据</span></span><br><span class="line">        <span class="keyword">for</span> pp.gFree.n &lt; <span class="number">32</span> &#123;</span><br><span class="line">            <span class="comment">// 优先获取有栈的g</span></span><br><span class="line">            gp := sched.gFree.stack.pop()</span><br><span class="line">            <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 无栈的g</span></span><br><span class="line">                gp = sched.gFree.noStack.pop()</span><br><span class="line">                <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// 都没有数据</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计数器-=1</span></span><br><span class="line">            sched.gFree.n--</span><br><span class="line">            <span class="comment">// 放到本地gFree</span></span><br><span class="line">            pp.gFree.push(gp)</span><br><span class="line">            <span class="comment">// 计数器+=1</span></span><br><span class="line">            pp.gFree.n++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.gFree.lock)</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> retry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个g</span></span><br><span class="line">    gp := pp.gFree.pop()</span><br><span class="line">    <span class="comment">// 本地跟全局gFree都没有数据</span></span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器-=1</span></span><br><span class="line">    pp.gFree.n--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g有栈 and 栈大小超过2KB</span></span><br><span class="line">    <span class="keyword">if</span> gp.stack.lo != <span class="number">0</span> &amp;&amp; gp.stack.hi-gp.stack.lo != <span class="type">uintptr</span>(startingStackSize) &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 释放栈</span></span><br><span class="line">            stackfree(gp.stack)</span><br><span class="line">            gp.stack.lo = <span class="number">0</span></span><br><span class="line">            gp.stack.hi = <span class="number">0</span></span><br><span class="line">            gp.stackguard0 = <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g无栈</span></span><br><span class="line">    <span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 申请2KB的栈</span></span><br><span class="line">            gp.stack = stackalloc(startingStackSize)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// stackguard0（用于正常函数调用时检查）= stack.lo+928</span></span><br><span class="line">        gp.stackguard0 = gp.stack.lo + stackGuard</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把本地gFree数据迁移到全局gFree里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gfpurge</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        inc      <span class="type">int32</span></span><br><span class="line">        stackQ   gQueue</span><br><span class="line">        noStackQ gQueue</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 清空gFree</span></span><br><span class="line">    <span class="keyword">for</span> !pp.gFree.empty() &#123;</span><br><span class="line">        gp := pp.gFree.pop()</span><br><span class="line">        pp.gFree.n--</span><br><span class="line">        <span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 无栈</span></span><br><span class="line">            noStackQ.push(gp)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有栈</span></span><br><span class="line">            stackQ.push(gp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        inc++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局gFree加锁</span></span><br><span class="line">    lock(&amp;sched.gFree.lock)</span><br><span class="line">    <span class="comment">// 无栈</span></span><br><span class="line">    sched.gFree.noStack.pushAll(noStackQ)</span><br><span class="line">    <span class="comment">// 有栈</span></span><br><span class="line">    sched.gFree.stack.pushAll(stackQ)</span><br><span class="line">    sched.gFree.n += inc</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.gFree.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="user-sys类型判断"><a href="#user-sys类型判断" class="headerlink" title="user&#x2F;sys类型判断"></a>user&#x2F;sys类型判断</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GC开始到标记结束这个过程只允许sys类型的g运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedEnabled</span><span class="params">(gp *g)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC时禁止user类型g</span></span><br><span class="line">    <span class="keyword">if</span> sched.disable.user &#123;</span><br><span class="line">        <span class="comment">// 判断g是否是sys类型，一般runtime.*的都是，除了少部分如runtime.main等</span></span><br><span class="line">        <span class="keyword">return</span> isSystemGoroutine(gp, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="status状态管理"><a href="#status状态管理" class="headerlink" title="status状态管理"></a>status状态管理</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除_Gscan标志位，如果旧状态不符合要求则抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casfrom_Gscanstatus</span><span class="params">(gp *g, oldval, newval <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    success := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧值</span></span><br><span class="line">    <span class="keyword">switch</span> oldval &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 默认抛出异常</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: casfrom_Gscanstatus bad oldval gp=&quot;</span>, gp, <span class="string">&quot;, oldval=&quot;</span>, hex(oldval), <span class="string">&quot;, newval=&quot;</span>, hex(newval), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">&quot;casfrom_Gscanstatus:top gp-&gt;status is not in scan state&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _Gscanrunnable,</span><br><span class="line">        _Gscanwaiting,</span><br><span class="line">        _Gscanrunning,</span><br><span class="line">        _Gscansyscall,</span><br><span class="line">        _Gscanpreempted:</span><br><span class="line">        <span class="comment">// 加上_Gscan标志标志位</span></span><br><span class="line">        <span class="keyword">if</span> newval == oldval&amp;^_Gscan &#123;</span><br><span class="line">            success = gp.atomicstatus.CompareAndSwap(oldval, newval)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 失败，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> !success &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: casfrom_Gscanstatus failed gp=&quot;</span>, gp, <span class="string">&quot;, oldval=&quot;</span>, hex(oldval), <span class="string">&quot;, newval=&quot;</span>, hex(newval), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">&quot;casfrom_Gscanstatus: gp-&gt;status is not in scan state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同releasem（staticlockranking默认为false）</span></span><br><span class="line">    releaseLockRankAndM(lockRankGscan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非_Gscan状态转换为带_Gscan状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">castogscanstatus</span><span class="params">(gp *g, oldval, newval <span class="type">uint32</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> oldval &#123;</span><br><span class="line">    <span class="keyword">case</span> _Grunnable,</span><br><span class="line">        _Grunning,</span><br><span class="line">        _Gwaiting,</span><br><span class="line">        _Gsyscall:</span><br><span class="line">        <span class="keyword">if</span> newval == oldval|_Gscan &#123;</span><br><span class="line">            r := gp.atomicstatus.CompareAndSwap(oldval, newval)</span><br><span class="line">            <span class="keyword">if</span> r &#123;</span><br><span class="line">                <span class="comment">// 同acquirem（staticlockranking默认为false）</span></span><br><span class="line">                acquireLockRankAndM(lockRankGscan)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;runtime: castogscanstatus oldval=&quot;</span>, hex(oldval), <span class="string">&quot; newval=&quot;</span>, hex(newval), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    throw(<span class="string">&quot;castogscanstatus&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not reached&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casgstatus</span><span class="params">(gp *g, oldval, newval <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 有_Gscan标志位 or 新旧数值相同</span></span><br><span class="line">    <span class="keyword">if</span> (oldval&amp;_Gscan != <span class="number">0</span>) || (newval&amp;_Gscan != <span class="number">0</span>) || oldval == newval &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// Call on the systemstack to prevent print and throw from counting</span></span><br><span class="line">            <span class="comment">// against the nosplit stack reservation.</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: casgstatus: oldval=&quot;</span>, hex(oldval), <span class="string">&quot; newval=&quot;</span>, hex(newval), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;casgstatus: bad incoming values&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    lockWithRankMayAcquire(<span class="literal">nil</span>, lockRankGscan)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟时间</span></span><br><span class="line">    <span class="keyword">const</span> yieldDelay = <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">    <span class="keyword">var</span> nextYield <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断尝试，直到GC完成</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; !gp.atomicstatus.CompareAndSwap(oldval, newval); i++ &#123;</span><br><span class="line">        <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">        <span class="keyword">if</span> oldval == _Gwaiting &amp;&amp; gp.atomicstatus.Load() == _Grunnable &#123;</span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;casgstatus: waiting for Gwaiting but is Grunnable&quot;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次尝试</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 延迟5us</span></span><br><span class="line">            nextYield = nanotime() + yieldDelay</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还没到指定时刻</span></span><br><span class="line">        <span class="keyword">if</span> nanotime() &lt; nextYield &#123;</span><br><span class="line">            <span class="comment">// 等待atomicstatus复原</span></span><br><span class="line">            <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span> &amp;&amp; gp.atomicstatus.Load() != oldval; x++ &#123;</span><br><span class="line">                <span class="comment">// 自旋，短暂的忙等待（纳秒级）</span></span><br><span class="line">                procyield(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已到指定时刻</span></span><br><span class="line">            <span class="comment">// 主动让出CPU，让OS选择其他线程运行（微秒级到毫秒级）</span></span><br><span class="line">            osyield()</span><br><span class="line">            <span class="comment">// 延迟2.5us</span></span><br><span class="line">            nextYield = nanotime() + yieldDelay/<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成状态修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            gp.syncGroup.changegstatus(gp, oldval, newval)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原状态为_Grunning</span></span><br><span class="line">    <span class="keyword">if</span> oldval == _Grunning &#123;</span><br><span class="line">        <span class="comment">// casgstatusAlwaysTrack默认为false or trackingSeq/8 == 0</span></span><br><span class="line">        <span class="keyword">if</span> casgstatusAlwaysTrack || gp.trackingSeq%gTrackingPeriod == <span class="number">0</span> &#123;</span><br><span class="line">            gp.tracking = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器（初始值随机）+=1</span></span><br><span class="line">        gp.trackingSeq++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !gp.tracking &#123;</span><br><span class="line">        <span class="comment">// tracking为false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tracking为true</span></span><br><span class="line">    <span class="comment">// 统计g位与_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计运行时长、阻塞（mutex）时长</span></span><br><span class="line">    <span class="keyword">switch</span> oldval &#123;</span><br><span class="line">    <span class="keyword">case</span> _Grunnable: <span class="comment">// 原状态为_Grunnable</span></span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="comment">// 计算g处于_Grunnable状态的时长</span></span><br><span class="line">        gp.runnableTime += now - gp.trackingStamp</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        gp.trackingStamp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> _Gwaiting: <span class="comment">// 原状态为_Gwaiting</span></span><br><span class="line">        <span class="comment">// 如果不是mutex导致的等待，不统计</span></span><br><span class="line">        <span class="keyword">if</span> !gp.waitreason.isMutexWait() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="comment">// 累计所有处于_Gwaiting状态的g的时长</span></span><br><span class="line">        sched.totalMutexWaitTime.Add((now - gp.trackingStamp) * gTrackingPeriod)</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        gp.trackingStamp = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> newval &#123;</span><br><span class="line">    <span class="keyword">case</span> _Gwaiting: <span class="comment">// 新状态为_Gwaiting</span></span><br><span class="line">        <span class="comment">// 如果不是mutex导致的等待，不统计</span></span><br><span class="line">        <span class="keyword">if</span> !gp.waitreason.isMutexWait() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="comment">// trackingStamp纪录当前时刻</span></span><br><span class="line">        gp.trackingStamp = now</span><br><span class="line">    <span class="keyword">case</span> _Grunnable: <span class="comment">// 新状态为_Grunnable</span></span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="comment">// trackingStamp纪录当前时刻</span></span><br><span class="line">        gp.trackingStamp = now</span><br><span class="line">    <span class="keyword">case</span> _Grunning: <span class="comment">// 新状态为_Grunning</span></span><br><span class="line">        <span class="comment">// 取消tracking跟踪统计</span></span><br><span class="line">        gp.tracking = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 累计所有处于_Grunnable状态的g的时长</span></span><br><span class="line">        sched.timeToRun.record(gp.runnableTime)</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        gp.runnableTime = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为_Gwaiting状态并设置waitreason</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casGToWaiting</span><span class="params">(gp *g, old <span class="type">uint32</span>, reason waitReason)</span></span> &#123;</span><br><span class="line">    gp.waitreason = reason</span><br><span class="line">    <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">    casgstatus(gp, old, _Gwaiting)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为_Gwaiting状态并设置waitreason</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casGToWaitingForGC</span><span class="params">(gp *g, old <span class="type">uint32</span>, reason waitReason)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !reason.isWaitingForGC() &#123;</span><br><span class="line">        throw(<span class="string">&quot;casGToWaitingForGC with non-isWaitingForGC wait reason&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    casGToWaiting(gp, old, reason)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从_Grunning状态改为_Gscanpreempted</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casGToPreemptScan</span><span class="params">(gp *g, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> old != _Grunning || <span class="built_in">new</span> != _Gscan|_Gpreempted &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad g transition&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同acquirem（staticlockranking默认为false）</span></span><br><span class="line">    acquireLockRankAndM(lockRankGscan)</span><br><span class="line">    <span class="comment">// 不停尝试切换状态</span></span><br><span class="line">    <span class="keyword">for</span> !gp.atomicstatus.CompareAndSwap(_Grunning, _Gscan|_Gpreempted) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从_Gpreempted状态改为_Gwaiting</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">casGFromPreempted</span><span class="params">(gp *g, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> old != _Gpreempted || <span class="built_in">new</span> != _Gwaiting &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad g transition&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waitreason = waitReasonPreempted</span><br><span class="line">    <span class="keyword">if</span> !gp.atomicstatus.CompareAndSwap(_Gpreempted, _Gwaiting) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg := gp.syncGroup; sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        sg.changegstatus(gp, _Gpreempted, _Gwaiting)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="allg-全局列表"><a href="#allg-全局列表" class="headerlink" title="allg-全局列表"></a>allg-全局列表</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把g放到allg列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allgadd</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态，如果是默认状态</span></span><br><span class="line">    <span class="keyword">if</span> readgstatus(gp) == _Gidle &#123;</span><br><span class="line">        throw(<span class="string">&quot;allgadd: bad status Gidle&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;allglock)</span><br><span class="line">    <span class="comment">// 放到allgs末尾</span></span><br><span class="line">    allgs = <span class="built_in">append</span>(allgs, gp)</span><br><span class="line">    <span class="comment">// 指针指向了过期的g，更新</span></span><br><span class="line">    <span class="keyword">if</span> &amp;allgs[<span class="number">0</span>] != allgptr &#123;</span><br><span class="line">        atomicstorep(unsafe.Pointer(&amp;allgptr), unsafe.Pointer(&amp;allgs[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新allglen</span></span><br><span class="line">    atomic.Storeuintptr(&amp;allglen, <span class="type">uintptr</span>(<span class="built_in">len</span>(allgs)))</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;allglock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回allg</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allGsSnapshot</span><span class="params">()</span></span> []*g &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;allglock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allgs[:<span class="built_in">len</span>(allgs):<span class="built_in">len</span>(allgs)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="machine"><a href="#machine" class="headerlink" title="machine"></a>machine</h3><h4 id="结构体验证"><a href="#结构体验证" class="headerlink" title="结构体验证"></a>结构体验证</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证m数据结构的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockVerifyMSize</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// m大小为1912，最后的size应为2040+8=2048</span></span><br><span class="line">    size := roundupsize(unsafe.Sizeof(m&#123;&#125;), <span class="literal">false</span>) + mallocHeaderSize</span><br><span class="line">    <span class="comment">// 2048&amp;1023 =&gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> size&amp;mutexMMask != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;M structure uses sizeclass &quot;</span>, size, <span class="string">&quot;/&quot;</span>, hex(size), <span class="string">&quot; bytes; &quot;</span>,</span><br><span class="line">            <span class="string">&quot;incompatible with mutex flag mask &quot;</span>, hex(mutexMMask), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;runtime.m memory alignment too small for spinbit mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清理freem链表，创建并初始化m，locked或cgo类型的m由模板线程延迟创建，其他类型则立即调用平台相关函数创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span></span>, pp *p, id <span class="type">int64</span>) &#123;</span><br><span class="line">    acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理freem链表，创建并初始化m</span></span><br><span class="line">    mp := allocm(pp, fn, id)</span><br><span class="line">    <span class="comment">// 将p存储到nextp</span></span><br><span class="line">    mp.nextp.set(pp)</span><br><span class="line">    <span class="comment">// 信号掩码设置</span></span><br><span class="line">    mp.sigmask = initSigmask</span><br><span class="line">    <span class="comment">// g、m不为nil and (有lockedm or cgo) and 非plan9</span></span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp != <span class="literal">nil</span> &amp;&amp; gp.m != <span class="literal">nil</span> &amp;&amp; (gp.m.lockedExt != <span class="number">0</span> || gp.m.incgo) &amp;&amp; GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock(&amp;newmHandoff.lock)</span><br><span class="line">        <span class="comment">// 未设置，异常</span></span><br><span class="line">        <span class="keyword">if</span> newmHandoff.haveTemplateThread == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;on a locked thread with no template thread&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// next指针，指向newm，m成为链表的头部</span></span><br><span class="line">        mp.schedlink = newmHandoff.newm</span><br><span class="line">        <span class="comment">// newm链表指针设置为m</span></span><br><span class="line">        newmHandoff.newm.set(mp)</span><br><span class="line">        <span class="comment">// 如果templateThread正在休眠</span></span><br><span class="line">        <span class="keyword">if</span> newmHandoff.waiting &#123;</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            newmHandoff.waiting = <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 唤醒m（m放在wake.key）</span></span><br><span class="line">            notewakeup(&amp;newmHandoff.wake)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;newmHandoff.lock)</span><br><span class="line">        releasem(getg().m)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用平台相关函数创建线程</span></span><br><span class="line">    newm1(mp)</span><br><span class="line">    releasem(getg().m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用平台相关函数创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    <span class="comment">// cgo</span></span><br><span class="line">    <span class="keyword">if</span> iscgo &#123;</span><br><span class="line">        <span class="keyword">var</span> ts cgothreadstart</span><br><span class="line">        <span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;_cgo_thread_start missing&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ts.g.set(mp.g0)</span><br><span class="line">        ts.tls = (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;mp.tls[<span class="number">0</span>]))</span><br><span class="line">        ts.fn = unsafe.Pointer(abi.FuncPCABI0(mstart))</span><br><span class="line">        <span class="comment">// Prevent process clone</span></span><br><span class="line">        execLock.rlock()</span><br><span class="line">        asmcgocall(_cgo_thread_start, unsafe.Pointer(&amp;ts))</span><br><span class="line">        execLock.runlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    execLock.rlock()</span><br><span class="line">    <span class="comment">// 调用平台相关函数创建线程</span></span><br><span class="line">    newosproc(mp)</span><br><span class="line">    execLock.runlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用平台相关函数创建线程</span></span><br><span class="line"><span class="comment">// src/runtime/os_linux.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    <span class="comment">// g0栈顶</span></span><br><span class="line">    stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;newosproc stk=&quot;</span>, stk, <span class="string">&quot; m=&quot;</span>, mp, <span class="string">&quot; g=&quot;</span>, mp.g0, <span class="string">&quot; clone=&quot;</span>, abi.FuncPCABI0(clone), <span class="string">&quot; id=&quot;</span>, mp.id, <span class="string">&quot; ostk=&quot;</span>, &amp;mp, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧的sigset</span></span><br><span class="line">    <span class="keyword">var</span> oset sigset</span><br><span class="line">    <span class="comment">// 用sigset_all设置，旧的放到oset</span></span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">    ret := retryOnEAGAIN(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">        <span class="comment">// 成功返回tid，失败返回errno</span></span><br><span class="line">        r := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(abi.FuncPCABI0(mstart)))</span><br><span class="line">        <span class="comment">// 成功返回，不需要tid</span></span><br><span class="line">        <span class="keyword">if</span> r &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回errno</span></span><br><span class="line">        <span class="keyword">return</span> -r</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 还原</span></span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程失败</span></span><br><span class="line">    <span class="keyword">if</span> ret != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: failed to create new OS thread (have &quot;</span>, mcount(), <span class="string">&quot; already; errno=&quot;</span>, ret, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ret == _EAGAIN &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: may need to increase max user processes (ulimit -u)&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        throw(<span class="string">&quot;newosproc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理freem链表，创建并初始化m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocm</span><span class="params">(pp *p, fn <span class="keyword">func</span>()</span></span>, id <span class="type">int64</span>) *m &#123;</span><br><span class="line">    allocmLock.rlock()</span><br><span class="line"></span><br><span class="line">    acquirem()</span><br><span class="line"></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 当前m没有p</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">        acquirep(pp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待释放的m链表不为空，只保留仍在使用的m</span></span><br><span class="line">    <span class="keyword">if</span> sched.freem != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 仍在使用的m链表</span></span><br><span class="line">        <span class="keyword">var</span> newList *m</span><br><span class="line">        <span class="comment">// 遍历整个freem链表</span></span><br><span class="line">        <span class="keyword">for</span> freem := sched.freem; freem != <span class="literal">nil</span>; &#123;</span><br><span class="line">            <span class="comment">// m.freeWait</span></span><br><span class="line">            wait := freem.freeWait.Load()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把所有状态为freeMWait的m连接成一个新链表</span></span><br><span class="line">            <span class="comment">// m.freeWait == 2 =&gt; 仍在使用，退出前的初始状态，线程还没退出</span></span><br><span class="line">            <span class="keyword">if</span> wait == freeMWait &#123;</span><br><span class="line">                <span class="comment">// 获取下一个freem</span></span><br><span class="line">                next := freem.freelink</span><br><span class="line">                <span class="comment">// 修改next指针（指向prev）</span></span><br><span class="line">                freem.freelink = newList</span><br><span class="line">                <span class="comment">// prev指针指向freem</span></span><br><span class="line">                newList = freem</span><br><span class="line">                <span class="comment">// 指向下一个freem</span></span><br><span class="line">                freem = next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面是m.freeWait != 2 的节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// m.freeWait == 0 =&gt; exitThread，栈可回收</span></span><br><span class="line">            <span class="keyword">if</span> wait == freeMStack &#123;</span><br><span class="line">                systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    <span class="comment">// 释放g0的栈</span></span><br><span class="line">                    stackfree(freem.g0.stack)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// m.freeWait == 1 =&gt; 线程退出最后一步</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一个freem</span></span><br><span class="line">            freem = freem.freelink</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换freem链表</span></span><br><span class="line">        sched.freem = newList</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建m</span></span><br><span class="line">    mp := <span class="built_in">new</span>(m)</span><br><span class="line">    <span class="comment">// 设置启动函数</span></span><br><span class="line">    mp.mstartfn = fn</span><br><span class="line">    <span class="comment">// m通用初始化</span></span><br><span class="line">    mcommoninit(mp, id)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个m分配一个g0</span></span><br><span class="line">    <span class="comment">// cgo or 栈由系统分配（linux为false，由go分配）</span></span><br><span class="line">    <span class="keyword">if</span> iscgo || mStackIsSystemAllocated() &#123;</span><br><span class="line">        <span class="comment">// 创建g、分配栈，无栈</span></span><br><span class="line">        mp.g0 = malg(<span class="number">-1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建g、分配栈，16KB的栈</span></span><br><span class="line">        mp.g0 = malg(<span class="number">16384</span> * sys.StackGuardMultiplier)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双向绑定</span></span><br><span class="line">    mp.g0.m = mp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟m当前p是同一个</span></span><br><span class="line">    <span class="keyword">if</span> pp == gp.m.p.ptr() &#123;</span><br><span class="line">        <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">        releasep()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    releasem(gp.m)</span><br><span class="line">    allocmLock.runlock()</span><br><span class="line">    <span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通用初始化"><a href="#通用初始化" class="headerlink" title="通用初始化"></a>通用初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m通用初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mcommoninit</span><span class="params">(mp *m, id <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果g不是g0</span></span><br><span class="line">    <span class="keyword">if</span> gp != gp.m.g0 &#123;</span><br><span class="line">        <span class="comment">// 获取当前调用栈信息，存入createstack数组</span></span><br><span class="line">        callers(<span class="number">1</span>, mp.createstack[:])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录m.id</span></span><br><span class="line">    <span class="keyword">if</span> id &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        mp.id = id</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有超过最大数量限制，则返回全局唯一id</span></span><br><span class="line">        mp.id = mReserveID()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化m的随机状态：m.chacha8、m.cheaprand</span></span><br><span class="line">    mrandinit(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.gsignal初始化（32KB栈的g，平台相关）</span></span><br><span class="line">    mpreinit(mp)</span><br><span class="line">    <span class="comment">// 初始化成功</span></span><br><span class="line">    <span class="keyword">if</span> mp.gsignal != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// stack.lo+928</span></span><br><span class="line">        mp.gsignal.stackguard1 = mp.gsignal.stack.lo + stackGuard</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next指针，跟allm串联起来成为新的allm</span></span><br><span class="line">    mp.alllink = allm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新allm指针</span></span><br><span class="line">    atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cgo相关</span></span><br><span class="line">    <span class="keyword">if</span> iscgo || GOOS == <span class="string">&quot;solaris&quot;</span> || GOOS == <span class="string">&quot;illumos&quot;</span> || GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">        mp.cgoCallers = <span class="built_in">new</span>(cgoCallers)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存剖析调用栈初始化</span></span><br><span class="line">    mProfStackInit(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号处理初始化"><a href="#信号处理初始化" class="headerlink" title="信号处理初始化"></a>信号处理初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m0信号处理初始化（平台相关），如果是cgo，生成一定数量的extraM</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstartm0</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// cgoHasExtraM默认为false</span></span><br><span class="line">    <span class="comment">// cgo或者是Windows</span></span><br><span class="line">    <span class="keyword">if</span> (iscgo || GOOS == <span class="string">&quot;windows&quot;</span>) &amp;&amp; !cgoHasExtraM &#123;</span><br><span class="line">        <span class="comment">// 设置为true</span></span><br><span class="line">        cgoHasExtraM = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 生成extraMWaiters数量的g、m并纪录在allg、extraM</span></span><br><span class="line">        newextram()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 信号处理初始化（平台相关）</span></span><br><span class="line">    initsig(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理初始化（平台相关）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initsig</span><span class="params">(preinit <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !preinit &#123;</span><br><span class="line">        <span class="comment">// preinit为false时</span></span><br><span class="line">        signalsOK = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态库（c-archive/c-shared） and </span></span><br><span class="line">    <span class="keyword">if</span> (isarchive || islibrary) &amp;&amp; !preinit &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 32个元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; _NSIG; i++ &#123;</span><br><span class="line">        t := &amp;sigtable[i]</span><br><span class="line">        <span class="comment">// 默认？ or 状态为_SigDefault（=16，第5位）</span></span><br><span class="line">        <span class="keyword">if</span> t.flags == <span class="number">0</span> || t.flags&amp;_SigDefault != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有其他G并行处理，不需要CAS</span></span><br><span class="line">        fwdSig[i] = getsig(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 安装go级别的函数</span></span><br><span class="line">        <span class="keyword">if</span> !sigInstallGoHandler(i) &#123;</span><br><span class="line">            <span class="comment">// 默认行为、忽略信号</span></span><br><span class="line">            <span class="keyword">if</span> fwdSig[i] != _SIG_DFL &amp;&amp; fwdSig[i] != _SIG_IGN &#123;</span><br><span class="line">                <span class="comment">// 注册备用信号栈</span></span><br><span class="line">                setsigstack(i)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> fwdSig[i] == _SIG_IGN &#123;</span><br><span class="line">                <span class="comment">// 初始化并检测哪些信号在进程启动时被忽略</span></span><br><span class="line">                sigInitIgnored(i)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组，32个元素</span></span><br><span class="line">        handlingSig[i] = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 安装信号</span></span><br><span class="line">        setsig(i, abi.FuncPCABIInternal(sighandler))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自增ID"><a href="#自增ID" class="headerlink" title="自增ID"></a>自增ID</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果没有超过最大数量限制，则返回全局唯一id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mReserveID</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否会溢出</span></span><br><span class="line">    <span class="keyword">if</span> sched.mnext+<span class="number">1</span> &lt; sched.mnext &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: thread ID overflow&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// id=当前mnext</span></span><br><span class="line">    id := sched.mnext</span><br><span class="line">    <span class="comment">// mnext+=1</span></span><br><span class="line">    sched.mnext++</span><br><span class="line">    <span class="comment">// 检查m的数量是否超过最大数量限制</span></span><br><span class="line">    checkmcount()</span><br><span class="line">    <span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数量限制检测"><a href="#数量限制检测" class="headerlink" title="数量限制检测"></a>数量限制检测</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查m的数量是否超过最大数量限制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkmcount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计总量 - 累计释放m数量 - 运行中的extraM数量 - 未运行的extraM数量</span></span><br><span class="line">    <span class="comment">// sched.mnext - sched.nmfreed - extraMInUse - extraMLength</span></span><br><span class="line">    count := mcount() - <span class="type">int32</span>(extraMInUse.Load()) - <span class="type">int32</span>(extraMLength.Load())</span><br><span class="line">    <span class="comment">// 超过最大数量限制</span></span><br><span class="line">    <span class="keyword">if</span> count &gt; sched.maxmcount &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: program exceeds &quot;</span>, sched.maxmcount, <span class="string">&quot;-thread limit\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;thread exhaustion&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="midle-全局空闲队列"><a href="#midle-全局空闲队列" class="headerlink" title="midle-全局空闲队列"></a>midle-全局空闲队列</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把m放到midle空闲链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mput</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把m放到midle链表头部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// next指针指向midle</span></span><br><span class="line">    mp.schedlink = sched.midle</span><br><span class="line">    <span class="comment">// mp替换midle</span></span><br><span class="line">    sched.midle.set(mp)</span><br><span class="line">    <span class="comment">// 计数器+1</span></span><br><span class="line">    sched.nmidle++</span><br><span class="line">    <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">    checkdead()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从midle空闲链表中拿一个m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mget</span><span class="params">()</span></span> *m &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// midle链表头部</span></span><br><span class="line">    mp := sched.midle.ptr()</span><br><span class="line">    <span class="comment">// 有空闲m</span></span><br><span class="line">    <span class="keyword">if</span> mp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// schedlink即为next指针</span></span><br><span class="line">        sched.midle = mp.schedlink</span><br><span class="line">        <span class="comment">// 计数器-1</span></span><br><span class="line">        sched.nmidle--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="m启动-停止"><a href="#m启动-停止" class="headerlink" title="m启动&#x2F;停止"></a>m启动&#x2F;停止</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(pp *p, spinning, lockheld <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要加锁，返回时再根据lockheld同步锁状态</span></span><br><span class="line">    <span class="keyword">if</span> !lockheld &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p为nil</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// spinning为true时，p不能为nil</span></span><br><span class="line">        <span class="keyword">if</span> spinning &#123;</span><br><span class="line">            throw(<span class="string">&quot;startm: P required for spinning=true&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// spinning为false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从空闲链表拿一个p</span></span><br><span class="line">        pp, _ = pidleget(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 没有拿到</span></span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 返回前同步锁状态</span></span><br><span class="line">            <span class="keyword">if</span> !lockheld &#123;</span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">            &#125;</span><br><span class="line">            releasem(mp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，p不可能为nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从midle空闲链表中拿一个m</span></span><br><span class="line">    nmp := mget()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有拿到m</span></span><br><span class="line">    <span class="keyword">if</span> nmp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有超过最大数量限制，则返回全局唯一id，避免死锁</span></span><br><span class="line">        id := mReserveID()</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步spinning状态</span></span><br><span class="line">        <span class="keyword">if</span> spinning &#123;</span><br><span class="line">            <span class="comment">// 该函数将m.spinning置为true</span></span><br><span class="line">            fn = mspinning</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理freem链表，创建并初始化m，locked或cgo类型的m由模板线程延迟创建，其他类型则立即调用平台相关函数创建线程</span></span><br><span class="line">        newm(fn, pp, id)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回前同步锁状态</span></span><br><span class="line">        <span class="keyword">if</span> lockheld &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到空闲的m了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回前同步锁状态</span></span><br><span class="line">    <span class="keyword">if</span> !lockheld &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 空闲m不能有spinning状态</span></span><br><span class="line">    <span class="keyword">if</span> nmp.spinning &#123;</span><br><span class="line">        throw(<span class="string">&quot;startm: m is spinning&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nextp不应该有数据</span></span><br><span class="line">    <span class="keyword">if</span> nmp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;startm: m has p&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// spinning意味着本地队列为空，这里数据不一致</span></span><br><span class="line">    <span class="keyword">if</span> spinning &amp;&amp; !runqempty(pp) &#123;</span><br><span class="line">        throw(<span class="string">&quot;startm: p has runnable gs&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步spinning状态</span></span><br><span class="line">    nmp.spinning = spinning</span><br><span class="line">    <span class="comment">// 不直接绑定p，而是绑定nextp</span></span><br><span class="line">    nmp.nextp.set(pp)</span><br><span class="line">    <span class="comment">// 唤醒m（m放在m.park.key）</span></span><br><span class="line">    notewakeup(&amp;nmp.park)</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m已加锁</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;stopm holding locks&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m没有让出p</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;stopm holding p&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自旋中</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.spinning &#123;</span><br><span class="line">        throw(<span class="string">&quot;stopm spinning&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 把m放到midle空闲链表</span></span><br><span class="line">    mput(gp.m)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m挂起休眠，等待唤醒</span></span><br><span class="line">    mPark()</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">    acquirep(gp.m.nextp.ptr())</span><br><span class="line">    <span class="comment">// 重置nextp</span></span><br><span class="line">    gp.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m线程退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mexit</span><span class="params">(osStack <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m0</span></span><br><span class="line">    <span class="keyword">if</span> mp == &amp;m0 &#123;</span><br><span class="line">        <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">        handoffp(releasep())</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 累计释放m数量+=1</span></span><br><span class="line">        sched.nmfreed++</span><br><span class="line">        <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">        checkdead()</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// m挂起休眠，等待唤醒</span></span><br><span class="line">        mPark()</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">        throw(<span class="string">&quot;locked m0 woke up&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通m（按道理，只有m0才会运行该函数才对）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞所有信号（平台相关）</span></span><br><span class="line">    sigblock(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 信号处理（平台相关）</span></span><br><span class="line">    unminit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gsignal</span></span><br><span class="line">    <span class="keyword">if</span> mp.gsignal != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 释放栈</span></span><br><span class="line">        stackfree(mp.gsignal.stack)</span><br><span class="line">        <span class="comment">// g被释放</span></span><br><span class="line">        mp.gsignal = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 遍历allm</span></span><br><span class="line">    <span class="keyword">for</span> pprev := &amp;allm; *pprev != <span class="literal">nil</span>; pprev = &amp;(*pprev).alllink &#123;</span><br><span class="line">        <span class="comment">// 找到当前m</span></span><br><span class="line">        <span class="keyword">if</span> *pprev == mp &#123;</span><br><span class="line">            <span class="comment">// 链接下一个m</span></span><br><span class="line">            *pprev = mp.alllink</span><br><span class="line">            <span class="keyword">goto</span> found</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    throw(<span class="string">&quot;m not found in allm&quot;</span>)</span><br><span class="line">found:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.freeWait == 2 =&gt; 仍在使用，退出前的初始状态，线程还没退出</span></span><br><span class="line">    mp.freeWait.Store(freeMWait)</span><br><span class="line">    <span class="comment">// m放到freem链表</span></span><br><span class="line">    mp.freelink = sched.freem</span><br><span class="line">    <span class="comment">// 替换freem链表</span></span><br><span class="line">    sched.freem = mp</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.ncgocall累加到ncgocall</span></span><br><span class="line">    atomic.Xadd64(&amp;ncgocall, <span class="type">int64</span>(mp.ncgocall))</span><br><span class="line">    <span class="comment">// 纪录总等待耗时</span></span><br><span class="line">    sched.totalRuntimeLockWaitTime.Add(mp.mLockProfile.waitTime.Load())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">    handoffp(releasep())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 累计释放m数量+=1</span></span><br><span class="line">    sched.nmfreed++</span><br><span class="line">    <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">    checkdead()</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// macOS/iOS</span></span><br><span class="line">    <span class="keyword">if</span> GOOS == <span class="string">&quot;darwin&quot;</span> || GOOS == <span class="string">&quot;ios&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> mp.signalPending.Load() != <span class="number">0</span> &#123;</span><br><span class="line">            pendingPreemptSignals.Add(<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源（平台相关）</span></span><br><span class="line">    mdestroy(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否由系统分配</span></span><br><span class="line">    <span class="keyword">if</span> osStack &#123;</span><br><span class="line">        <span class="comment">// m.freeWait == 1 =&gt; 标记线程退出最后一步</span></span><br><span class="line">        mp.freeWait.Store(freeMRef)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回mstart，由系统释放g0栈并终止线程</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接退出（linux下为汇编函数runtime·exitThread）</span></span><br><span class="line">    exitThread(&amp;mp.freeWait)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自旋等待"><a href="#自旋等待" class="headerlink" title="自旋等待"></a>自旋等待</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重置m.spinning，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetspinning</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 状态不一致</span></span><br><span class="line">    <span class="keyword">if</span> !gp.m.spinning &#123;</span><br><span class="line">        throw(<span class="string">&quot;resetspinning: not a spinning m&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置spinning</span></span><br><span class="line">    gp.m.spinning = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// nmspinning-=1</span></span><br><span class="line">    nmspinning := sched.nmspinning.Add(<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 数量小于0，异常</span></span><br><span class="line">    <span class="keyword">if</span> nmspinning &lt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;findrunnable: negative nmspinning&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    wakep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="processor"><a href="#processor" class="headerlink" title="processor"></a>processor</h3><h4 id="创建-容量调整"><a href="#创建-容量调整" class="headerlink" title="创建&#x2F;容量调整"></a>创建&#x2F;容量调整</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据数量n调整p容量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="type">int32</span>)</span></span> *p &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧值</span></span><br><span class="line">    old := gomaxprocs</span><br><span class="line">    <span class="keyword">if</span> old &lt; <span class="number">0</span> || nprocs &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;procresize: invalid arg&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 上一次调整的时刻</span></span><br><span class="line">    <span class="keyword">if</span> sched.procresizetime != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 所有核心的运行时长</span></span><br><span class="line">        sched.totaltime += <span class="type">int64</span>(old) * (now - sched.procresizetime)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新调整时刻</span></span><br><span class="line">    sched.procresizetime = now</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 32个p一组，每个p用一个bit表示状态</span></span><br><span class="line">    maskWords := (nprocs + <span class="number">31</span>) / <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整p</span></span><br><span class="line">    <span class="keyword">if</span> nprocs &gt; <span class="type">int32</span>(<span class="built_in">len</span>(allp)) &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock(&amp;allpLock)</span><br><span class="line">        <span class="comment">// 缩容</span></span><br><span class="line">        <span class="keyword">if</span> nprocs &lt;= <span class="type">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line">            allp = allp[:nprocs]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            <span class="comment">// 创建新的allp</span></span><br><span class="line">            nallp := <span class="built_in">make</span>([]*p, nprocs)</span><br><span class="line">            <span class="comment">// 复制旧的p</span></span><br><span class="line">            <span class="built_in">copy</span>(nallp, allp[:<span class="built_in">cap</span>(allp)])</span><br><span class="line">            <span class="comment">// 替换allp</span></span><br><span class="line">            allp = nallp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩容/不变</span></span><br><span class="line">        <span class="keyword">if</span> maskWords &lt;= <span class="type">int32</span>(<span class="built_in">cap</span>(idlepMask)) &#123;</span><br><span class="line">            idlepMask = idlepMask[:maskWords]</span><br><span class="line">            timerpMask = timerpMask[:maskWords]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 扩容，状态位数量=maskWords*32</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// idlepMask</span></span><br><span class="line">            nidlepMask := <span class="built_in">make</span>([]<span class="type">uint32</span>, maskWords)</span><br><span class="line">            <span class="built_in">copy</span>(nidlepMask, idlepMask)</span><br><span class="line">            idlepMask = nidlepMask</span><br><span class="line"></span><br><span class="line">            <span class="comment">// timerpMask</span></span><br><span class="line">            ntimerpMask := <span class="built_in">make</span>([]<span class="type">uint32</span>, maskWords)</span><br><span class="line">            <span class="built_in">copy</span>(ntimerpMask, timerpMask)</span><br><span class="line">            timerpMask = ntimerpMask</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;allpLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新创建的p要进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> i := old; i &lt; nprocs; i++ &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="comment">// 创建p</span></span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            pp = <span class="built_in">new</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        pp.init(i)</span><br><span class="line">        <span class="comment">// 纪录p指针</span></span><br><span class="line">        atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 当前p的id&lt;nprocs</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &amp;&amp; gp.m.p.ptr().id &lt; nprocs &#123;</span><br><span class="line">        <span class="comment">// 可以继续使用</span></span><br><span class="line">        gp.m.p.ptr().status = _Prunning</span><br><span class="line">        <span class="comment">// mcache清理</span></span><br><span class="line">        <span class="comment">// alloc列表mspan放到partial或full链表、tiny区域清空</span></span><br><span class="line">        <span class="comment">// 清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</span></span><br><span class="line">        gp.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁p前，先释放</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前p</span></span><br><span class="line">        <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 解除m绑定</span></span><br><span class="line">            gp.m.p.ptr().m = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// m解除p绑定</span></span><br><span class="line">        gp.m.p = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 拿第一个p</span></span><br><span class="line">        pp := allp[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 解除m绑定</span></span><br><span class="line">        pp.m = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 重置为默认状态_Pidle</span></span><br><span class="line">        pp.status = _Pidle</span><br><span class="line">        <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">        acquirep(pp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g.m.p还没绑定，暂时不需要mcache0</span></span><br><span class="line">    mcache0 = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩容后，allp销毁多余的p</span></span><br><span class="line">    <span class="keyword">for</span> i := nprocs; i &lt; old; i++ &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="comment">// p销毁</span></span><br><span class="line">        pp.destroy()</span><br><span class="line">        <span class="comment">// 还不能回收，因为可能有正在执行syscall的m在引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">int32</span>(<span class="built_in">len</span>(allp)) != nprocs &#123;</span><br><span class="line">        lock(&amp;allpLock)</span><br><span class="line">        allp = allp[:nprocs]</span><br><span class="line">        idlepMask = idlepMask[:maskWords]</span><br><span class="line">        timerpMask = timerpMask[:maskWords]</span><br><span class="line">        unlock(&amp;allpLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非空闲的p，链表</span></span><br><span class="line">    <span class="keyword">var</span> runnablePs *p</span><br><span class="line">    <span class="comment">// 从后往前扫描</span></span><br><span class="line">    <span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="comment">// p当前使用着</span></span><br><span class="line">        <span class="keyword">if</span> gp.m.p.ptr() == pp &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置为默认状态_Pidle</span></span><br><span class="line">        pp.status = _Pidle</span><br><span class="line">        <span class="comment">// 本地队列为空</span></span><br><span class="line">        <span class="keyword">if</span> runqempty(pp) &#123;</span><br><span class="line">            <span class="comment">// 把p放进空闲链表</span></span><br><span class="line">            pidleput(pp, now)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从midle空闲链表中拿一个m，放到p.m</span></span><br><span class="line">            pp.m.set(mget())</span><br><span class="line">            <span class="comment">// next指针设置</span></span><br><span class="line">            pp.link.set(runnablePs)</span><br><span class="line">            <span class="comment">// 替换链表头</span></span><br><span class="line">            runnablePs = pp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偷取顺序重置</span></span><br><span class="line">    stealOrder.reset(<span class="type">uint32</span>(nprocs))</span><br><span class="line">    <span class="comment">// 编译器检查用，判断是否是int32类型</span></span><br><span class="line">    <span class="keyword">var</span> int32p *<span class="type">int32</span> = &amp;gomaxprocs</span><br><span class="line">    <span class="comment">// 更新gomaxprocs</span></span><br><span class="line">    atomic.Store((*<span class="type">uint32</span>)(unsafe.Pointer(int32p)), <span class="type">uint32</span>(nprocs))</span><br><span class="line">    <span class="comment">// p的数量有改动</span></span><br><span class="line">    <span class="keyword">if</span> old != nprocs &#123;</span><br><span class="line">        <span class="comment">// 重置CPU限制器状态</span></span><br><span class="line">        gcCPULimiter.resetCapacity(now, nprocs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回非空闲的p</span></span><br><span class="line">    <span class="keyword">return</span> runnablePs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *p)</span></span> init(id <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 纪录p在allp内的索引</span></span><br><span class="line">    pp.id = id</span><br><span class="line">    <span class="comment">// 初始化，状态为_Pgcstop</span></span><br><span class="line">    pp.status = _Pgcstop</span><br><span class="line">    <span class="comment">// 0长度切片</span></span><br><span class="line">    pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 0长度切片</span></span><br><span class="line">    pp.deferpool = pp.deferpoolbuf[:<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 重置wbBuf的next、end指针</span></span><br><span class="line">    pp.wbBuf.reset()</span><br><span class="line">    <span class="comment">// mcache</span></span><br><span class="line">    <span class="keyword">if</span> pp.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是第一个p</span></span><br><span class="line">        <span class="keyword">if</span> id == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 全局变量未初始化</span></span><br><span class="line">            <span class="keyword">if</span> mcache0 == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;missing mcache?&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用全局变量</span></span><br><span class="line">            pp.mcache = mcache0</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 运行时创建</span></span><br><span class="line">            <span class="comment">// 从cachealloc分配器获取mcache</span></span><br><span class="line">            pp.mcache = allocmcache()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁初始化（定时器timers最小堆）</span></span><br><span class="line">    lockInit(&amp;pp.timers.mu, lockRankTimers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要p在使用，timerpMask就要标记该p</span></span><br><span class="line">    timerpMask.set(id)</span><br><span class="line">    <span class="comment">// p清理空闲标志，这个标记可以实时改</span></span><br><span class="line">    idlepMask.clear(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pidle-全局空闲链表"><a href="#pidle-全局空闲链表" class="headerlink" title="pidle-全局空闲链表"></a>pidle-全局空闲链表</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把p放进空闲链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidleput</span><span class="params">(pp *p, now <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> !runqempty(pp) &#123;</span><br><span class="line">        throw(<span class="string">&quot;pidleput: P has non-empty run queue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// timers最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> pp.timers.<span class="built_in">len</span>.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 清除标记</span></span><br><span class="line">        timerpMask.clear(pp.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记为空闲状态</span></span><br><span class="line">    idlepMask.set(pp.id)</span><br><span class="line">    <span class="comment">// 设置next指针</span></span><br><span class="line">    pp.link = sched.pidle</span><br><span class="line">    <span class="comment">// 放到链表头部</span></span><br><span class="line">    sched.pidle.set(pp)</span><br><span class="line">    <span class="comment">// 空闲p数量+1</span></span><br><span class="line">    sched.npidle.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// stamp存储limiterEventIdle和now</span></span><br><span class="line">    <span class="keyword">if</span> !pp.limiterEvent.start(limiterEventIdle, now) &#123;</span><br><span class="line">        throw(<span class="string">&quot;must be able to track idle limiter event&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从空闲链表拿一个p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidleget</span><span class="params">(now <span class="type">int64</span>)</span></span> (*p, <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲p链表</span></span><br><span class="line">    pp := sched.pidle.ptr()</span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时刻</span></span><br><span class="line">        <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">            now = nanotime()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// timer可能随时都会加进来，非空闲状态都要设置</span></span><br><span class="line">        timerpMask.set(pp.id)</span><br><span class="line">        <span class="comment">// 取消空闲标记</span></span><br><span class="line">        idlepMask.clear(pp.id)</span><br><span class="line">        <span class="comment">// 把下一个pp放到pidle（这是一个链表）</span></span><br><span class="line">        sched.pidle = pp.link</span><br><span class="line">        <span class="comment">// 空闲p数量-1</span></span><br><span class="line">        sched.npidle.Add(<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// 重置stamp字段，纪录耗时</span></span><br><span class="line">        pp.limiterEvent.stop(limiterEventIdle, now)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pp, now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidlegetSpinning</span><span class="params">(now <span class="type">int64</span>)</span></span> (*p, <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲链表拿一个p</span></span><br><span class="line">    pp, now := pidleget(now)</span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 通知所有m，让其中一个m丢弃p，进入自旋等待</span></span><br><span class="line">        sched.needspinning.Store(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pp, now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p销毁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *p)</span></span> destroy() &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迁移本地队列</span></span><br><span class="line">    <span class="comment">// 本地队列不为空</span></span><br><span class="line">    <span class="keyword">for</span> pp.runqhead != pp.runqtail &#123;</span><br><span class="line">        <span class="comment">// tail索引</span></span><br><span class="line">        pp.runqtail--</span><br><span class="line">        <span class="comment">// g</span></span><br><span class="line">        gp := pp.runq[pp.runqtail%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">        <span class="comment">// 把g放到全局队列头部</span></span><br><span class="line">        globrunqputhead(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// runnext不为空</span></span><br><span class="line">    <span class="keyword">if</span> pp.runnext != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 把g放到全局队列头部</span></span><br><span class="line">        globrunqputhead(pp.runnext.ptr())</span><br><span class="line">        <span class="comment">// 重置runnext</span></span><br><span class="line">        pp.runnext = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迁移timers</span></span><br><span class="line">    <span class="comment">// 把最小堆里的timer全部迁移到当前p</span></span><br><span class="line">    getg().m.p.ptr().timers.take(&amp;pp.timers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">    <span class="comment">// GC运行中</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">        <span class="comment">// 扫描p.wbBuf，把标记好的数据放在p.gcw，最后清空p.wbBuf</span></span><br><span class="line">        wbBufFlush1(pp)</span><br><span class="line">        <span class="comment">// wbuf1、wbuf2根据容量选择放入work.empty或work.full队列</span></span><br><span class="line">        pp.gcw.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空sudog</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pp.sudogbuf &#123;</span><br><span class="line">        pp.sudogbuf[i] = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置为0长度切片</span></span><br><span class="line">    pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    pp.pinnerCache = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 清空defer</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> pp.deferpoolbuf &#123;</span><br><span class="line">        pp.deferpoolbuf[j] = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置为0长度切片</span></span><br><span class="line">    pp.deferpool = pp.deferpoolbuf[:<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// mcache</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 遍历mspancache</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pp.mspancache.<span class="built_in">len</span>; i++ &#123;</span><br><span class="line">            <span class="comment">// 放回spanalloc的空闲链表</span></span><br><span class="line">            mheap_.spanalloc.free(unsafe.Pointer(pp.mspancache.buf[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清0</span></span><br><span class="line">        pp.mspancache.<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">        lock(&amp;mheap_.lock)</span><br><span class="line">        <span class="comment">// 清空pcache</span></span><br><span class="line">        pp.pcache.flush(&amp;mheap_.pages)</span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// mcache相关字段清空并放回cachealloc分配器空闲链表</span></span><br><span class="line">    freemcache(pp.mcache)</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    pp.mcache = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 把本地gFree数据迁移到全局gFree里</span></span><br><span class="line">    gfpurge(pp)</span><br><span class="line">    <span class="comment">// 重置为0</span></span><br><span class="line">    pp.gcAssistTime = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 标记为_Pdead</span></span><br><span class="line">    pp.status = _Pdead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runq-本地goroutine队列"><a href="#runq-本地goroutine队列" class="headerlink" title="runq-本地goroutine队列"></a>runq-本地goroutine队列</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把g放到本地队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqput</span><span class="params">(pp *p, gp *g, next <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// wasm（一般情况都有sysmon） and 放在队列首</span></span><br><span class="line">    <span class="keyword">if</span> !haveSysmon &amp;&amp; next &#123;</span><br><span class="line">        <span class="comment">// 放在队列尾</span></span><br><span class="line">        next = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般情况下raceenabled为false</span></span><br><span class="line">    <span class="comment">// raceenabled==true and 放在队列首 and 1/2的概率？</span></span><br><span class="line">    <span class="keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; randn(<span class="number">2</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 放在队列尾</span></span><br><span class="line">        next = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放在队列首</span></span><br><span class="line">    <span class="keyword">if</span> next &#123;</span><br><span class="line">    retryNext:</span><br><span class="line">        <span class="comment">// 纪录runnext</span></span><br><span class="line">        oldnext := pp.runnext</span><br><span class="line">        <span class="comment">// 尝试替换</span></span><br><span class="line">        <span class="keyword">if</span> !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;</span><br><span class="line">            <span class="comment">// 替换失败，重试</span></span><br><span class="line">            <span class="keyword">goto</span> retryNext</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换成功</span></span><br><span class="line">        <span class="comment">// 原runnext没有纪录，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> oldnext == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原runnext有G指针</span></span><br><span class="line">        <span class="comment">// 修改gp为原runnext，后面放在队列尾</span></span><br><span class="line">        gp = oldnext.ptr()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// head索引</span></span><br><span class="line">    h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire</span></span><br><span class="line">    <span class="comment">// tail索引</span></span><br><span class="line">    t := pp.runqtail</span><br><span class="line">    <span class="comment">// 没有超过runq的容量-256</span></span><br><span class="line">    <span class="keyword">if</span> t-h &lt; <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)) &#123;</span><br><span class="line">        <span class="comment">// 放在队列尾</span></span><br><span class="line">        pp.runq[t%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].set(gp)</span><br><span class="line">        <span class="comment">// 更新tail索引</span></span><br><span class="line">        atomic.StoreRel(&amp;pp.runqtail, t+<span class="number">1</span>) <span class="comment">// store-release</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过队列容量</span></span><br><span class="line">    <span class="comment">// 把一半的g放在调度器的全局队列</span></span><br><span class="line">    <span class="keyword">if</span> runqputslow(pp, gp, h, t) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 失败重试</span></span><br><span class="line">    <span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一半的g放在调度器的全局队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqputslow</span><span class="params">(pp *p, gp *g, h, t <span class="type">uint32</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// runq的一半+1个待入队的g</span></span><br><span class="line">    <span class="keyword">var</span> batch [<span class="built_in">len</span>(pp.runq)/<span class="number">2</span> + <span class="number">1</span>]*g</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总量</span></span><br><span class="line">    n := t - h</span><br><span class="line">    <span class="comment">// 一半</span></span><br><span class="line">    n = n / <span class="number">2</span></span><br><span class="line">    <span class="comment">// runq未满，异常</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)/<span class="number">2</span>) &#123;</span><br><span class="line">        throw(<span class="string">&quot;runqputslow: queue is not full&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿走一半的g</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        batch[i] = pp.runq[(h+i)%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新head索引</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <span class="comment">// cas-release</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 待入队的g放在尾部</span></span><br><span class="line">    batch[n] = gp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果raceenabled为true，忽略</span></span><br><span class="line">    <span class="keyword">if</span> randomizeScheduler &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">1</span>); i &lt;= n; i++ &#123;</span><br><span class="line">            j := cheaprandn(i + <span class="number">1</span>)</span><br><span class="line">            batch[i], batch[j] = batch[j], batch[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把这部份g链接起来作为一个链表</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        batch[i].schedlink.set(batch[i+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成gQueue类型</span></span><br><span class="line">    <span class="keyword">var</span> q gQueue</span><br><span class="line">    q.head.set(batch[<span class="number">0</span>])</span><br><span class="line">    q.tail.set(batch[n])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 把一批g放到全局队列</span></span><br><span class="line">    globrunqputbatch(&amp;q, <span class="type">int32</span>(n+<span class="number">1</span>))</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一批g放到本地队列尾部，如果本地队列满了放到全局队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqputbatch</span><span class="params">(pp *p, q *gQueue, qsize <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// head索引</span></span><br><span class="line">    h := atomic.LoadAcq(&amp;pp.runqhead)</span><br><span class="line">    <span class="comment">// tail索引</span></span><br><span class="line">    t := pp.runqtail</span><br><span class="line">    <span class="comment">// 已入队g数量</span></span><br><span class="line">    n := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 没有超过runq的容量-256</span></span><br><span class="line">    <span class="keyword">for</span> !q.empty() &amp;&amp; t-h &lt; <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)) &#123;</span><br><span class="line">        <span class="comment">// 待入队链表首个g</span></span><br><span class="line">        gp := q.pop()</span><br><span class="line">        <span class="comment">// 放入runq</span></span><br><span class="line">        pp.runq[t%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].set(gp)</span><br><span class="line">        <span class="comment">// 索引/计数器更新</span></span><br><span class="line">        t++</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列可能已满</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余待入队g数量</span></span><br><span class="line">    qsize -= <span class="type">int</span>(n)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果raceenabled为true，忽略</span></span><br><span class="line">    <span class="keyword">if</span> randomizeScheduler &#123;</span><br><span class="line">        off := <span class="function"><span class="keyword">func</span><span class="params">(o <span class="type">uint32</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (pp.runqtail + o) % <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">1</span>); i &lt; n; i++ &#123;</span><br><span class="line">            j := cheaprandn(i + <span class="number">1</span>)</span><br><span class="line">            pp.runq[off(i)], pp.runq[off(j)] = pp.runq[off(j)], pp.runq[off(i)]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新tail索引</span></span><br><span class="line">    atomic.StoreRel(&amp;pp.runqtail, t)</span><br><span class="line">    <span class="comment">// q队列不为空，也就是说还有g没有入队</span></span><br><span class="line">    <span class="keyword">if</span> !q.empty() &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 把一批g放到全局队列</span></span><br><span class="line">        globrunqputbatch(q, <span class="type">int32</span>(qsize))</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从p的runq拿一个g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqget</span><span class="params">(pp *p)</span></span> (gp *g, inheritTime <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// runnext有数据，直接返回</span></span><br><span class="line">    next := pp.runnext</span><br><span class="line">    <span class="comment">// runnext不为0 and 原子替换出runnext</span></span><br><span class="line">    <span class="keyword">if</span> next != <span class="number">0</span> &amp;&amp; pp.runnext.cas(next, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功拿到runnext</span></span><br><span class="line">        <span class="keyword">return</span> next.ptr(), <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// head索引</span></span><br><span class="line">        h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire</span></span><br><span class="line">        <span class="comment">// tail索引</span></span><br><span class="line">        t := pp.runqtail</span><br><span class="line">        <span class="comment">// 队列为空</span></span><br><span class="line">        <span class="keyword">if</span> t == h &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿队列第一个</span></span><br><span class="line">        gp := pp.runq[h%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">        <span class="comment">// 更新head索引</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+<span class="number">1</span>) &#123; <span class="comment">// cas-release</span></span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽走p本地队列所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqdrain</span><span class="params">(pp *p)</span></span> (drainQ gQueue, n <span class="type">uint32</span>) &#123;</span><br><span class="line">    <span class="comment">// 原runnext</span></span><br><span class="line">    oldNext := pp.runnext</span><br><span class="line">    <span class="comment">// double-check and 原子替换出runnext</span></span><br><span class="line">    <span class="keyword">if</span> oldNext != <span class="number">0</span> &amp;&amp; pp.runnext.cas(oldNext, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 放进队列</span></span><br><span class="line">        drainQ.pushBack(oldNext.ptr())</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// head索引</span></span><br><span class="line">    h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire</span></span><br><span class="line">    <span class="comment">// tail索引</span></span><br><span class="line">    t := pp.runqtail</span><br><span class="line">    <span class="comment">// 本地队列数据量</span></span><br><span class="line">    qn := t - h</span><br><span class="line">    <span class="comment">// 本地队列为空</span></span><br><span class="line">    <span class="keyword">if</span> qn == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据不一致</span></span><br><span class="line">    <span class="keyword">if</span> qn &gt; <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)) &#123;</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> retry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先更新索引，因为可能会跟runqsteal并行运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新head索引</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+qn) &#123; <span class="comment">// cas-release</span></span><br><span class="line">        <span class="comment">// 失败重试</span></span><br><span class="line">        <span class="keyword">goto</span> retry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有g放进drainQ队列</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; qn; i++ &#123;</span><br><span class="line">        gp := pp.runq[(h+i)%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">        drainQ.pushBack(gp)</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定p的本地队列偷走一半g</span></span><br><span class="line"><span class="comment">// pp是其他p</span></span><br><span class="line"><span class="comment">// batch是当前p的runq指针</span></span><br><span class="line"><span class="comment">// batchHead是当前p的runq的尾索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqgrab</span><span class="params">(pp *p, batch *[256]guintptr, batchHead <span class="type">uint32</span>, stealRunNextG <span class="type">bool</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// head索引</span></span><br><span class="line">        h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire</span></span><br><span class="line">        <span class="comment">// tail索引</span></span><br><span class="line">        t := atomic.LoadAcq(&amp;pp.runqtail) <span class="comment">// load-acquire</span></span><br><span class="line">        <span class="comment">// 总量</span></span><br><span class="line">        n := t - h</span><br><span class="line">        <span class="comment">// 一半</span></span><br><span class="line">        n = n - n/<span class="number">2</span></span><br><span class="line">        <span class="comment">// runq为空</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果需要把pp.runnext偷走</span></span><br><span class="line">            <span class="keyword">if</span> stealRunNextG &#123;</span><br><span class="line">                <span class="comment">// pp.runnext有数据</span></span><br><span class="line">                <span class="keyword">if</span> next := pp.runnext; next != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// p的状态为_Prunning</span></span><br><span class="line">                    <span class="keyword">if</span> pp.status == _Prunning &#123;</span><br><span class="line">                        <span class="comment">// 睡眠3us，确保当前g还在忙碌，没空执行runnext</span></span><br><span class="line">                        <span class="comment">// osHasLowResTimer一般为false</span></span><br><span class="line">                        <span class="keyword">if</span> !osHasLowResTimer &#123;</span><br><span class="line">                            usleep(<span class="number">3</span>)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 其他平台的定时器的颗粒度是1-15ms，太大了，不适合</span></span><br><span class="line">                            <span class="comment">// 主动让出CPU，让OS选择其他线程运行（微秒级到毫秒级）</span></span><br><span class="line">                            osyield()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原子替换出runnext</span></span><br><span class="line">                    <span class="keyword">if</span> !pp.runnext.cas(next, <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 替换失败，重试</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 只偷走runnext</span></span><br><span class="line">                    batch[batchHead%<span class="type">uint32</span>(<span class="built_in">len</span>(batch))] = next</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不需要偷走runnext，返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// runq不为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据前后不一致</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿走一半的g</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">            <span class="comment">// g</span></span><br><span class="line">            g := pp.runq[(h+i)%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))]</span><br><span class="line">            <span class="comment">// 放到当前p.runq</span></span><br><span class="line">            batch[(batchHead+i)%<span class="type">uint32</span>(<span class="built_in">len</span>(batch))] = g</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新head索引</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <span class="comment">// cas-release</span></span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从p2的runq偷走一半的g放到p的runq，最后返回一个g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqsteal</span><span class="params">(pp, p2 *p, stealRunNextG <span class="type">bool</span>)</span></span> *g &#123;</span><br><span class="line">    <span class="comment">// tail索引</span></span><br><span class="line">    t := pp.runqtail</span><br><span class="line">    <span class="comment">// 从p2的本地队列偷走一半的g</span></span><br><span class="line">    n := runqgrab(p2, &amp;pp.runq, t, stealRunNextG)</span><br><span class="line">    <span class="comment">// 没偷到</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [0,n)</span></span><br><span class="line">    n--</span><br><span class="line">    <span class="comment">// 拿最后一个g</span></span><br><span class="line">    gp := pp.runq[(t+n)%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">    <span class="comment">// 总共才偷到一个g</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偷到多个g的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// head索引</span></span><br><span class="line">    h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire</span></span><br><span class="line">    <span class="comment">// 超过队列容量，异常</span></span><br><span class="line">    <span class="keyword">if</span> t-h+n &gt;= <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)) &#123;</span><br><span class="line">        throw(<span class="string">&quot;runqsteal: runq overflow&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新tail索引</span></span><br><span class="line">    atomic.StoreRel(&amp;pp.runqtail, t+n) <span class="comment">// store-release</span></span><br><span class="line">    <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调度器相关"><a href="#调度器相关" class="headerlink" title="调度器相关"></a>调度器相关</h3><h4 id="g-m挂起、唤醒"><a href="#g-m挂起、唤醒" class="headerlink" title="g&#x2F;m挂起、唤醒"></a>g&#x2F;m挂起、唤醒</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同协程yield关键字，当前g让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 该函数只在wasm有效</span></span><br><span class="line">    checkTimeouts()</span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行gosched_m函数</span></span><br><span class="line">    <span class="comment">// 当前g、m解除绑定，g交给其他空闲m执行，当前m重新寻找并运行可运行的g</span></span><br><span class="line">    mcall(gosched_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前g、m解除绑定，g交给其他空闲m执行，当前m重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gosched_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 非抢占</span></span><br><span class="line">    <span class="comment">// 当前g、m解除绑定，g交给其他空闲m执行，当前m重新寻找并运行可运行的g</span></span><br><span class="line">    goschedImpl(gp, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前g、m解除绑定，g交给其他空闲m执行，当前m重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g, preempted <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态</span></span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="comment">// 异常，_Grunning位未设置</span></span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">&quot;bad g status&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Grunnable</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 把g放到全局队列尾部</span></span><br><span class="line">    globrunqput(gp)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtime已执行初始化，允许newproc创建运行M</span></span><br><span class="line">    <span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">        <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        wakep()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前g让出CPU，g0执行调度运行其他g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span></span> <span class="type">bool</span>, lock unsafe.Pointer, reason waitReason, traceReason traceBlockReason, traceskip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 非time.Sleep</span></span><br><span class="line">    <span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">        <span class="comment">// 该函数只在wasm有效</span></span><br><span class="line">        checkTimeouts()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    gp := mp.curg</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态</span></span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="comment">// 异常，_Grunning位未设置</span></span><br><span class="line">    <span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">        throw(<span class="string">&quot;gopark: bad g status&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 纪录解锁函数、参数等信息</span></span><br><span class="line">    mp.waitlock = lock</span><br><span class="line">    mp.waitunlockf = unlockf</span><br><span class="line">    gp.waitreason = reason</span><br><span class="line">    mp.waitTraceBlockReason = traceReason</span><br><span class="line">    mp.waitTraceSkip = traceskip</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行park_m函数</span></span><br><span class="line">    mcall(park_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放到本地队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goready</span><span class="params">(gp *g, traceskip <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 将g放到p.runq队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        <span class="comment">// 放到队列头部</span></span><br><span class="line">        ready(gp, traceskip, <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放到p.runq队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ready</span><span class="params">(gp *g, traceskip <span class="type">int</span>, next <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态</span></span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 预期状态是_Gwaiting，异常</span></span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Gwaiting &#123;</span><br><span class="line">        <span class="comment">// 打印g状态</span></span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">&quot;bad g-&gt;status in ready&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把g放到本地队列，根据next判断放在首尾</span></span><br><span class="line">    runqput(mp.p.ptr(), gp, next)</span><br><span class="line">    <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    wakep()</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放回本地队列尾部，重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goyield</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 该函数只在wasm有效</span></span><br><span class="line">    checkTimeouts()</span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行goyield_m函数</span></span><br><span class="line">    <span class="comment">// 将g放回本地队列尾部，重新寻找并运行可运行的g</span></span><br><span class="line">    mcall(goyield_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将g放回本地队列尾部，重新寻找并运行可运行的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goyield_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Grunnable</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line">    <span class="comment">// 把g放到本地队列尾部</span></span><br><span class="line">    runqput(pp, gp, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m挂起休眠，等待唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mPark</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// semaphore，只有g0可以执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起休眠（m放在m.park.key），标记blocked为true</span></span><br><span class="line">    notesleep(&amp;gp.m.park)</span><br><span class="line">    <span class="comment">// 被notewakeup唤醒，标记blocked为false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将m.park.key重置为0</span></span><br><span class="line">    noteclear(&amp;gp.m.park)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除绑定、修改状态、运行调度函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    sg := gp.syncGroup</span><br><span class="line">    <span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        sg.incActive()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Gwaiting</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁函数</span></span><br><span class="line">    <span class="keyword">if</span> fn := mp.waitunlockf; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 执行是否成功</span></span><br><span class="line">        ok := fn(gp, mp.waitlock)</span><br><span class="line">        <span class="comment">// 移除函数及其参数数据</span></span><br><span class="line">        mp.waitunlockf = <span class="literal">nil</span></span><br><span class="line">        mp.waitlock = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="comment">// 测试，忽略</span></span><br><span class="line">            <span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">                sg.decActive()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line">            execute(gp, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        sg.decActive()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g、m解除绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dropg</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    setMNoWB(&amp;gp.m.curg.m, <span class="literal">nil</span>)</span><br><span class="line">    setGNoWB(&amp;gp.m.curg, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取p"><a href="#获取p" class="headerlink" title="获取p"></a>获取p</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 期望nmspinning为0，且nmspinning+=1成功</span></span><br><span class="line">    <span class="keyword">if</span> sched.nmspinning.Load() != <span class="number">0</span> || !sched.nmspinning.CompareAndSwap(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时nmspinning=1</span></span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pp *p</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">    pp, _ = pidlegetSpinning(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 没拿到</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 复原，nmspinning-=1</span></span><br><span class="line">        <span class="keyword">if</span> sched.nmspinning.Add(<span class="number">-1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 小于0，异常</span></span><br><span class="line">            throw(<span class="string">&quot;wakep: negative nmspinning&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">    startm(pp, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有一个p是忙碌的，从剩余空闲p中拿走一个（可能拿不到）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkRunqsNoP</span><span class="params">(allpSnapshot []*p, idlepMaskSnapshot pMask)</span></span> *p &#123;</span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> id, p2 := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">        <span class="comment">// p2忙碌中 and p2的本地队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> !idlepMaskSnapshot.read(<span class="type">uint32</span>(id)) &amp;&amp; !runqempty(p2) &#123;</span><br><span class="line">            <span class="comment">// 调度器加锁</span></span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">            pp, _ := pidlegetSpinning(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 没拿到p</span></span><br><span class="line">            <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 剩下的p也不用找了</span></span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了</span></span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">return</span> pp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的p都处于默认空闲状态或者runq为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到所有p中的最小pollUntil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkTimersNoP</span><span class="params">(allpSnapshot []*p, timerpMaskSnapshot pMask, pollUntil <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> id, p2 := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">        <span class="comment">// p2可能有timer</span></span><br><span class="line">        <span class="keyword">if</span> timerpMaskSnapshot.read(<span class="type">uint32</span>(id)) &#123;</span><br><span class="line">            <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">            w := p2.timers.wakeTime()</span><br><span class="line">            <span class="comment">// w也是pollUntil</span></span><br><span class="line">            <span class="comment">// pollUntil = min(pollUntil, w)</span></span><br><span class="line">            <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">                pollUntil = w</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有p中的最小值</span></span><br><span class="line">    <span class="keyword">return</span> pollUntil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果GC已启动且有空闲的标记g，获取p和g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkIdleGCNoP</span><span class="params">()</span></span> (*p, *g) &#123;</span><br><span class="line">    <span class="comment">// GC未启动/停止 or 空闲标记线程数量已经超过最大限制</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;gcBlackenEnabled) == <span class="number">0</span> || !gcController.needIdleMarkWorker() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）</span></span><br><span class="line">    <span class="keyword">if</span> !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 标记完毕</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">    pp, now := pidlegetSpinning(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 没拿到</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC未启动/停止 or 空闲标记线程数量加1失败</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> || !gcController.addIdleMarkWorker() &#123;</span><br><span class="line">        <span class="comment">// 把p放进空闲链表</span></span><br><span class="line">        pidleput(pp, now)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 把p放进空闲链表</span></span><br><span class="line">        pidleput(pp, now)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 恢复状态，idleMarkWorkers计数器减1</span></span><br><span class="line">        gcController.removeIdleMarkWorker()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pp, node.gp.ptr()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="偷取任务"><a href="#偷取任务" class="headerlink" title="偷取任务"></a>偷取任务</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试从所有其他p偷取g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stealWork</span><span class="params">(now <span class="type">int64</span>)</span></span> (gp *g, inheritTime <span class="type">bool</span>, rnow, pollUntil <span class="type">int64</span>, newWork <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有执行过timer</span></span><br><span class="line">    ranTimer := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多尝试4次</span></span><br><span class="line">    <span class="keyword">const</span> stealTries = <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; stealTries; i++ &#123;</span><br><span class="line">        <span class="comment">// 如果是最后一次，偷取timer或者runnext</span></span><br><span class="line">        stealTimersOrRunNextG := i == stealTries<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机选一个p</span></span><br><span class="line">        <span class="keyword">for</span> enum := stealOrder.start(cheaprand()); !enum.done(); enum.next() &#123;</span><br><span class="line">            <span class="comment">// STW，当前p释放到空闲队列</span></span><br><span class="line">            <span class="keyword">if</span> sched.gcwaiting.Load() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, now, pollUntil, <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p2</span></span><br><span class="line">            p2 := allp[enum.position()]</span><br><span class="line">            <span class="comment">// 同一个p</span></span><br><span class="line">            <span class="keyword">if</span> pp == p2 &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果需要偷取timer或者runnext and p可能有timer</span></span><br><span class="line">            <span class="keyword">if</span> stealTimersOrRunNextG &amp;&amp; timerpMask.read(enum.position()) &#123;</span><br><span class="line">                <span class="comment">// 定时器p.timers检查</span></span><br><span class="line">                <span class="comment">// 清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行</span></span><br><span class="line">                tnow, w, ran := p2.timers.check(now)</span><br><span class="line">                <span class="comment">// 当前时刻</span></span><br><span class="line">                now = tnow</span><br><span class="line">                <span class="comment">// w也是pollUntil</span></span><br><span class="line">                <span class="comment">// pollUntil = min(pollUntil, w)</span></span><br><span class="line">                <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">                    pollUntil = w</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果有执行过timer，有g被放到runq</span></span><br><span class="line">                <span class="keyword">if</span> ran &#123;</span><br><span class="line">                    <span class="comment">// 从p2的runq拿一个g</span></span><br><span class="line">                    <span class="keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="comment">// 成功</span></span><br><span class="line">                        <span class="comment">// 这里的ranTimer是不是应该改为true？</span></span><br><span class="line">                        <span class="keyword">return</span> gp, inheritTime, now, pollUntil, ranTimer</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 没拿到</span></span><br><span class="line">                    <span class="comment">// 标记，表示有执行过timer</span></span><br><span class="line">                    ranTimer = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非空闲状态，如果p2处于默认的空闲状态，则不处理</span></span><br><span class="line">            <span class="keyword">if</span> !idlepMask.read(enum.position()) &#123;</span><br><span class="line">                <span class="comment">// 从p2的runq偷走一半的g放到p的runq，最后返回一个g</span></span><br><span class="line">                <span class="keyword">if</span> gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// 偷到了</span></span><br><span class="line">                    <span class="keyword">return</span> gp, <span class="literal">false</span>, now, pollUntil, ranTimer</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, now, pollUntil, ranTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runq-全局队列"><a href="#runq-全局队列" class="headerlink" title="runq-全局队列"></a>runq-全局队列</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把g放到全局队列尾部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqput</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到全局队列末尾</span></span><br><span class="line">    sched.runq.pushBack(gp)</span><br><span class="line">    <span class="comment">// 计数器+1</span></span><br><span class="line">    sched.runqsize++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把g放到全局队列头部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqputhead</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到全局队列头部</span></span><br><span class="line">    sched.runq.push(gp)</span><br><span class="line">    <span class="comment">// 计数器+1</span></span><br><span class="line">    sched.runqsize++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一批g放到全局队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqputbatch</span><span class="params">(batch *gQueue, n <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把q2链表放到q链表末尾</span></span><br><span class="line">    sched.runq.pushBackAll(*batch)</span><br><span class="line">    <span class="comment">// 计数器+n</span></span><br><span class="line">    sched.runqsize += n</span><br><span class="line">    <span class="comment">// 数据清理</span></span><br><span class="line">    *batch = gQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从全局队列获取一批p放到本地队列，返回第一个g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqget</span><span class="params">(pp *p, max <span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局队列为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按p数量均分</span></span><br><span class="line">    n := sched.runqsize/gomaxprocs + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 边界处理</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; sched.runqsize &#123;</span><br><span class="line">        n = sched.runqsize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最多max个g</span></span><br><span class="line">    <span class="keyword">if</span> max &gt; <span class="number">0</span> &amp;&amp; n &gt; max &#123;</span><br><span class="line">        n = max</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最多128个g</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="type">int32</span>(<span class="built_in">len</span>(pp.runq))/<span class="number">2</span> &#123;</span><br><span class="line">        n = <span class="type">int32</span>(<span class="built_in">len</span>(pp.runq)) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器-n</span></span><br><span class="line">    sched.runqsize -= n</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿链表第一个g</span></span><br><span class="line">    gp := sched.runq.pop()</span><br><span class="line">    <span class="comment">// 总量-1</span></span><br><span class="line">    n--</span><br><span class="line">    <span class="comment">// 如果剩余总量不为0</span></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">        <span class="comment">// 一次拿一个g</span></span><br><span class="line">        gp1 := sched.runq.pop()</span><br><span class="line">        <span class="comment">// 把g放到本地队列尾部</span></span><br><span class="line">        runqput(pp, gp1, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回第一个g</span></span><br><span class="line">    <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectglist</span><span class="params">(glist *gList)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 为空，不处理</span></span><br><span class="line">    <span class="keyword">if</span> glist.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个g</span></span><br><span class="line">    head := glist.head.ptr()</span><br><span class="line">    <span class="keyword">var</span> tail *g</span><br><span class="line">    qsize := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到队列的尾部、计算数据量、g状态修改</span></span><br><span class="line">    <span class="keyword">for</span> gp := head; gp != <span class="literal">nil</span>; gp = gp.schedlink.ptr() &#123;</span><br><span class="line">        tail = gp</span><br><span class="line">        qsize++</span><br><span class="line">        <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gList转换为gQueue</span></span><br><span class="line">    <span class="keyword">var</span> q gQueue</span><br><span class="line">    q.head.set(head)</span><br><span class="line">    q.tail.set(tail)</span><br><span class="line">    *glist = gList&#123;&#125;</span><br><span class="line"></span><br><span class="line">    startIdle := <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            mp := acquirem()</span><br><span class="line">            <span class="comment">// 调度器加锁</span></span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">            pp, _ := pidlegetSpinning(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 没拿到p</span></span><br><span class="line">            <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁，返回</span></span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                releasem(mp)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">            startm(pp, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            releasem(mp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有p</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 把一批g放到全局队列</span></span><br><span class="line">        globrunqputbatch(&amp;q, <span class="type">int32</span>(qsize))</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 尝试唤醒m处理</span></span><br><span class="line">        startIdle(qsize)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲p数量</span></span><br><span class="line">    npidle := <span class="type">int</span>(sched.npidle.Load())</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        globq gQueue</span><br><span class="line">        n     <span class="type">int</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 拿一批最多与空闲p数量相等的g</span></span><br><span class="line">    <span class="keyword">for</span> n = <span class="number">0</span>; n &lt; npidle &amp;&amp; !q.empty(); n++ &#123;</span><br><span class="line">        g := q.pop()</span><br><span class="line">        globq.pushBack(g)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有空闲p</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 把上面这批g放到全局队列</span></span><br><span class="line">        globrunqputbatch(&amp;globq, <span class="type">int32</span>(n))</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 尝试唤醒m处理</span></span><br><span class="line">        startIdle(n)</span><br><span class="line">        <span class="comment">// 剩余g数量</span></span><br><span class="line">        qsize -= n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// q队列不为空，也就是说还有g没有入队</span></span><br><span class="line">    <span class="keyword">if</span> !q.empty() &#123;</span><br><span class="line">        <span class="comment">// 把一批g放到本地队列尾部，如果本地队列满了放到全局队列</span></span><br><span class="line">        runqputbatch(pp, &amp;q, qsize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    wakep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="g-m绑定、解绑"><a href="#g-m绑定、解绑" class="headerlink" title="g&#x2F;m绑定、解绑"></a>g&#x2F;m绑定、解绑</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计数器m.lockedInt+=1</span></span><br><span class="line">    getg().m.lockedInt++</span><br><span class="line">    dolockOSThread()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dolockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放在lockedg、lockedm，双向绑定</span></span><br><span class="line">    gp.m.lockedg.set(gp)</span><br><span class="line">    gp.lockedm.set(gp.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unlockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.lockedInt == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        systemstack(badunlockosthread)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器m.lockedInt-=1</span></span><br><span class="line">    gp.m.lockedInt--</span><br><span class="line">    <span class="comment">// 重置lockedg、lockedm</span></span><br><span class="line">    dounlockOSThread()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dounlockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 计数器m.lockedInt不为0，不处理</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.lockedInt != <span class="number">0</span> || gp.m.lockedExt != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    gp.m.lockedg = <span class="number">0</span></span><br><span class="line">    gp.lockedm = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让出p给lockedm并唤醒，把当前m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startlockedm</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// m</span></span><br><span class="line">    mp := gp.lockedm.ptr()</span><br><span class="line">    <span class="comment">// m跟当前g的m不一样</span></span><br><span class="line">    <span class="keyword">if</span> mp == getg().m &#123;</span><br><span class="line">        throw(<span class="string">&quot;startlockedm: locked to me&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nextp有数据</span></span><br><span class="line">    <span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;startlockedm: m has p&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 空闲的locked的m数量-=1</span></span><br><span class="line">    incidlelocked(<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">    pp := releasep()</span><br><span class="line">    <span class="comment">// nextp设置为p</span></span><br><span class="line">    mp.nextp.set(pp)</span><br><span class="line">    <span class="comment">// 唤醒m（m放在m.park.key）</span></span><br><span class="line">    notewakeup(&amp;mp.park)</span><br><span class="line">    <span class="comment">// 把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">    stopm()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m让出p并挂起休眠，直到lockedg状态变为可运行，被唤醒后绑定一个p返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stoplockedm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.lockedg为0（不为0才会走到这里） or g.lockedm不是当前m</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.lockedg == <span class="number">0</span> || gp.m.lockedg.ptr().lockedm.ptr() != gp.m &#123;</span><br><span class="line">        throw(<span class="string">&quot;stoplockedm: inconsistent locking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p不为空，把这个p给其他m</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">        pp := releasep()</span><br><span class="line">        <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">        handoffp(pp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复原，空闲的locked的m数量+=1，检查是否存在死锁</span></span><br><span class="line">    incidlelocked(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// m挂起休眠，等待唤醒</span></span><br><span class="line">    mPark()</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取locked的g.atomicstatus状态</span></span><br><span class="line">    status := readgstatus(gp.m.lockedg.ptr())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果状态不是_Grunnable，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunnable &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime:stoplockedm: lockedg (atomicstatus=&quot;</span>, status, <span class="string">&quot;) is not Grunnable or Gscanrunnable\n&quot;</span>)</span><br><span class="line">        dumpgstatus(gp.m.lockedg.ptr())</span><br><span class="line">        throw(<span class="string">&quot;stoplockedm: not runnable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">    acquirep(gp.m.nextp.ptr())</span><br><span class="line">    <span class="comment">// 重置nextp</span></span><br><span class="line">    gp.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲的locked的m数量调整</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incidlelocked</span><span class="params">(v <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.nmidlelocked += v</span><br><span class="line">    <span class="comment">// v为-1时加锁，为1时是解锁</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">        checkdead()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="m-p绑定、解绑"><a href="#m-p绑定、解绑" class="headerlink" title="m&#x2F;p绑定、解绑"></a>m&#x2F;p绑定、解绑</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquirep</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 绑定m和p</span></span><br><span class="line">    wirep(pp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启写屏障</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mcache清理</span></span><br><span class="line">    <span class="comment">// alloc列表mspan放到partial或full链表、tiny区域清空</span></span><br><span class="line">    <span class="comment">// 清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</span></span><br><span class="line">    pp.mcache.prepareForSweep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定m和p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wirep</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m已经跟其他p绑定</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;wirep: already in go&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p也有其他m绑定着 or p的状态不是默认的_Pidle</span></span><br><span class="line">    <span class="keyword">if</span> pp.m != <span class="number">0</span> || pp.status != _Pidle &#123;</span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            id := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> pp.m != <span class="number">0</span> &#123;</span><br><span class="line">                id = pp.m.ptr().id</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;wirep: p-&gt;m=&quot;</span>, pp.m, <span class="string">&quot;(&quot;</span>, id, <span class="string">&quot;) p-&gt;status=&quot;</span>, pp.status, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;wirep: invalid p state&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m.p绑定p</span></span><br><span class="line">    gp.m.p.set(pp)</span><br><span class="line">    <span class="comment">// p.m绑定m</span></span><br><span class="line">    pp.m.set(gp.m)</span><br><span class="line">    <span class="comment">// 从_Pidle状态改为_Prunning</span></span><br><span class="line">    pp.status = _Prunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消p与m的绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releasep</span><span class="params">()</span></span> *p &#123;</span><br><span class="line">    <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">    <span class="keyword">return</span> releasepNoTrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消p与m的绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releasepNoTrace</span><span class="params">()</span></span> *p &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g.m.p不为0才会走到这里</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;releasep: invalid arg&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line">    <span class="comment">// p.m不是当前m or p.status不是_Prunning</span></span><br><span class="line">    <span class="keyword">if</span> pp.m.ptr() != gp.m || pp.status != _Prunning &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;releasep: m=&quot;</span>, gp.m, <span class="string">&quot; m-&gt;p=&quot;</span>, gp.m.p.ptr(), <span class="string">&quot; p-&gt;m=&quot;</span>, hex(pp.m), <span class="string">&quot; p-&gt;status=&quot;</span>, pp.status, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;releasep: invalid p state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m.p取消绑定</span></span><br><span class="line">    gp.m.p = <span class="number">0</span></span><br><span class="line">    <span class="comment">// p.m取消绑定</span></span><br><span class="line">    pp.m = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 重置为默认状态_Pidle</span></span><br><span class="line">    pp.status = _Pidle</span><br><span class="line">    <span class="keyword">return</span> pp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoffp</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 本地队列不为空 or 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> !runqempty(pp) || sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">        startm(pp, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动（gcStart时为true） and 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(pp) &#123;</span><br><span class="line">        <span class="comment">// 还在标记</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">        startm(pp, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有任务可以执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋等待的m</span></span><br><span class="line">    <span class="keyword">if</span> sched.nmspinning.Load()+sched.npidle.Load() == <span class="number">0</span> &amp;&amp; sched.nmspinning.CompareAndSwap(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 重置，其他m不需要自旋让出p</span></span><br><span class="line">        sched.needspinning.Store(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">        startm(pp, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// STW，当前p释放到空闲队列</span></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting.Load() &#123;</span><br><span class="line">        <span class="comment">// 状态改为_Pgcstop</span></span><br><span class="line">        pp.status = _Pgcstop</span><br><span class="line">        <span class="comment">// 因为GC导致的暂停的时刻</span></span><br><span class="line">        pp.gcStopTime = nanotime()</span><br><span class="line">        <span class="comment">// 待_Pgcstop的p数量-1</span></span><br><span class="line">        sched.stopwait--</span><br><span class="line">        <span class="comment">// 所有p已_Pgcstop</span></span><br><span class="line">        <span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 唤醒m（m放在stopnote.key）执行GC</span></span><br><span class="line">            notewakeup(&amp;sched.stopnote)</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// GC标志需要执行safePointFn and 重置runSafePointFn成功</span></span><br><span class="line">    <span class="keyword">if</span> pp.runSafePointFn != <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;pp.runSafePointFn, <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行safePointFn</span></span><br><span class="line">        sched.safePointFn(pp)</span><br><span class="line">        <span class="comment">// 计数器safePointWait-=1（safePointWait=gomaxprocs-1）</span></span><br><span class="line">        sched.safePointWait--</span><br><span class="line">        <span class="comment">// 如果是最后一个p（其他p都已经执行了safePointFn）</span></span><br><span class="line">        <span class="keyword">if</span> sched.safePointWait == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 唤醒m（m放在safePointNote.key）</span></span><br><span class="line">            notewakeup(&amp;sched.safePointNote)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">        startm(pp, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p是最后一放入空闲队列的（其他p都在空闲队列） and 当前没有进行netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> sched.npidle.Load() == gomaxprocs<span class="number">-1</span> &amp;&amp; sched.lastpoll.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">        startm(pp, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p不是最后一个放进空闲队列的 or 正在执行netpoll轮询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">    when := pp.timers.wakeTime()</span><br><span class="line">    <span class="comment">// 把p放进空闲链表</span></span><br><span class="line">    pidleput(pp, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> when != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果正在轮询netpoll且有更早过期的事件，中断netpoll轮询。如果没有轮询netpoll，则从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        wakeNetPoller(when)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="netpoll"><a href="#netpoll" class="headerlink" title="netpoll"></a>netpoll</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果正在轮询netpoll且有更早过期的事件，中断netpoll轮询。如果没有轮询netpoll，则从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakeNetPoller</span><span class="params">(when <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 正在轮询netpoll中</span></span><br><span class="line">    <span class="keyword">if</span> sched.lastpoll.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        pollerPollUntil := sched.pollUntil.Load()</span><br><span class="line">        <span class="comment">// 轮询完毕 or 有更早过期的事件</span></span><br><span class="line">        <span class="keyword">if</span> pollerPollUntil == <span class="number">0</span> || pollerPollUntil &gt; when &#123;</span><br><span class="line">            <span class="comment">// 中断netpoll轮询</span></span><br><span class="line">            netpollBreak()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非plan9</span></span><br><span class="line">        <span class="keyword">if</span> GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">            wakep()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行safePointFn，如果是最后一个p，则唤醒safePointNote</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runSafePointFn</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置runSafePointFn</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;p.runSafePointFn, <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行safePointFn</span></span><br><span class="line">    sched.safePointFn(p)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 计数器safePointWait-=1（safePointWait=gomaxprocs-1）</span></span><br><span class="line">    sched.safePointWait--</span><br><span class="line">    <span class="comment">// 如果是最后一个p（其他p都已经执行了safePointFn）</span></span><br><span class="line">    <span class="keyword">if</span> sched.safePointWait == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒m（m放在safePointNote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.safePointNote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="寄存器数据保存"><a href="#寄存器数据保存" class="headerlink" title="寄存器数据保存"></a>寄存器数据保存</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存到sched字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">(pc, sp, bp <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是g0或者是gsignal</span></span><br><span class="line">    <span class="keyword">if</span> gp == gp.m.g0 || gp == gp.m.gsignal &#123;</span><br><span class="line">        throw(<span class="string">&quot;save on system g not allowed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存到sched字段</span></span><br><span class="line">    gp.sched.pc = pc</span><br><span class="line">    gp.sched.sp = sp</span><br><span class="line">    gp.sched.lr = <span class="number">0</span></span><br><span class="line">    gp.sched.ret = <span class="number">0</span></span><br><span class="line">    gp.sched.bp = bp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保ctxt为0</span></span><br><span class="line">    <span class="keyword">if</span> gp.sched.ctxt != <span class="literal">nil</span> &#123;</span><br><span class="line">        badctxt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抢占相关"><a href="#抢占相关" class="headerlink" title="抢占相关"></a>抢占相关</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历p，抢占超时的g、回收阻塞在syscall的p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="type">int64</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="comment">// 强制回收p的数量</span></span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allp加锁</span></span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历allp，因为会临时解锁，不能用range</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">        <span class="comment">// p</span></span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="comment">// 扩容中</span></span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 不处理当前p</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sysmon纪录的的当前p的调度次数</span></span><br><span class="line">        pd := &amp;pp.sysmontick</span><br><span class="line">        <span class="comment">// 下面只判断_Prunning、_Psyscall两种状态</span></span><br><span class="line">        s := pp.status</span><br><span class="line">        <span class="comment">// m是否进入syscall</span></span><br><span class="line">        sysretake := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s == _Prunning || s == _Psyscall &#123;</span><br><span class="line">            <span class="comment">// p的调度次数</span></span><br><span class="line">            t := <span class="type">int64</span>(pp.schedtick)</span><br><span class="line">            <span class="comment">// p的调度次数跟sysmon纪录的的调度次数不一致</span></span><br><span class="line">            <span class="keyword">if</span> <span class="type">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">                <span class="comment">// 同步调度次数</span></span><br><span class="line">                pd.schedtick = <span class="type">uint32</span>(t)</span><br><span class="line">                pd.schedwhen = now</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;</span><br><span class="line">                <span class="comment">// 调度次数一致，但超时了（10ms）</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置g、p抢占标志、发送抢占信号给m</span></span><br><span class="line">                preemptone(pp)</span><br><span class="line">                <span class="comment">// m进入syscall，preemptone失效</span></span><br><span class="line">                sysretake = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// syscall时重试</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line">            <span class="comment">// p的syscall次数</span></span><br><span class="line">            t := <span class="type">int64</span>(pp.syscalltick)</span><br><span class="line">            <span class="comment">// m没有进入syscall and p与sysmon纪录的syscall次数不一致</span></span><br><span class="line">            <span class="keyword">if</span> !sysretake &amp;&amp; <span class="type">int64</span>(pd.syscalltick) != t &#123;</span><br><span class="line">                <span class="comment">// 同步syscall次数</span></span><br><span class="line">                pd.syscalltick = <span class="type">uint32</span>(t)</span><br><span class="line">                pd.syscallwhen = now</span><br><span class="line">                <span class="comment">// 不处理当前p</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// m进入syscall or p与sysmon纪录的syscall次数一致</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 本地队列为空 and 自旋m数量+空闲p数量&gt;0 and syscall次数一致但没有超时（10ms）</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(pp) &amp;&amp; sched.nmspinning.Load()+sched.npidle.Load() &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="comment">// 不处理当前p</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// allp解锁，以便接下来调度器加锁</span></span><br><span class="line">            unlock(&amp;allpLock)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 空闲的locked的m数量-=1，假装是locked的m在运行</span></span><br><span class="line">            incidlelocked(<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">// 强制回收p</span></span><br><span class="line">            <span class="comment">// p状态改为_Pidle</span></span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;pp.status, s, _Pidle) &#123;</span><br><span class="line">                <span class="comment">// 强制回收p的数量+1</span></span><br><span class="line">                n++</span><br><span class="line">                <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">                pp.syscalltick++</span><br><span class="line">                <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">                handoffp(pp)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 复原，空闲的locked的m数量+=1，检查是否存在死锁</span></span><br><span class="line">            incidlelocked(<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 重新加锁</span></span><br><span class="line">            lock(&amp;allpLock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint32</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐个设置p的抢占标志，发送信号给线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptall</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    res := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// p的状态非_Prunning</span></span><br><span class="line">        <span class="keyword">if</span> pp.status != _Prunning &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置g、p抢占标志、发送抢占信号给m</span></span><br><span class="line">        <span class="keyword">if</span> preemptone(pp) &#123;</span><br><span class="line">            res = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有一个成功即为true</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置g、p抢占标志、发送抢占信号给m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptone</span><span class="params">(pp *p)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    mp := pp.m.ptr()</span><br><span class="line">    <span class="comment">// m为nil or m为当前m</span></span><br><span class="line">    <span class="keyword">if</span> mp == <span class="literal">nil</span> || mp == getg().m &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    gp := mp.curg</span><br><span class="line">    <span class="comment">// g为nil or m为g0</span></span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> || gp == mp.g0 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g设置标志位（可能设置错了g，也可能不执行）</span></span><br><span class="line">    gp.preempt = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// stackguard0（用于正常函数调用时检查）设置为0xfffffade</span></span><br><span class="line">    gp.stackguard0 = stackPreempt</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preemptMSupported默认为true and asyncpreemptoff默认为0（为1时禁用基于信号的异步抢占）</span></span><br><span class="line">    <span class="keyword">if</span> preemptMSupported &amp;&amp; debug.asyncpreemptoff == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// p设置标志位</span></span><br><span class="line">        pp.preempt = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 发送抢占信号给m（平台相关）</span></span><br><span class="line">        preemptM(mp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g状态修改、解除与m的绑定，重新寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptPark</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取g.atomicstatus状态</span></span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="comment">// 异常，_Grunning位未设置</span></span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">&quot;bad g status&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// asyncSafePoint</span></span><br><span class="line">    <span class="keyword">if</span> gp.asyncSafePoint &#123;</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        f := findfunc(gp.sched.pc)</span><br><span class="line">        <span class="keyword">if</span> !f.valid() &#123;</span><br><span class="line">            throw(<span class="string">&quot;preempt at unknown pc&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> f.flag&amp;abi.FuncFlagSPWrite != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: unexpected SPWRITE function&quot;</span>, funcname(f), <span class="string">&quot;in async preempt&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;preempt SPWRITE&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Gscanpreempted</span></span><br><span class="line">    casGToPreemptScan(gp, _Grunning, _Gscan|_Gpreempted)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Gscanpreempted状态改为_Gpreempted</span></span><br><span class="line">    casfrom_Gscanstatus(gp, _Gscan|_Gpreempted, _Gpreempted)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改g状态、纪录寄存器状态，唤醒sysmon、GC等线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reentersyscall</span><span class="params">(pc, sp, bp <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m加锁</span></span><br><span class="line">    gp.m.locks++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stackguard0（用于正常函数调用时检查）设置为0xfffffade</span></span><br><span class="line">    gp.stackguard0 = stackPreempt</span><br><span class="line">    <span class="comment">// 禁止栈分裂/扩容，否则抛出异常</span></span><br><span class="line">    gp.throwsplit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储到g.sched</span></span><br><span class="line">    save(pc, sp, bp)</span><br><span class="line">    <span class="comment">// 同步到syscall相关字段</span></span><br><span class="line">    gp.syscallsp = sp</span><br><span class="line">    gp.syscallpc = pc</span><br><span class="line">    gp.syscallbp = bp</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Gsyscall</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gsyscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// staticLockRanking默认为false</span></span><br><span class="line">    <span class="keyword">if</span> staticLockRanking &#123;</span><br><span class="line">        save(pc, sp, bp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过边界，异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallsp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallsp &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscall inconsistent sp &quot;</span>, hex(gp.syscallsp), <span class="string">&quot; [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscall&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过边界，异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallbp != <span class="number">0</span> &amp;&amp; gp.syscallbp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallbp &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscall inconsistent bp &quot;</span>, hex(gp.syscallbp), <span class="string">&quot; [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscall&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sysmon挂起休眠了</span></span><br><span class="line">    <span class="keyword">if</span> sched.sysmonwait.Load() &#123;</span><br><span class="line">        <span class="comment">// entersyscall_sysmon</span></span><br><span class="line">        <span class="comment">// 有工作了，唤醒sysmon</span></span><br><span class="line">        systemstack(entersyscall_sysmon)</span><br><span class="line">        <span class="comment">// 存储到g.sched</span></span><br><span class="line">        save(pc, sp, bp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC标志需要执行safePointFn</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 执行runSafePointFn函数</span></span><br><span class="line">        <span class="comment">// 执行safePointFn，如果是最后一个p，则唤醒safePointNote</span></span><br><span class="line">        systemstack(runSafePointFn)</span><br><span class="line">        <span class="comment">// 存储到g.sched</span></span><br><span class="line">        save(pc, sp, bp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录p的syscall次数到m</span></span><br><span class="line">    gp.m.syscalltick = gp.m.p.ptr().syscalltick</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line">    <span class="comment">// p取消m绑定</span></span><br><span class="line">    pp.m = <span class="number">0</span></span><br><span class="line">    <span class="comment">// m纪录p到oldp</span></span><br><span class="line">    gp.m.oldp.set(pp)</span><br><span class="line">    <span class="comment">// m取消p绑定</span></span><br><span class="line">    gp.m.p = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 状态改为_Psyscall</span></span><br><span class="line">    atomic.Store(&amp;pp.status, _Psyscall)</span><br><span class="line">    <span class="comment">// STW，当前p释放到空闲队列</span></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting.Load() &#123;</span><br><span class="line">        <span class="comment">// 执行entersyscall_gcwait</span></span><br><span class="line">        <span class="comment">// p停止，唤醒m执行GC</span></span><br><span class="line">        systemstack(entersyscall_gcwait)</span><br><span class="line">        <span class="comment">// 存储到g.sched</span></span><br><span class="line">        save(pc, sp, bp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    gp.m.locks--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改g状态、纪录寄存器状态，唤醒sysmon、GC等线程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fp := getcallerfp()</span><br><span class="line">    <span class="comment">// 修改g状态、纪录寄存器状态，唤醒sysmon、GC等线程</span></span><br><span class="line">    reentersyscall(sys.GetCallerPC(), sys.GetCallerSP(), fp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有工作了，唤醒sysmon</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscall_sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// sysmon空闲等待中</span></span><br><span class="line">    <span class="keyword">if</span> sched.sysmonwait.Load() &#123;</span><br><span class="line">        <span class="comment">// 取消等待标记</span></span><br><span class="line">        sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 唤醒sysmon（m放在sysmonnote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p停止，唤醒m执行GC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscall_gcwait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// syscall前使用的p</span></span><br><span class="line">    pp := gp.m.oldp.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// GC and p从_Psyscall状态改为_Pgcstop</span></span><br><span class="line">    <span class="keyword">if</span> sched.stopwait &gt; <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;pp.status, _Psyscall, _Pgcstop) &#123;</span><br><span class="line">        <span class="comment">// 因为GC导致的暂停的时刻</span></span><br><span class="line">        pp.gcStopTime = nanotime()</span><br><span class="line">        <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">        pp.syscalltick++</span><br><span class="line">        <span class="comment">// 待_Pgcstop的p数量-1，如果所有p已_Pgcstop</span></span><br><span class="line">        <span class="keyword">if</span> sched.stopwait--; sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 唤醒m（m放在stopnote.key）执行GC</span></span><br><span class="line">            notewakeup(&amp;sched.stopnote)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改g状态、纪录寄存器状态，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscallblock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m加锁</span></span><br><span class="line">    gp.m.locks++</span><br><span class="line">    <span class="comment">// 禁止栈分裂/扩容，否则抛出异常</span></span><br><span class="line">    gp.throwsplit = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// stackguard0（用于正常函数调用时检查）设置为0xfffffade</span></span><br><span class="line">    gp.stackguard0 = stackPreempt</span><br><span class="line">    <span class="comment">// 纪录p的syscall次数到m</span></span><br><span class="line">    gp.m.syscalltick = gp.m.p.ptr().syscalltick</span><br><span class="line">    <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">    gp.m.p.ptr().syscalltick++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    pc := sys.GetCallerPC()</span><br><span class="line">    sp := sys.GetCallerSP()</span><br><span class="line">    bp := getcallerfp()</span><br><span class="line">    <span class="comment">// 存储到g.sched</span></span><br><span class="line">    save(pc, sp, bp)</span><br><span class="line">    <span class="comment">// 同步到syscall相关字段</span></span><br><span class="line">    gp.syscallsp = gp.sched.sp</span><br><span class="line">    gp.syscallpc = gp.sched.pc</span><br><span class="line">    gp.syscallbp = gp.sched.bp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过边界，异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallsp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallsp &#123;</span><br><span class="line">        sp1 := sp</span><br><span class="line">        sp2 := gp.sched.sp</span><br><span class="line">        sp3 := gp.syscallsp</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscallblock inconsistent sp &quot;</span>, hex(sp1), <span class="string">&quot; &quot;</span>, hex(sp2), <span class="string">&quot; &quot;</span>, hex(sp3), <span class="string">&quot; [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscallblock&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从_Grunning状态改为_Gsyscall</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gsyscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过边界，异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallsp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallsp &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscallblock inconsistent sp &quot;</span>, hex(sp), <span class="string">&quot; &quot;</span>, hex(gp.sched.sp), <span class="string">&quot; &quot;</span>, hex(gp.syscallsp), <span class="string">&quot; [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscallblock&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过边界，异常</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallbp != <span class="number">0</span> &amp;&amp; gp.syscallbp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallbp &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;entersyscallblock inconsistent bp &quot;</span>, hex(bp), <span class="string">&quot; &quot;</span>, hex(gp.sched.bp), <span class="string">&quot; &quot;</span>, hex(gp.syscallbp), <span class="string">&quot; [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;entersyscallblock&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行entersyscallblock_handoff</span></span><br><span class="line">    <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">    systemstack(entersyscallblock_handoff)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储到g.sched</span></span><br><span class="line">    save(sys.GetCallerPC(), sys.GetCallerSP(), getcallerfp())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m解锁</span></span><br><span class="line">    gp.m.locks--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscallblock_handoff</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">    handoffp(releasep())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m尝试绑定syscall前使用的p，或者从空闲p列表拿一个绑定，绑定成功返回，失败则把m放到空闲队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m加锁</span></span><br><span class="line">    gp.m.locks++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sys.GetCallerSP() &gt; gp.syscallsp &#123;</span><br><span class="line">        throw(<span class="string">&quot;exitsyscall: syscall frame is no longer valid&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    gp.waitsince = <span class="number">0</span></span><br><span class="line">    <span class="comment">// syscall前使用的p</span></span><br><span class="line">    oldp := gp.m.oldp.ptr()</span><br><span class="line">    <span class="comment">// 重置该字段</span></span><br><span class="line">    gp.m.oldp = <span class="number">0</span></span><br><span class="line">    <span class="comment">// m尝试绑定syscall前使用的p，或者从空闲p列表拿一个绑定</span></span><br><span class="line">    <span class="keyword">if</span> exitsyscallfast(oldp) &#123;</span><br><span class="line">        <span class="comment">// pprof相关</span></span><br><span class="line">        <span class="keyword">if</span> goroutineProfile.active &#123;</span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="comment">// 在写屏障路径上记录g的profile相关信息</span></span><br><span class="line">                tryRecordGoroutineProfileWB(gp)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">        gp.m.p.ptr().syscalltick++</span><br><span class="line">        <span class="comment">// 从_Gsyscall状态改为_Grunning</span></span><br><span class="line">        casgstatus(gp, _Gsyscall, _Grunning)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC未运行</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        gp.syscallsp = <span class="number">0</span></span><br><span class="line">        <span class="comment">// m解锁</span></span><br><span class="line">        gp.m.locks--</span><br><span class="line">        <span class="comment">// g被抢占</span></span><br><span class="line">        <span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">            <span class="comment">// stackguard0（用于正常函数调用时检查）设置为0xfffffade</span></span><br><span class="line">            gp.stackguard0 = stackPreempt</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非抢占</span></span><br><span class="line">            <span class="comment">// stack.lo+928</span></span><br><span class="line">            gp.stackguard0 = gp.stack.lo + stackGuard</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 允许栈分裂/扩容</span></span><br><span class="line">        gp.throwsplit = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC时只有sys类型的g允许运行</span></span><br><span class="line">        <span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">            <span class="comment">// 同协程yield关键字，当前g让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">            Gosched()</span><br><span class="line">            <span class="comment">// 被重新调度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿不到p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// m解锁</span></span><br><span class="line">    gp.m.locks--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行exitsyscall0函数</span></span><br><span class="line">    <span class="comment">// 能拿到p则绑定执行g，拿不到时，如果有locked的m则让出CPU等待locked的g可运行，否则把当前m放到空闲m列表</span></span><br><span class="line">    mcall(exitsyscall0)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    gp.syscallsp = <span class="number">0</span></span><br><span class="line">    <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">    gp.m.p.ptr().syscalltick++</span><br><span class="line">    <span class="comment">// 允许栈分裂/扩容</span></span><br><span class="line">    gp.throwsplit = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试绑定m和oldp，或者从空闲p列表拿一个绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscallfast</span><span class="params">(oldp *p)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// freezeStopWait表示发生panic</span></span><br><span class="line">    <span class="keyword">if</span> sched.stopwait == freezeStopWait &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试将oldp的状态从_Psyscall改为_Pidle</span></span><br><span class="line">    <span class="keyword">if</span> oldp != <span class="literal">nil</span> &amp;&amp; oldp.status == _Psyscall &amp;&amp; atomic.Cas(&amp;oldp.status, _Psyscall, _Pidle) &#123;</span><br><span class="line">        <span class="comment">// 绑定m和oldp</span></span><br><span class="line">        wirep(oldp)</span><br><span class="line">        <span class="comment">// 同步m与p的syscall次数</span></span><br><span class="line">        exitsyscallfast_reacquired(trace)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oldp为nil or oldp状态非_Psyscall or 状态修改失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲p链表有数据</span></span><br><span class="line">    <span class="keyword">if</span> sched.pidle != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 从空闲链表拿一个p并绑定m</span></span><br><span class="line">            ok = exitsyscallfast_pidle()</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 拿到了</span></span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没拿到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步m与p的syscall次数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscallfast_reacquired</span><span class="params">(trace traceLocker)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// m与p的syscall次数不一致</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.syscalltick != gp.m.p.ptr().syscalltick &#123;</span><br><span class="line">        <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">        gp.m.p.ptr().syscalltick++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从空闲链表拿一个p并绑定m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscallfast_pidle</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">    pp, _ := pidleget(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 拿到p and sysmon挂起休眠了</span></span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &amp;&amp; sched.sysmonwait.Load() &#123;</span><br><span class="line">        <span class="comment">// 取消等待标记</span></span><br><span class="line">        sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 唤醒sysmon（m放在sysmonnote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到p</span></span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">        acquirep(pp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于runtime，能拿到p则绑定执行g，拿不到时，如果有locked的m则让出CPU等待locked的g可运行，否则把当前m放到空闲m列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从_Gsyscall状态改为_Grunnable</span></span><br><span class="line">    casgstatus(gp, _Gsyscall, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g、m解除绑定</span></span><br><span class="line">    dropg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pp *p</span><br><span class="line">    <span class="comment">// GC开始到标记结束这个过程只允许sys类型的g运行</span></span><br><span class="line">    <span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">        <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">        pp, _ = pidleget(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> locked <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有拿到p</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 把g放到全局队列尾部</span></span><br><span class="line">        globrunqput(gp)</span><br><span class="line">        <span class="comment">// 是否有locked的m</span></span><br><span class="line">        locked = gp.lockedm != <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> sched.sysmonwait.Load() &#123;</span><br><span class="line">        <span class="comment">// 拿到p，sysmon挂起休眠了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消等待标记</span></span><br><span class="line">        sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 唤醒sysmon（m放在sysmonnote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到p</span></span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 绑定m和p，并清理p.mcache</span></span><br><span class="line">        acquirep(pp)</span><br><span class="line">        <span class="comment">// g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line">        execute(gp, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有拿到p</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lockedm不为空</span></span><br><span class="line">    <span class="keyword">if</span> locked &#123;</span><br><span class="line">        <span class="comment">// m让出p并挂起休眠，直到lockedg状态变为可运行，被唤醒后绑定一个p返回</span></span><br><span class="line">        stoplockedm()</span><br><span class="line">        <span class="comment">// g调整状态等数据，和m双向绑定，最后切换到g的上下文执行（该函数永不返回）</span></span><br><span class="line">        execute(gp, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lockedm为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">    stopm()</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找并运行可运行的g（该函数永不返回）</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main相关"><a href="#main相关" class="headerlink" title="main相关"></a>main相关</h3><h4 id="init初始化函数"><a href="#init初始化函数" class="headerlink" title="init初始化函数"></a>init初始化函数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行init函数，可以是runtime相关或module相关</span></span><br><span class="line"><span class="comment">// var runtime_inittasks []*initTask</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doInit</span><span class="params">(ts []*initTask)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        doInit1(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行单个init函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doInit1</span><span class="params">(t *initTask)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t.state &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 完成</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 执行中</span></span><br><span class="line">        throw(<span class="string">&quot;recursive call during initialization - linker skew&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:<span class="comment">// 0-未开始</span></span><br><span class="line">        <span class="comment">// 设置为执行中</span></span><br><span class="line">        t.state = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            start  <span class="type">int64</span>        <span class="comment">// 开始时刻-单调时钟</span></span><br><span class="line">            before tracestat    <span class="comment">// 原状态</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inittrace-全局变量</span></span><br><span class="line">        <span class="keyword">if</span> inittrace.active &#123;</span><br><span class="line">            start = nanotime()</span><br><span class="line">            before = inittrace</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init函数数量</span></span><br><span class="line">        <span class="keyword">if</span> t.nfns == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;inittask with no functions&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定位到第一个init函数的位置</span></span><br><span class="line">        firstFunc := add(unsafe.Pointer(t), <span class="number">8</span>)</span><br><span class="line">        <span class="comment">// 执行所有init函数</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; t.nfns; i++ &#123;</span><br><span class="line">            p := add(firstFunc, <span class="type">uintptr</span>(i)*goarch.PtrSize)</span><br><span class="line">            f := *(*<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)(unsafe.Pointer(&amp;p))</span><br><span class="line">            f()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收尾</span></span><br><span class="line">        <span class="keyword">if</span> inittrace.active &#123;</span><br><span class="line">            <span class="comment">// 纪录结束时刻</span></span><br><span class="line">            end := nanotime()</span><br><span class="line">            <span class="comment">// 当前状态</span></span><br><span class="line">            after := inittrace</span><br><span class="line"></span><br><span class="line">            f := *(*<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)(unsafe.Pointer(&amp;firstFunc))</span><br><span class="line">            pkg := funcpkgpath(findfunc(abi.FuncPCABIInternal(f)))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印耗时等信息</span></span><br><span class="line">            <span class="keyword">var</span> sbuf [<span class="number">24</span>]<span class="type">byte</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;init &quot;</span>, pkg, <span class="string">&quot; @&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">string</span>(fmtNSAsMS(sbuf[:], <span class="type">uint64</span>(start-runtimeInitTime))), <span class="string">&quot; ms, &quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">string</span>(fmtNSAsMS(sbuf[:], <span class="type">uint64</span>(end-start))), <span class="string">&quot; ms clock, &quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">string</span>(itoa(sbuf[:], after.bytes-before.bytes)), <span class="string">&quot; bytes, &quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">string</span>(itoa(sbuf[:], after.allocs-before.allocs)), <span class="string">&quot; allocs&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记完成</span></span><br><span class="line">        t.state = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h3><h4 id="启动sweeper、scavenger"><a href="#启动sweeper、scavenger" class="headerlink" title="启动sweeper、scavenger"></a>启动sweeper、scavenger</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动sweeper、scavenger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcenable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// sweeper</span></span><br><span class="line">    <span class="keyword">go</span> bgsweep(c)</span><br><span class="line">    <span class="comment">// scavenger</span></span><br><span class="line">    <span class="keyword">go</span> bgscavenge(c)</span><br><span class="line">    &lt;-c</span><br><span class="line">    &lt;-c</span><br><span class="line">    <span class="comment">// 运行时已完成初始化，可以执行GC</span></span><br><span class="line">    memstats.enablegc = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GC调度"><a href="#GC调度" class="headerlink" title="GC调度"></a>GC调度</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地/全局队列为空时，执行netpoll轮询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pollWork</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// 本地队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> !runqempty(p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// netpoll已初始化 and 挂起的g数量不为0 and 当前没有进行netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; netpollAnyWaiters() &amp;&amp; sched.lastpoll.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 平台相关</span></span><br><span class="line">        <span class="comment">// 执行epollWait检查，0-没有数据立即返回</span></span><br><span class="line">        <span class="keyword">if</span> list, delta := netpoll(<span class="number">0</span>); !list.empty() &#123;</span><br><span class="line">            <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">            netpollAdjustWaiters(delta)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sysmon相关"><a href="#sysmon相关" class="headerlink" title="sysmon相关"></a>sysmon相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空闲时轮询netpoll，其他时候，抢占超时的g、回收阻塞在syscall的p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// sys类型的m数量+=1</span></span><br><span class="line">    sched.nmsys++</span><br><span class="line">    <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">    checkdead()</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    lasttrace := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    idle := <span class="number">0</span></span><br><span class="line">    delay := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 永久循环</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> idle == <span class="number">0</span> &#123;          <span class="comment">// 休眠20us</span></span><br><span class="line">            delay = <span class="number">20</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123;   <span class="comment">// 50次20us后，双倍休眠时间</span></span><br><span class="line">            delay *= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123;    <span class="comment">// 最多休眠10ms</span></span><br><span class="line">            delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始前，先休眠一段时间</span></span><br><span class="line">        usleep(delay)</span><br><span class="line"></span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="comment">// schedtrace默认为0 and (STW，当前p释放到空闲队列 or 所有的p都空闲)</span></span><br><span class="line">        <span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting.Load() || sched.npidle.Load() == gomaxprocs) &#123;</span><br><span class="line">            <span class="comment">// 调度器加锁</span></span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            <span class="comment">// STW，当前p释放到空闲队列 or 所有的p都空闲</span></span><br><span class="line">            <span class="keyword">if</span> sched.gcwaiting.Load() || sched.npidle.Load() == gomaxprocs &#123;</span><br><span class="line">                syscallWake := <span class="literal">false</span></span><br><span class="line">                <span class="comment">// 遍历所有P，找到全局最小的when</span></span><br><span class="line">                next := timeSleepUntil()</span><br><span class="line">                <span class="comment">// 还未到超时时刻</span></span><br><span class="line">                <span class="keyword">if</span> next &gt; now &#123;</span><br><span class="line">                    <span class="comment">// 标记空闲等待中</span></span><br><span class="line">                    sched.sysmonwait.Store(<span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 休眠前先解锁</span></span><br><span class="line">                    unlock(&amp;sched.lock)</span><br><span class="line">                    <span class="comment">// sleep = forcegcperiod/2 = 1min</span></span><br><span class="line">                    sleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">                    <span class="comment">// 下一个超时时刻在1min内</span></span><br><span class="line">                    <span class="keyword">if</span> next-now &lt; sleep &#123;</span><br><span class="line">                        sleep = next - now</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 非Windows下为true，sleep &gt;= 0</span></span><br><span class="line">                    shouldRelax := sleep &gt;= osRelaxMinNS</span><br><span class="line">                    <span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">                        <span class="comment">// 非Windows下为空函数</span></span><br><span class="line">                        osRelax(<span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 挂起休眠指定时间（m放在sysmonnote.key），标记blocked为true</span></span><br><span class="line">                    syscallWake = notetsleep(&amp;sched.sysmonnote, sleep)</span><br><span class="line">                    <span class="comment">// 被唤醒/超时</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">                        <span class="comment">// 非Windows下为空函数</span></span><br><span class="line">                        osRelax(<span class="literal">false</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 唤醒后重新加锁</span></span><br><span class="line">                    lock(&amp;sched.lock)</span><br><span class="line">                    <span class="comment">// 取消等待标记</span></span><br><span class="line">                    sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">                    <span class="comment">// 将sysmonnote.key重置为0</span></span><br><span class="line">                    noteclear(&amp;sched.sysmonnote)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 成功唤醒</span></span><br><span class="line">                <span class="keyword">if</span> syscallWake &#123;</span><br><span class="line">                    idle = <span class="number">0</span></span><br><span class="line">                    delay = <span class="number">20</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从这里到末尾都要加锁访问</span></span><br><span class="line">        lock(&amp;sched.sysmonlock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前时刻</span></span><br><span class="line">        now = nanotime()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cgo</span></span><br><span class="line">        <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">            asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上一次执行netpoll的时刻</span></span><br><span class="line">        lastpoll := sched.lastpoll.Load()</span><br><span class="line">        <span class="comment">// netpoll已初始化 and 当前没有进行netpoll轮询 and lastpoll距离现在没有超过10ms</span></span><br><span class="line">        <span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">            <span class="comment">// lastpoll更新为当前时刻</span></span><br><span class="line">            sched.lastpoll.CompareAndSwap(lastpoll, now)</span><br><span class="line">            <span class="comment">// 执行epollWait检查，0-没有数据立即返回</span></span><br><span class="line">            list, delta := netpoll(<span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            <span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">                <span class="comment">// 空闲的locked的m数量-=1，假装是locked的m在运行</span></span><br><span class="line">                incidlelocked(<span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">                injectglist(&amp;list)</span><br><span class="line">                <span class="comment">// 复原，空闲的locked的m数量+=1，检查是否存在死锁</span></span><br><span class="line">                incidlelocked(<span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">                netpollAdjustWaiters(delta)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// netbsd相关</span></span><br><span class="line">        <span class="keyword">if</span> GOOS == <span class="string">&quot;netbsd&quot;</span> &amp;&amp; needSysmonWorkaround &#123;</span><br><span class="line">            <span class="keyword">if</span> next := timeSleepUntil(); next &lt; now &#123;</span><br><span class="line">                startm(<span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为1时sysmon将会唤醒scavenger</span></span><br><span class="line">        <span class="keyword">if</span> scavenger.sysmonWake.Load() != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 重置scavenger状态，修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            scavenger.wake()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历p，抢占超时的g、回收阻塞在syscall的p</span></span><br><span class="line">        <span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 有回收p</span></span><br><span class="line">            idle = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无回收p</span></span><br><span class="line">            idle++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; forcegc.idle.Load() &#123;</span><br><span class="line">            <span class="comment">// forcegc加锁</span></span><br><span class="line">            lock(&amp;forcegc.lock)</span><br><span class="line">            <span class="comment">// 重置idle</span></span><br><span class="line">            forcegc.idle.Store(<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">var</span> list gList</span><br><span class="line">            <span class="comment">// 把g放到链表</span></span><br><span class="line">            list.push(forcegc.g)</span><br><span class="line">            <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;forcegc.lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// schedtrace默认为0，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="type">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">            lasttrace = now</span><br><span class="line">            schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.sysmonlock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cgo相关"><a href="#cgo相关" class="headerlink" title="cgo相关"></a>cgo相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建模板线程，每次唤醒时创建所有locked和cgo类型的m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTemplateThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// wasm只有一个线程</span></span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 原子设置haveTemplateThread为1</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;newmHandoff.haveTemplateThread, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置失败，有其他线程已经执行了</span></span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理freem链表，创建并初始化m，locked或cgo类型的m由模板线程延迟创建，其他类型则立即调用平台相关函数创建线程</span></span><br><span class="line">    <span class="comment">// templateThread：每次唤醒时创建所有locked和cgo类型的m</span></span><br><span class="line">    newm(templateThread, <span class="literal">nil</span>, <span class="number">-1</span>)</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次唤醒时创建所有locked和cgo类型的m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">templateThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// sys类型的m数量+=1</span></span><br><span class="line">    sched.nmsys++</span><br><span class="line">    <span class="comment">// 检查是否存在死锁</span></span><br><span class="line">    checkdead()</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 永久循环</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        lock(&amp;newmHandoff.lock)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// m队列不为空</span></span><br><span class="line">        <span class="keyword">for</span> newmHandoff.newm != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 拿到整个m链表</span></span><br><span class="line">            newm := newmHandoff.newm.ptr()</span><br><span class="line">            <span class="comment">// 清除指针</span></span><br><span class="line">            newmHandoff.newm = <span class="number">0</span></span><br><span class="line">            unlock(&amp;newmHandoff.lock)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历整个m链表并创建线程运行m</span></span><br><span class="line">            <span class="keyword">for</span> newm != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 下一个m，也是新链表的头部</span></span><br><span class="line">                next := newm.schedlink.ptr()</span><br><span class="line">                <span class="comment">// m清除next指针</span></span><br><span class="line">                newm.schedlink = <span class="number">0</span></span><br><span class="line">                <span class="comment">// 调用平台相关函数创建线程运行m</span></span><br><span class="line">                newm1(newm)</span><br><span class="line">                <span class="comment">// 指向下一个m</span></span><br><span class="line">                newm = next</span><br><span class="line">            &#125;</span><br><span class="line">            lock(&amp;newmHandoff.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前m等待唤醒，下面会进行sleep</span></span><br><span class="line">        newmHandoff.waiting = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 将wake.key重置为0</span></span><br><span class="line">        noteclear(&amp;newmHandoff.wake)</span><br><span class="line"></span><br><span class="line">        unlock(&amp;newmHandoff.lock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挂起休眠（m放在wake.key），标记blocked为true</span></span><br><span class="line">        notesleep(&amp;newmHandoff.wake)</span><br><span class="line">        <span class="comment">// 被notewakeup唤醒，标记blocked为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="profiling相关"><a href="#profiling相关" class="headerlink" title="profiling相关"></a>profiling相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存剖析调用栈初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mProfStackInit</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 为0不处理，profstackdepth默认128，最大值1024</span></span><br><span class="line">    <span class="keyword">if</span> debug.profstackdepth == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// make([]uintptr, 1+6+debug.profstackdepth)</span></span><br><span class="line">    mp.profStack = makeProfStackFP()</span><br><span class="line">    <span class="comment">// make([]uintptr, 1+6+debug.profstackdepth)</span></span><br><span class="line">    mp.mLockProfile.stack = makeProfStackFP()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="sudog相关"><a href="#sudog相关" class="headerlink" title="sudog相关"></a>sudog相关</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从sudogcache获取一个sudog</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireSudog</span><span class="params">()</span></span> *sudog &#123;</span><br><span class="line">    <span class="comment">// sema -&gt; acquireSudog -&gt; new(sudog) -&gt; malloc -&gt; GC -&gt; sema</span></span><br><span class="line">    <span class="comment">// 有环，需要使用acquirem避免GC</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// sudog列表为空，从调度器拿</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.sudoglock)</span><br><span class="line">        <span class="comment">// 数据量没有超过容量一半 and 调度器的sudog列表不为空</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &lt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &amp;&amp; sched.sudogcache != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 从调度器的sudog链表拿走放到p里</span></span><br><span class="line">            s := sched.sudogcache</span><br><span class="line">            sched.sudogcache = s.next</span><br><span class="line">            s.next = <span class="literal">nil</span></span><br><span class="line">            pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.sudoglock)</span><br><span class="line">        <span class="comment">// 调度器的sudog列表也是空的</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 使用new创建一个sudog放到p里</span></span><br><span class="line">            pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, <span class="built_in">new</span>(sudog))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿走列表里最后一个sudog</span></span><br><span class="line">    n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">    s := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">    pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">    pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;acquireSudog: found s.elem != nil in cache&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把sudog放回cache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseSudog</span><span class="params">(s *sudog)</span></span> &#123;</span><br><span class="line">    <span class="comment">// guard</span></span><br><span class="line">    <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-nil elem&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.isSelect &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-false isSelect&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.next != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-nil next&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-nil prev&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.waitlink != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-nil waitlink&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.c != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: sudog with non-nil c&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp.param != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: releaseSudog with non-nil gp.param&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// 本地队列满了，把一半的数量放到全局队列</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="built_in">cap</span>(pp.sudogcache) &#123;</span><br><span class="line">        <span class="comment">// 链表头部和尾部指针</span></span><br><span class="line">        <span class="keyword">var</span> first, last *sudog</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &gt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &#123;</span><br><span class="line">            <span class="comment">// 拿走列表里最后一个sudog</span></span><br><span class="line">            n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">            p := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">            pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">            pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// 如果是第一个数据</span></span><br><span class="line">            <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">                first = p</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 上一个sudog指向当前sudog</span></span><br><span class="line">                last.next = p</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指向当前sudog</span></span><br><span class="line">            last = p</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调度器加锁</span></span><br><span class="line">        lock(&amp;sched.sudoglock)</span><br><span class="line">        <span class="comment">// 链接全局sudog链表头部</span></span><br><span class="line">        last.next = sched.sudogcache</span><br><span class="line">        <span class="comment">// 替换（GC时清空全局sudog缓存）</span></span><br><span class="line">        sched.sudogcache = first</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.sudoglock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放到本地链表</span></span><br><span class="line">    pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在死锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkdead</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态库（c-archive/c-shared） and 非wasm平台</span></span><br><span class="line">    <span class="keyword">if</span> (islibrary || isarchive) &amp;&amp; GOARCH != <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic</span></span><br><span class="line">    <span class="keyword">if</span> panicking.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> run0 <span class="type">int32</span></span><br><span class="line">    <span class="comment">// 没有运行cgo and 有额外的m（Windows）</span></span><br><span class="line">    <span class="keyword">if</span> !iscgo &amp;&amp; cgoHasExtraM &amp;&amp; extraMLength.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        run0 = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户m数量 = 累计总量 - 累计释放m数量 - 空闲m数量 - locked的m数量 - sys类型m数量</span></span><br><span class="line">    <span class="comment">// = sched.mnext - sched.nmfreed - sched.nmidle - sched.nmidlelocked - sched.nmsys</span></span><br><span class="line">    run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面条件一般情况下都满足</span></span><br><span class="line">    <span class="keyword">if</span> run &gt; run0 &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run为0或1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> run &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: checkdead: nmidle=&quot;</span>, sched.nmidle, <span class="string">&quot; nmidlelocked=&quot;</span>, sched.nmidlelocked, <span class="string">&quot; mcount=&quot;</span>, mcount(), <span class="string">&quot; nmsys=&quot;</span>, sched.nmsys, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        throw(<span class="string">&quot;checkdead: inconsistent counts&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grunning := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 每个g都执行一遍该函数，期间allglock会被锁住</span></span><br><span class="line">    forEachG(<span class="function"><span class="keyword">func</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 是否是runtime相关的函数，除了部份如runtime.main</span></span><br><span class="line">        <span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取g.atomicstatus状态</span></span><br><span class="line">        s := readgstatus(gp)</span><br><span class="line">        <span class="keyword">switch</span> s &amp;^ _Gscan &#123;</span><br><span class="line">        <span class="keyword">case</span> _Gwaiting,</span><br><span class="line">            _Gpreempted: <span class="comment">// _Gwaiting、_Gpreempted</span></span><br><span class="line">            grunning++</span><br><span class="line">        <span class="keyword">case</span> _Grunnable,</span><br><span class="line">            _Grunning,</span><br><span class="line">            _Gsyscall: <span class="comment">// _Grunnable、_Grunning、_Gsyscall</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: checkdead: find g &quot;</span>, gp.goid, <span class="string">&quot; in status &quot;</span>, s, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            throw(<span class="string">&quot;checkdead: runnable g&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 如果runtime·Goexit()</span></span><br><span class="line">    <span class="keyword">if</span> grunning == <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        fatal(<span class="string">&quot;no goroutines (main called runtime.Goexit) - deadlock!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// faketime，忽略</span></span><br><span class="line">    <span class="keyword">if</span> faketime != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> when := timeSleepUntil(); when &lt; maxWhen &#123;</span><br><span class="line">            faketime = when</span><br><span class="line"></span><br><span class="line">            pp, _ := pidleget(faketime)</span><br><span class="line">            <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                throw(<span class="string">&quot;checkdead: no p for timer&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            mp := mget()</span><br><span class="line">            <span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span><br><span class="line">                unlock(&amp;sched.lock)</span><br><span class="line">                throw(<span class="string">&quot;checkdead: no m for timer&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            sched.nmspinning.Add(<span class="number">1</span>)</span><br><span class="line">            mp.spinning = <span class="literal">true</span></span><br><span class="line">            mp.nextp.set(pp)</span><br><span class="line">            notewakeup(&amp;mp.park)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有goroutine运行，检查p</span></span><br><span class="line">    <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// 有timer</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pp.timers.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    fatal(<span class="string">&quot;all goroutines are asleep - deadlock!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">6.5 调度器</a><br><a href="https://xargin.com/go-bootstrap/">Go 系列文章2：Go 程序的启动流程</a><br><a href="https://blog.nindalf.com/posts/how-goroutines-work/">How Goroutines Work</a><br><a href="https://medium.com/@ninucium/golang-concurrency-patterns-for-select-done-errgroup-and-worker-pool-645bec0bd3c9">Golang Concurrency Patterns: For-Select-Done, Errgroup and Worker Pool</a><br><a href="https://www.youtube.com/watch?v=-K11rY57K7k">Dmitry Vyukov — Go scheduler: Implementing language with lightweight concurrency</a><br><a href="https://www.youtube.com/watch?v=5zXAHh5tJqQ">GopherCon 2018: Bryan C. Mills - Rethinking Classical Concurrency Patterns</a><br><a href="https://medium.com/@ankur_anand/illustrated-tales-of-go-runtime-scheduler-74809ef6d19b">Illustrated Tales of Go Runtime Scheduler.</a><br><a href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a">Go: Goroutine, OS Thread and CPU Management</a><br><a href="https://www.youtube.com/watch?v=YHRO5WQGh0k">GopherCon 2018: Kavya Joshi - The Scheduler Saga</a><br><a href="https://agrim123.github.io/posts/goroutines.html">Goroutines: M, P, G orchestration</a><br><a href="https://www.cnblogs.com/zkweb/p/7815600.html">Golang源码探索(二) 协程的实现原理 </a><br><a href="https://tontinton.com/posts/scheduling-internals/">Scheduling Internals.</a><br><a href="https://xargin.com/go-scheduler/">Go 系列文章4 : 调度器</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Cond</title>
    <url>/golang-series-sync-cond/</url>
    <content><![CDATA[<p>sync.Cond经常用在多个 goroutine 等待，一个 goroutine 通知（事件发生）的场景。如果是一个通知，一个等待，使用互斥锁或 channel 就能搞定了。底层实现基于信号量semaphore</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>以下展示一个sync.Cond的使用案例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shared = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reader 打印shared[key]</span></span><br><span class="line">    reader := <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        cond.L.Lock()</span><br><span class="line">        <span class="comment">// 等待，直到shared有数据</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(shared) == <span class="number">0</span> &#123;</span><br><span class="line">            cond.Wait() <span class="comment">// Wait内部会暂时解锁/加锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(shared[key])</span><br><span class="line">        cond.L.Unlock()</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> reader(<span class="string">&quot;rsc1&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> reader(<span class="string">&quot;rsc2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writer</span></span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    shared[<span class="string">&quot;rsc1&quot;</span>] = <span class="string">&quot;foo&quot;</span></span><br><span class="line">    shared[<span class="string">&quot;rsc2&quot;</span>] = <span class="string">&quot;bar&quot;</span></span><br><span class="line">    <span class="comment">// 通知所有goroutine</span></span><br><span class="line">    cond.Broadcast()</span><br><span class="line">    cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>Cond的数据结构如下</p>
<ul>
<li><code>L</code> - 只要实现Locker接口的类型都可以，比如Mutex</li>
<li><code>notify</code> - 计数器也是ticket生成器，可实现等待队列的先进先出-FIFO，由内部sema使用</li>
<li><code>checker</code> - 用来检测是否被复制</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sync.Cond结构体，看notify就行了</span></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker                <span class="comment">// mutex，由外部传入</span></span><br><span class="line"></span><br><span class="line">    notify  notifyList      <span class="comment">// 计数器+sudog链表，内部sema使用</span></span><br><span class="line">    checker copyChecker     <span class="comment">// 检查Cond是否被复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">    wait atomic.Uint32      <span class="comment">// 等待g数量，只增不减</span></span><br><span class="line"></span><br><span class="line">    notify <span class="type">uint32</span>           <span class="comment">// 唤醒g数量，范围[0,wait]，保证waiter先进先出</span></span><br><span class="line"></span><br><span class="line">    lock mutex              <span class="comment">// 锁</span></span><br><span class="line">    <span class="comment">// 下面是等待g的链表的头部跟尾部</span></span><br><span class="line">    head *sudog             <span class="comment">// 指向第一个sudog</span></span><br><span class="line">    tail *sudog             <span class="comment">// 指向最后一个sudog</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="NewCond"><a href="#NewCond" class="headerlink" title="NewCond"></a>NewCond</h3><p>创建一个condition variable，没什么好讲的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没什么好说的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h2><p>大概逻辑如下</p>
<ol>
<li>更新wait计数器，获得ticket，临时解锁cond，让其他goroutine可以获得ticket并挂起</li>
<li>将当前goroutine和ticket打包进sudog，放进队列，当前goroutine挂起陷入等待</li>
<li>goroutine被唤醒，加锁cond</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">//    c.L.Lock()</span></span><br><span class="line"><span class="comment">//    for !condition() &#123;</span></span><br><span class="line"><span class="comment">//        c.Wait()</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    ... make use of condition ...</span></span><br><span class="line"><span class="comment">//    c.L.Unlock()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 上层业务逻辑已加锁 =&gt; cond.L.Lock()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否被复制</span></span><br><span class="line">    c.checker.check()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait计数器更新</span></span><br><span class="line">    <span class="comment">// t = (c.notify.wait+=1) - 1</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁，其他g现在可以调用Wait了</span></span><br><span class="line">    c.L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前g挂起，等待唤醒（函数看下方notifyListWait）</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复加锁，由上层业务逻辑负责继续解锁 =&gt; cond.L.Unlock()</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime_notifyListWait函数</span></span><br><span class="line"><span class="comment">// sudog纪录g放入链表，g让出CPU挂起等待唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t是等待计数器wait，每次唤醒时notify计数器+1，任何wait&lt;notify的id说明该g已被/应被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取sudog</span></span><br><span class="line">    s := acquireSudog()</span><br><span class="line">    <span class="comment">// 封装当前g</span></span><br><span class="line">    s.g = getg()</span><br><span class="line">    <span class="comment">// ticket可以纪录一个uint32的数</span></span><br><span class="line">    s.ticket = t</span><br><span class="line">    <span class="comment">// 纪录g阻塞耗时</span></span><br><span class="line">    s.releasetime = <span class="number">0</span></span><br><span class="line">    t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">        s.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把sudog加到链表</span></span><br><span class="line">    <span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.head = s</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l.tail.next = s</span><br><span class="line">    &#125;</span><br><span class="line">    l.tail = s</span><br><span class="line">    <span class="comment">// 当前g让出CPU，g0执行调度运行其他g</span></span><br><span class="line">    <span class="comment">// 在内部g、m解除绑定后会解锁l.lock</span></span><br><span class="line">    goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceBlockCondWait, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 纪录阻塞事件</span></span><br><span class="line">        blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放sudog</span></span><br><span class="line">    releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>大概逻辑如下</p>
<ol>
<li>如果waiter数量为0（wait&#x3D;&#x3D;notify），不处理</li>
<li>根据notify计算出待唤醒的waiter_id，并更新notify</li>
<li>在sudog列表查找ticket&#x3D;&#x3D;waiter_id的goroutine，将其唤醒</li>
<li>如果goroutine在wait时就接到信号，那么它肯定不在sudog列表，不处理</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒一个g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 按顺序唤醒一个g（看下方notifyListNotifyOne）</span></span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime_notifyListNotifyOne函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 每次唤醒时notify计数器+1，任何wait&lt;notify的id说明该g已被/应被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> l.wait.Load() == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应被唤醒的g的id</span></span><br><span class="line">    t := l.notify</span><br><span class="line">    <span class="comment">// wait计数器==notify计数器，g已被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> t == l.wait.Load() &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// notify计数器+=1</span></span><br><span class="line">    atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历sudog链表</span></span><br><span class="line">    <span class="comment">// prev，curr = nil, l.head</span></span><br><span class="line">    <span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">        <span class="comment">// ticket相同，找到了</span></span><br><span class="line">        <span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">            <span class="comment">// 下一个sudog</span></span><br><span class="line">            n := s.next</span><br><span class="line">            <span class="comment">// prev不为nil，将其与next相连接</span></span><br><span class="line">            <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">                p.next = n</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l.head = n</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">                l.tail = p</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;l.lock)</span><br><span class="line">            <span class="comment">// 当前sudog的一些字段都要重置</span></span><br><span class="line">            s.next = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">// 测试，忽略</span></span><br><span class="line">            <span class="keyword">if</span> s.g.syncGroup != <span class="literal">nil</span> &amp;&amp; getg().syncGroup != s.g.syncGroup &#123;</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;semaphore wake of synctest goroutine&quot;</span>, s.g.goid, <span class="string">&quot;from outside bubble&quot;</span>)</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;semaphore wake of synctest goroutine from outside bubble&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 纪录releasetime，调用goready唤醒g</span></span><br><span class="line">            <span class="comment">// 将g放到本地队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">            readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到sudog</span></span><br><span class="line">    unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h2><p>大概逻辑如下</p>
<ol>
<li>如果waiter数量为0（wait&#x3D;&#x3D;notify），不处理</li>
<li>更新notify，使其等于wait</li>
<li>扫描sudog列表，逐个唤醒goroutine</li>
<li>如果goroutine在wait时就接到信号，那么它肯定不在sudog列表，不处理</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 唤醒所有goroutine（看下方notifyListNotifyAll）</span></span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 每次唤醒时notify计数器+1，任何wait&lt;notify的id说明该g已被/应被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> l.wait.Load() == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line">    <span class="comment">// 获取整个sudog链表</span></span><br><span class="line">    s := l.head</span><br><span class="line">    <span class="comment">// 重置head和tail</span></span><br><span class="line">    l.head = <span class="literal">nil</span></span><br><span class="line">    l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使两个计数器数值相等</span></span><br><span class="line">    atomic.Store(&amp;l.notify, l.wait.Load())</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历sudog链表</span></span><br><span class="line">    <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">        next := s.next</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        s.next = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        <span class="keyword">if</span> s.g.syncGroup != <span class="literal">nil</span> &amp;&amp; getg().syncGroup != s.g.syncGroup &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;semaphore wake of synctest goroutine&quot;</span>, s.g.goid, <span class="string">&quot;from outside bubble&quot;</span>)</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;semaphore wake of synctest goroutine from outside bubble&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 纪录releasetime，调用goready唤醒g</span></span><br><span class="line">        <span class="comment">// 将g放到本地队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">        s = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://victoriametrics.com/blog/go-sync-cond/index.html">Go sync.Cond, the Most Overlooked Sync Mechanism</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Map</title>
    <url>/golang-series-sync-map/</url>
    <content><![CDATA[<p>map不支持并发读写，但我们可以转变下思路，将value改为一个指向结构体entry的指针，结构体内部的字段我们是可以随意修改的，如下，将并发读写map改为并发读map，读写转移到entry</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]*entry</span><br></pre></td></tr></table></figure>

<p>上面的方法看起来解决了并发读写的问题，但还不够，当有新的key写入时，还是变回了原来的map并发读写。sync.Map提供了一种思路，使用两个map，read负责已有key的并发读写，dirty负责新key的读写，只有当read找不到key，才去找dirty。</p>
<p>现在还剩最后一个问题，read和dirty如何保证数据一致&#x2F;同步，我们可以改造entry，使其指向value的指针，如此一来，read和dirty的entry可以指向同一个value，如下，这就是sync.Map的大致思路</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p *any</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read  -&gt; key0|*entry0         entry0.p -&gt; &amp;value</span></span><br><span class="line"><span class="comment">//       -&gt; key1|*entry1</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// dirty -&gt; key0|*entry0</span></span><br><span class="line"><span class="comment">//       -&gt; key1|*entry1</span></span><br><span class="line"><span class="comment">//       -&gt; key2|*entry2</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>尽管如此，sync.Map并不完美，以上设计导致我们无法直接计算出哈希表的元素数量，需要遍历进行统计，而且还不一定准确</p>
<p>当前go版本：1.23，1.24版本改为HashTrieMap实现</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> syncMap sync.Map</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写</span></span><br><span class="line">    syncMap.Store(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;VictoriaMetrics&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读</span></span><br><span class="line">    value, ok := syncMap.Load(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">    fmt.Println(value, ok)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    syncMap.Delete(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">    value, ok = syncMap.Load(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">    fmt.Println(value, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># VictoriaMetrics true</span></span><br><span class="line"><span class="comment"># &lt;nil&gt; false</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sync/map.go</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex                        <span class="comment">// dirty锁</span></span><br><span class="line">    read atomic.Pointer[readOnly]   <span class="comment">// 负责已有key的读写</span></span><br><span class="line">    dirty <span class="keyword">map</span>[any]*entry            <span class="comment">// 负责新key的读写，替换read后设置为nil</span></span><br><span class="line">    misses <span class="type">int</span>                      <span class="comment">// 计数器，如果read找不到key时加一，当misses==len(dirty)，用dirty替换掉read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map+amended</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    m       <span class="keyword">map</span>[any]*entry          <span class="comment">// </span></span><br><span class="line">    amended <span class="type">bool</span>                    <span class="comment">// 修正，当dirty有新的key写入时为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针-运行时生成，表示数据已完全删除</span></span><br><span class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any)</span><br><span class="line"></span><br><span class="line"><span class="comment">// value的封装，被read和dirty共享</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p atomic.Pointer[any]           <span class="comment">// 指针-任意类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里值得注意的是entry的p指针，有三个状态</p>
<table>
<thead>
<tr>
<th align="left">p</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;value</td>
<td align="left">正常状态</td>
</tr>
<tr>
<td align="left">nil</td>
<td align="left">已删除，可以当作是墓碑来理解</td>
</tr>
<tr>
<td align="left">expunged</td>
<td align="left">dirty替代read时，从nil改为expunged，在下一轮替换中，移除该key</td>
</tr>
</tbody></table>
<p>三种状态转移路线：</p>
<ol>
<li>&amp;value   -&gt; nil -&gt; expunged</li>
<li>expunged -&gt; nil -&gt; &amp;value</li>
</ol>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>根据key获取value，具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，返回</li>
<li>加锁，再找一遍read，如果找到，返回（double-check）</li>
<li>amended为true表示dirty有新的key，在dirty找</li>
<li>更新misses计数器，如果misses&#x3D;&#x3D;len(dirty)，用dirty替换掉read</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key any) (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 没找到但dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 在dirty找</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// misses++</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取m.read</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> loadReadOnly() readOnly &#123;</span><br><span class="line">    <span class="keyword">if</span> p := m.read.Load(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readOnly&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="comment">// 已删除</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// misses计数器更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// misses == len(m.dirty)</span></span><br><span class="line">    <span class="comment">// 用dirty替换read</span></span><br><span class="line">    m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>存储key&#x2F;value。本质就是Swap方法，但丢弃其返回值，具体看Swap</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    _, _ = m.Swap(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadOrStore"><a href="#LoadOrStore" class="headerlink" title="LoadOrStore"></a>LoadOrStore</h3><p>根据key获取value，如果没有该key&#x2F;value，则改为写入。该方法逻辑与Swap方法十分相似</p>
<p>具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，返回</li>
<li>加锁，再找一遍read，如果找到，返回（double-check）</li>
<li>如果在dirty找到，获取&#x2F;更新key，同时更新misses计数器，返回</li>
<li>都没找到说明是新key，写入dirty，返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value any) (actual any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// e有数值则获取，没有则更新并获取</span></span><br><span class="line">        actual, loaded, ok := e.tryLoadOrStore(value)</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> actual, loaded</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在read中没找到（dirty可能有）</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 在read找到</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// e指针从expunged改为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 凡是expunged变为nil状态的，read要同步到dirty</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 在dirty找到</span></span><br><span class="line">        actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">        <span class="comment">// misses++</span></span><br><span class="line">        m.missLocked()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dirty也没有 =&gt; 全新写入</span></span><br><span class="line">        <span class="comment">// 有新的key写入，需要更新amended</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            <span class="comment">// 克隆read到dirty（只保留未删除的纪录）</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            <span class="comment">// 有新key写入，需要将amended改为true</span></span><br><span class="line">            m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 凡是新key，都放在dirty</span></span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">        actual, loaded = value, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> actual, loaded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有数值则获取，没有则更新并获取返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryLoadOrStore(i any) (actual any, loaded, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="comment">// 完全删除</span></span><br><span class="line">    <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不为nil</span></span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *p, <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为nil</span></span><br><span class="line">    ic := i</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 替换成功</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, &amp;ic) &#123;</span><br><span class="line">            <span class="keyword">return</span> i, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重复上面的操作</span></span><br><span class="line">        p = e.p.Load()</span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *p, <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e指针从expunged改为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> unexpungeLocked() (wasExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> e.p.CompareAndSwap(expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">    <span class="comment">// dirty已经存在了，忽略</span></span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 创建dirty，与read同等大小</span></span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="comment">// 把nil的entry改为expunged</span></span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 其他非删除数据复制到dirty</span></span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.p指针从nil改为expunged</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// nil -&gt; expunged</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = e.p.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>删除指定key，具体看LoadAndDelete</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key any) &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadAndDelete"><a href="#LoadAndDelete" class="headerlink" title="LoadAndDelete"></a>LoadAndDelete</h3><p>逻辑与Load相似，具体如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，将entry置为nil</li>
<li>加锁，再找一遍read，如果找到，将entry置为nil（double-check）</li>
<li>amended为true表示dirty有新的key，在dirty找</li>
<li>更新misses计数器，如果misses&#x3D;&#x3D;len(dirty)，将dirty迁移到read</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key any) (value any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 没找到但dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 在dirty找</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// read没有但dirty有，直接删除</span></span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">            <span class="comment">// misses++</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="comment">// e.p改为nil</span></span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.p改为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 已删除</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndDelete"><a href="#CompareAndDelete" class="headerlink" title="CompareAndDelete"></a>CompareAndDelete</h3><p>具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，纪录e</li>
<li>加锁，再找一遍read，如果找到，纪录e（double-check）</li>
<li>amended为true表示dirty有新的key，在dirty找</li>
<li>更新misses计数器，如果misses&#x3D;&#x3D;len(dirty)，用dirty替换掉read</li>
<li>已删除或比对失败返回false，否则将e.p置为nil，返回true</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> CompareAndDelete(key, old any) (deleted <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 没找到但dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 在dirty找</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// misses++</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ok &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 已删除或比对失败</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged || *p != old &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>使用value替换key当前存储的数据。具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，替换并返回</li>
<li>加锁，再找一遍read，如果找到，替换并返回（double-check）</li>
<li>如果在dirty找到，替换并返回</li>
<li>都没找到说明是新key，写入dirty，返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Swap(key, value any) (previous any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">if</span> v, ok := e.trySwap(&amp;value); ok &#123;</span><br><span class="line">            <span class="comment">// 已删除</span></span><br><span class="line">            <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有值，返回</span></span><br><span class="line">            <span class="keyword">return</span> *v, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在read中没找到（dirty可能有）</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 在read找到</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// e指针从expunged改为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 凡是expunged变为nil状态的，read要同步到dirty</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            loaded = <span class="literal">true</span></span><br><span class="line">            previous = *v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 在dirty找到</span></span><br><span class="line">        <span class="comment">// 修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            loaded = <span class="literal">true</span></span><br><span class="line">            previous = *v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dirty也没有 =&gt; 全新写入</span></span><br><span class="line">        <span class="comment">// 有新的key写入，需要更新amended</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            <span class="comment">// 克隆read到dirty（只保留未删除的纪录）</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            <span class="comment">// 有新key写入，需要将amended改为true</span></span><br><span class="line">            m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 凡是新key，都放在dirty</span></span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> previous, loaded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> trySwap(i *any) (*any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 已删除</span></span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换成功</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;</span><br><span class="line">            <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> swapLocked(i *any) *any &#123;</span><br><span class="line">    <span class="keyword">return</span> e.p.Swap(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h3><p>具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，替换并返回</li>
<li>如果dirty没有新key，到此为止，返回</li>
<li>加锁，再找一遍read，如果找到，替换并返回（double-check）</li>
<li>如果在dirty找到，替换并返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> CompareAndSwap(key, old, <span class="built_in">new</span> any) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 尝试修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">return</span> e.tryCompareAndSwap(old, <span class="built_in">new</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">        <span class="comment">// 没找到，dirty也没有新key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在read中没找到但dirty可能有</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    swapped = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        swapped = e.tryCompareAndSwap(old, <span class="built_in">new</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 在dirty找到</span></span><br><span class="line">        <span class="comment">// 尝试修改指针指向新的value</span></span><br><span class="line">        swapped = e.tryCompareAndSwap(old, <span class="built_in">new</span>)</span><br><span class="line">        <span class="comment">// misses++</span></span><br><span class="line">        m.missLocked()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> swapped</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryCompareAndSwap(old, <span class="built_in">new</span> any) <span class="type">bool</span> &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="comment">// 已删除或比对失败</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged || *p != old &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子替换</span></span><br><span class="line">    nc := <span class="built_in">new</span> <span class="comment">// 优化，具体看原注释</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, &amp;nc) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = e.p.Load()</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged || *p != old &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>具体逻辑如下</p>
<ol>
<li>复制read，如果dirty有新key写入，则复制dirty并用dirty替换read</li>
<li>遍历哈希表</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value any)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 复制read</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">            <span class="comment">// 复制dirty</span></span><br><span class="line">            read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">            copyRead := read</span><br><span class="line">            <span class="comment">// 用dirty替换掉read</span></span><br><span class="line">            m.read.Store(&amp;copyRead)</span><br><span class="line">            m.dirty = <span class="literal">nil</span></span><br><span class="line">            m.misses = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希表</span></span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        v, ok := e.load()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h3><p>具体逻辑如下</p>
<ol>
<li>read为空且dirty也为空，返回</li>
<li>read不为空或者dirty有新数据<ul>
<li>复制read并将read置空</li>
<li>将dirty清空</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Clear() &#123;</span><br><span class="line">    <span class="comment">// 复制read</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// read为空且dirty也为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(read.m) == <span class="number">0</span> &amp;&amp; !read.amended &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read不为空或者dirty有新数据</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制read</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    <span class="comment">// read置空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(read.m) &gt; <span class="number">0</span> || read.amended &#123;</span><br><span class="line">        m.read.Store(&amp;readOnly&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirty清空</span></span><br><span class="line">    clear(m.dirty)</span><br><span class="line">    <span class="comment">// Don&#x27;t immediately promote the newly-cleared dirty map on the next operation.</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://victoriametrics.com/blog/go-sync-map/index.html">Go sync.Map: The Right Tool for the Right Job</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync/atomic</title>
    <url>/golang-series-sync-atomic/</url>
    <content><![CDATA[<p>sync&#x2F;atomic标准库包中提供的原子操作。原子操作是无锁的，直接通过CPU指令实现。</p>
<p>当你想要在多个goroutine中无锁访问一个变量时，就可以考虑使用atomic包提供的数据类型实现</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>以下是一个使用atomic.Uint64数据类型实现的计数器，它确保了多个goroutine按顺序正确更新数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ops atomic.Uint64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line"></span><br><span class="line">                ops.Add(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;ops:&quot;</span>, ops.Load())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><p>sync&#x2F;atomic包中，通用的数据结构有</p>
<ul>
<li><code>Value</code></li>
</ul>
<p>使用Value可以存储任意类型的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    v any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// efaceWords is interface&#123;&#125; internal representation.</span></span><br><span class="line"><span class="keyword">type</span> efaceWords <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ  unsafe.Pointer</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他具体的数据结构有</p>
<ul>
<li><code>Bool</code></li>
<li><code>Int32</code></li>
<li><code>Int64</code></li>
<li><code>Uint32</code></li>
<li><code>Uint64</code></li>
<li><code>Uintptr</code></li>
<li><code>Pointer</code></li>
</ul>
<p>举个例子，Pointer类型的数据结构如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Pointer is an atomic pointer of type *T. The zero value is a nil *T.</span></span><br><span class="line"><span class="keyword">type</span> Pointer[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Mention *T in a field to disallow conversion between Pointer types.</span></span><br><span class="line">    <span class="comment">// See go.dev/issue/56603 for more details.</span></span><br><span class="line">    <span class="comment">// Use *T, not T, to avoid spurious recursive type definition errors.</span></span><br><span class="line">    _ [<span class="number">0</span>]*T</span><br><span class="line"></span><br><span class="line">    _ noCopy</span><br><span class="line">    v unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>基本上，atomic提供的数据类型有几个通用的方法：Load、Store、Swap、CompareAndSwap</p>
<p>下面展示一个基本的使用方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init  -&gt; v=nil</span></span><br><span class="line">v := atomic.Value&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store -&gt; v=1</span></span><br><span class="line">v.Store(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// load</span></span><br><span class="line"><span class="comment">// print 1</span></span><br><span class="line">fmt.Println(v.Load())</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap  -&gt; v=2</span></span><br><span class="line"><span class="comment">// print 1</span></span><br><span class="line">fmt.Println(v.Swap(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// print 2</span></span><br><span class="line">fmt.Println(v.Load())</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS   -&gt; v=3</span></span><br><span class="line"><span class="comment">// print true</span></span><br><span class="line">fmt.Println(v.CompareAndSwap(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// print 3</span></span><br><span class="line">fmt.Println(v.Load())</span><br></pre></td></tr></table></figure>

<h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>获取atomic类型存储的数值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Load returns the value set by the most recent Store.</span></span><br><span class="line"><span class="comment">// It returns nil if there has been no call to Store for this Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (val any) &#123;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">    <span class="keyword">if</span> typ == <span class="literal">nil</span> || typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">        <span class="comment">// First store not yet completed.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    data := LoadPointer(&amp;vp.data)</span><br><span class="line">    vlp := (*efaceWords)(unsafe.Pointer(&amp;val))</span><br><span class="line">    vlp.typ = typ</span><br><span class="line">    vlp.data = data</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>更新&#x2F;覆盖atomic类型的数值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Store sets the value of the [Value] v to val.</span></span><br><span class="line"><span class="comment">// All calls to Store for a given Value must use values of the same concrete type.</span></span><br><span class="line"><span class="comment">// Store of an inconsistent type panics, as does Store(nil).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(val any) &#123;</span><br><span class="line">    <span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of nil value into Value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    vlp := (*efaceWords)(unsafe.Pointer(&amp;val))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Attempt to start first store.</span></span><br><span class="line">            <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">            <span class="comment">// active spin wait to wait for completion.</span></span><br><span class="line">            runtime_procPin()</span><br><span class="line">            <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">                runtime_procUnpin()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Complete first store.</span></span><br><span class="line">            StorePointer(&amp;vp.data, vlp.data)</span><br><span class="line">            StorePointer(&amp;vp.typ, vlp.typ)</span><br><span class="line">            runtime_procUnpin()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">            <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">            <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">            <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">        <span class="keyword">if</span> typ != vlp.typ &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        StorePointer(&amp;vp.data, vlp.data)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>类似Store，更新atomic类型的数值-&gt;newVal，并返回先前数值-&gt;oldVal</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swap stores new into Value and returns the previous value. It returns nil if</span></span><br><span class="line"><span class="comment">// the Value is empty.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All calls to Swap for a given Value must use values of the same concrete</span></span><br><span class="line"><span class="comment">// type. Swap of an inconsistent type panics, as does Swap(nil).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Swap(<span class="built_in">new</span> any) (old any) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: swap of nil value into Value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    np := (*efaceWords)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Attempt to start first store.</span></span><br><span class="line">            <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">            <span class="comment">// active spin wait to wait for completion; and so that</span></span><br><span class="line">            <span class="comment">// GC does not see the fake type accidentally.</span></span><br><span class="line">            runtime_procPin()</span><br><span class="line">            <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">                runtime_procUnpin()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Complete first store.</span></span><br><span class="line">            StorePointer(&amp;vp.data, np.data)</span><br><span class="line">            StorePointer(&amp;vp.typ, np.typ)</span><br><span class="line">            runtime_procUnpin()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">            <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">            <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">            <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">        <span class="keyword">if</span> typ != np.typ &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: swap of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        op := (*efaceWords)(unsafe.Pointer(&amp;old))</span><br><span class="line">        op.typ, op.data = np.typ, SwapPointer(&amp;vp.data, np.data)</span><br><span class="line">        <span class="keyword">return</span> old</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h3><p>对比atomic类型当前数值，相同则更新并返回true，否则不处理并返回false</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CompareAndSwap executes the compare-and-swap operation for the [Value].</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All calls to CompareAndSwap for a given Value must use values of the same</span></span><br><span class="line"><span class="comment">// concrete type. CompareAndSwap of an inconsistent type panics, as does</span></span><br><span class="line"><span class="comment">// CompareAndSwap(old, nil).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> CompareAndSwap(old, <span class="built_in">new</span> any) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of nil value into Value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    vp := (*efaceWords)(unsafe.Pointer(v))</span><br><span class="line">    np := (*efaceWords)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">    op := (*efaceWords)(unsafe.Pointer(&amp;old))</span><br><span class="line">    <span class="keyword">if</span> op.typ != <span class="literal">nil</span> &amp;&amp; np.typ != op.typ &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of inconsistently typed values&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Attempt to start first store.</span></span><br><span class="line">            <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">            <span class="comment">// active spin wait to wait for completion; and so that</span></span><br><span class="line">            <span class="comment">// GC does not see the fake type accidentally.</span></span><br><span class="line">            runtime_procPin()</span><br><span class="line">            <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;</span><br><span class="line">                runtime_procUnpin()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Complete first store.</span></span><br><span class="line">            StorePointer(&amp;vp.data, np.data)</span><br><span class="line">            StorePointer(&amp;vp.typ, np.typ)</span><br><span class="line">            runtime_procUnpin()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;</span><br><span class="line">            <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">            <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">            <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">        <span class="keyword">if</span> typ != np.typ &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: compare and swap of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Compare old and current via runtime equality check.</span></span><br><span class="line">        <span class="comment">// This allows value types to be compared, something</span></span><br><span class="line">        <span class="comment">// not offered by the package functions.</span></span><br><span class="line">        <span class="comment">// CompareAndSwapPointer below only ensures vp.data</span></span><br><span class="line">        <span class="comment">// has not changed since LoadPointer.</span></span><br><span class="line">        data := LoadPointer(&amp;vp.data)</span><br><span class="line">        <span class="keyword">var</span> i any</span><br><span class="line">        (*efaceWords)(unsafe.Pointer(&amp;i)).typ = typ</span><br><span class="line">        (*efaceWords)(unsafe.Pointer(&amp;i)).data = data</span><br><span class="line">        <span class="keyword">if</span> i != old &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CompareAndSwapPointer(&amp;vp.data, data, np.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特定类型方法"><a href="#特定类型方法" class="headerlink" title="特定类型方法"></a>特定类型方法</h2><p>相对于其他，整型数有几个额外方法：Add、And、Or，相关类型是</p>
<ul>
<li><code>Int32</code></li>
<li><code>Int64</code></li>
<li><code>Uint32</code></li>
<li><code>Uint64</code></li>
<li><code>Uintptr</code></li>
</ul>
<p>示例代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">counter := <span class="type">int32</span>(<span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter += 1</span></span><br><span class="line">counter = atomic.AddInt32(&amp;counter, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// print 100</span></span><br><span class="line">fmt.Println(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0110 0100 &amp; 0000 0111 -&gt; 0000 0100 =&gt; 4</span></span><br><span class="line"><span class="comment">// print 100</span></span><br><span class="line">fmt.Println(atomic.AndInt32(&amp;counter, <span class="number">7</span>))</span><br><span class="line"><span class="comment">// print 4</span></span><br><span class="line">fmt.Println(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0100 | 0000 0010 -&gt; 0000 0110 =&gt; 6</span></span><br><span class="line"><span class="comment">// print 4</span></span><br><span class="line">fmt.Println(atomic.OrInt32(&amp;counter, <span class="number">2</span>))</span><br><span class="line"><span class="comment">// print 6</span></span><br><span class="line">fmt.Println(counter)</span><br></pre></td></tr></table></figure>

<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a><code>Add</code></h3><p>原子加法操作，两个数相加，返回结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/runtime/atomic/atomic_amd64.s</span></span><br><span class="line"><span class="comment">// src/sync/atomic/type.go</span></span><br><span class="line"><span class="comment">// Add atomically adds delta to x and returns the new value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int64)</span></span> Add(delta <span class="type">int64</span>) (<span class="built_in">new</span> <span class="type">int64</span>) &#123; <span class="keyword">return</span> AddInt64(&amp;x.v, delta) &#125;</span><br></pre></td></tr></table></figure>

<p>AddInt64汇编代码如下，本人对汇编代码不了解，下面的注释是由ChatGPT提供的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// uint64 Xadd64(uint64 volatile *val, int64 delta)</span><br><span class="line">// Atomically:</span><br><span class="line">//    *val += delta;</span><br><span class="line">//    return *val;</span><br><span class="line">TEXT ·Xadd64(SB), NOSPLIT, $0-24</span><br><span class="line">    MOVQ    ptr+0(FP), BX       // ptr（val 的地址）被加载到寄存器 BX 中</span><br><span class="line">    MOVQ    delta+8(FP), AX     // delta 被加载到寄存器 AX 中</span><br><span class="line">    MOVQ    AX, CX              // 复制 AX 的值到 CX，以便后面能把 delta 加到返回值中</span><br><span class="line">    LOCK                        // 确保接下来的操作是原子性的</span><br><span class="line">    XADDQ    AX, 0(BX)           // 指令会将 AX 加到 BX 指向的值，并返回加法操作前的旧值（旧值会存入 AX）</span><br><span class="line">    ADDQ    CX, AX              // 将之前存储的delta加回AX上，得到最终结果</span><br><span class="line">    MOVQ    AX, ret+16(FP)      // 把最终的结果存入返回值地址</span><br><span class="line">    RET                         // 返回</span><br><span class="line"></span><br><span class="line">TEXT ·Xaddint64(SB), NOSPLIT, $0-24</span><br><span class="line">    JMP    ·Xadd64(SB)</span><br></pre></td></tr></table></figure>

<p>更多的注释如下</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>TEXT</code></td>
<td align="left">标志这段代码是一个函数</td>
</tr>
<tr>
<td align="left"><code>·Xadd64(SB)</code></td>
<td align="left">函数名称</td>
</tr>
<tr>
<td align="left"><code>SB</code></td>
<td align="left">是指向当前函数栈帧的偏移量，传递给 racecallatomic 作为栈帧的指针。</td>
</tr>
<tr>
<td align="left"><code>NOSPLIT</code></td>
<td align="left">表示该函数不会执行栈分割，也就是说，它不会访问 Go 层的栈分配</td>
</tr>
<tr>
<td align="left"><code>$0-24</code></td>
<td align="left">指示函数参数的大小范围，在这种情况下，0-24 意味着该函数有 24 字节的局部空间（用于存储传入的参数等）</td>
</tr>
</tbody></table>
<h3 id="And"><a href="#And" class="headerlink" title="And"></a><code>And</code></h3><p>原子位与（&amp;）操作，新结果写入变量，返回旧的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// And atomically performs a bitwise AND operation on x using the bitmask</span></span><br><span class="line"><span class="comment">// provided as mask and returns the old value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int64)</span></span> And(mask <span class="type">int64</span>) (old <span class="type">int64</span>) &#123; <span class="keyword">return</span> AndInt64(&amp;x.v, mask) &#125;</span><br></pre></td></tr></table></figure>

<p>AndInt64汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEXT    sync∕atomic·AndInt64(SB), NOSPLIT|NOFRAME, $0-24    // </span><br><span class="line">    GO_ARGS</span><br><span class="line">    MOVQ    $__tsan_go_atomic64_fetch_and(SB), AX</span><br><span class="line">    CALL    racecallatomic&lt;&gt;(SB)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<p>相关注释如下，只展示与AddInt64汇编代码不同的部份</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>GO_ARGS</code></td>
<td align="left">这是一个宏，表示处理传入的 Go 参数，具体的参数内容会根据函数调用的上下文进行调整。这是 Go 编译器用来处理函数调用时的一些约定。它会将传入的参数从 Go 栈中提取到寄存器中</td>
</tr>
<tr>
<td align="left"><code>__tsan_go_atomic64_fetch_and</code></td>
<td align="left">是一个标识符，Go 在进行原子操作时，通常会使用一个特殊的函数来标识和追踪潜在的数据竞争。这种操作确保了线程安全，并且在并发环境中避免了出现未同步的数据访问</td>
</tr>
<tr>
<td align="left"><code>racecallatomic</code></td>
<td align="left">Go 的一个内建函数，用来执行原子操作并同时为 ThreadSanitizer（TSan）提供监控支持。它会根据 AX 寄存器中存储的函数地址（即 __tsan_go_atomic64_fetch_and）执行对应的操作</td>
</tr>
<tr>
<td align="left"><code>&lt;&gt;</code></td>
<td align="left">表示泛型类型参数，在 Go 汇编中表示函数的参数类型。racecallatomic 函数会根据这些类型参数来处理实际的原子操作。</td>
</tr>
</tbody></table>
<h3 id="Or"><a href="#Or" class="headerlink" title="Or"></a><code>Or</code></h3><p>原子位或（|）操作，新结果写入变量，返回旧的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Or atomically performs a bitwise OR operation on x using the bitmask</span></span><br><span class="line"><span class="comment">// provided as mask and returns the old value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Int64)</span></span> Or(mask <span class="type">int64</span>) (old <span class="type">int64</span>) &#123; <span class="keyword">return</span> OrInt64(&amp;x.v, mask) &#125;</span><br></pre></td></tr></table></figure>

<p>OrInt64的汇编代码如下，不再展示注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEXT    sync∕atomic·OrInt64(SB), NOSPLIT|NOFRAME, $0-24</span><br><span class="line">    GO_ARGS</span><br><span class="line">    MOVQ    $__tsan_go_atomic64_fetch_or(SB), AX</span><br><span class="line">    CALL    racecallatomic&lt;&gt;(SB)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://pkg.go.dev/sync/atomic">atomic</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Mutex</title>
    <url>/golang-series-sync-mutex/</url>
    <content><![CDATA[<p>Mutex（MUTualEx）-互斥锁是一种可以保证每次只有一个goroutine访问贡献资源的方法。这个资源可以是一段程序代码、一个整数、一个map、一个struct、一个channel或其他任何东西。通过观察Mutex的源代码实现，可以将Mutex看作是一个队列（FIFO&#x2F;LIFO），具体看后面的详细描述</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu       sync.Mutex</span><br><span class="line">    counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span></span> inc(name <span class="type">string</span>) &#123;</span><br><span class="line">    c.mu.Lock()         <span class="comment">// 互斥锁，获取失败等待挂起</span></span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">    c.counters[name]++  <span class="comment">// 共享资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Container&#123;</span><br><span class="line">        counters: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">0</span>, <span class="string">&quot;b&quot;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    doIncrement := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            c.inc(name)</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> doIncrement(<span class="string">&quot;a&quot;</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">go</span> doIncrement(<span class="string">&quot;a&quot;</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">go</span> doIncrement(<span class="string">&quot;b&quot;</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(c.counters)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># map[a:20000 b:10000]</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>sync.Mutex提供的数据结构跟方法只是一层封装，实际的代码放在<code>src/internal/sync/mutex.go</code></p>
<p>Mutex的数据结构由state、sema字段组成，其中state是由三个状态位和一个29位的waiter计数器组成，sema使waiter陷入等待</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/sync/mutex.go</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 由29位的waiter_counter和3个状态位组成，结构如下</span></span><br><span class="line">    <span class="comment">// | &lt;- 29bit -&gt;    | 1bit          | 1bit       | 1bit        |</span></span><br><span class="line">    <span class="comment">// | waiter_counter | mutexStarving | mutexWoken | mutexLocked |</span></span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    <span class="comment">// semaphore</span></span><br><span class="line">    sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>mutex分为Normal-普通模式和Starvation-饥饿模式，两个模式的区别如下</p>
<p><strong>普通模式</strong></p>
<ol>
<li>新的goroutine不会进入队列排队等待，而是会尝试通过自旋抢占锁，排队中的goroutine会陷入更长时间的等待</li>
<li>当goroutine释放锁时，因为支持锁被抢占（避免CPU上下文切换）的缘故，不一定会唤醒其他goroutine</li>
</ol>
<p><strong>饥饿模式</strong></p>
<ol>
<li>禁止自旋抢占，在goroutine释放锁时，一定会唤醒队列中的其他goroutine</li>
</ol>
<p><strong>注意</strong></p>
<p>只有被唤醒woken的goroutine才能等待锁释放，其他都要挂起排队等待被唤醒</p>
<h3 id="状态位"><a href="#状态位" class="headerlink" title="状态位"></a>状态位</h3><p>mutex的三个状态位说明如下</p>
<p><strong>mutexLocked</strong></p>
<p>第1位，为0表示未锁定，为1表示已锁定</p>
<p><strong>mutexWoken</strong></p>
<p>第2位，只在普通模式使用，有woken位才能等待锁释放，该位可被新goroutine抢占。注意：goroutine在Unlock时如果判断有该标志位则不能唤醒队列中的goroutine</p>
<p><strong>mutexStarving</strong></p>
<p>第3位，goroutine等待超过1ms时设置该位，如果当前G的等待时间小于1ms或者是队列中最后一个排队的G则取消该位。该位被设置时的具体行为见上面饥饿模式的介绍</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>Mutex的方法有Lock、Unlock、TryLock，具体如下</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>大概逻辑如下</p>
<ol>
<li>CAS获取锁，成功返回</li>
<li>满足条件则进入自旋等待锁释放</li>
<li>更新state<ul>
<li>获取锁成功，返回（普通模式）</li>
<li>失败则挂起等待唤醒</li>
<li>唤醒后<ul>
<li>如果不是饥饿模式，回到第2步重试</li>
<li>如果是饥饿模式，直接获取锁返回</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// 设置locked位成功，返回</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="type">int64</span>     <span class="comment">// 用于计算等待耗时</span></span><br><span class="line">    starving := <span class="literal">false</span>           <span class="comment">// 排队等待超过1ms，进入饥饿模式</span></span><br><span class="line">    awoke := <span class="literal">false</span>              <span class="comment">// 普通模式自旋抢占锁</span></span><br><span class="line">    iter := <span class="number">0</span>                   <span class="comment">// 自旋计数器，最多4次，被唤醒后重置</span></span><br><span class="line">    old := m.state              <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 普通模式，进入自旋等待锁的释放</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">            <span class="comment">// 尝试抢占woken位，让Unlock方法不要唤醒其他goroutine</span></span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进入自旋等待</span></span><br><span class="line">            runtime_doSpin()</span><br><span class="line">            iter++</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 其他情况：饥饿模式 or 锁可用 or 自旋次数过多</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        <span class="comment">// 普通模式</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked <span class="comment">// 饥饿模式下不能动这个位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 饥饿模式 or 锁被占用</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 只要没拿到锁就等待，waiter_counter++</span></span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前G陷入饥饿 and 锁被占用</span></span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving <span class="comment">// 已经是饥饿模式的话不用再设置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通模式下被唤醒，清除woken位</span></span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清除woken位</span></span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 普通模式 获取锁成功</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 队列进出策略是LIFO还是FIFO</span></span><br><span class="line">            <span class="comment">// LIFO：如果被挂起等待好几次了，放队列前面</span></span><br><span class="line">            <span class="comment">// FIFO：新的goroutine，放队列后面</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试获取m.sema，失败则挂起等待</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">2</span>)</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算耗时，如果当前goroutine等待超过1ms，进入饥饿状态</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒后再一次读取state</span></span><br><span class="line">            old = m.state</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 饥饿模式</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Unlock已经将mutexLocked位设置为0</span></span><br><span class="line">                <span class="comment">// 饥饿模式下，Unlock唤醒goroutine时不会设置mutexWoken位，也不会更新waiter数量，由当前goroutine处理</span></span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// delta = 1-2^3 =&gt; -7 (0b00000111)</span></span><br><span class="line">                delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前G运行不超过1ms or 当前G是最后一个waiter</span></span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="comment">// delta -= 4 (0b00001011)</span></span><br><span class="line">                    delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 初始状态-delta -&gt; 结果状态</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 示例1：饥饿模式+两个排队的goroutine</span></span><br><span class="line">                <span class="comment">// 10 100 - 00 111(7)  -&gt; 01 101</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="comment">// 示例2：饥饿模式+1个排队的goroutine</span></span><br><span class="line">                <span class="comment">// 01 100 - 01 011(11) -&gt; 00 001</span></span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="comment">// 获取锁成功</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以下两个字段影响普通模式，对饥饿模式没影响</span></span><br><span class="line">            awoke = <span class="literal">true</span>    <span class="comment">// 唤醒后设置为true，因为woken标志位在goroutine唤醒时已设置，见Unlock</span></span><br><span class="line">            iter = <span class="number">0</span>        <span class="comment">// 可以重新进入自旋</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 更新失败，再一次读取state</span></span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname internal_sync_runtime_canSpin internal/sync.runtime_canSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internal_sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 自旋次数不能超过4次</span></span><br><span class="line">    <span class="comment">// 2. cpu只有一个的话不能自旋</span></span><br><span class="line">    <span class="comment">// 3. 不能有大量的空闲、自旋的goroutine</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= sched.npidle.Load()+sched.nmspinning.Load()+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前P的runq不为空，不应该自旋</span></span><br><span class="line">    <span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname internal_sync_runtime_SemacquireMutex internal/sync.runtime_SemacquireMutex</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internal_sync_runtime_SemacquireMutex</span><span class="params">(addr *<span class="type">uint32</span>, lifo <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile, skipframes, waitReasonSyncMutexLock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryLock"><a href="#TryLock" class="headerlink" title="TryLock"></a>TryLock</h3><p>大概逻辑如下</p>
<ol>
<li>获取state判断，如果锁被其他goroutine获取则返回false</li>
<li>锁可以被获取则使用CAS尝试获得锁，失败返回false，成功返回true</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> TryLock() <span class="type">bool</span> &#123;</span><br><span class="line">    old := m.state</span><br><span class="line">    <span class="comment">// 锁被其他goroutine获取 or 饥饿模式</span></span><br><span class="line">    <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置locked位</span></span><br><span class="line">    <span class="comment">// 直接return不行？</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><p>大概逻辑如下</p>
<ol>
<li>state-1，非常理想的情况下，如没有排队的goroutine，则state为0</li>
<li>如果unlock了一个unlocked的mutex，异常，不允许这么做</li>
<li>普通模式下因为支持抢占的原因，需要根据woken标记判断是否要唤醒队列中的goroutine</li>
<li>饥饿模式下直接唤醒一个goroutine</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// locked置0</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="comment">// 有waiter or 饥饿模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">        m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 异常，不能unlock已经unlocked的mutex</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否要去唤醒goroutine</span></span><br><span class="line">            <span class="comment">// 1. waiter数量为0，不用唤醒</span></span><br><span class="line">            <span class="comment">// 2. 锁已经被其他goroutine获取</span></span><br><span class="line">            <span class="comment">// 3. 如果有goroutine被唤醒，那么不再唤醒其他</span></span><br><span class="line">            <span class="comment">// 4. 饥饿模式不走这个逻辑</span></span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// waiter数量减一 并 设置woken位</span></span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                <span class="comment">// 唤醒一个goroutine</span></span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败重试</span></span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 饥饿模式，没有减少counter，也没有设置woken位</span></span><br><span class="line">        <span class="comment">// 唤醒一个goroutine</span></span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://victoriametrics.com/blog/go-sync-mutex/index.html">Go sync.Mutex: Normal and Starvation Mode</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Once</title>
    <url>/golang-series-sync-once/</url>
    <content><![CDATA[<p>如果要实现如Singleton、Lazy Initialization模式，那么你需要了解sync.Once，它可以用于保证如：只加载一次配置文件、只初始化一次数据库连接等，此外它还可以帮助实现更好的Plugin封装</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>以下代码展示了如何使用sync.Once实现singleton模式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    data <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Creating Singleton instance&quot;</span>)</span><br><span class="line">        instance = &amp;Singleton&#123;data: <span class="string">&quot;I&#x27;m the only one!&quot;</span>&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, GetInstance())</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for goroutines to finish</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>sync.Once的数据结构由一个atomic类型和一个mutex锁组成，通过加锁访问done标志判断</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// done indicates whether the action has been performed.</span></span><br><span class="line">    <span class="comment">// It is first in the struct because it is used in the hot path.</span></span><br><span class="line">    <span class="comment">// The hot path is inlined at every call site.</span></span><br><span class="line">    <span class="comment">// Placing done first allows more compact instructions on some architectures (amd64/386),</span></span><br><span class="line">    <span class="comment">// and fewer instructions (to calculate offset) on other architectures.</span></span><br><span class="line">    done atomic.Uint32</span><br><span class="line">    m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h3><p>Do方法的逻辑如下</p>
<ol>
<li>通过CAS原子操作读取done字段数据，如果值是1-已执行则立即返回，否则进入加锁状态</li>
<li>加锁，执行传入的函数代码，并更新done的数值</li>
</ol>
<p>原本代码的注释挺有用的，就不再赘述了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do calls the function f if and only if Do is being called for the</span></span><br><span class="line"><span class="comment">// first time for this instance of [Once]. In other words, given</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    var once Once</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// if once.Do(f) is called multiple times, only the first call will invoke f,</span></span><br><span class="line"><span class="comment">// even if f has a different value in each invocation. A new instance of</span></span><br><span class="line"><span class="comment">// Once is required for each function to execute.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do is intended for initialization that must be run exactly once. Since f</span></span><br><span class="line"><span class="comment">// is niladic, it may be necessary to use a function literal to capture the</span></span><br><span class="line"><span class="comment">// arguments to a function to be invoked by Do:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    config.once.Do(func() &#123; config.init(filename) &#125;)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because no call to Do returns until the one call to f returns, if f causes</span></span><br><span class="line"><span class="comment">// Do to be called, it will deadlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, Do considers it to have returned; future calls of Do return</span></span><br><span class="line"><span class="comment">// without calling f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">    <span class="comment">// Note: Here is an incorrect implementation of Do:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    if o.done.CompareAndSwap(0, 1) &#123;</span></span><br><span class="line">    <span class="comment">//        f()</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do guarantees that when it returns, f has finished.</span></span><br><span class="line">    <span class="comment">// This implementation would not implement that guarantee:</span></span><br><span class="line">    <span class="comment">// given two simultaneous calls, the winner of the cas would</span></span><br><span class="line">    <span class="comment">// call f, and the second would return immediately, without</span></span><br><span class="line">    <span class="comment">// waiting for the first&#x27;s call to f to complete.</span></span><br><span class="line">    <span class="comment">// This is why the slow path falls back to a mutex, and why</span></span><br><span class="line">    <span class="comment">// the o.done.Store must be delayed until after f returns.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> o.done.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">        o.doSlow(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="keyword">if</span> o.done.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> o.done.Store(<span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>从1.21版本开始，Austin Clements添加了三个sync.Once的封装：OnceFunc、OnceValue、OnceValues，方便写出更简洁紧凑的代码</p>
<h3 id="OnceFunc"><a href="#OnceFunc" class="headerlink" title="OnceFunc"></a>OnceFunc</h3><p>OnceFunc适合无任何返回值的业务逻辑，不适合用作Singleton、Lazy Initialization模式，下面是一个简单的示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    onceVoid := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    call := sync.OnceFunc(onceVoid)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        call()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnceFunc内部实现逻辑如下</p>
<ol>
<li>定义状态、封装传入的函数</li>
<li>只要f执行成功，更新状态，如将valid设置为true（已执行）</li>
<li>如果f的执行有panic，继续向上抛出异常</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OnceFunc returns a function that invokes f only once. The returned function</span></span><br><span class="line"><span class="comment">// may be called concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, the returned function will panic with the same value on every call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceFunc</span><span class="params">(f <span class="keyword">func</span>()</span></span>) <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        once  Once</span><br><span class="line">        valid <span class="type">bool</span></span><br><span class="line">        p     any</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// Construct the inner closure just once to reduce costs on the fast path.</span></span><br><span class="line">    g := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            p = <span class="built_in">recover</span>()</span><br><span class="line">            <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                <span class="comment">// Re-panic immediately so on the first call the user gets a</span></span><br><span class="line">                <span class="comment">// complete stack trace into f.</span></span><br><span class="line">                <span class="built_in">panic</span>(p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        f()</span><br><span class="line">        f = <span class="literal">nil</span>      <span class="comment">// Do not keep f alive after invoking it.</span></span><br><span class="line">        valid = <span class="literal">true</span> <span class="comment">// Set only if f does not panic.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        once.Do(g)</span><br><span class="line">        <span class="keyword">if</span> !valid &#123;</span><br><span class="line">            <span class="built_in">panic</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OnceValue"><a href="#OnceValue" class="headerlink" title="OnceValue"></a>OnceValue</h3><p>一般情况下，我们的业务逻辑使用用OnceValue即可，不够的话，还可以使用OnceValues，下面是使用OnceValue改造后的【快速上手】的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    data <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例/惰性加载</span></span><br><span class="line"><span class="keyword">var</span> instance = sync.OnceValue(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Creating Singleton instance&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;Singleton&#123;data: <span class="string">&quot;I&#x27;m the only one!&quot;</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, instance)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for goroutines to finish</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnceValue内部实现逻辑与OnceFunc一致，不同的是，内部增加了result字段用于缓存函数的返回值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OnceValue returns a function that invokes f only once and returns the value</span></span><br><span class="line"><span class="comment">// returned by f. The returned function may be called concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, the returned function will panic with the same value on every call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceValue</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(f <span class="keyword">func</span>()</span></span> T) <span class="function"><span class="keyword">func</span><span class="params">()</span></span> T &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        once   Once</span><br><span class="line">        valid  <span class="type">bool</span></span><br><span class="line">        p      any</span><br><span class="line">        result T</span><br><span class="line">    )</span><br><span class="line">    g := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            p = <span class="built_in">recover</span>()</span><br><span class="line">            <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                <span class="built_in">panic</span>(p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        result = f()</span><br><span class="line">        f = <span class="literal">nil</span></span><br><span class="line">        valid = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> T &#123;</span><br><span class="line">        once.Do(g)</span><br><span class="line">        <span class="keyword">if</span> !valid &#123;</span><br><span class="line">            <span class="built_in">panic</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OnceValues"><a href="#OnceValues" class="headerlink" title="OnceValues"></a>OnceValues</h3><p>与OnceValue不同的是，OnceValues会返回两个数值，很适合用于加载配置文件、创建数据库连接等。下面代码展示了如何使用OnceValues创建数据库连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/golang/go/issues/56102</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    db <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*sql.DB, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(dbPath <span class="type">string</span>)</span></span> *Server &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Server&#123;</span><br><span class="line">        db: sync.OnceFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*sql.DB, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sql.Open(<span class="string">&quot;sqlite&quot;</span>, dbPath)</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> DoSomething() <span class="type">error</span> &#123;</span><br><span class="line">    db, err := s.db()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    _ = db <span class="comment">// do something with db</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnceValues内部实现逻辑与OnceValue一致，不同的是，内部使用的是r1、r2两个字段用于缓存函数的返回值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OnceValues returns a function that invokes f only once and returns the values</span></span><br><span class="line"><span class="comment">// returned by f. The returned function may be called concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, the returned function will panic with the same value on every call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnceValues</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(f <span class="keyword">func</span>()</span></span> (T1, T2)) <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (T1, T2) &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        once  Once</span><br><span class="line">        valid <span class="type">bool</span></span><br><span class="line">        p     any</span><br><span class="line">        r1    T1</span><br><span class="line">        r2    T2</span><br><span class="line">    )</span><br><span class="line">    g := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            p = <span class="built_in">recover</span>()</span><br><span class="line">            <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                <span class="built_in">panic</span>(p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        r1, r2 = f()</span><br><span class="line">        f = <span class="literal">nil</span></span><br><span class="line">        valid = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (T1, T2) &#123;</span><br><span class="line">        once.Do(g)</span><br><span class="line">        <span class="keyword">if</span> !valid &#123;</span><br><span class="line">            <span class="built_in">panic</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1, r2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://cristiancurteanu.com/understanding-go-sync-once/">Understanding Golang’s sync.Once: Practical Examples in 2024</a><br><a href="https://github.com/golang/go/issues/56102">sync: add OnceFunc, OnceValue, OnceValues</a><br><a href="https://victoriametrics.com/blog/go-sync-once/index.html">Go sync.Once is Simple… Does It Really?</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Pool</title>
    <url>/golang-series-sync-pool/</url>
    <content><![CDATA[<p>sync.Pool-临时对象池，是golang一个很关键的数据结构，通过复用历史对象，缓解因频繁创建、删除对象而导致的内存分配压力、GC压力，在社区中被广泛使用，有如go-gin、kubernetes等</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>下面展示一个简单的使用示例，用于帮助用户快速上手</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> JobState <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    JobStateFresh JobState = <span class="literal">iota</span></span><br><span class="line">    JobStateRunning</span><br><span class="line">    JobStateRecycled</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    state JobState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *Job)</span></span> Run() &#123;</span><br><span class="line">    <span class="keyword">switch</span> j.state &#123;</span><br><span class="line">    <span class="keyword">case</span> JobStateRecycled:</span><br><span class="line">        fmt.Println(<span class="string">&quot;this job came from the pool&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> JobStateFresh:</span><br><span class="line">        fmt.Println(<span class="string">&quot;this job just got allocated&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j.state = JobStateRunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个对象池</span></span><br><span class="line">    pool := &amp;sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;Job&#123;state: JobStateFresh&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个对象，可以是新建的或者是历史使用过的</span></span><br><span class="line">    job := pool.Get().(*Job)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行业务代码</span></span><br><span class="line">    job.Run()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset状态并放回池子里，方便下次使用</span></span><br><span class="line">    job.state = JobStateRecycled</span><br><span class="line">    pool.Put(job)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>sync.Pool的源代码注释被我删除了，建议自行查看源代码，简单总结如下</p>
<ol>
<li>sync.Pool用于临时对象服务存储&#x2F;获取（临时对象可能随时被清理掉）</li>
<li>sync.Pool是线程安全的</li>
<li>sync.Pool使用后不应该也不能被复制</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pool -&gt; local -&gt; poolLocal_0 -&gt; poolChainElt_0(head) -&gt; poolDequeue(2^(3+N)</span></span><br><span class="line"><span class="comment">//                                  ↕</span></span><br><span class="line"><span class="comment">//                              -&gt; poolChainElt_1       -&gt; poolDequeue(2^(3+N-1)</span></span><br><span class="line"><span class="comment">//                              -&gt; ...</span></span><br><span class="line"><span class="comment">//                              -&gt; poolChainElt_N(tail) -&gt; poolDequeue(2^3=8个数据)</span></span><br><span class="line"><span class="comment">//               -&gt; ...</span></span><br><span class="line"><span class="comment">//               -&gt; poolLocal_P</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      -&gt; victim</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/pool.go</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    local     unsafe.Pointer  <span class="comment">// 临时对象数组指针，真实结构是[P]poolLocal，每个P一个poolLocal链表</span></span><br><span class="line">    localSize <span class="type">uintptr</span>         <span class="comment">// local数组的大小，一般情况下与P的数量相同</span></span><br><span class="line">    victim     unsafe.Pointer <span class="comment">// 前local数组，被GC搬过来的</span></span><br><span class="line">    victimSize <span class="type">uintptr</span>        <span class="comment">// 前local数组的大小</span></span><br><span class="line">    New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any            <span class="comment">// New 用于创建临时对象，如果池子内没有数据的话</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">    poolLocalInternal         <span class="comment">// 实际数据存储位置-链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevents false sharing on widespread platforms with</span></span><br><span class="line">    <span class="comment">// 128 mod (cache line size) = 0 .</span></span><br><span class="line">    <span class="comment">// pad在amd64平台下是96个字节大小</span></span><br><span class="line">    pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">    private any               <span class="comment">// 单个数据，优化读写，该字段只被当前P访问</span></span><br><span class="line">    shared  poolChain         <span class="comment">// 链表，当前P读写都在头部，其他P没数据时从末尾偷</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 新的poolChainElt在head，容量是上一个poolChainElt的双倍</span></span><br><span class="line">    head *poolChainElt                      <span class="comment">// 头部 数据读写 =&gt; 1 write</span></span><br><span class="line">    tail atomic.Pointer[poolChainElt]       <span class="comment">// 尾部 数据读取 =&gt; N read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">    poolDequeue                             <span class="comment">// 数据部份-环形数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// prev指向旧poolChainElt</span></span><br><span class="line">    <span class="comment">// next指向新poolChainElt</span></span><br><span class="line">    next, prev atomic.Pointer[poolChainElt]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ptr -&gt; | tail |      |      |      | head |     |</span></span><br><span class="line">    <span class="comment">// idx -&gt; | 0    | 1    | ...  | 98   | 99   | ... |</span></span><br><span class="line">    <span class="comment">// val -&gt; | 1    | 2    | ...  | 98   | nil  | nil |</span></span><br><span class="line">    headTail atomic.Uint64                  <span class="comment">// head(高32bit) + tail(低32bit)</span></span><br><span class="line">    vals []eface                            <span class="comment">// 环形数组 初始容量=8 =&gt; 2的乘方，最大不能超过2^30 =&gt; 1GB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里有几个全局变量用于纪录所有创建的池子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// Pool创建或者local扩容时使用</span></span><br><span class="line">    allPoolsMu Mutex</span><br><span class="line">    <span class="comment">// 所有创建的Pool都纪录到这里</span></span><br><span class="line">    allPools []*Pool</span><br><span class="line">    <span class="comment">// allPools的上一个历史版本，每次GC都会将allPools移动到oldPools</span></span><br><span class="line">    oldPools []*Pool</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>Get和Put操作都依赖的几个公共方法放在这里，可以先看后续的读写代码再回头看这部份</p>
<ol>
<li>pin - 用于绑定goroutine和P，阻止进入抢占模式，并返回pid</li>
<li>indexLocal - 获取local数组中指定的P的poolLocal索引</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回poolLocal和id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// pool不能为nil</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;nil Pool&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取pid</span></span><br><span class="line">    pid := runtime_procPin()</span><br><span class="line">    <span class="comment">// 数据量</span></span><br><span class="line">    s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">    <span class="comment">// poolLocal</span></span><br><span class="line">    l := p.local                              <span class="comment">// load-consume</span></span><br><span class="line">    <span class="comment">// 正常情况或P缩小了</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">        <span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// P扩容了，池子不够大</span></span><br><span class="line">    <span class="keyword">return</span> p.pinSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    allPoolsMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> allPoolsMu.Unlock()</span><br><span class="line">    <span class="comment">// 重新pin</span></span><br><span class="line">    pid := runtime_procPin()</span><br><span class="line">    <span class="comment">// 加锁后直接获取size和poolLocal</span></span><br><span class="line">    s := p.localSize</span><br><span class="line">    l := p.local</span><br><span class="line">    <span class="comment">// 其他goroutine完成了扩容？</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">        <span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的池子，注册到allPools</span></span><br><span class="line">    <span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;</span><br><span class="line">        allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果GOMAXPROCS有改动，生成新的poolLocal替换旧的</span></span><br><span class="line">    size := runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 一个P一个poolLocal</span></span><br><span class="line">    local := <span class="built_in">make</span>([]poolLocal, size)</span><br><span class="line">    atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release</span></span><br><span class="line">    runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release</span></span><br><span class="line">    <span class="keyword">return</span> &amp;local[pid], pid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// local数组索引，根据P的值定位poolLocal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexLocal</span><span class="params">(l unsafe.Pointer, i <span class="type">int</span>)</span></span> *poolLocal &#123;</span><br><span class="line">    lp := unsafe.Pointer(<span class="type">uintptr</span>(l) + <span class="type">uintptr</span>(i)*unsafe.Sizeof(poolLocal&#123;&#125;))</span><br><span class="line">    <span class="keyword">return</span> (*poolLocal)(lp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取一个对象"><a href="#获取一个对象" class="headerlink" title="获取一个对象"></a>获取一个对象</h3><p>大概逻辑如下</p>
<ol>
<li>根据P的值定位poolLocal链表</li>
<li>如果private有数值，返回该值</li>
<li>从shared(head)获取一个数据</li>
<li>从所有P的poolLocal链表找数据（从下一个P开始）<ul>
<li>从local查找              -&gt; private      -&gt; shared(tail)</li>
<li>从victim查找（只使用一次） -&gt; shared(tail)</li>
</ul>
</li>
<li>使用New方法生成一个新对象</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() any &#123;</span><br><span class="line">    <span class="comment">// 获取pid和poolLocal链表</span></span><br><span class="line">    l, pid := p.pin()</span><br><span class="line">    <span class="comment">// 直接读取private字段，如果有数据的话，这是一个优化，避免去查队列</span></span><br><span class="line">    x := l.private</span><br><span class="line">    l.private = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 如果private没有数据</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从shared头部获取一个数据</span></span><br><span class="line">        x, _ = l.shared.popHead()</span><br><span class="line">        <span class="comment">// 还是没有</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 从别的P偷一个回来</span></span><br><span class="line">            x = p.getSlow(pid)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unpin</span></span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">    <span class="comment">// 也没偷到</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 调用New函数</span></span><br><span class="line">        x = p.New()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) any &#123;</span><br><span class="line">    size := runtime_LoadAcquintptr(&amp;p.localSize)</span><br><span class="line">    locals := p.local</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 在local找</span></span><br><span class="line">    <span class="comment">// P可能扩容也可能缩容</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">        <span class="comment">// local数组索引，根据P的值定位poolLocal</span></span><br><span class="line">        <span class="comment">// 遍历所有P，从下一个P开始</span></span><br><span class="line">        l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size))</span><br><span class="line">        <span class="comment">// 从shared尾部获取一个数据</span></span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在victim找</span></span><br><span class="line">    size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">    <span class="comment">// 1. gc后P扩容了，没有当前P的数据</span></span><br><span class="line">    <span class="comment">// 2. victim被其他P访问过了</span></span><br><span class="line">    <span class="comment">// 3. victim为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有扩容或者缩容了</span></span><br><span class="line">    locals = p.victim</span><br><span class="line">    <span class="comment">// local数组索引，根据P的值定位poolLocal</span></span><br><span class="line">    l := indexLocal(locals, pid)</span><br><span class="line">    <span class="comment">// 下面同Get方法 </span></span><br><span class="line">    <span class="comment">// -&gt; private -&gt; shared</span></span><br><span class="line">    <span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;</span><br><span class="line">        l.private = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">        l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))</span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// victimSize设置为0</span></span><br><span class="line">    atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// poolChainElt</span></span><br><span class="line">    d := c.head</span><br><span class="line">    <span class="comment">// 从head扫描到tail</span></span><br><span class="line">    <span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 找到一个数据</span></span><br><span class="line">        <span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> val, ok</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// prev</span></span><br><span class="line">        d = d.prev.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// poolChainElt</span></span><br><span class="line">    d := c.tail.Load()</span><br><span class="line">    <span class="comment">// shared链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// next</span></span><br><span class="line">        d2 := d.next.Load()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前d找到一个数据</span></span><br><span class="line">        <span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> val, ok</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next为nil</span></span><br><span class="line">        <span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前d没数据，next不为nil，修改tail指针以及prev指针</span></span><br><span class="line">        <span class="keyword">if</span> c.tail.CompareAndSwap(d, d2) &#123;</span><br><span class="line">            d2.prev.Store(<span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        d = d2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> slot *eface</span><br><span class="line">    <span class="comment">// vals是一个环形数组</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ptrs := d.headTail.Load()</span><br><span class="line">        <span class="comment">// 从headTail解析</span></span><br><span class="line">        head, tail := d.unpack(ptrs)</span><br><span class="line">        <span class="comment">// 数组是空的</span></span><br><span class="line">        <span class="keyword">if</span> tail == head &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挪动指针</span></span><br><span class="line">        head--</span><br><span class="line">        ptrs2 := d.pack(head, tail)</span><br><span class="line">        <span class="comment">// 回写成功</span></span><br><span class="line">        <span class="keyword">if</span> d.headTail.CompareAndSwap(ptrs, ptrs2) &#123;</span><br><span class="line">            slot = &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">    <span class="comment">// nil特殊处理判断</span></span><br><span class="line">    <span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">        val = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认值</span></span><br><span class="line">    *slot = eface&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> slot *eface</span><br><span class="line">    <span class="comment">// vals是一个环形数组</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ptrs := d.headTail.Load()</span><br><span class="line">        <span class="comment">// 从headTail解析</span></span><br><span class="line">        head, tail := d.unpack(ptrs)</span><br><span class="line">        <span class="comment">// 数组是空的</span></span><br><span class="line">        <span class="keyword">if</span> tail == head &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        ptrs2 := d.pack(head, tail+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 回写成功</span></span><br><span class="line">        <span class="keyword">if</span> d.headTail.CompareAndSwap(ptrs, ptrs2) &#123;</span><br><span class="line">            slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We now own slot.</span></span><br><span class="line">    val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">    <span class="comment">// nil特殊处理判断</span></span><br><span class="line">    <span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">        val = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 置为nil</span></span><br><span class="line">    slot.val = <span class="literal">nil</span></span><br><span class="line">    atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>) <span class="comment">// 读写判断该字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保存一个对象"><a href="#保存一个对象" class="headerlink" title="保存一个对象"></a>保存一个对象</h3><p>大概逻辑如下</p>
<ol>
<li>如果对象为nil，不处理</li>
<li>根据P的值定位poolLocal链表</li>
<li>如果private为nil，直接写入</li>
<li>如果private有数据，写入shared(head)<ul>
<li>shared链表为空，创建链表（初始数据量为8）</li>
<li>写入成功？返回</li>
<li>写入失败？扩容后再次写入（数据量最大不能超过2^30&#x3D;1GB）</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sync/pool.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x any) &#123;</span><br><span class="line">    <span class="comment">// x=nil，不操作</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取pid和poolLocal链表</span></span><br><span class="line">    l, _ := p.pin()</span><br><span class="line">    <span class="comment">// private字段是空的？直接写入</span></span><br><span class="line">    <span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.private = x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 放置在shared头部</span></span><br><span class="line">        l.shared.pushHead(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unpin</span></span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val any) &#123;</span><br><span class="line">    d := c.head</span><br><span class="line">    <span class="comment">// shared链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个poolChainElt，关联head和tail</span></span><br><span class="line">        <span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2</span></span><br><span class="line">        d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">        d.vals = <span class="built_in">make</span>([]eface, initSize)</span><br><span class="line">        c.head = d</span><br><span class="line">        c.tail.Store(d)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入成功</span></span><br><span class="line">    <span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入失败</span></span><br><span class="line">    <span class="comment">// 当前poolChainElt数据满了，双倍扩容</span></span><br><span class="line">    newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line">    <span class="comment">// 最大不能超过2^30 =&gt; 1GB</span></span><br><span class="line">    <span class="keyword">if</span> newSize &gt;= dequeueLimit &#123;</span><br><span class="line">        newSize = dequeueLimit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d2 := &amp;poolChainElt&#123;&#125;</span><br><span class="line">    d2.prev.Store(d)</span><br><span class="line">    d2.vals = <span class="built_in">make</span>([]eface, newSize)</span><br><span class="line">    c.head = d2</span><br><span class="line">    d.next.Store(d2)</span><br><span class="line">    d2.pushHead(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val any) <span class="type">bool</span> &#123;</span><br><span class="line">    ptrs := d.headTail.Load()</span><br><span class="line">    <span class="comment">// 从headTail解析</span></span><br><span class="line">    head, tail := d.unpack(ptrs)</span><br><span class="line">    <span class="comment">// (tail_idx+size)&amp;mask == head</span></span><br><span class="line">    <span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;</span><br><span class="line">        <span class="comment">// Queue is full.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标slot还有数据</span></span><br><span class="line">    <span class="comment">// Check if the head slot has been released by popTail.</span></span><br><span class="line">    typ := atomic.LoadPointer(&amp;slot.typ)</span><br><span class="line">    <span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil转换</span></span><br><span class="line">    <span class="comment">// The head slot is free, so we own it.</span></span><br><span class="line">    <span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">        val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    *(*any)(unsafe.Pointer(slot)) = val</span><br><span class="line"></span><br><span class="line">    d.headTail.Add(<span class="number">1</span> &lt;&lt; dequeueBits)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h3><p>每当GC进入STW状态时，清理Pool相关数据</p>
<ol>
<li>Pool内数据过期：local -&gt; victim &amp; victim -&gt; nil</li>
<li>全局变量数据过期：allPools -&gt; oldPools &amp; oldPools -&gt; nil</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// oldPools、allPools存储的都是指针，可以指向同一个p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历oldPools，清空victim</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">        p.victim = <span class="literal">nil</span></span><br><span class="line">        p.victimSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历allPools，把local迁移到victim</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">        p.victim = p.local</span><br><span class="line">        p.victimSize = p.localSize</span><br><span class="line">        p.local = <span class="literal">nil</span></span><br><span class="line">        p.localSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allPools的数据迁移到oldPools</span></span><br><span class="line">    oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 纪录poolCleanup函数，每次GC开始前执行</span></span><br><span class="line">    runtime_registerPoolCleanup(poolCleanup)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储切片注意"><a href="#存储切片注意" class="headerlink" title="存储切片注意"></a>存储切片注意</h2><p>当使用sync.Pool存储切片时，sync.Pool会如何处理呢？看下面示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool = sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := pool.Get().([]<span class="type">byte</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...do something with b</span></span><br><span class="line">    _ = b</span><br><span class="line"></span><br><span class="line">    pool.Put(b) <span class="comment">// this is line 21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码看，我们创建了一个可以重复利用的切片&#x2F;缓存区。打开Escape Analysis-逃逸分析运行看看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run -gcflags=<span class="string">&quot;-m&quot;</span> hello.go  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># # command-line-arguments</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: can inline init.0.func1</span></span><br><span class="line"><span class="comment"># ./hello.go:7:6: can inline init.0</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ./hello.go:10:15: make([]byte, 4096) escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:10:15: make([]byte, 4096) escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: func literal escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:21:11: b escapes to heap</span></span><br></pre></td></tr></table></figure>

<p>当创建一个slice-切片时，我们得到的是一个header，系统判断其不仅局限于New函数，使其逃逸至heap上分配，而b也是一个header，同样，系统也会使其逃逸至heap</p>
<p>重新调整代码，改为一个指向slice的指针，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool = sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any &#123;</span><br><span class="line">            b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> &amp;b</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bPtr := pool.Get().(*[]<span class="type">byte</span>)</span><br><span class="line">    b := *bPtr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...do something with b</span></span><br><span class="line">    _ = b</span><br><span class="line"></span><br><span class="line">    pool.Put(bPtr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再一次运行逃逸分析，得到结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run -gcflags=<span class="string">&quot;-m&quot;</span> hello.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # command-line-arguments</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: can inline init.0.func1</span></span><br><span class="line"><span class="comment"># ./hello.go:7:6: can inline init.0</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ./hello.go:10:4: moved to heap: b</span></span><br><span class="line"><span class="comment"># ./hello.go:10:13: make([]byte, 4096) escapes to heap</span></span><br><span class="line"><span class="comment"># ./hello.go:9:8: func literal escapes to heap</span></span><br></pre></td></tr></table></figure>

<p>这一次，把原始指针放回Pool就不会发生逃逸现象</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://unskilled.blog/posts/lets-dive-a-tour-of-sync.pool-internals/">Let’s dive: a tour of sync.Pool internals</a><br><a href="https://www.cyhone.com/articles/think-in-sync-pool/">深度分析 Golang sync.Pool 底层原理</a><br><a href="https://victoriametrics.com/blog/go-sync-pool/index.html">Go sync.Pool and the Mechanics Behind It</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.RWMutex</title>
    <url>/golang-series-sync-rwmutex/</url>
    <content><![CDATA[<p>RWMutex-读写锁，该锁可以被任意多个reader持有，或被一个writer持有。通过观察RWMutex的源代码实现，可以将RWMutex看作是FIFO队列，具体看后面的详细描述</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line"></span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="type">int</span>, size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">            rwm.Lock()          <span class="comment">// 写锁</span></span><br><span class="line">            count++             <span class="comment">// 更新资源</span></span><br><span class="line">            rwm.Unlock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        indx := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">            rwm.RLock()         <span class="comment">// 读锁</span></span><br><span class="line">            queue[indx] = count <span class="comment">// 只读</span></span><br><span class="line">            rwm.RUnlock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(count)</span><br><span class="line">    fmt.Println(queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>RWMutex结构如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sync/rwmutex.go</span></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex</span><br><span class="line">    writerSem   <span class="type">uint32</span></span><br><span class="line">    readerSem   <span class="type">uint32</span></span><br><span class="line">    readerCount atomic.Int32</span><br><span class="line">    readerWait  atomic.Int32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各字段说明如下</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>w</code></td>
<td align="left">写锁，所有的writer都会阻塞在这里</td>
</tr>
<tr>
<td align="left"><code>writerSem</code></td>
<td align="left">writer队列，获取w锁成功后，如果readerCount不为0，挂起等待reader释放锁</td>
</tr>
<tr>
<td align="left"><code>readerSem</code></td>
<td align="left">reader队列，readerCount为负时，新的reader都在这里挂起等待</td>
</tr>
<tr>
<td align="left"><code>readerCount</code></td>
<td align="left">读锁&#x2F;reader总数，max&#x3D;2^30&#x3D;1GB，为负数时表示有writer等待</td>
</tr>
<tr>
<td align="left"><code>readerWait</code></td>
<td align="left">待释放锁reader总数，获取w锁成功后纪录当前reader数量，等待reader释放读锁</td>
</tr>
</tbody></table>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><p>读加锁，具体逻辑如下</p>
<ol>
<li>readerCount++，如果返回的结果小于0，说明有writer在等待或执行，放进readerSem等待唤醒</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">    <span class="comment">// readerCount++</span></span><br><span class="line">    <span class="comment">// readerCount &lt; 0？有writer等待</span></span><br><span class="line">    <span class="keyword">if</span> rw.readerCount.Add(<span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 放到队列里等待</span></span><br><span class="line">        runtime_SemacquireRWMutexR(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryRLock"><a href="#TryRLock" class="headerlink" title="TryRLock"></a>TryRLock</h3><p>尝试获取读锁，具体逻辑如下</p>
<ol>
<li>readerCount如果小于0，说明有writer在等待或执行，返回false</li>
<li>CAS尝试更新readerCount，成功则返回，失败则回到第一步重试，永久尝试</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryRLock() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c := rw.readerCount.Load()</span><br><span class="line">        <span class="comment">// readerCount &lt; 0？有writer等待</span></span><br><span class="line">        <span class="keyword">if</span> c &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS加锁，成功则返回，失败则再次尝试</span></span><br><span class="line">        <span class="keyword">if</span> rw.readerCount.CompareAndSwap(c, c+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RUnlock"><a href="#RUnlock" class="headerlink" title="RUnlock"></a>RUnlock</h3><p>读解锁，具体逻辑如下</p>
<ol>
<li>readerCount减1，如果结果小于0，说明有writer在等待</li>
<li>readerWait减1，如果结果等于0，唤醒writer</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">    <span class="comment">// readerCount &lt; 0？有writer等待</span></span><br><span class="line">    <span class="keyword">if</span> r := rw.readerCount.Add(<span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        rw.rUnlockSlow(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复释放锁，异常</span></span><br><span class="line">    <span class="comment">// org_r == 0 =&gt; 无任何goroutine访问</span></span><br><span class="line">    <span class="comment">// org_r == -rwmutexMaxReaders =&gt; 有writer无reader</span></span><br><span class="line">    <span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">        fatal(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writer在等待，新reader肯定不会unlock，能unlock的只有readerWait</span></span><br><span class="line">    <span class="keyword">if</span> rw.readerWait.Add(<span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// readerWait归零，唤醒writer</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>写加锁，具体逻辑如下</p>
<ol>
<li>w加锁，使其它writer排队等待</li>
<li>readerCount-&#x3D;rwmutexMaxReaders，通知新的reader有writer在等待</li>
<li>原readerCount不为0，说明有reader在运行，纪录到readerWait</li>
<li>将writer放到writerSem队列，等待唤醒</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// w加锁，使其它writer排队等待</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知新的reader有writer在等待</span></span><br><span class="line">    <span class="comment">// r = readerCount =&gt; 理想情况下为0</span></span><br><span class="line">    <span class="comment">// readerCount -= 2^30</span></span><br><span class="line">    r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录在运行的reader的数量到readerWait</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; rw.readerWait.Add(r) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前goroutine放进writerSem队列，等待唤醒</span></span><br><span class="line">        runtime_SemacquireRWMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryLock"><a href="#TryLock" class="headerlink" title="TryLock"></a>TryLock</h3><p>尝试换取写锁，具体逻辑如下</p>
<ol>
<li>w尝试加锁，失败返回false</li>
<li>CAS尝试更新readerCount-&#x3D;rwmutexMaxReaders，成功则返回true，失败则解锁w并返回false</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryLock() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// w尝试加锁</span></span><br><span class="line">    <span class="keyword">if</span> !rw.w.TryLock() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知新的reader有writer在等待写入</span></span><br><span class="line">    <span class="comment">// readerCount=-rwmutexMaxReaders =&gt; 期望当前reader的数量为0</span></span><br><span class="line">    <span class="keyword">if</span> !rw.readerCount.CompareAndSwap(<span class="number">0</span>, -rwmutexMaxReaders) &#123;</span><br><span class="line">        <span class="comment">// 失败解锁w</span></span><br><span class="line">        rw.w.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><p>写解锁，具体逻辑如下</p>
<ol>
<li>readerCount+&#x3D;rwmutexMaxReaders，使其为正数，让新的reader知道锁可用</li>
<li>如果readerCount不为0，说明有reader在排队，唤醒全部reader</li>
<li>w解锁，唤醒其他排队的writer</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// 更新readerCount，让新的reader知道锁可用</span></span><br><span class="line">    r := rw.readerCount.Add(rwmutexMaxReaders)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复释放锁，异常</span></span><br><span class="line">    <span class="comment">// org_r == 0 =&gt; 无任何goroutine访问</span></span><br><span class="line">    <span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">        fatal(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将readerSem队列里等待的reader全部唤醒</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// w解锁，唤醒其他排队的writer</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-垃圾回收</title>
    <url>/golang-series-garbage-collection/</url>
    <content><![CDATA[<p>go的垃圾回收原理官方说法是是三色标记法+混合写屏障，但是，理论上怎么说是一回事，具体实现又是另一回事了，或者说实现已经偏离文档描述。总的来说，GC这部份的内容要比GMP跟内存分配都要复杂的多且出人意料。当前go版本：1.24</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h3><p>Go的GC并不扫描整个内存，只关注以下区域：</p>
<ol>
<li>heap上分配的对象（在mspan管理范围）</li>
<li>data&#x2F;bss段的全局变量</li>
<li>栈上的引用（扫描stackRoots）</li>
</ol>
<h3 id="触发类型"><a href="#触发类型" class="headerlink" title="触发类型"></a>触发类型</h3><table>
<thead>
<tr>
<th align="left">触发类型</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gcTriggerHeap</td>
<td align="left">堆大小触发，heap内存达到一个临界点触发（最常用）</td>
</tr>
<tr>
<td align="left">gcTriggerTime</td>
<td align="left">时间触发，超时2min未执行GC则强制执行</td>
</tr>
<tr>
<td align="left">gcTriggerCycle</td>
<td align="left">手动触发，用户调用runtime.GC()</td>
</tr>
</tbody></table>
<h3 id="角色-分工"><a href="#角色-分工" class="headerlink" title="角色&#x2F;分工"></a>角色&#x2F;分工</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
<th>工作阶段</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Mark Worker（标记工作线程）</td>
<td>遍历对象图，标记存活对象，防止被错误回收</td>
<td>标记阶段（Marking）</td>
<td>运行时创建多个并发 Mark Worker，加快标记速度</td>
</tr>
<tr>
<td>Sweeper（清扫器）</td>
<td>清理未标记的对象，将其内存释放回空闲列表（mheap.free）</td>
<td>清扫阶段（Sweeping）</td>
<td>逐步清理，避免一次性 STW（Stop The World）</td>
</tr>
<tr>
<td>Scavenger（内存回收器）</td>
<td>释放长期未使用的堆内存，归还给OS以减少RSS</td>
<td>后台运行（定期触发）</td>
<td>主要针对大对象或空闲mspans，减少物理内存占用</td>
</tr>
</tbody></table>
<p><strong>标记工作线程</strong></p>
<p>其中，标记工作线程的会根据工作模式进一步区分，如下</p>
<table>
<thead>
<tr>
<th align="left">标记工作线程模式</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gcMarkWorkerNotWorker</td>
<td align="left">默认，未运行</td>
</tr>
<tr>
<td align="left">gcMarkWorkerDedicatedMode</td>
<td align="left">专用标记任务，最高优先级，非抢占</td>
</tr>
<tr>
<td align="left">gcMarkWorkerFractionalMode</td>
<td align="left">比例标记任务，跟其他g共享时间，可被抢占</td>
</tr>
<tr>
<td align="left">gcMarkWorkerIdleMode</td>
<td align="left">空闲时执行的低优先级标记任务，需要p空闲</td>
</tr>
</tbody></table>
<p><strong>CPU限制</strong></p>
<p>标记工作线程的CPU使用率被限制在25%（GOGC&#x3D;100时），假设系统使用一个6核CPU，那么GC在标记阶段大约会使用1.5个CPU资源：</p>
<ol>
<li>1个CPU由Dedicated（专用模式）的标记工作线程持续占用，该线程不允许抢占，直到标记任务完成</li>
<li>0.5个CPU由Fractional（比例模式）的标记工作线程使用，该线程仅在由额外CPU资源可用时运行，并会根据系统负责动态调整自身的CPU使用率</li>
</ol>
<h3 id="完整运行流程"><a href="#完整运行流程" class="headerlink" title="完整运行流程"></a>完整运行流程</h3><ol>
<li><p>Sweep Termination（清理终止）</p>
<ul>
<li>STW（Stop The World），确保所有P都达到GC安全点</li>
<li>完成上一轮GC未完成的sweep（清扫），回收剩余的的mspan</li>
<li>准备GC统计数据，为新一轮的GC计算目标heap大小、触发阈值等</li>
</ul>
</li>
<li><p>Mark（标记）</p>
<ul>
<li>STW，切换GC状态<ul>
<li>gcphase从_GCoff切换到_GCmark</li>
<li>开启写屏障（write barrier），允许Mutator协助GC标记，以维护三色标记不变性</li>
<li>启动GC后台线程，执行并发标记任务</li>
<li>根对象入队（包括栈、全局变量）</li>
</ul>
</li>
<li>恢复世界（Start The World），GC线程进入并发标记阶段<ul>
<li>从根对象开始标记，遍历所有可达对象</li>
<li>扫描灰色对象（已发现但未完全扫描的对象）并进行扫描，将其置黑，并将其引用的对象入队为灰色</li>
<li>混合写屏障（Hybrid Write Barrier）确保一致性</li>
</ul>
</li>
<li>完成标记</li>
</ul>
</li>
<li><p>Mark Termination（标记终止）</p>
<ul>
<li>STW，切换GC状态<ul>
<li>gcphase从_GCmark切换到_GCmarktermination</li>
<li>停止并发标记任务</li>
<li>执行终结器finalizer，如果有的话</li>
<li>清理mcache以确保没有悬挂对象</li>
</ul>
</li>
</ul>
</li>
<li><p>Sweep（清理）</p>
<ul>
<li>切换GC状态<ul>
<li>gcphase从_GCmarktermination切换回_GCoff</li>
<li>关闭写屏障（Mutator不再协助GC标记）</li>
</ul>
</li>
<li>恢复世界（Start The World），进入并发清扫阶段<ul>
<li>清理未被标记的对象</li>
<li>回收mspan到mheap或mcentral，部份回收到mcache</li>
<li>Mutator分配内存时，可能会触发增量清扫（Incremental Sweeping），加快回收过程</li>
</ul>
</li>
</ul>
</li>
<li><p>满足触发条件，启动下一轮GC</p>
</li>
</ol>
<p>简单的说，标记然后清扫</p>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>如果没有特别说明的话，下面的耗时字段都指一个GC周期内的</p>
<h3 id="workType"><a href="#workType" class="headerlink" title="workType"></a>workType</h3><p>workType类似GMP里的全局调度器schedt，负责GC的任务调度与阶段状态，包括管理GC周期中的各类任务、调度器状态、根对象索引、全局任务队列、并发控制等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 世界停止前获取，恢复世界后释放。确保同一时间只有一个GC流程在运行</span></span><br><span class="line"><span class="keyword">var</span> gcsema <span class="type">uint32</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 世界停止前获取，恢复世界后释放。确保同一时间只能有一个线程执行STW（其他组件也能STW）</span></span><br><span class="line"><span class="keyword">var</span> worldsema <span class="type">uint32</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// workType.startSema    // 第1阶段启动前获取并在末尾释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> work workType</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">type</span> workType <span class="keyword">struct</span> &#123;</span><br><span class="line">    full      lfstack          <span class="comment">// 全局任务缓冲区，wbuf中元素数量不为0</span></span><br><span class="line">    _         cpu.CacheLinePad <span class="comment">// 防止false-sharing</span></span><br><span class="line">    empty     lfstack          <span class="comment">// 全局任务缓冲区，wbuf中元素数量为0</span></span><br><span class="line">    _         cpu.CacheLinePad</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan，用于分配、存储wbuf-任务缓冲区</span></span><br><span class="line">    <span class="comment">// mspan会一次性创建n个mspan，一个返回，剩余n-1个放到empty</span></span><br><span class="line">    wbufSpans <span class="keyword">struct</span> &#123;</span><br><span class="line">        lock mutex</span><br><span class="line">        free mSpanList         <span class="comment">// 空的mspan，一般是busy清空后放到这里</span></span><br><span class="line">        busy mSpanList         <span class="comment">// 含有wbuf的mspan</span></span><br><span class="line">    &#125;</span><br><span class="line">    _            <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">    bytesMarked  <span class="type">uint64</span>        <span class="comment">// 已标记字节数</span></span><br><span class="line">    markrootNext <span class="type">uint32</span>        <span class="comment">// markroot任务id/计数器</span></span><br><span class="line">    markrootJobs <span class="type">uint32</span>        <span class="comment">// markroot任务总数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// nproc是固定值，跟nwait是一对，用于表示标记工作线程数量（Assist-协助线程也会调整这个计数器）</span></span><br><span class="line">    nproc        <span class="type">uint32</span>        <span class="comment">// 初始值为2^32-1</span></span><br><span class="line">    tstart       <span class="type">int64</span>         <span class="comment">//</span></span><br><span class="line">    nwait        <span class="type">uint32</span>        <span class="comment">// 初始值为2^32-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根对象块数量，如nStackRoots == len(stackRoots)</span></span><br><span class="line">    nDataRoots, nBSSRoots, nSpanRoots, nStackRoots    <span class="type">int</span></span><br><span class="line">    <span class="comment">// 根对象块的基地址（索引），baseEnd是边界</span></span><br><span class="line">    baseData, baseBSS, baseSpans, baseStacks, baseEnd <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">    stackRoots      []*g       <span class="comment">// allgs快照（在标记之前获取）</span></span><br><span class="line">    startSema       <span class="type">uint32</span>     <span class="comment">// 信号量，GC启动前获取，</span></span><br><span class="line">    markDoneSema    <span class="type">uint32</span>     <span class="comment">// 信号量，gcMarkDone时使用</span></span><br><span class="line">    bgMarkDone      <span class="type">uint32</span>     <span class="comment">// 这个字段整个源代码都没有使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0-并发标记清扫 1-STW标记+并发清扫 2-STW标记+STW清扫</span></span><br><span class="line">    mode            gcMode     <span class="comment">// 模式，默认0-gcBackgroundMode，debug时可设置其他模式</span></span><br><span class="line"></span><br><span class="line">    userForced      <span class="type">bool</span>       <span class="comment">// 是否用户手动/强制运行</span></span><br><span class="line">    initialHeapLive <span class="type">uint64</span>     <span class="comment">// heapLive快照</span></span><br><span class="line">    assistQueue     <span class="keyword">struct</span> &#123;   <span class="comment">// bgScanCredit额度不足时将g挂起</span></span><br><span class="line">        lock mutex</span><br><span class="line">        q    gQueue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sweepWaiters <span class="keyword">struct</span> &#123;      <span class="comment">// 当前g挂起等待第n个GC周期结束（手动触发使用）</span></span><br><span class="line">        lock mutex</span><br><span class="line">        list gList             <span class="comment">// 执行runtime.GC的g，_GCmarktermination时唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strongFromWeak <span class="keyword">struct</span> &#123;    <span class="comment">// 控制weak-&gt;strong指针转换</span></span><br><span class="line">        block <span class="type">bool</span>             <span class="comment">// 是否阻止weak-&gt;strong转换</span></span><br><span class="line">        lock  mutex</span><br><span class="line">        q     gQueue           <span class="comment">// block为true时将g放到q，false时将q内全部g放进p本地/全局队列</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cycles                             atomic.Uint32 <span class="comment">// 周期计数器，gcStart时递增</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// stwprocs=max(gomaxprocs,ncpu), maxprocs=gomaxprocs</span></span><br><span class="line">    stwprocs, maxprocs                 <span class="type">int32</span>         <span class="comment">// 同p数量</span></span><br><span class="line">    <span class="comment">// tSweepTerm - 第1阶段开始时刻</span></span><br><span class="line">    <span class="comment">// tMark      - 第2阶段开始时刻</span></span><br><span class="line">    <span class="comment">// tMarkTerm  - 第3阶段开始时刻</span></span><br><span class="line">    <span class="comment">// tEnd       - 第4阶段开始时刻</span></span><br><span class="line">    tSweepTerm, tMark, tMarkTerm, tEnd <span class="type">int64</span>         <span class="comment">// 当前时刻</span></span><br><span class="line">    pauseNS                            <span class="type">int64</span>         <span class="comment">// 当前GC循环累计STW耗时</span></span><br><span class="line">    <span class="comment">// heap0 =&gt; heapLive快照-heap存活字节数</span></span><br><span class="line">    <span class="comment">// heap1 =&gt; heapLive快照-heap存活字节数</span></span><br><span class="line">    <span class="comment">// heap2 =&gt; bytesMarked快照-已标记字节数</span></span><br><span class="line">    heap0, heap1, heap2                <span class="type">uint64</span>        <span class="comment">// 当前循环的debug.gctrace heap大小</span></span><br><span class="line">    <span class="comment">// GC暂停耗时、GC流程总耗时</span></span><br><span class="line">    cpuStats                                         <span class="comment">// CPU统计信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcControllerState"><a href="#gcControllerState" class="headerlink" title="gcControllerState"></a>gcControllerState</h3><p>gcControllerState-垃圾回收节奏控制（pacing），保持系统平稳运行。负责内存使用与触发GC的策略控制，包括控制GC何时触发，计算下一次触发时机、控制GC比例（目标）、动态调整参数（如GOGC）等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gcController gcControllerState</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似schedt结构体</span></span><br><span class="line"><span class="keyword">type</span> gcControllerState <span class="keyword">struct</span> &#123;</span><br><span class="line">    gcPercent                  atomic.Int32     <span class="comment">// 从GOGC环境变量获取，默认100</span></span><br><span class="line">    memoryLimit                atomic.Int64     <span class="comment">// 从GOMEMLIMIT环境变量获取，默认2^64-1</span></span><br><span class="line"></span><br><span class="line">    heapMinimum                <span class="type">uint64</span>           <span class="comment">// heap内存空间大小，默认为4MB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跑道，飞机起飞前需要滑行的距离</span></span><br><span class="line">    <span class="comment">// 控制goroutine是否需要协助标记，避免GC跑不完。默认情况下为根对象大小的3倍</span></span><br><span class="line">    runway                     atomic.Uint64</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前并发标记进度</span></span><br><span class="line">    <span class="comment">// consMark &gt; 1.0 =&gt; GC当前落后于内存分配速度，会启用更激进的GC策略</span></span><br><span class="line">    <span class="comment">// consMark &lt; 1.0 =&gt; GC当前标记进度是健康的</span></span><br><span class="line">    consMark                   <span class="type">float64</span></span><br><span class="line"></span><br><span class="line">    lastConsMark               [<span class="number">4</span>]<span class="type">float64</span>       <span class="comment">// 历史4次GC的并发标记进度</span></span><br><span class="line">    gcPercentHeapGoal          atomic.Uint64    <span class="comment">// 目标heap大小</span></span><br><span class="line">    sweepDistMinTrigger        atomic.Uint64    <span class="comment">// GC启动的一个底线阈值，非清扫阶段为0，否则为heapLive+1MB</span></span><br><span class="line">    triggered                  <span class="type">uint64</span>           <span class="comment">// 默认2^64-1，GC启动时为heapLive快照</span></span><br><span class="line">    lastHeapGoal               <span class="type">uint64</span>           <span class="comment">// GC结束时计算的目标heap大小</span></span><br><span class="line">    heapLive                   atomic.Uint64    <span class="comment">// heap存活字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记终止阶段同步heapScanWork，与lastHeapScan不同，内存分配时也会继续累计</span></span><br><span class="line">    heapScan                   atomic.Uint64    <span class="comment">// heapScanWork快照</span></span><br><span class="line">    lastHeapScan               <span class="type">uint64</span>           <span class="comment">// heapScanWork快照</span></span><br><span class="line">    lastStackScan              atomic.Uint64    <span class="comment">// stackScanWork快照</span></span><br><span class="line">    maxStackScan               atomic.Uint64    <span class="comment">// 累计所有的栈字节数</span></span><br><span class="line">    globalsScan                atomic.Uint64    <span class="comment">// 全部模块的bss+data段大小</span></span><br><span class="line"></span><br><span class="line">    heapMarked                 <span class="type">uint64</span>           <span class="comment">// 上一次GC后heap存活字节数，heapLive快照</span></span><br><span class="line"></span><br><span class="line">    heapScanWork               atomic.Int64     <span class="comment">// heap扫描字节数，同gcw.heapScanWork</span></span><br><span class="line">    stackScanWork              atomic.Int64     <span class="comment">// stack扫描字节数</span></span><br><span class="line">    globalsScanWork            atomic.Int64     <span class="comment">// bss/data扫描字节数</span></span><br><span class="line"></span><br><span class="line">    bgScanCredit               atomic.Int64     <span class="comment">// 扫描额度，同gcw.heapScanWork</span></span><br><span class="line">    assistTime                 atomic.Int64     <span class="comment">// GC助攻耗时</span></span><br><span class="line"></span><br><span class="line">    dedicatedMarkTime          atomic.Int64     <span class="comment">// 累计所有p的标记耗时（专用标记任务）</span></span><br><span class="line">    fractionalMarkTime         atomic.Int64     <span class="comment">// 累计所有p的标记耗时（比例标记任务）</span></span><br><span class="line">    idleMarkTime               atomic.Int64     <span class="comment">// 累计所有p的标记耗时（空闲标记任务）</span></span><br><span class="line"></span><br><span class="line">    markStartTime              <span class="type">int64</span>            <span class="comment">// 当前循环开始时刻，gcStart时纪录</span></span><br><span class="line"></span><br><span class="line">    dedicatedMarkWorkersNeeded atomic.Int64     <span class="comment">// 专用标记任务需要的线程数量</span></span><br><span class="line">    idleMarkWorkers            atomic.Uint64    <span class="comment">// 空闲标记线程数量，一般是procs-专用标记线程数量</span></span><br><span class="line">    <span class="comment">// 下面两个互为倒数</span></span><br><span class="line">    assistWorkPerByte          atomic.Float64   <span class="comment">// 每分配1字节需要辅助完成多少GC工作量</span></span><br><span class="line">    assistBytesPerWork         atomic.Float64   <span class="comment">// 每完成1单位GC工作量可以分配多少字节</span></span><br><span class="line">    fractionalUtilizationGoal  <span class="type">float64</span>          <span class="comment">// 比例标记任务利用率目标，为0时不需要标记线程</span></span><br><span class="line"></span><br><span class="line">    heapInUse                  sysMemStat       <span class="comment">// heap内存使用量（mSpanInUse）</span></span><br><span class="line">    heapReleased               sysMemStat       <span class="comment">// heap内存释放量（释放回OS）</span></span><br><span class="line">    <span class="comment">// heapFree在allocSpan时减少，freeSpanLocked时增加，一般为负数</span></span><br><span class="line">    heapFree                   sysMemStat       <span class="comment">// heap内存可复用量</span></span><br><span class="line"></span><br><span class="line">    totalAlloc                 atomic.Uint64    <span class="comment">// 累计已分配字节数</span></span><br><span class="line">    totalFree                  atomic.Uint64    <span class="comment">// 累计回收量</span></span><br><span class="line">    <span class="comment">// 已映射且可用的内存量（总内存），最底层OS级别的内存统计</span></span><br><span class="line">    <span class="comment">// sysAlloc、sysUsed时增加，sysUnused、sysFree、sysFault时减少</span></span><br><span class="line">    mappedReady                atomic.Uint64</span><br><span class="line"></span><br><span class="line">    test                       <span class="type">bool</span>             <span class="comment">// 测试，忽略</span></span><br><span class="line">    _                          cpu.CacheLinePad</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcCPULimiterState"><a href="#gcCPULimiterState" class="headerlink" title="gcCPULimiterState"></a>gcCPULimiterState</h3><p>CPU限制器，负责限制GC对CPU的占用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gcCPULimiter gcCPULimiterState</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会在gcStart和gcMarkDone调整</span></span><br><span class="line"><span class="keyword">type</span> gcCPULimiterState <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock          atomic.Uint32    <span class="comment">// 0-未锁定，1-已锁定</span></span><br><span class="line">    enabled       atomic.Bool      <span class="comment">// 是否已经触发限速状态，fill==capacity时限制GC运行</span></span><br><span class="line">    gcEnabled     <span class="type">bool</span>             <span class="comment">// gcBlackenEnabled快照</span></span><br><span class="line">    transitioning <span class="type">bool</span>             <span class="comment">// 是否处于过渡状态，true-意味着GC目前正在调整CPU限制</span></span><br><span class="line">    test          <span class="type">bool</span>             <span class="comment">// 测试，忽略</span></span><br><span class="line"></span><br><span class="line">    bucket        <span class="keyword">struct</span> &#123;         <span class="comment">// 水桶</span></span><br><span class="line">        <span class="comment">// capacity是整个水桶的容量，=nprocs*1e9 =&gt; 每个CPU有1s</span></span><br><span class="line">        <span class="comment">// fill是水桶剩余量，可以理解为GC额度，初始值为capacity，意味着从一开始就限制GC运行</span></span><br><span class="line">        fill, capacity <span class="type">uint64</span>      <span class="comment">// fill &lt;= capacity</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    overflow         <span class="type">uint64</span>        <span class="comment">// 累计bucket溢出部份（从程序开始一直累计）</span></span><br><span class="line">    assistTimePool   atomic.Int64  <span class="comment">// 从上一次更新开始累计的助攻积分</span></span><br><span class="line">    idleMarkTimePool atomic.Int64  <span class="comment">//</span></span><br><span class="line">    idleTimePool     atomic.Int64  <span class="comment">// 从上一次更新开始累计的p空闲时辅助标记的耗时</span></span><br><span class="line">    lastUpdate       atomic.Int64  <span class="comment">// 上一次更新的时刻</span></span><br><span class="line">    lastEnabledCycle atomic.Uint32 <span class="comment">// enabled为true时，纪录为numgc+1。numgc =&gt; gc计数器，类似cycle</span></span><br><span class="line">    nprocs           <span class="type">int32</span>         <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清扫器"><a href="#清扫器" class="headerlink" title="清扫器"></a>清扫器</h3><p>sweeper-清扫器，负责将内存回收到mheap</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sweep sweepdata</span><br><span class="line"></span><br><span class="line"><span class="comment">// sweeper状态，负责清理不可达对象的内存</span></span><br><span class="line"><span class="keyword">type</span> sweepdata <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock         mutex</span><br><span class="line">    <span class="comment">// 下面两个是sweeper专用的</span></span><br><span class="line">    g            *g          <span class="comment">// sweeper</span></span><br><span class="line">    parked       <span class="type">bool</span>        <span class="comment">// 挂起时为true，被唤醒后重置为false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他g可以协助sweeper并发清扫</span></span><br><span class="line">    <span class="comment">// 为什么还有计数器呢？因为除了第一个默认的sweeper，其他的g可以协助并发清扫</span></span><br><span class="line">    active       activeSweep <span class="comment">// 计数器，最高位为1时表示清扫完毕</span></span><br><span class="line">    centralIndex sweepClass  <span class="comment">// 索引，指向当前未清扫的mspan，用于mcentral</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> activeSweep <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 最高位是flag，为1时表示队列为空，剩余31位为计数器</span></span><br><span class="line">    state atomic.Uint32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sweepClass <span class="type">uint32</span></span><br></pre></td></tr></table></figure>

<h3 id="内存回收器"><a href="#内存回收器" class="headerlink" title="内存回收器"></a>内存回收器</h3><p>内存回收器负责将内存归还OS，其中</p>
<ol>
<li>scavenge-负责回收目标计算、回收时机判断</li>
<li>scavenger-节奏调度器<ul>
<li>当前目标释放速率（sleepRatio, targetCPUFraction）</li>
<li>实际是否要执行（shouldStop）</li>
<li>具体怎么执行（scavenge回调函数由pageAlloc注入）</li>
<li>用PI控制器sleepController平滑地控制回收速率：更类似GC的pacer</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回收目标计算、回收时机判断</span></span><br><span class="line"><span class="keyword">var</span> scavenge <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 1. lastHeapGoal为0</span></span><br><span class="line">    <span class="comment">// 2. heapInUse+heapFree &lt; gcPercentGoal</span></span><br><span class="line">    <span class="comment">// 3. heapInUse+heapFree &lt; gcPercentGoal+physPageSize</span></span><br><span class="line">    <span class="comment">// 以上三种情况设置为2^64-1，否则需要计算得出</span></span><br><span class="line">    gcPercentGoal   atomic.Uint64 <span class="comment">// GC触发临界点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果超过95%的memoryLimit则设置为95%的memoryLimit，否则设置为2^64-1</span></span><br><span class="line">    memoryLimitGoal atomic.Uint64 <span class="comment">// 内存限制</span></span><br><span class="line"></span><br><span class="line">    assistTime      atomic.Int64  <span class="comment">// 助攻耗时</span></span><br><span class="line">    backgroundTime  atomic.Int64  <span class="comment">// 运行耗时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scavenger scavengerState</span><br><span class="line"></span><br><span class="line"><span class="comment">// pacing-节奏调度器</span></span><br><span class="line"><span class="keyword">type</span> scavengerState <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock                 mutex</span><br><span class="line"></span><br><span class="line">    g                    *g                               <span class="comment">// scavenger</span></span><br><span class="line">    timer                *timer                           <span class="comment">// 定时器，看起来没什么用</span></span><br><span class="line">    sysmonWake           atomic.Uint32                    <span class="comment">// 为1时sysmon将会唤醒scavenger</span></span><br><span class="line">    parked               <span class="type">bool</span>                             <span class="comment">// 是否挂起</span></span><br><span class="line">    printControllerReset <span class="type">bool</span>                             <span class="comment">// </span></span><br><span class="line">    targetCPUFraction    <span class="type">float64</span>                          <span class="comment">// </span></span><br><span class="line">    sleepRatio           <span class="type">float64</span>                          <span class="comment">// 低值意味着更多睡眠，高值意味着更激进的scavenging</span></span><br><span class="line">    sleepController      piController                     <span class="comment">// </span></span><br><span class="line">    controllerCooldown   <span class="type">int64</span>                            <span class="comment">// </span></span><br><span class="line">    sleepStub            <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int64</span>)</span></span> <span class="type">int64</span>              <span class="comment">// </span></span><br><span class="line">    scavenge             <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">uintptr</span>)</span></span> (<span class="type">uintptr</span>, <span class="type">int64</span>) <span class="comment">// pageAlloc执行scavenge，累计耗时到backgroundTime</span></span><br><span class="line">    shouldStop           <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>                      <span class="comment">// 只要没达到阈值，scavenger就不需要回收</span></span><br><span class="line"></span><br><span class="line">    gomaxprocs           <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int32</span>                     <span class="comment">// 测试用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pageAlloc相关</span></span><br><span class="line"><span class="comment">// 回收索引-负责追踪哪些内存物理页已经被回收或可被回收</span></span><br><span class="line"><span class="keyword">type</span> scavengeIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 用于追踪chunk中哪些页已经被释放</span></span><br><span class="line">    <span class="comment">// 总大小512MB，可通过load方法转换为scavChunkData</span></span><br><span class="line">    chunks          []atomicScavChunkData <span class="comment">//</span></span><br><span class="line">    min, max        atomic.Uintptr        <span class="comment">// 最小base、最大limit</span></span><br><span class="line">    minHeapIdx      atomic.Uintptr        <span class="comment">// 全局最小的chunkIndex</span></span><br><span class="line">    searchAddrBg    atomicOffAddr         <span class="comment">// 搜索地址，由后台运行的scavenger更新</span></span><br><span class="line">    searchAddrForce atomicOffAddr         <span class="comment">// 搜索地址，由分配内存时协助回收更新</span></span><br><span class="line">    freeHWM         offAddr               <span class="comment">// free函数执行时纪录的最高地址</span></span><br><span class="line">    gen             <span class="type">uint32</span>                <span class="comment">// 版本计数器</span></span><br><span class="line">    test            <span class="type">bool</span>                  <span class="comment">// 测试用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8字节，可转换为scavChunkData</span></span><br><span class="line"><span class="keyword">type</span> atomicScavChunkData <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// | 32bit | 6bit           | 10bit     | 16bit |</span></span><br><span class="line">    <span class="comment">// | gen   | scavChunkFlags | lastInUse | inUse |</span></span><br><span class="line">    value atomic.Uint64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12个字节</span></span><br><span class="line"><span class="keyword">type</span> scavChunkData <span class="keyword">struct</span> &#123;</span><br><span class="line">    inUse          <span class="type">uint16</span> <span class="comment">// 页数，表示有多少个页当前已分配，只有低10位被使用</span></span><br><span class="line">    lastInUse      <span class="type">uint16</span> <span class="comment">// inUse快照，版本变更时纪录</span></span><br><span class="line">    gen            <span class="type">uint32</span> <span class="comment">// 版本计数器</span></span><br><span class="line">    scavChunkFlags        <span class="comment">// 只有低6位在使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> scavChunkFlags <span class="type">uint8</span></span><br></pre></td></tr></table></figure>

<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>这几个缓冲区都放在P内部，作为本地缓冲区，全局缓冲区放在workType</p>
<ol>
<li>workbuf-任务缓冲区</li>
<li>wbBuf-写屏障缓冲区</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作队列</span></span><br><span class="line"><span class="keyword">type</span> gcWork <span class="keyword">struct</span> &#123;</span><br><span class="line">    wbuf1, wbuf2 *workbuf <span class="comment">// 任务缓冲区</span></span><br><span class="line">    bytesMarked  <span class="type">uint64</span>   <span class="comment">// </span></span><br><span class="line">    heapScanWork <span class="type">int64</span>    <span class="comment">// 扫描字节数</span></span><br><span class="line">    flushedWork  <span class="type">bool</span>     <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务缓冲区，固定2KB</span></span><br><span class="line"><span class="keyword">type</span> workbuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ sys.NotInHeap</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    workbufhdr</span><br><span class="line">    <span class="comment">// 253个指针</span></span><br><span class="line">    obj [(_WorkbufSize - unsafe.Sizeof(workbufhdr&#123;&#125;)) / goarch.PtrSize]<span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 24字节</span></span><br><span class="line"><span class="keyword">type</span> workbufhdr <span class="keyword">struct</span> &#123;</span><br><span class="line">    node lfnode           <span class="comment">//</span></span><br><span class="line">    nobj <span class="type">int</span>              <span class="comment">// 对象数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写屏障缓冲，4112字节</span></span><br><span class="line"><span class="keyword">type</span> wbBuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    next <span class="type">uintptr</span>               <span class="comment">// 指针的地址，指向下一个元素时移动8个字节（指针大小）</span></span><br><span class="line">    end  <span class="type">uintptr</span>               <span class="comment">// 边界，指向最后一个元素的末尾</span></span><br><span class="line">    <span class="comment">// 不直接使用buf</span></span><br><span class="line">    buf  [wbBufEntries]<span class="type">uintptr</span> <span class="comment">// 512个指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>gcTrigger-触发类型</li>
<li>gcBgMarkWorkerNode-标记工作线程</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发类型</span></span><br><span class="line"><span class="keyword">type</span> gcTrigger <span class="keyword">struct</span> &#123;</span><br><span class="line">    kind gcTriggerKind    <span class="comment">// 类型</span></span><br><span class="line">    now  <span class="type">int64</span>            <span class="comment">// 当前时刻，时间触发才有</span></span><br><span class="line">    n    <span class="type">uint32</span>           <span class="comment">// 版本计数器，手动触发才有，从work.cycles同步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记工作线程，这是单个节点，所有的节点会存储在全局变量gcBgMarkWorkerPool中</span></span><br><span class="line"><span class="keyword">type</span> gcBgMarkWorkerNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    node lfnode           <span class="comment">// 链表，将当前节点跟其他节点链接起来</span></span><br><span class="line">    gp   guintptr         <span class="comment">// g</span></span><br><span class="line">    m    muintptr         <span class="comment">// m，禁止抢占</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无锁栈</span></span><br><span class="line"><span class="keyword">type</span> lfnode <span class="keyword">struct</span> &#123;</span><br><span class="line">    next    <span class="type">uint64</span>        <span class="comment">// next指针</span></span><br><span class="line">    pushcnt <span class="type">uintptr</span>       <span class="comment">// 计数器/索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><h3 id="时间触发"><a href="#时间触发" class="headerlink" title="时间触发"></a>时间触发</h3><p>时间触发的GC注册在init函数，由runtime.main负责启动，如果检查到2min内没有执行过任何GC，则触发运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// start forcegc helper goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// gcTriggerTime类型的GC</span></span><br><span class="line">    <span class="keyword">go</span> forcegchelper()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由sysmon管理</span></span><br><span class="line"><span class="keyword">type</span> forcegcstate <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock mutex       <span class="comment">// 锁</span></span><br><span class="line">    g    *g          <span class="comment">// g</span></span><br><span class="line">    idle atomic.Bool <span class="comment">// 空闲时挂起休眠，g运行时设置为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> forcegc forcegcstate</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcTriggerTime类型的GC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forcegchelper</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 纪录当前g</span></span><br><span class="line">    forcegc.g = getg()</span><br><span class="line">    <span class="comment">// 锁初始化</span></span><br><span class="line">    lockInit(&amp;forcegc.lock, lockRankForcegc)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock(&amp;forcegc.lock)</span><br><span class="line">        <span class="comment">// 期望idle为false</span></span><br><span class="line">        <span class="keyword">if</span> forcegc.idle.Load() &#123;</span><br><span class="line">            throw(<span class="string">&quot;forcegc: phase error&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// idle设置为true</span></span><br><span class="line">        forcegc.idle.Store(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前g让出CPU，g0执行调度运行其他g</span></span><br><span class="line">        <span class="comment">// 在内部g、m解除绑定后会解锁forcegc.lock</span></span><br><span class="line">        goparkunlock(&amp;forcegc.lock, waitReasonForceGCIdle, traceBlockSystemGoroutine, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被sysmon唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为0，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.gctrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;GC forced&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gcTriggerTime类型，超过2min未GC则强制运行</span></span><br><span class="line">        gcStart(gcTrigger&#123;kind: gcTriggerTime, now: nanotime()&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆大小触发"><a href="#堆大小触发" class="headerlink" title="堆大小触发"></a>堆大小触发</h3><p>每次分配内存时，判断heap内存大小是否达到临界点，达到临界点则触发运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">    gcStart(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>由用户调用runtime.GC()手动触发，大概的逻辑为：</p>
<ol>
<li>等待当前周期结束</li>
<li>执行新周期的GC</li>
<li>等待标记、清扫完全结束</li>
<li>更新heap统计数据</li>
</ol>
<p>该操作会阻塞当前线程，甚至是阻塞整个程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := work.cycles.Load()</span><br><span class="line">    <span class="comment">// 等待第n个周期结束（_GCmarktermination时唤醒）</span></span><br><span class="line">    gcWaitOnMark(n)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行GC</span></span><br><span class="line">    gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待第n+1个周期结束（_GCmarktermination时唤醒）</span></span><br><span class="line">    gcWaitOnMark(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtime.GC()被很多测试、压测调用，需要确保GC完成sweep阶段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前周期 and 完成剩余mspan的清扫</span></span><br><span class="line">    <span class="keyword">for</span> work.cycles.Load() == n+<span class="number">1</span> &amp;&amp; sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 清理了一个mspan</span></span><br><span class="line">        <span class="comment">// 同协程yield关键字，当前G让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">        Gosched()</span><br><span class="line">        <span class="comment">// 被重新调度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap的状态可能还在周期n</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前周期 and sweep阶段还没结束</span></span><br><span class="line">    <span class="keyword">for</span> work.cycles.Load() == n+<span class="number">1</span> &amp;&amp; !isSweepDone() &#123;</span><br><span class="line">        <span class="comment">// 同协程yield关键字，当前G让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">        Gosched()</span><br><span class="line">        <span class="comment">// 被重新调度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，sweep阶段确定是结束了</span></span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    cycle := work.cycles.Load()</span><br><span class="line">    <span class="comment">// 当前周期 or 下一个周期</span></span><br><span class="line">    <span class="keyword">if</span> cycle == n+<span class="number">1</span> || (gcphase == _GCmark &amp;&amp; cycle == n+<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 将的heap统计数据累加到active</span></span><br><span class="line">        mProf_PostSweep()</span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><h3 id="第1阶段：Sweep-Termination（清理终止）"><a href="#第1阶段：Sweep-Termination（清理终止）" class="headerlink" title="第1阶段：Sweep Termination（清理终止）"></a>第1阶段：Sweep Termination（清理终止）</h3><p>大概流程如下</p>
<ol>
<li>guard，检查函数运行的前提条件</li>
<li>协助sweeper清理剩余的mspan</li>
<li>创建标记工作线程（这个阶段前，将世界停止）</li>
<li>重置GC状态</li>
<li>停止所有p</li>
<li>清扫、回收</li>
<li>开始启动GC（设置各种状态、纪录快照等，开启写屏障）</li>
<li>一切都准备好了，可以并发标记了（这个阶段后，恢复世界）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// g0或m禁止抢占</span></span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp == mp.g0 || mp.locks &gt; <span class="number">1</span> || mp.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 不处理</span></span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line">    mp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        sg := gp.syncGroup</span><br><span class="line">        gp.syncGroup = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            gp.syncGroup = sg</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 协助清扫</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果满足运行条件就把剩余的mspan都清扫完</span></span><br><span class="line">    <span class="keyword">for</span> trigger.test() &amp;&amp; sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不满足GC运行条件 or 没有mspan需要清扫</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取work.startSema，失败则挂起等待</span></span><br><span class="line">    semacquire(&amp;work.startSema)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="comment">// 不满足GC运行条件</span></span><br><span class="line">    <span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">        <span class="comment">// 恢复世界后释放，唤醒其他g，可以运行其他GC了，虽然可能会被阻挡</span></span><br><span class="line">        semrelease(&amp;work.startSema)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有mspan需要清扫，可以启动新流程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认，并发GC和sweep</span></span><br><span class="line">    mode := gcBackgroundMode</span><br><span class="line">    <span class="comment">// gcstoptheworld默认为0，下面两个条件不管</span></span><br><span class="line">    <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">1</span> &#123;</span><br><span class="line">        mode = gcForceMode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">2</span> &#123;</span><br><span class="line">        mode = gcForceBlockMode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取gcsema，失败则挂起等待（确保同一时间只有一个GC流程在运行）</span></span><br><span class="line">    semacquire(&amp;gcsema)</span><br><span class="line">    <span class="comment">// 尝试获取worldsema，失败则挂起等待（确保同一时间只能有一个线程执行STW）</span></span><br><span class="line">    semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcTriggerCycle =&gt; 手动强制执行（这里用于统计）</span></span><br><span class="line">    work.userForced = trigger.kind == gcTriggerCycle</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历allp</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// 一般情况下flushGen与sweepgen是同步的</span></span><br><span class="line">        <span class="keyword">if</span> fg := p.mcache.flushGen.Load(); fg != mheap_.sweepgen &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: p&quot;</span>, p.id, <span class="string">&quot;flushGen&quot;</span>, fg, <span class="string">&quot;!= sweepgen&quot;</span>, mheap_.sweepgen)</span><br><span class="line">            throw(<span class="string">&quot;p mcache not flushed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建标记工作线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个p启动一个标记工作线程gcBgMarkWorker，负责第2阶段，先挂起等待调度器调度</span></span><br><span class="line">    <span class="comment">// （调度的前提是gcBlackenEnabled=1，下方设置）</span></span><br><span class="line">    gcBgMarkStartWorkers()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 重置GC状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，切换到g0运行gcResetMarkState</span></span><br><span class="line">    <span class="comment">// 所有g标记为栈未扫描、助攻积分清0，所有heapArena清除pageMarks，重置bytesMarked、同步heapLive</span></span><br><span class="line">    systemstack(gcResetMarkState)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 停止所有p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同p的总量</span></span><br><span class="line">    work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs</span><br><span class="line">    <span class="comment">// =max(gomaxprocs,ncpu)</span></span><br><span class="line">    <span class="keyword">if</span> work.stwprocs &gt; ncpu &#123;</span><br><span class="line">        <span class="comment">// 取实际CPU核心数量</span></span><br><span class="line">        work.stwprocs = ncpu</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// heap存活字节数</span></span><br><span class="line">    work.heap0 = gcController.heapLive.Load()</span><br><span class="line">    <span class="comment">// STW耗时</span></span><br><span class="line">    work.pauseNS = <span class="number">0</span></span><br><span class="line">    <span class="comment">// gcBackgroundMode，默认，并发标记、清扫</span></span><br><span class="line">    work.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 第1阶段开始时刻</span></span><br><span class="line">    work.tSweepTerm = now</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STW原因、耗时信息</span></span><br><span class="line">    <span class="keyword">var</span> stw worldStop</span><br><span class="line">    <span class="comment">// 切换到g0执行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 将所有p都停止，返回原因、时间信息</span></span><br><span class="line">        stw = stopTheWorldWithSema(stwGCSweepTerm)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，所有的p都放进空闲队列了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 清扫、回收</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU暂停时间GCPauseTime、GCTotalTime更新 =&gt; +=stoppingCPUTime*1</span></span><br><span class="line">    work.cpuStats.accumulateGCPauseTime(stw.stoppingCPUTime, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到g0执行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 清理所有mspan、重置mcentral、唤醒scavenger、gcBitsArenas迭代</span></span><br><span class="line">        finishsweep_m()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC第1阶段时，清理sync.Pool、sudog缓存、defer pool及其他</span></span><br><span class="line">    clearpools()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 开始启动GC</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 周期计数器n+1</span></span><br><span class="line">    work.cycles.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置相关字段，计算不同模式的标记工作线程目标，设置最大标记工作线程数，计算辅助GC的工作量转换参数</span></span><br><span class="line">    gcController.startCycle(now, <span class="type">int</span>(gomaxprocs), trigger)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步gcEnabled、标记当前处于过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">    gcCPULimiter.startGCTransition(<span class="literal">true</span>, now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非默认模式，忽略</span></span><br><span class="line">    <span class="keyword">if</span> mode != gcBackgroundMode &#123;</span><br><span class="line">        <span class="comment">// 同步标记，如果允许user类型g运行则把阻塞的g全部放回全局队列并尝试获取p绑定m唤醒运行</span></span><br><span class="line">        schedEnableUser(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步gcphase，如果是_GCmark或_GCmarktermination，开启写屏障</span></span><br><span class="line">    setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nproc、nwait设为32位无符号数最大值（需要在协助线程启动前运行）</span></span><br><span class="line">    gcBgMarkPrepare()</span><br><span class="line">    <span class="comment">// 获取快照，计算各个根对象的块数量、基地址（索引）</span></span><br><span class="line">    gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tiny区域对象置灰放入队列</span></span><br><span class="line">    gcMarkTinyAllocs()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcBlackenEnabled意味着写屏障、协助线程已开启，可以开始标记</span></span><br><span class="line">    atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 到这里，第2阶段已经可以准备运行了 =&gt; gcBgMarkWorker可以开始标记了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    mp = acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU暂停时间GCPauseTime、GCTotalTime更新 =&gt; +=d*maxprocs</span></span><br><span class="line">    work.cpuStats.accumulateGCPauseTime(nanotime()-stw.finishedStopping, work.maxprocs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 一切都准备好了，可以并发标记了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发标记</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</span></span><br><span class="line">        now = startTheWorldWithSema(<span class="number">0</span>, stw)</span><br><span class="line">        <span class="comment">// 到这里，已经有p和m被唤醒绑定并去寻找g运行了，第2阶段确实在运行了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// STW耗时</span></span><br><span class="line">        work.pauseNS += now - stw.startedStopping</span><br><span class="line">        <span class="comment">// 第2阶段开始时刻</span></span><br><span class="line">        work.tMark = now</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解除过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">        gcCPULimiter.finishGCTransition(now)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复世界后释放，唤醒其他g，其他组件可以开始STW</span></span><br><span class="line">    <span class="comment">// 注意：需要在Gosched前先释放，后面会重新获取，否则造成死锁</span></span><br><span class="line">    semrelease(&amp;worldsema)</span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非默认模式，忽略</span></span><br><span class="line">    <span class="keyword">if</span> mode != gcBackgroundMode &#123;</span><br><span class="line">        <span class="comment">// 同协程yield关键字，当前G让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">        Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复世界后释放，唤醒其他g，可以运行其他GC了，虽然可能会被阻挡</span></span><br><span class="line">    semrelease(&amp;work.startSema)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个p启动一个标记工作线程gcBgMarkWorker，负责第2阶段，先挂起等待调度器调度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 数量足够</span></span><br><span class="line">    <span class="keyword">if</span> gcBgMarkWorkerCount &gt;= gomaxprocs &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 带缓存channel</span></span><br><span class="line">    ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 恢复</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数量不足</span></span><br><span class="line">    <span class="keyword">for</span> gcBgMarkWorkerCount &lt; gomaxprocs &#123;</span><br><span class="line">        <span class="comment">// 禁止抢占</span></span><br><span class="line">        mp := acquirem()</span><br><span class="line">        <span class="comment">// 启动gcBgMarkWorker</span></span><br><span class="line">        <span class="keyword">go</span> gcBgMarkWorker(ready)</span><br><span class="line">        <span class="comment">// 恢复</span></span><br><span class="line">        releasem(mp)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待gcBgMarkWorker准备好</span></span><br><span class="line">        &lt;-ready</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器更新</span></span><br><span class="line">        gcBgMarkWorkerCount++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第2阶段：Mark（标记）"><a href="#第2阶段：Mark（标记）" class="headerlink" title="第2阶段：Mark（标记）"></a>第2阶段：Mark（标记）</h3><p>大概流程如下</p>
<ol>
<li>挂起等待调度器唤醒</li>
<li>根据模式设置标志位，运行标记任务<ol>
<li>初始化参数</li>
<li>扫描根对象</li>
<li>从队列获取灰色对象标记</li>
</ol>
</li>
<li>重置相关字段、纪录耗时，如果是最后一个标记工作线程，启动第3阶段：Mark Termination（标记终止）<ol>
<li>STW，确定已经没有标记任务</li>
<li>根据统计数据调整栈的初始大小</li>
<li>唤醒所有因为辅助标记、weak-&gt;strong转换挂起的g</li>
<li>运行user类型的g运行</li>
<li>计算目标heap大小和并发标记进度</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标记工作线程，负责第2阶段：Mark（标记）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">(ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    gp.m.preemptoff = <span class="string">&quot;GC worker init&quot;</span></span><br><span class="line">    <span class="comment">// worker</span></span><br><span class="line">    node := <span class="built_in">new</span>(gcBgMarkWorkerNode)</span><br><span class="line">    <span class="comment">// 重置（可抢占）</span></span><br><span class="line">    gp.m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂存g</span></span><br><span class="line">    node.gp.set(gp)</span><br><span class="line">    <span class="comment">// 暂存m</span></span><br><span class="line">    node.m.set(acquirem())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知父g</span></span><br><span class="line">    ready &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后台mark线程由gcController.findRunnableGCWorker调度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 当前G让出CPU，g0执行调度运行其他g</span></span><br><span class="line">        gopark(<span class="function"><span class="keyword">func</span><span class="params">(g *g, nodep unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="comment">// 挂起前运行</span></span><br><span class="line">            <span class="comment">// 创建worker放到gcBgMarkWorkerPool</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 类型转换</span></span><br><span class="line">            node := (*gcBgMarkWorkerNode)(nodep)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// g与m已关联</span></span><br><span class="line">            <span class="keyword">if</span> mp := node.m.ptr(); mp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 释放</span></span><br><span class="line">                releasem(mp)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把g放到gcBgMarkWorkerPool队列头部</span></span><br><span class="line">            gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;, unsafe.Pointer(node), waitReasonGCWorkerIdle, traceBlockSystemGoroutine, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 被调度器唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止抢占</span></span><br><span class="line">        node.m.set(acquirem())</span><br><span class="line">        <span class="comment">// m.p不会被改变</span></span><br><span class="line">        pp := gp.m.p.ptr()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC未启动/停止，异常</span></span><br><span class="line">        <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;worker mode&quot;</span>, pp.gcMarkWorkerMode)</span><br><span class="line">            throw(<span class="string">&quot;gcBgMarkWorker: blackening not enabled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mode为默认值 =&gt; 未更新</span></span><br><span class="line">        <span class="keyword">if</span> pp.gcMarkWorkerMode == gcMarkWorkerNotWorker &#123;</span><br><span class="line">            throw(<span class="string">&quot;gcBgMarkWorker: mode not set&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC标记线程的执行开始时刻</span></span><br><span class="line">        startTime := nanotime()</span><br><span class="line">        pp.gcMarkWorkerStartTime = startTime</span><br><span class="line">        <span class="keyword">var</span> trackLimiterEvent <span class="type">bool</span></span><br><span class="line">        <span class="comment">// 空闲标记任务</span></span><br><span class="line">        <span class="keyword">if</span> pp.gcMarkWorkerMode == gcMarkWorkerIdleMode &#123;</span><br><span class="line">            <span class="comment">// stamp存储limiterEventIdleMarkWork和startTime</span></span><br><span class="line">            trackLimiterEvent = pp.limiterEvent.start(limiterEventIdleMarkWork, startTime)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列容量/计数器 nwait-=1</span></span><br><span class="line">        decnwait := atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// 异常，nproc&gt;=nwait</span></span><br><span class="line">        <span class="keyword">if</span> decnwait == work.nproc &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: work.nwait=&quot;</span>, decnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">            throw(<span class="string">&quot;work.nwait was &gt; work.nproc&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面扫描根对象、灰色对象队列并标记（标记g为可抢占，使得栈可被扫描）</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">            casGToWaitingForGC(gp, _Grunning, waitReasonGCWorkerActive)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// gcMarkWorkerMode在findRunnableGCWorker设置</span></span><br><span class="line">            <span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// 为0或其他，异常状态</span></span><br><span class="line">                throw(<span class="string">&quot;gcBgMarkWorker: unexpected gcMarkWorkerMode&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerDedicatedMode:     <span class="comment">// 专用标记任务，p被mark线程占用，不可被抢占</span></span><br><span class="line">                <span class="comment">// 设置gcDrainFlushBgCredit|gcDrainUntilPreempt标记，执行gcDrain（可被抢占）</span></span><br><span class="line">                gcDrainMarkWorkerDedicated(&amp;pp.gcw, <span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 被抢占中</span></span><br><span class="line">                <span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">                    <span class="comment">// 抽走p本地队列所有数据</span></span><br><span class="line">                    <span class="keyword">if</span> drainQ, n := runqdrain(pp); n &gt; <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 全局队列加锁</span></span><br><span class="line">                        lock(&amp;sched.lock)</span><br><span class="line">                        <span class="comment">// 把一批g放到全局队列</span></span><br><span class="line">                        globrunqputbatch(&amp;drainQ, <span class="type">int32</span>(n))</span><br><span class="line">                        <span class="comment">// 解锁</span></span><br><span class="line">                        unlock(&amp;sched.lock)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置gcDrainFlushBgCredit标记，执行gcDrain（不可被抢占）</span></span><br><span class="line">                gcDrainMarkWorkerDedicated(&amp;pp.gcw, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerFractionalMode:     <span class="comment">// 比例标记任务，可被抢占</span></span><br><span class="line">                <span class="comment">// 设置gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit标记，执行gcDrain</span></span><br><span class="line">                <span class="comment">// pollFractionalWorkerExit返回true时会自行抢占</span></span><br><span class="line">                gcDrainMarkWorkerFractional(&amp;pp.gcw)</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerIdleMode:             <span class="comment">// 空闲标记任务</span></span><br><span class="line">                <span class="comment">// 设置gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit标记，执行gcDrain</span></span><br><span class="line">                <span class="comment">// 如果p有其他g，转而执行其他g</span></span><br><span class="line">                gcDrainMarkWorkerIdle(&amp;pp.gcw)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 耗时</span></span><br><span class="line">        now := nanotime()</span><br><span class="line">        duration := now - startTime</span><br><span class="line">        <span class="comment">// 累计标记耗时、复原计数器</span></span><br><span class="line">        gcController.markWorkerStop(pp.gcMarkWorkerMode, duration)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> trackLimiterEvent &#123;</span><br><span class="line">            <span class="comment">// 重置stamp字段，纪录耗时</span></span><br><span class="line">            pp.limiterEvent.stop(limiterEventIdleMarkWork, now)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比例标记任务</span></span><br><span class="line">        <span class="keyword">if</span> pp.gcMarkWorkerMode == gcMarkWorkerFractionalMode &#123;</span><br><span class="line">            <span class="comment">// 累计比例标记任务任务下的标记耗时</span></span><br><span class="line">            atomic.Xaddint64(&amp;pp.gcFractionalMarkTime, duration)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器，同时也是用于判断是否是最后一个标记工作线程</span></span><br><span class="line">        incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> incnwait &gt; work.nproc &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: p.gcMarkWorkerMode=&quot;</span>, pp.gcMarkWorkerMode,</span><br><span class="line">                <span class="string">&quot;work.nwait=&quot;</span>, incnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">            throw(<span class="string">&quot;work.nwait &gt; work.nproc&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置为0</span></span><br><span class="line">        pp.gcMarkWorkerMode = gcMarkWorkerNotWorker</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列为空（最后一个标记工作线程） and 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）</span></span><br><span class="line">        <span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">            releasem(node.m.ptr())</span><br><span class="line">            <span class="comment">// 解除m绑定</span></span><br><span class="line">            node.m.set(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            gcMarkDone()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲标记任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrainMarkWorkerIdle</span><span class="params">(gcw *gcWork)</span></span> &#123;</span><br><span class="line">    gcDrain(gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 专用标记任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrainMarkWorkerDedicated</span><span class="params">(gcw *gcWork, untilPreempt <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    flags := gcDrainFlushBgCredit</span><br><span class="line">    <span class="keyword">if</span> untilPreempt &#123;</span><br><span class="line">        <span class="comment">// 可被抢占</span></span><br><span class="line">        flags |= gcDrainUntilPreempt</span><br><span class="line">    &#125;</span><br><span class="line">    gcDrain(gcw, flags)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比例标记任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrainMarkWorkerFractional</span><span class="params">(gcw *gcWork)</span></span> &#123;</span><br><span class="line">    gcDrain(gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描根对象、灰色对象队列并标记</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 写屏障未开启</span></span><br><span class="line">    <span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcDrain phase incorrect&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    gp := getg().m.curg</span><br><span class="line">    <span class="comment">// p （前提是非抢占）</span></span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line">    <span class="comment">// 一般都有设置gcDrainUntilPreempt</span></span><br><span class="line">    preemptible := flags&amp;gcDrainUntilPreempt != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 默认开启</span></span><br><span class="line">    flushBgCredit := flags&amp;gcDrainFlushBgCredit != <span class="number">0</span></span><br><span class="line">    <span class="comment">// p空闲</span></span><br><span class="line">    idle := flags&amp;gcDrainIdle != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快照</span></span><br><span class="line">    initScanWork := gcw.heapScanWork</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始为2^64-1，后面根据任务类型调整，空闲标记任务和比例标记任务只有100000额度</span></span><br><span class="line">    checkWork := <span class="type">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有空闲标记任务和比例标记任务才有</span></span><br><span class="line">    <span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空闲标记任务 or 比例标记任务</span></span><br><span class="line">    <span class="keyword">if</span> flags&amp;(gcDrainIdle|gcDrainFractional) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// heapScanWork快照+100000</span></span><br><span class="line">        checkWork = initScanWork + drainCheckThreshold</span><br><span class="line">        <span class="keyword">if</span> idle &#123;</span><br><span class="line">            <span class="comment">// 空闲标记任务</span></span><br><span class="line">            <span class="comment">// 队列为空时执行netpoll轮询，检查有g返回true</span></span><br><span class="line">            check = pollWork</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> flags&amp;gcDrainFractional != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 比例标记任务</span></span><br><span class="line">            <span class="comment">// 判断标记工作线程是否需要自我抢占，超过目标值返回true</span></span><br><span class="line">            check = pollFractionalWorkerExit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描根对象</span></span><br><span class="line">    <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="comment">// 如果可抢占、有g想要STW、有g在运行forEachP，停止</span></span><br><span class="line">        <span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || sched.gcwaiting.Load() || pp.runSafePointFn != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// job=markrootNext; markrootNext+=1</span></span><br><span class="line">            job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">            <span class="comment">// 索引/计数器超限，没任务了</span></span><br><span class="line">            <span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line">                <span class="comment">// 退出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据索引扫描指定的根对象，扫描的字节数除了返回还会累计到gcController</span></span><br><span class="line">            markroot(gcw, job, flushBgCredit)</span><br><span class="line">            <span class="comment">// 空闲标记任务和比例标记任务需要运行check函数</span></span><br><span class="line">            <span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">                <span class="comment">// 需要让出CPU，退出标记任务</span></span><br><span class="line">                <span class="keyword">goto</span> done</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描灰色对象队列</span></span><br><span class="line">    <span class="comment">// 如果可抢占、有g想要STW、有g在运行forEachP，停止</span></span><br><span class="line">    <span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || sched.gcwaiting.Load() || pp.runSafePointFn != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// work.full为空 =&gt; 确保work.full不为空</span></span><br><span class="line">        <span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// wbuf2不为空则全部放入work.full，否则将wbuf1的一半放到work.full</span></span><br><span class="line">            gcw.balance()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先从工作队列拿数据，没有就从写屏障拿</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从wbuf获取一个obj，未初始化或为空直接返回</span></span><br><span class="line">        b := gcw.tryGetFast()</span><br><span class="line">        <span class="comment">// 没有拿到</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 从wbuf获取一个obj</span></span><br><span class="line">            b = gcw.tryGet()</span><br><span class="line">            <span class="comment">// 还是没有</span></span><br><span class="line">            <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">                wbBufFlush()</span><br><span class="line">                <span class="comment">// 从wbuf获取一个obj</span></span><br><span class="line">                b = gcw.tryGet()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3次均失败</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从本地任务缓冲区获取到对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描一个对象（最多128KB，剩余放到任务缓冲区）内所有指针，设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">        scanobject(b, gcw)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;= 2000 =&gt; heapScanWork每达到2000则刷新到全局计数器里</span></span><br><span class="line">        <span class="keyword">if</span> gcw.heapScanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">            <span class="comment">// 累计到全局heapScanWork</span></span><br><span class="line">            gcController.heapScanWork.Add(gcw.heapScanWork)</span><br><span class="line">            <span class="comment">// 默认开启</span></span><br><span class="line">            <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">                <span class="comment">// 根据额度唤醒一批g，额度有剩余就累计到全局额度bgScanCredit（与gcParkAssist成对使用）</span></span><br><span class="line">                gcFlushBgCredit(gcw.heapScanWork - initScanWork)</span><br><span class="line">                <span class="comment">// 快照清0，跟heapScanWork同步</span></span><br><span class="line">                initScanWork = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 额度扣除</span></span><br><span class="line">            checkWork -= gcw.heapScanWork</span><br><span class="line">            <span class="comment">//重置</span></span><br><span class="line">            gcw.heapScanWork = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 额度不足</span></span><br><span class="line">            <span class="keyword">if</span> checkWork &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 说明是空闲标记任务和比例标记任务</span></span><br><span class="line">                <span class="comment">// 额度再加100000</span></span><br><span class="line">                checkWork += drainCheckThreshold</span><br><span class="line">                <span class="comment">// 空闲标记任务和比例标记任务需要运行check函数</span></span><br><span class="line">                <span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">                    <span class="comment">// 需要让出CPU，退出标记任务</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// 收尾，循环后，本地heapScanWork有剩余，刷新到全局计数器里（看循环内部代码即可）</span></span><br><span class="line">    <span class="keyword">if</span> gcw.heapScanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 累计到全局heapScanWork</span></span><br><span class="line">        gcController.heapScanWork.Add(gcw.heapScanWork)</span><br><span class="line">        <span class="comment">// 默认开启</span></span><br><span class="line">        <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">            <span class="comment">// 根据额度唤醒一批g，额度有剩余就累计到全局额度bgScanCredit（与gcParkAssist成对使用）</span></span><br><span class="line">            gcFlushBgCredit(gcw.heapScanWork - initScanWork)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        gcw.heapScanWork = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责启动第3阶段：Mark Termination（标记终止）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取work.markDoneSema，失败则挂起等待（确保只有一个线程在执行）</span></span><br><span class="line">    semacquire(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="comment">// !(标记阶段 and 队列为空 and 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）)</span></span><br><span class="line">    <span class="keyword">if</span> !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>)) &#123;</span><br><span class="line">        <span class="comment">// 还在有对象需要标记</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放信号量，唤醒其他g</span></span><br><span class="line">        semrelease(&amp;work.markDoneSema)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取worldsema，失败则挂起等待（STW）</span></span><br><span class="line">    semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止weak-&gt;strong转换</span></span><br><span class="line">    work.strongFromWeak.block = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空所有本地缓存并收集标记</span></span><br><span class="line">    gcMarkDoneFlushed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让p的g进入等待，强制让p进入空闲状态，执行safePoint函数</span></span><br><span class="line">    forEachP(waitReasonGCMarkTermination, <span class="function"><span class="keyword">func</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">        wbBufFlush1(pp)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf1、wbuf2根据容量选择放入work.empty或work.full队列</span></span><br><span class="line">        pp.gcw.dispose()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">        <span class="keyword">if</span> pp.gcw.flushedWork &#123;</span><br><span class="line">            <span class="comment">// 累计</span></span><br><span class="line">            atomic.Xadd(&amp;gcMarkDoneFlushed, <span class="number">1</span>)</span><br><span class="line">            pp.gcw.flushedWork = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有更多灰色对象被发现，不能进入第3阶段</span></span><br><span class="line">    <span class="keyword">if</span> gcMarkDoneFlushed != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复世界后释放，唤醒其他g，其他组件可以开始STW</span></span><br><span class="line">        semrelease(&amp;worldsema)</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">for</span> gcDebugMarkDone.spinAfterRaggedBarrier.Load() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经没有任何标记任务了，可以开启第3阶段</span></span><br><span class="line"></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 第3阶段开始时刻</span></span><br><span class="line">    work.tMarkTerm = now</span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    getg().m.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stw worldStop</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 将所有p都停止，返回原因、时间信息</span></span><br><span class="line">        stw = stopTheWorldWithSema(stwGCMarkTerm)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU暂停时间GCPauseTime、GCTotalTime更新 =&gt; +=d*maxprocs</span></span><br><span class="line">    work.cpuStats.accumulateGCPauseTime(stw.stoppingCPUTime, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为写屏障的缘故，可能还有一些任务残留</span></span><br><span class="line">    restart := <span class="literal">false</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">            wbBufFlush1(p)</span><br><span class="line">            <span class="comment">// wbuf队列不为空，不能进入第3阶段</span></span><br><span class="line">            <span class="keyword">if</span> !p.gcw.empty() &#123;</span><br><span class="line">                restart = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 回到开头重试</span></span><br><span class="line">    <span class="keyword">if</span> restart &#123;</span><br><span class="line">        gcDebugMarkDone.restartedDueTo27993 = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置（可抢占）</span></span><br><span class="line">        getg().m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// CPU暂停时间GCPauseTime、GCTotalTime更新 =&gt; +=d*maxprocs</span></span><br><span class="line">            work.cpuStats.accumulateGCPauseTime(nanotime()-stw.finishedStopping, work.maxprocs)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</span></span><br><span class="line">            now := startTheWorldWithSema(<span class="number">0</span>, stw)</span><br><span class="line">            <span class="comment">// STW耗时</span></span><br><span class="line">            work.pauseNS += now - stw.startedStopping</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 恢复世界后释放，唤醒其他g，其他组件可以开始STW</span></span><br><span class="line">        semrelease(&amp;worldsema)</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里确定可以进入第3阶段了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据统计数据调整栈的初始大小</span></span><br><span class="line">    gcComputeStartingStackSize()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC未启动/停止 =&gt; 协助线程、标记工作线程已停止，禁止标记</span></span><br><span class="line">    atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步gcEnabled、标记当前处于过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">    gcCPULimiter.startGCTransition(<span class="literal">false</span>, now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有被阻塞的g（辅助标记）</span></span><br><span class="line">    gcWakeAllAssists()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许所有weak-&gt;strong转换</span></span><br><span class="line">    work.strongFromWeak.block = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 将strongFromWeak.q所有的g放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">    gcWakeAllStrongFromWeak()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放信号量，唤醒其他g，使其他g可以调用gcMarkDone</span></span><br><span class="line">    semrelease(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步标记，如果允许user类型g运行则把阻塞的g全部放回全局队列并尝试获取p绑定m唤醒运行</span></span><br><span class="line">    schedEnableUser(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从gcStart启动循环，到这里终止循环</span></span><br><span class="line">    <span class="comment">// 计算目标heap大小和并发标记进度</span></span><br><span class="line">    gcController.endCycle(now, <span class="type">int</span>(gomaxprocs), work.userForced)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入第3阶段：Mark Termination（标记终止）（该函数会恢复世界-Start The World）</span></span><br><span class="line">    gcMarkTermination(stw)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第3阶段：Mark-Termination（标记终止）"><a href="#第3阶段：Mark-Termination（标记终止）" class="headerlink" title="第3阶段：Mark Termination（标记终止）"></a>第3阶段：Mark Termination（标记终止）</h3><p>大概流程如下</p>
<ol>
<li>设置各种状态<ul>
<li>gcphase切换到_GCmarktermination，继续开启写屏障</li>
<li>m禁止抢占，g切换到_Gwaiting，可抢占</li>
<li>清空allgs快照、gcw&#x2F;mcache等残留处理</li>
</ul>
</li>
<li>gcphase切换到_GCoff，关闭写屏障，开启第4阶段：Sweep（清理）</li>
<li>统计信息并计算pacing参数，重置scavenger状态<ul>
<li>同步heap内存使用量</li>
<li>更新memstats、cpuStats耗时信息</li>
<li>设置GC启动阈值、计算目标heap大小和跑道大小</li>
<li>计算辅助GC的工作量转换参数</li>
<li>计算GC触发阈值和目标heap大小</li>
<li>更新sweeper、scavenger的pacing参数</li>
<li>重置scavenge状态、更新scavengeIndex状态</li>
</ul>
</li>
<li>收尾&#x2F;清理<ul>
<li>g切换到_Grunning，m允许抢占</li>
<li>将sweepWaiters放进本地&#x2F;全局队列，并尝试唤醒m处理</li>
<li>epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</li>
<li>清空empty链表，将busy链表数据搬到free链表</li>
<li>stackpool内所有allocCount为0的mspan以及stackLarge所有mspan全部释放</li>
<li>mcache清理<ul>
<li>alloc列表mspan放到partial或full链表、tiny区域清空</li>
<li>清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</li>
</ul>
</li>
<li>pageCache清空</li>
<li>如果目标heap大小超过1GB，尝试开启大页支持</li>
</ul>
</li>
</ol>
<p>到这里，世界开始恢复</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTermination</span><span class="params">(stw worldStop)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 同步gcphase，如果是_GCmark或_GCmarktermination，开启写屏障</span></span><br><span class="line">    setGCPhase(_GCmarktermination)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步heapLive快照</span></span><br><span class="line">    work.heap1 = gcController.heapLive.Load()</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    startTime := nanotime()</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    mp.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">    mp.traceback = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    curgp := mp.curg</span><br><span class="line">    <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">    casGToWaitingForGC(curgp, _Grunning, waitReasonGarbageCollection)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到g0执行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 清空allgs快照、gcw/mcache等残留处理</span></span><br><span class="line">        gcMark(startTime)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stwSwept <span class="type">bool</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 同步bytesMarked-已标记字节数</span></span><br><span class="line">        work.heap2 = work.bytesMarked</span><br><span class="line">        <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &#123;</span><br><span class="line">            startCheckmarks()</span><br><span class="line">            gcResetMarkState()</span><br><span class="line">            gcw := &amp;getg().m.p.ptr().gcw</span><br><span class="line">            gcDrain(gcw, <span class="number">0</span>)</span><br><span class="line">            wbBufFlush1(getg().m.p.ptr())</span><br><span class="line">            gcw.dispose()</span><br><span class="line">            endCheckmarks()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步gcphase，如果是_GCmark或_GCmarktermination，开启写屏障</span></span><br><span class="line">        setGCPhase(_GCoff)</span><br><span class="line">        <span class="comment">// 启动第4阶段</span></span><br><span class="line">        stwSwept = gcSweep(work.mode)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    mp.traceback = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">    casgstatus(curgp, _Gwaiting, _Grunning)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置（可抢占）</span></span><br><span class="line">    mp.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">        throw(<span class="string">&quot;gc done but gcphase != _GCoff&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步heap内存使用量，用于scavenge</span></span><br><span class="line">    memstats.lastHeapInUse = gcController.heapInUse.load()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行gcControllerCommit</span></span><br><span class="line">    <span class="comment">// 设置GC启动阈值、计算目标heap大小和跑道大小，计算辅助GC的工作量转换参数，计算GC触发阈值和目标heap大小，更新sweeper、scavenger的pacing参数</span></span><br><span class="line">    systemstack(gcControllerCommit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新memstats</span></span><br><span class="line">    now := nanotime()                         <span class="comment">// 当前时刻（单调时钟）</span></span><br><span class="line">    sec, nsec, _ := time_now()                <span class="comment">// 获取墙上时钟</span></span><br><span class="line">    unixNow := sec*<span class="number">1e9</span> + <span class="type">int64</span>(nsec)          <span class="comment">// unix时间戳</span></span><br><span class="line">    work.pauseNS += now - stw.startedStopping <span class="comment">// STW耗时</span></span><br><span class="line">    work.tEnd = now                           <span class="comment">// 第4阶段开始时刻</span></span><br><span class="line">    atomic.Store64(&amp;memstats.last_gc_unix, <span class="type">uint64</span>(unixNow)) <span class="comment">// unix时间戳比较好理解</span></span><br><span class="line">    atomic.Store64(&amp;memstats.last_gc_nanotime, <span class="type">uint64</span>(now)) <span class="comment">// 单调时钟</span></span><br><span class="line">    memstats.pause_ns[memstats.numgc%<span class="type">uint32</span>(<span class="built_in">len</span>(memstats.pause_ns))] = <span class="type">uint64</span>(work.pauseNS)</span><br><span class="line">    memstats.pause_end[memstats.numgc%<span class="type">uint32</span>(<span class="built_in">len</span>(memstats.pause_end))] = <span class="type">uint64</span>(unixNow)</span><br><span class="line">    memstats.pause_total_ns += <span class="type">uint64</span>(work.pauseNS)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU暂停时间GCPauseTime、GCTotalTime更新 =&gt; +=d*maxprocs</span></span><br><span class="line">    work.cpuStats.accumulateGCPauseTime(now-stw.finishedStopping, work.maxprocs)</span><br><span class="line">    <span class="comment">// GC、scavenge的累计耗时更新</span></span><br><span class="line">    work.cpuStats.accumulate(now, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =(GCTotalTime-GCIdleTime)/TotalTime</span></span><br><span class="line">    memstats.gc_cpu_fraction = <span class="type">float64</span>(work.cpuStats.GCTotalTime-work.cpuStats.GCIdleTime) / <span class="type">float64</span>(work.cpuStats.TotalTime)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC助攻累计时间</span></span><br><span class="line">    scavenge.assistTime.Store(<span class="number">0</span>)</span><br><span class="line">    scavenge.backgroundTime.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲耗时</span></span><br><span class="line">    sched.idleTime.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动启动</span></span><br><span class="line">    <span class="keyword">if</span> work.userForced &#123;</span><br><span class="line">        <span class="comment">// 计数器更新</span></span><br><span class="line">        memstats.numforcedgc++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前g挂起等待第n个GC周期结束</span></span><br><span class="line">    lock(&amp;work.sweepWaiters.lock)</span><br><span class="line">    <span class="comment">// gc计数器</span></span><br><span class="line">    memstats.numgc++</span><br><span class="line">    <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">    injectglist(&amp;work.sweepWaiters.list)</span><br><span class="line">    unlock(&amp;work.sweepWaiters.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新内存回收器（scavengeIndex）版本计数器、searchAddr、freeHWM</span></span><br><span class="line">    mheap_.pages.scav.index.nextGen()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">    gcCPULimiter.finishGCTransition(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mProfCycle计数器更新</span></span><br><span class="line">    mProf_NextCycle()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器加1，返回mheap_.sweepgen及sweepDrainedMask标记是否已设置</span></span><br><span class="line">    sl := sweep.active.begin()</span><br><span class="line">    <span class="comment">// sweepDrainedMask标记已设置（表示sweeper队列为空）</span></span><br><span class="line">    <span class="keyword">if</span> !stwSwept &amp;&amp; !sl.valid &#123;</span><br><span class="line">        throw(<span class="string">&quot;failed to set sweep barrier&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> stwSwept &amp;&amp; sl.valid &#123;</span><br><span class="line">        throw(<span class="string">&quot;non-concurrent sweep failed to drain all sweep queues&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</span></span><br><span class="line">        startTheWorldWithSema(now, stw)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mProfCycle最低位设置为1</span></span><br><span class="line">    mProf_Flush()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空empty链表，将busy链表数据搬到free链表</span></span><br><span class="line">    prepareFreeWorkbufs()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用freeStackSpans</span></span><br><span class="line">    <span class="comment">// stackpool内所有allocCount为0的mspan以及stackLarge所有mspan全部释放</span></span><br><span class="line">    systemstack(freeStackSpans)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让p的g进入等待，强制让p进入空闲状态，执行safePoint函数</span></span><br><span class="line">    forEachP(waitReasonFlushProcCaches, <span class="function"><span class="keyword">func</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">        <span class="comment">// mcache清理</span></span><br><span class="line">        <span class="comment">// alloc列表mspan放到partial或full链表、tiny区域清空</span></span><br><span class="line">        <span class="comment">// 清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</span></span><br><span class="line">        pp.mcache.prepareForSweep()</span><br><span class="line">        <span class="keyword">if</span> pp.status == _Pidle &#123;</span><br><span class="line">            <span class="comment">// 空闲状态</span></span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                lock(&amp;mheap_.lock)</span><br><span class="line">                <span class="comment">// 清空pageCache</span></span><br><span class="line">                pp.pcache.flush(&amp;mheap_.pages)</span><br><span class="line">                unlock(&amp;mheap_.lock)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        pp.pinnerCache = <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果更新sl.state计数器成功</span></span><br><span class="line">    <span class="keyword">if</span> sl.valid &#123;</span><br><span class="line">        <span class="comment">// 计数器减1</span></span><br><span class="line">        sweep.active.end(sl)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arena包相关，手动管理内存，不讲</span></span><br><span class="line">    lock(&amp;userArenaState.lock)</span><br><span class="line">    faultList := userArenaState.fault</span><br><span class="line">    userArenaState.fault = <span class="literal">nil</span></span><br><span class="line">    unlock(&amp;userArenaState.lock)</span><br><span class="line">    <span class="keyword">for</span> _, lc := <span class="keyword">range</span> faultList &#123;</span><br><span class="line">        <span class="comment">// 使用sysFault将mspan的内存区域标记为不可访问，更新统计信息，最后放到quarantineList列表</span></span><br><span class="line">        lc.mspan.setUserArenaChunkToFault()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果目标heap大小超过1GB</span></span><br><span class="line">    <span class="keyword">if</span> gcController.heapGoal() &gt; minHeapForMetadataHugePages &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 相关内存如heapArena、chunk元素重新按huge_page的大小对齐（linux才有，不一定成功）</span></span><br><span class="line">            mheap_.enableMetadataHugePages()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复世界后释放，唤醒其他g，其他组件可以开始STW</span></span><br><span class="line">    semrelease(&amp;worldsema)</span><br><span class="line">    semrelease(&amp;gcsema)</span><br><span class="line">    <span class="comment">// 到这里，另一个GC循环可能会开始启动</span></span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">    mp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// concurrentSweep默认为true，故这里的判断失败，不执行</span></span><br><span class="line">    <span class="keyword">if</span> !concurrentSweep &#123;</span><br><span class="line">        <span class="comment">// 运行finalizers</span></span><br><span class="line">        <span class="comment">// 同协程yield关键字，当前G让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">        Gosched()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第4阶段：Sweep（清理）"><a href="#第4阶段：Sweep（清理）" class="headerlink" title="第4阶段：Sweep（清理）"></a>第4阶段：Sweep（清理）</h3><p>大概流程如下</p>
<ol>
<li>重置mheap、sweep相关状态</li>
<li>非并发清理模式或手动强制GC<ul>
<li>mcache清理<ul>
<li>alloc列表mspan放到partial或full链表、tiny区域清空</li>
<li>清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</li>
</ul>
</li>
<li>不断的逐个清理mspan</li>
<li>清空empty链表，将busy链表数据搬到free链表</li>
<li>wbuf的free链表清理64个mspan、mspan内存释放回mheap</li>
</ul>
</li>
<li>并发清理模式（默认）<ul>
<li>唤醒后台清扫器-sweeper清扫<ul>
<li>不断的逐个清理mspan，每10个执行一次goschedIfBusy，当可抢占时让出CPU</li>
<li>wbuf的free链表清理64个mspan、mspan内存释放回mheap，当可抢占时让出CPU</li>
<li>还有sweeper在运行时，继续清理mspan，否则挂起休眠</li>
<li>清理mspan时，如果判断已经没有更多的mspan需要清理则设置完结标记，最后一个sweeper通知sysmon唤醒scavenger</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>当scavenger被唤醒后，大概逻辑如下</p>
<ol>
<li>scavenger开始回收，运行时间限制1ms<ol>
<li>如果heap内存没有超过GC触发临界点且总内存没有超过限制，退出</li>
<li>执行mheap_.pages.scavenge，回收64KB字节数量的内存，统计累计耗时</li>
<li>如果回收字节数不足64KB，说明没有更多内存需要回收，退出</li>
<li>如果累计耗时超过1ms，退出</li>
</ol>
</li>
<li>如果释放的字节数为0，挂起休眠，唤醒后重试</li>
<li>累计释放字节数，让出CPU挂起一段时间，更新sleepRatio等信息</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动清扫</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcSweep</span><span class="params">(mode gcMode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非_GCoff阶段</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcSweep being done but phase is not GCoff&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新、重置相关字段</span></span><br><span class="line">    mheap_.sweepgen += <span class="number">2</span> <span class="comment">// 每次清扫完毕都+2</span></span><br><span class="line">    sweep.active.reset() <span class="comment">// sweep.active.state设为0</span></span><br><span class="line">    mheap_.pagesSwept.Store(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// sweepArenas为allArenas快照（凡是heap管理的arena都会放在这里，用户手动管理则不会）</span></span><br><span class="line">    mheap_.sweepArenas = mheap_.allArenas</span><br><span class="line">    mheap_.reclaimIndex.Store(<span class="number">0</span>)</span><br><span class="line">    mheap_.reclaimCredit.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    unlock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置为0</span></span><br><span class="line">    sweep.centralIndex.clear()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非并发GC并发清扫模式（默认） or 手动强制执行</span></span><br><span class="line">    <span class="keyword">if</span> !concurrentSweep || mode == gcForceBlockMode &#123;</span><br><span class="line">        lock(&amp;mheap_.lock)</span><br><span class="line">        <span class="comment">// 每分配1字节需要清扫的页数</span></span><br><span class="line">        mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有p</span></span><br><span class="line">        <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            <span class="comment">// mcache清理</span></span><br><span class="line">            <span class="comment">// alloc列表mspan放到partial或full链表、tiny区域清空</span></span><br><span class="line">            <span class="comment">// 清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</span></span><br><span class="line">            pp.mcache.prepareForSweep()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不断的逐个清理mspan</span></span><br><span class="line">        <span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空empty链表，将busy链表数据搬到free链表</span></span><br><span class="line">        prepareFreeWorkbufs()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf的free链表清理64个mspan、mspan内存释放回mheap</span></span><br><span class="line">        <span class="keyword">for</span> freeSomeWbufs(<span class="literal">false</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mProfCycle计数器更新</span></span><br><span class="line">        mProf_NextCycle()</span><br><span class="line">        <span class="comment">// mProfCycle最低位设置为1</span></span><br><span class="line">        mProf_Flush()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非默认模式手动强制执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒sweeper</span></span><br><span class="line">    lock(&amp;sweep.lock)</span><br><span class="line">    <span class="keyword">if</span> sweep.parked &#123;</span><br><span class="line">        sweep.parked = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 将g放到p.runq队列头部，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        ready(sweep.g, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sweep.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台sweeper，被唤醒时，不停清理wbuf的mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bgsweep</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 纪录当前g</span></span><br><span class="line">    sweep.g = getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    lockInit(&amp;sweep.lock, lockRankSweep)</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;sweep.lock)</span><br><span class="line">    <span class="comment">// 挂起</span></span><br><span class="line">    sweep.parked = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 发送信号给gcenable</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    <span class="comment">// 当前g让出CPU，g0执行调度运行其他g（其内部lock会被解锁）</span></span><br><span class="line">    goparkunlock(&amp;sweep.lock, waitReasonGCSweepWait, traceBlockGCSweep, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 低优先级，尽量空闲时运行</span></span><br><span class="line">        <span class="keyword">const</span> sweepBatchSize = <span class="number">10</span></span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        nSwept := <span class="number">0</span></span><br><span class="line">        <span class="comment">// 不断的逐个清理mspan</span></span><br><span class="line">        <span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            nSwept++</span><br><span class="line">            <span class="comment">// 每10个执行一次goschedIfBusy</span></span><br><span class="line">            <span class="keyword">if</span> nSwept%sweepBatchSize == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 可抢占时让出CPU</span></span><br><span class="line">                goschedIfBusy()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wbuf的free链表清理64个mspan、mspan内存释放回mheap</span></span><br><span class="line">        <span class="keyword">for</span> freeSomeWbufs(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时free链表还有数据</span></span><br><span class="line">            <span class="comment">// 可抢占时让出CPU</span></span><br><span class="line">            goschedIfBusy()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock(&amp;sweep.lock)</span><br><span class="line">        <span class="comment">// sweeper数量不为0</span></span><br><span class="line">        <span class="keyword">if</span> !isSweepDone() &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sweep.lock)</span><br><span class="line">            <span class="comment">// 继续清理mspan</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清理完毕，设置为挂起状态</span></span><br><span class="line">        sweep.parked = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前g让出CPU，g0执行调度运行其他g（其内部lock会被解锁）</span></span><br><span class="line">        goparkunlock(&amp;sweep.lock, waitReasonGCSweepWait, traceBlockGCSweep, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理一个mspan，返回释放页数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweepone</span><span class="params">()</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放置抢占</span></span><br><span class="line">    gp.m.locks++</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计数器加1，返回mheap_.sweepgen及sweepDrainedMask标记是否已设置</span></span><br><span class="line">    sl := sweep.active.begin()</span><br><span class="line">    <span class="comment">// sweeper数量为0</span></span><br><span class="line">    <span class="keyword">if</span> !sl.valid &#123;</span><br><span class="line">        <span class="comment">// sweepDrainedMask标记已设置（表示sweeper队列为空）</span></span><br><span class="line">        gp.m.locks--</span><br><span class="line">        <span class="keyword">return</span> ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =2^64-1</span></span><br><span class="line">    npages := ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> noMoreWork <span class="type">bool</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 根据centralIndex在mcentral寻找未清理的mspan</span></span><br><span class="line">        s := mheap_.nextSpanForSweep()</span><br><span class="line">        <span class="comment">// mspan为nil</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 设置sweepDrainedMask标记，表示sweep已完成</span></span><br><span class="line">            noMoreWork = sweep.active.markDrained()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清理只针对heap管理类型，手动不管</span></span><br><span class="line">        <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> !(s.sweepgen == sl.sweepGen || s.sweepgen == sl.sweepGen+<span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;runtime: bad span s.state=&quot;</span>, state, <span class="string">&quot; s.sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; sweepgen=&quot;</span>, sl.sweepGen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                throw(<span class="string">&quot;non in-use span in unswept list&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试获得mspan的所有权</span></span><br><span class="line">        <span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            npages = s.npages</span><br><span class="line">            <span class="comment">// 清理一个mspan，释放回heap返回true</span></span><br><span class="line">            <span class="keyword">if</span> s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="comment">// 整个mspan都被清理释放</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                mheap_.reclaimCredit.Add(npages)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mspan还在使用中</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                npages = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器减1</span></span><br><span class="line">    sweep.active.end(sl)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sweep已完成</span></span><br><span class="line">    <span class="keyword">if</span> noMoreWork &#123;</span><br><span class="line">        <span class="comment">// 最后一个sweeper负责唤醒scavenger（此时可能还有sweeper在并发运行）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// debug，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.scavtrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                lock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">                releasedBg := mheap_.pages.scav.releasedBg.Load()</span><br><span class="line">                releasedEager := mheap_.pages.scav.releasedEager.Load()</span><br><span class="line"></span><br><span class="line">                printScavTrace(releasedBg, releasedEager, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">                mheap_.pages.scav.releasedBg.Add(-releasedBg)</span><br><span class="line">                mheap_.pages.scav.releasedEager.Add(-releasedEager)</span><br><span class="line">                unlock(&amp;mheap_.lock)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知sysmon唤醒scavenger</span></span><br><span class="line">        scavenger.ready()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp.m.locks--</span><br><span class="line">    <span class="keyword">return</span> npages</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有g标记为栈未扫描、助攻积分清0，所有heapArena清除pageMarks，重置bytesMarked、同步heapLive</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcResetMarkState</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// allg中每个g都执行一遍该函数，期间allglock会被锁住</span></span><br><span class="line">    forEachG(<span class="function"><span class="keyword">func</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 标记栈未扫描</span></span><br><span class="line">        gp.gcscandone = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// Assist额度/助攻积分清0</span></span><br><span class="line">        gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    lock(&amp;mheap_.lock)</span><br><span class="line">    <span class="comment">// allArenas快照 =&gt; []arenaIdx</span></span><br><span class="line">    arenas := mheap_.allArenas</span><br><span class="line">    unlock(&amp;mheap_.lock)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历allArenas快照</span></span><br><span class="line">    <span class="keyword">for</span> _, ai := <span class="keyword">range</span> arenas &#123;</span><br><span class="line">        <span class="comment">// 找到heapArena</span></span><br><span class="line">        ha := mheap_.arenas[ai.l1()][ai.l2()]</span><br><span class="line">        <span class="comment">// 清除pageMarks，共1024*8=8192个位</span></span><br><span class="line">        clear(ha.pageMarks[:])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已标记字节数为0</span></span><br><span class="line">    work.bytesMarked = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 同步heapLive-heap存活字节数快照</span></span><br><span class="line">    work.initialHeapLive = gcController.heapLive.Load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理所有mspan、重置mcentral、唤醒scavenger、gcBitsArenas迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finishsweep_m</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的逐个清理mspan</span></span><br><span class="line">    <span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有mspan可以清理了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从state获取sweeper数量，如果不为0，异常</span></span><br><span class="line">    <span class="keyword">if</span> sweep.active.sweepers() != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;active sweepers found at start of mark phase&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置所有未清理的mspan</span></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// 遍历所有mcentral</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> mheap_.central &#123;</span><br><span class="line">        c := &amp;mheap_.central[i].mcentral</span><br><span class="line">        <span class="comment">// 重置空的spanSet，清理残留的block</span></span><br><span class="line">        c.partialUnswept(sg).reset()</span><br><span class="line">        <span class="comment">// 重置空的spanSet，清理残留的block</span></span><br><span class="line">        c.fullUnswept(sg).reset()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置scavenger状态，修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">    scavenger.wake()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcBitsArenas迭代，如用next替换current等</span></span><br><span class="line">    nextMarkBitArenaEpoch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可抢占时让出CPU</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedIfBusy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 不可抢占 and 空闲p数量不为0</span></span><br><span class="line">    <span class="keyword">if</span> !gp.preempt &amp;&amp; sched.npidle.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行gosched_m函数</span></span><br><span class="line">    <span class="comment">// 当前g、m解除绑定，g交给其他空闲m执行，当前m重新寻找并运行可运行的g</span></span><br><span class="line">    mcall(gosched_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不断执行mheap_.pages.scavenge</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bgscavenge</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// scavenger初始化，绑定g</span></span><br><span class="line">    scavenger.init()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信号给gcenable</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// scavenger让出CPU挂起休眠</span></span><br><span class="line">    scavenger.park()</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// func (s *scavengerState) run() (released uintptr, worked float64)</span></span><br><span class="line">        <span class="comment">// 执行mheap_.pages.scavenge，直到heap耗尽</span></span><br><span class="line">        released, workTime := scavenger.run()</span><br><span class="line">        <span class="comment">// 释放字节数</span></span><br><span class="line">        <span class="keyword">if</span> released == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// scavenger让出CPU挂起休眠</span></span><br><span class="line">            scavenger.park()</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累计释放字节数</span></span><br><span class="line">        mheap_.pages.scav.releasedBg.Add(released)</span><br><span class="line">        <span class="comment">// 让出CPU挂起一段时间，更新sleepRatio等信息</span></span><br><span class="line">        scavenger.sleep(workTime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h2><p><strong>不知道怎么说，从源代码看，跟设计思路对不上</strong></p>
<p>设计思路伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     writePointer(slot, ptr):</span></span><br><span class="line"><span class="comment">//         shade(*slot)              // 删除写屏障</span></span><br><span class="line"><span class="comment">//         if current stack is grey:</span></span><br><span class="line"><span class="comment">//             shade(ptr)            // 插入写屏障</span></span><br><span class="line"><span class="comment">//         *slot = ptr</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// *slot - 旧指针</span></span><br><span class="line"><span class="comment">// ptr   - 新指针</span></span><br></pre></td></tr></table></figure>

<p>实际：</p>
<p>在开启写屏障后，一些内存复制函数会将源内存区域跟目标内存区域内的指针对象收集起来，放入写屏障缓冲区，交给标记工作线程标记。涉及到slice、map、channel等组件，相关内存处理函数如下所示：</p>
<ul>
<li>typedmemmove</li>
<li>typedslicecopy</li>
<li>typedmemclr</li>
<li>memclrHasPointers</li>
<li>makeslicecopy</li>
<li>growslice</li>
<li>reflect.typedmemclr</li>
<li>reflect.typedmemclrpartial</li>
<li>reflect.typedarrayclear</li>
</ul>
<p>其中，typedmemmove源码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从src复制数据到dst</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typedmemmove</span><span class="params">(typ *abi.Type, dst, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 同一个指针</span></span><br><span class="line">    <span class="keyword">if</span> dst == src &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障开启 and 该类型包含指针</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &amp;&amp; typ.Pointers() &#123;</span><br><span class="line">        <span class="comment">// 在src和dst内存区域内寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line">        bulkBarrierPreWrite(<span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), typ.PtrBytes, typ)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从src复制n个字节到dst</span></span><br><span class="line">    memmove(dst, src, typ.Size_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认为false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> goexperiment.CgoCheck2 &#123;</span><br><span class="line">        cgoCheckMemmove2(typ, dst, src, <span class="number">0</span>, typ.Size_)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在src和dst内存区域内寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bulkBarrierPreWrite</span><span class="params">(dst, src, size <span class="type">uintptr</span>, typ *abi.Type)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 非8的倍数</span></span><br><span class="line">    <span class="keyword">if</span> (dst|src|size)&amp;(goarch.PtrSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;bulkBarrierPreWrite: unaligned arguments&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障未开启</span></span><br><span class="line">    <span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据地址找到heapArena再找到mspan</span></span><br><span class="line">    s := spanOf(dst)</span><br><span class="line">    <span class="comment">// p可能在data、bss段上或已释放或其他内存区域如mmap共享内存</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// data段</span></span><br><span class="line">        <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">            <span class="keyword">if</span> datap.data &lt;= dst &amp;&amp; dst &lt; datap.edata &#123;</span><br><span class="line">                <span class="comment">// 根据bitmap信息在src和dst内存区域寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line">                bulkBarrierBitmap(dst, src, size, dst-datap.data, datap.gcdatamask.bytedata)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bss段</span></span><br><span class="line">        <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">            <span class="keyword">if</span> datap.bss &lt;= dst &amp;&amp; dst &lt; datap.ebss &#123;</span><br><span class="line">                <span class="comment">// 根据bitmap信息在src和dst内存区域寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line">                bulkBarrierBitmap(dst, src, size, dst-datap.bss, datap.gcbssmask.bytedata)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s.state.get() != mSpanInUse || dst &lt; s.base() || s.limit &lt;= dst &#123;</span><br><span class="line">        <span class="comment">// 手动管理内存（栈上的引用） or 指针不在mspan管理范围</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面三种情况之一，不管</span></span><br><span class="line">        <span class="comment">// 1. mspan是被释放的heap空间</span></span><br><span class="line">        <span class="comment">// 2. 是某个goroutine的栈</span></span><br><span class="line">        <span class="comment">// 3. 是通过unsafe操作、channel发送，临时出现在其他栈上的指针</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写屏障缓冲</span></span><br><span class="line">    buf := &amp;getg().m.p.ptr().wbBuf</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">const</span> doubleCheck = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> doubleCheck &#123;</span><br><span class="line">        doubleCheckTypePointersOfType(s, typ, dst, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据对象的类型信息在一片内存区域内寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tp typePointers</span><br><span class="line">    <span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息（大对象）</span></span><br><span class="line">        tp = s.typePointersOfType(typ, dst)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息（小对象/对象内部）</span></span><br><span class="line">        tp = s.typePointersOf(dst, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// src为nil，只有一个数需要纪录</span></span><br><span class="line">    <span class="keyword">if</span> src == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> addr <span class="type">uintptr</span></span><br><span class="line">            <span class="comment">// mask第一个uint64不为0则调用nextFast，否则移动下一个uint64再重新判断</span></span><br><span class="line">            <span class="keyword">if</span> tp, addr = tp.next(dst + size); addr == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 扫描到末尾还是没有</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            dstx := (*<span class="type">uintptr</span>)(unsafe.Pointer(addr))</span><br><span class="line">            <span class="comment">// 获取写屏障缓冲区可写入位置（容量为1个指针）</span></span><br><span class="line">            p := buf.get1()</span><br><span class="line">            <span class="comment">// 将dstx写入到写屏障缓冲区</span></span><br><span class="line">            p[<span class="number">0</span>] = *dstx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> addr <span class="type">uintptr</span></span><br><span class="line">            <span class="comment">// mask第一个uint64不为0则调用nextFast，否则移动下一个uint64再重新判断</span></span><br><span class="line">            <span class="keyword">if</span> tp, addr = tp.next(dst + size); addr == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 扫描到末尾还是没有</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            dstx := (*<span class="type">uintptr</span>)(unsafe.Pointer(addr))</span><br><span class="line">            srcx := (*<span class="type">uintptr</span>)(unsafe.Pointer(src + (addr - dst)))</span><br><span class="line">            <span class="comment">// 获取写屏障缓冲区可写入位置（容量为2个指针）</span></span><br><span class="line">            p := buf.get2()</span><br><span class="line">            <span class="comment">// 将dstx、srcx写入到写屏障缓冲区</span></span><br><span class="line">            p[<span class="number">0</span>] = *dstx</span><br><span class="line">            p[<span class="number">1</span>] = *srcx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据bitmap信息在src和dst内存区域寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bulkBarrierBitmap</span><span class="params">(dst, src, size, maskOffset <span class="type">uintptr</span>, bits *<span class="type">uint8</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// =内存字节数/8 =&gt; 共word个指针</span></span><br><span class="line">    word := maskOffset / goarch.PtrSize</span><br><span class="line">    <span class="comment">// 定位到指针对应的bitmap</span></span><br><span class="line">    bits = addb(bits, word/<span class="number">8</span>)</span><br><span class="line">    <span class="comment">// uint8内第几位</span></span><br><span class="line">    mask := <span class="type">uint8</span>(<span class="number">1</span>) &lt;&lt; (word % <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障缓冲区</span></span><br><span class="line">    buf := &amp;getg().m.p.ptr().wbBuf</span><br><span class="line">    <span class="comment">// 遍历复制的字节数，步进为8</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; size; i += goarch.PtrSize &#123;</span><br><span class="line">        <span class="comment">// mask溢出，回到1开始</span></span><br><span class="line">        <span class="keyword">if</span> mask == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 下一个字节</span></span><br><span class="line">            bits = addb(bits, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 8个对象都不是指针类型</span></span><br><span class="line">            <span class="keyword">if</span> *bits == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 跳过这8个数据</span></span><br><span class="line">                i += <span class="number">7</span> * goarch.PtrSize</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回到1开始</span></span><br><span class="line">            mask = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到指针</span></span><br><span class="line">        <span class="keyword">if</span> *bits&amp;mask != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 地址</span></span><br><span class="line">            dstx := (*<span class="type">uintptr</span>)(unsafe.Pointer(dst + i))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// src为nil，只有一个数需要纪录</span></span><br><span class="line">            <span class="keyword">if</span> src == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 获取写屏障缓冲区可写入位置（容量为1个指针）</span></span><br><span class="line">                p := buf.get1()</span><br><span class="line">                <span class="comment">// 将dstx写入到写屏障缓冲区</span></span><br><span class="line">                p[<span class="number">0</span>] = *dstx</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                srcx := (*<span class="type">uintptr</span>)(unsafe.Pointer(src + i))</span><br><span class="line">                <span class="comment">// 获取写屏障缓冲区可写入位置（容量为2个指针）</span></span><br><span class="line">                p := buf.get2()</span><br><span class="line">                <span class="comment">// 将dstx、srcx写入到写屏障缓冲区</span></span><br><span class="line">                p[<span class="number">0</span>] = *dstx</span><br><span class="line">                p[<span class="number">1</span>] = *srcx</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往后寻找一个</span></span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关依赖函数"><a href="#相关依赖函数" class="headerlink" title="相关依赖函数"></a>相关依赖函数</h2><h3 id="GC初始化"><a href="#GC初始化" class="headerlink" title="GC初始化"></a>GC初始化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GC初始化，调度器初始化时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 确保workbuf结构有2KB大小</span></span><br><span class="line">    <span class="keyword">if</span> unsafe.Sizeof(workbuf&#123;&#125;) != _WorkbufSize &#123;</span><br><span class="line">        throw(<span class="string">&quot;size of Workbuf is suboptimal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示sweep阶段已完成</span></span><br><span class="line">    <span class="comment">// sweepDrainedMask = 2^31 =&gt; 2GB</span></span><br><span class="line">    sweep.active.state.Store(sweepDrainedMask)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pacer状态初始化（gcPercent从GOGC获取，memoryLimit从GOMEMLIMIT获取）</span></span><br><span class="line">    gcController.init(readGOGC(), readGOMEMLIMIT())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号量初始化</span></span><br><span class="line">    work.startSema = <span class="number">1</span></span><br><span class="line">    work.markDoneSema = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 锁初始化</span></span><br><span class="line">    lockInit(&amp;work.sweepWaiters.lock, lockRankSweepWaiters)</span><br><span class="line">    lockInit(&amp;work.assistQueue.lock, lockRankAssistQueue)</span><br><span class="line">    lockInit(&amp;work.strongFromWeak.lock, lockRankStrongFromWeakQueue)</span><br><span class="line">    lockInit(&amp;work.wbufSpans.lock, lockRankWbufSpans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动sweeper、scavenger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcenable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// sweeper</span></span><br><span class="line">    <span class="comment">// 被唤醒时，不停清理wbuf的mspan</span></span><br><span class="line">    <span class="keyword">go</span> bgsweep(c)</span><br><span class="line">    <span class="comment">// scavenger</span></span><br><span class="line">    <span class="comment">// 不断执行mheap_.pages.scavenge</span></span><br><span class="line">    <span class="keyword">go</span> bgscavenge(c)</span><br><span class="line">    &lt;-c</span><br><span class="line">    &lt;-c</span><br><span class="line">    <span class="comment">// 标记sweeper和scavenger已运行，可以开始运行GC</span></span><br><span class="line">    memstats.enablegc = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcTrigger-GC触发"><a href="#gcTrigger-GC触发" class="headerlink" title="gcTrigger-GC触发"></a>gcTrigger-GC触发</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否满足条件运行GC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span></span> test() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. gcenable执行后memstats.enablegc为true，false就是还没执行</span></span><br><span class="line">    <span class="comment">// 2. 遇到无法recover的panic时，panicking不为0</span></span><br><span class="line">    <span class="comment">// 3. GC处于非GCoff阶段</span></span><br><span class="line">    <span class="keyword">if</span> !memstats.enablegc || panicking.Load() != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">    <span class="keyword">case</span> gcTriggerHeap: <span class="comment">// heap达到一定大小</span></span><br><span class="line">        <span class="comment">// 计算GC触发阈值和目标heap大小</span></span><br><span class="line">        trigger, _ := gcController.trigger()</span><br><span class="line">        <span class="comment">// heap存活字节数 &gt;= </span></span><br><span class="line">        <span class="keyword">return</span> gcController.heapLive.Load() &gt;= trigger</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> gcTriggerTime: <span class="comment">// 有2min没执行GC</span></span><br><span class="line">        <span class="comment">// gcPercent默认为100</span></span><br><span class="line">        <span class="keyword">if</span> gcController.gcPercent.Load() &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// GC被关闭，不可以执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上一次GC的时刻</span></span><br><span class="line">        lastgc := <span class="type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超过2min未执行GC，可以执行</span></span><br><span class="line">        <span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> gcTriggerCycle: <span class="comment">// 手动、强制执行</span></span><br><span class="line">        <span class="comment">// 如果周期t.n大于全局周期work.cycles，可以执行，否则不执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">int32</span>(t.n-work.cycles.Load()) &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="世界停止-恢复"><a href="#世界停止-恢复" class="headerlink" title="世界停止&#x2F;恢复"></a>世界停止&#x2F;恢复</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使其他p中断/停止执行g进入安全点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorld</span><span class="params">(reason stwReason)</span></span> worldStop &#123;</span><br><span class="line">    <span class="comment">// 尝试获取worldsema，失败则挂起等待</span></span><br><span class="line">    semacquire(&amp;worldsema)</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    gp.m.preemptoff = reason.String()</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">        casGToWaitingForGC(gp, _Grunning, waitReasonStoppingTheWorld)</span><br><span class="line">        <span class="comment">// 将所有p都停止，返回原因、时间信息</span></span><br><span class="line">        stopTheWorldContext = stopTheWorldWithSema(reason)</span><br><span class="line">        <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> stopTheWorldContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等，最后唤醒阻塞在stopTheWorldGC的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorld</span><span class="params">(w worldStop)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 执行startTheWorldWithSema</span></span><br><span class="line">    <span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; startTheWorldWithSema(<span class="number">0</span>, w) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 重置（可抢占）</span></span><br><span class="line">    mp.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">// 释放信号量，唤醒其他阻塞在stopTheWorldGC的g</span></span><br><span class="line">    semrelease1(&amp;worldsema, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使其他p中断/停止执行g进入安全点（阻塞，按顺序执行）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldGC</span><span class="params">(reason stwReason)</span></span> worldStop &#123;</span><br><span class="line">    <span class="comment">// 尝试获取gcsema，失败则挂起等待</span></span><br><span class="line">    semacquire(&amp;gcsema)</span><br><span class="line">    <span class="comment">// 使其他p中断/停止执行g进入安全点</span></span><br><span class="line">    <span class="keyword">return</span> stopTheWorld(reason)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等，最后唤醒阻塞在stopTheWorldGC的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorldGC</span><span class="params">(w worldStop)</span></span> &#123;</span><br><span class="line">    <span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等，最后唤醒阻塞在stopTheWorldGC的g</span></span><br><span class="line">    startTheWorld(w)</span><br><span class="line">    <span class="comment">// 释放信号量，唤醒其他g</span></span><br><span class="line">    semrelease(&amp;gcsema)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有p都停止，返回原因、时间信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldWithSema</span><span class="params">(reason stwReason)</span></span> worldStop &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止抢占（这里容易造成死锁）</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.locks &gt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;stopTheWorld: holding locks&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    start := nanotime()</span><br><span class="line">    <span class="comment">// 待_Pgcstop的p数量</span></span><br><span class="line">    sched.stopwait = gomaxprocs</span><br><span class="line">    <span class="comment">// 调度器通知其他线程，有STW信号</span></span><br><span class="line">    sched.gcwaiting.Store(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 逐个设置p的抢占标志，发送信号给线程（把其他p丢到空闲队列）</span></span><br><span class="line">    preemptall()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前p丢到空闲队列</span></span><br><span class="line">    <span class="comment">// 状态改为_Pgcstop</span></span><br><span class="line">    gp.m.p.ptr().status = _Pgcstop</span><br><span class="line">    <span class="comment">// 停止时刻</span></span><br><span class="line">    gp.m.p.ptr().gcStopTime = start</span><br><span class="line">    <span class="comment">// 数量减1</span></span><br><span class="line">    sched.stopwait--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试回收正在执行系统调用的p</span></span><br><span class="line">    <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        s := pp.status</span><br><span class="line">        <span class="comment">// 系统调用中，切换到_Pgcstop</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &amp;&amp; atomic.Cas(&amp;pp.status, s, _Pgcstop) &#123;</span><br><span class="line">            <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">            pp.syscalltick++</span><br><span class="line">            <span class="comment">// 停止时刻</span></span><br><span class="line">            pp.gcStopTime = nanotime()</span><br><span class="line">            <span class="comment">// 数量减1</span></span><br><span class="line">            sched.stopwait--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经放在空闲队列的p状态修改</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">        pp, _ := pidleget(now)</span><br><span class="line">        <span class="comment">// 没有拿到</span></span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        pp.status = _Pgcstop</span><br><span class="line">        <span class="comment">// 停止时刻</span></span><br><span class="line">        pp.gcStopTime = nanotime()</span><br><span class="line">        <span class="comment">// 数量减1</span></span><br><span class="line">        sched.stopwait--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否还有p没有放到空闲队列</span></span><br><span class="line">    wait := sched.stopwait &gt; <span class="number">0</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有p未停止</span></span><br><span class="line">    <span class="keyword">if</span> wait &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 挂起休眠100us（m放在stopnote.key），标记blocked为true</span></span><br><span class="line">            <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 被唤醒</span></span><br><span class="line">                <span class="comment">// 将stopnote.key重置为0</span></span><br><span class="line">                noteclear(&amp;sched.stopnote)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 逐个设置p的抢占标志，发送信号给线程</span></span><br><span class="line">            preemptall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束时间</span></span><br><span class="line">    finish := nanotime()</span><br><span class="line">    <span class="comment">// 耗时</span></span><br><span class="line">    startTime := finish - start</span><br><span class="line">    <span class="comment">// 如果是gcStart或gcMarkDone这两个函数调用 =&gt; stwGCSweepTerm || stwGCMarkTerm</span></span><br><span class="line">    <span class="keyword">if</span> reason.isGC() &#123;</span><br><span class="line">        sched.stwStoppingTimeGC.record(startTime)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched.stwStoppingTimeOther.record(startTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计所有p的STW耗时</span></span><br><span class="line">    stoppingCPUTime := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 错误信息</span></span><br><span class="line">    bad := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sched.stopwait != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 仍有p未停止</span></span><br><span class="line">        bad = <span class="string">&quot;stopTheWorld: not stopped (stopwait != 0)&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 所有的p都停止了</span></span><br><span class="line">        <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            <span class="comment">// 状态核对</span></span><br><span class="line">            <span class="keyword">if</span> pp.status != _Pgcstop &#123;</span><br><span class="line">                bad = <span class="string">&quot;stopTheWorld: not stopped (status != _Pgcstop)&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> pp.gcStopTime == <span class="number">0</span> &amp;&amp; bad == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                bad = <span class="string">&quot;stopTheWorld: broken CPU time accounting&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 累计耗时</span></span><br><span class="line">            stoppingCPUTime += finish - pp.gcStopTime</span><br><span class="line">            <span class="comment">// 重置为0</span></span><br><span class="line">            pp.gcStopTime = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现无法恢复的panic</span></span><br><span class="line">    <span class="keyword">if</span> freezing.Load() &#123;</span><br><span class="line">        lock(&amp;deadlock)</span><br><span class="line">        lock(&amp;deadlock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> bad != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        throw(bad)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    worldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回原因、时间信息</span></span><br><span class="line">    <span class="keyword">return</span> worldStop&#123;</span><br><span class="line">        reason:           reason,          <span class="comment">// STW原因</span></span><br><span class="line">        startedStopping:  start,           <span class="comment">// 函数执行的开始时刻</span></span><br><span class="line">        finishedStopping: finish,          <span class="comment">// 所有p都停止了的时刻</span></span><br><span class="line">        stoppingCPUTime:  stoppingCPUTime, <span class="comment">// 累计STW耗时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorldWithSema</span><span class="params">(now <span class="type">int64</span>, w worldStop)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// netpoll已初始化</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &#123;</span><br><span class="line">        <span class="comment">// 执行epollWait检查，0-没有数据立即返回</span></span><br><span class="line">        list, delta := netpoll(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">        injectglist(&amp;list)</span><br><span class="line">        <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">        netpollAdjustWaiters(delta)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU数量</span></span><br><span class="line">    procs := gomaxprocs</span><br><span class="line">    <span class="comment">// 如果newprocs不为0，意味着用户调用GOMAXPROCS修改了p数量</span></span><br><span class="line">    <span class="keyword">if</span> newprocs != <span class="number">0</span> &#123;</span><br><span class="line">        procs = newprocs</span><br><span class="line">        newprocs = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据数量n扩容/缩容p</span></span><br><span class="line">    p1 := procresize(procs)</span><br><span class="line">    <span class="comment">// 调度器通知其他线程，STW停止，恢复世界</span></span><br><span class="line">    sched.gcwaiting.Store(<span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// sysmon挂起休眠了</span></span><br><span class="line">    <span class="keyword">if</span> sched.sysmonwait.Load() &#123;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 唤醒sysmon（m放在sysmonnote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    worldStarted()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲p数量不为0</span></span><br><span class="line">    <span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 获取第一个p</span></span><br><span class="line">        p := p1</span><br><span class="line">        <span class="comment">// 链表调整</span></span><br><span class="line">        p1 = p1.link.ptr()</span><br><span class="line">        <span class="comment">// p已被m持有</span></span><br><span class="line">        <span class="keyword">if</span> p.m != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// m</span></span><br><span class="line">            mp := p.m.ptr()</span><br><span class="line">            <span class="comment">// 移除m</span></span><br><span class="line">            p.m = <span class="number">0</span></span><br><span class="line">            <span class="comment">// nextp字段不为0</span></span><br><span class="line">            <span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;startTheWorld: inconsistent mp-&gt;nextp&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把p放到nextp字段</span></span><br><span class="line">            mp.nextp.set(p)</span><br><span class="line">            <span class="comment">// 唤醒m（m放在m.park.key）</span></span><br><span class="line">            notewakeup(&amp;mp.park)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// p未被m持有</span></span><br><span class="line">            <span class="comment">// 清理freem链表，创建并初始化m，locked或cgo类型的m由模板线程延迟创建，其他类型则立即调用平台相关函数创建线程</span></span><br><span class="line">            newm(<span class="literal">nil</span>, p, <span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// STW耗时</span></span><br><span class="line">    totalTime := now - w.startedStopping</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是gcStart或gcMarkDone这两个函数调用 =&gt; stwGCSweepTerm || stwGCMarkTerm</span></span><br><span class="line">    <span class="keyword">if</span> w.reason.isGC() &#123;</span><br><span class="line">        sched.stwTotalTimeGC.record(totalTime)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched.stwTotalTimeOther.record(totalTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    wakep()</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="keyword">return</span> now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让p的g进入等待，强制让p进入空闲状态，执行safePoint函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forEachP</span><span class="params">(reason waitReason, fn <span class="keyword">func</span>(*p)</span></span>) &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        gp := getg().m.curg</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">        casGToWaitingForGC(gp, _Grunning, reason)</span><br><span class="line">        <span class="comment">// 强制让p进入空闲状态，执行safePoint函数</span></span><br><span class="line">        forEachPInternal(fn)</span><br><span class="line">        <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制让p进入空闲状态，执行safePoint函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forEachPInternal</span><span class="params">(fn <span class="keyword">func</span>(*p)</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 防抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> sched.safePointWait != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;forEachP: sched.safePointWait != 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sched.safePointWait = gomaxprocs - <span class="number">1</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sched.safePointFn = fn</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让其他p执行safePoint函数</span></span><br><span class="line">    <span class="keyword">for</span> _, p2 := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="keyword">if</span> p2 != pp &#123;</span><br><span class="line">            atomic.Store(&amp;p2.runSafePointFn, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个设置p的抢占标志，发送抢占信号给线程</span></span><br><span class="line">    preemptall()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历空闲p链表</span></span><br><span class="line">    <span class="keyword">for</span> p := sched.pidle.ptr(); p != <span class="literal">nil</span>; p = p.link.ptr() &#123;</span><br><span class="line">        <span class="comment">// 重置状态</span></span><br><span class="line">        <span class="keyword">if</span> atomic.Cas(&amp;p.runSafePointFn, <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行safePoint函数</span></span><br><span class="line">            fn(p)</span><br><span class="line">            <span class="comment">// 计数器-1</span></span><br><span class="line">            sched.safePointWait--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有p未执行safePoint函数</span></span><br><span class="line">    wait := sched.safePointWait &gt; <span class="number">0</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前p执行safePoint函数</span></span><br><span class="line">    fn(pp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制将_Psyscall的p转为_Pidle并运行safePoint函数</span></span><br><span class="line">    <span class="keyword">for</span> _, p2 := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        s := p2.status</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从_Psyscall状态改为_Pidle</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &amp;&amp; p2.runSafePointFn == <span class="number">1</span> &amp;&amp; atomic.Cas(&amp;p2.status, s, _Pidle) &#123;</span><br><span class="line">            <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">            p2.syscalltick++</span><br><span class="line">            <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">            <span class="comment">// （其内部会执行safePoint函数、更新safePointWait计数器）</span></span><br><span class="line">            handoffp(p2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有p没运行safePoint函数</span></span><br><span class="line">    <span class="keyword">if</span> wait &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 挂起休眠100us（m放在safePointNote.key），标记blocked为true</span></span><br><span class="line">            <span class="keyword">if</span> notetsleep(&amp;sched.safePointNote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 被唤醒/超时</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将safePointNote.key重置为0</span></span><br><span class="line">                noteclear(&amp;sched.safePointNote)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超时</span></span><br><span class="line">            <span class="comment">// 逐个设置p的抢占标志，发送抢占信号给线程</span></span><br><span class="line">            preemptall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> sched.safePointWait != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;forEachP: not done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查每个p的状态</span></span><br><span class="line">    <span class="keyword">for</span> _, p2 := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="keyword">if</span> p2.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;forEachP: P did not run fn&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 重置函数指针</span></span><br><span class="line">    sched.safePointFn = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标记线程相关"><a href="#标记线程相关" class="headerlink" title="标记线程相关"></a>标记线程相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取快照，计算各个根对象的块数量、基地址（索引）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkRootPrepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算有多少个块，每个块256KB</span></span><br><span class="line">    nBlocks := <span class="function"><span class="keyword">func</span><span class="params">(bytes <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">// 按256KB的倍数向上取整</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">int</span>(divRoundUp(bytes, rootBlockBytes))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    work.nDataRoots = <span class="number">0</span></span><br><span class="line">    work.nBSSRoots = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计data、bss的块数量</span></span><br><span class="line">    <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">        <span class="comment">// 计算data包含多少个块（已初始化的全局变量和静态变量）</span></span><br><span class="line">        nDataRoots := nBlocks(datap.edata - datap.data)</span><br><span class="line">        <span class="keyword">if</span> nDataRoots &gt; work.nDataRoots &#123;</span><br><span class="line">            work.nDataRoots = nDataRoots</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算bss包含多少个块（未初始化的全局变量和静态变量）</span></span><br><span class="line">        nBSSRoots := nBlocks(datap.ebss - datap.bss)</span><br><span class="line">        <span class="keyword">if</span> nBSSRoots &gt; work.nBSSRoots &#123;</span><br><span class="line">            work.nBSSRoots = nBSSRoots</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描mspan的finalizer、specials纪录</span></span><br><span class="line">    <span class="comment">// markArenas为allArenas快照（凡是heap管理的arena都会放在这里，用户手动管理则不会）</span></span><br><span class="line">    mheap_.markArenas = mheap_.allArenas[:<span class="built_in">len</span>(mheap_.allArenas):<span class="built_in">len</span>(mheap_.allArenas)]</span><br><span class="line">    <span class="comment">// =length*8192/512 = length*16</span></span><br><span class="line">    work.nSpanRoots = <span class="built_in">len</span>(mheap_.markArenas) * (pagesPerArena / pagesPerSpanRoot)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描栈</span></span><br><span class="line">    <span class="comment">// allgs快照</span></span><br><span class="line">    work.stackRoots = allGsSnapshot()</span><br><span class="line">    work.nStackRoots = <span class="built_in">len</span>(work.stackRoots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟对象块id/计数器</span></span><br><span class="line">    work.markrootNext = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 跟对象块总数 = 2+data块数量+bss块数量+mspan块数量+stack数量</span></span><br><span class="line">    <span class="comment">// 这里有2个索引被占用了，0索引-扫描finalizer，1索引-扫描gFree.stack释放所有栈</span></span><br><span class="line">    work.markrootJobs = <span class="type">uint32</span>(fixedRootCount + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算索引</span></span><br><span class="line">    work.baseData = <span class="type">uint32</span>(fixedRootCount)</span><br><span class="line">    work.baseBSS = work.baseData + <span class="type">uint32</span>(work.nDataRoots)</span><br><span class="line">    work.baseSpans = work.baseBSS + <span class="type">uint32</span>(work.nBSSRoots)</span><br><span class="line">    work.baseStacks = work.baseSpans + <span class="type">uint32</span>(work.nSpanRoots)</span><br><span class="line">    work.baseEnd = work.baseStacks + <span class="type">uint32</span>(work.nStackRoots)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tiny区域对象置灰放入队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTinyAllocs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// 获取p.mcache</span></span><br><span class="line">        c := p.mcache</span><br><span class="line">        <span class="comment">// 未初始化</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="literal">nil</span> || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据p查找mspan，找到了返回对象在mspan内的位置和对象起始地址</span></span><br><span class="line">        _, span, objIndex := findObject(c.tiny, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前p的wbuf队列</span></span><br><span class="line">        gcw := &amp;p.gcw</span><br><span class="line">        <span class="comment">// 设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">        greyobject(c.tiny, <span class="number">0</span>, <span class="number">0</span>, span, gcw, objIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空allgs快照、gcw/mcache等残留处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMark</span><span class="params">(startTime <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 非_GCmarktermination阶段</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCmarktermination &#123;</span><br><span class="line">        throw(<span class="string">&quot;in gcMark expecting to see gcphase as _GCmarktermination&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    work.tstart = startTime</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认无标记任务残留</span></span><br><span class="line">    <span class="keyword">if</span> work.full != <span class="number">0</span> || work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: full=&quot;</span>, hex(work.full), <span class="string">&quot; next=&quot;</span>, work.markrootNext, <span class="string">&quot; jobs=&quot;</span>, work.markrootJobs, <span class="string">&quot; nDataRoots=&quot;</span>, work.nDataRoots, <span class="string">&quot; nBSSRoots=&quot;</span>, work.nBSSRoots, <span class="string">&quot; nSpanRoots=&quot;</span>, work.nSpanRoots, <span class="string">&quot; nStackRoots=&quot;</span>, work.nStackRoots, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;non-empty mark queue after concurrent mark&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &#123;</span><br><span class="line">        gcMarkRootCheck()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空allgs快照</span></span><br><span class="line">    work.stackRoots = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">            wbBufFlush1(p)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重置wbBuf的next、end指针</span></span><br><span class="line">            p.wbBuf.reset()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gcw := &amp;p.gcw</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gcw不为空，异常</span></span><br><span class="line">        <span class="keyword">if</span> !gcw.empty() &#123;</span><br><span class="line">            printlock()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: P &quot;</span>, p.id, <span class="string">&quot; flushedWork &quot;</span>, gcw.flushedWork)</span><br><span class="line">            <span class="keyword">if</span> gcw.wbuf1 == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot; wbuf1=&lt;nil&gt;&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot; wbuf1.n=&quot;</span>, gcw.wbuf1.nobj)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> gcw.wbuf2 == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot; wbuf2=&lt;nil&gt;&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot; wbuf2.n=&quot;</span>, gcw.wbuf2.nobj)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;P has cached GC work at end of mark termination&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gcw为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf1、wbuf2根据容量选择放入work.empty或work.full队列</span></span><br><span class="line">        gcw.dispose()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// mcache</span></span><br><span class="line">        c := p.mcache</span><br><span class="line">        <span class="comment">// 未初始化</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        c.scanAlloc = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记终止时，纪录快照，重置heapLive、heapMarked等字段</span></span><br><span class="line">    gcController.resetLive(work.bytesMarked)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GC第1阶段时，清理sync.Pool、sudog缓存、defer pool及其他</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clearpools</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 函数不为空</span></span><br><span class="line">    <span class="keyword">if</span> poolcleanup != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        poolcleanup()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除boringcrypto缓存</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> boringCaches &#123;</span><br><span class="line">        <span class="comment">// p置为nil</span></span><br><span class="line">        atomicstorep(p, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理unique map</span></span><br><span class="line">    <span class="keyword">if</span> uniqueMapCleanup != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> uniqueMapCleanup &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理全局sudog缓存</span></span><br><span class="line">    <span class="comment">// sudoglock加锁</span></span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="keyword">var</span> sg, sgnext *sudog</span><br><span class="line">    <span class="comment">// 遍历全局sudog链表</span></span><br><span class="line">    <span class="keyword">for</span> sg = sched.sudogcache; sg != <span class="literal">nil</span>; sg = sgnext &#123;</span><br><span class="line">        sgnext = sg.next</span><br><span class="line">        <span class="comment">// 取消链接</span></span><br><span class="line">        sg.next = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 置为nil</span></span><br><span class="line">    sched.sudogcache = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空全局defer pool</span></span><br><span class="line">    <span class="comment">// deferlock加锁</span></span><br><span class="line">    lock(&amp;sched.deferlock)</span><br><span class="line">    <span class="keyword">var</span> d, dlink *_defer</span><br><span class="line">    <span class="comment">// 遍历全局defer pool</span></span><br><span class="line">    <span class="keyword">for</span> d = sched.deferpool; d != <span class="literal">nil</span>; d = dlink &#123;</span><br><span class="line">        dlink = d.link</span><br><span class="line">        <span class="comment">// 取消链接</span></span><br><span class="line">        d.link = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 置为nil</span></span><br><span class="line">    sched.deferpool = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.deferlock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkWorkAvailable</span><span class="params">(p *p)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 本地任务缓冲区p.gcw不为空</span></span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.gcw.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局任务缓冲区不为空</span></span><br><span class="line">    <span class="keyword">if</span> !work.full.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根对象还没扫描完</span></span><br><span class="line">    <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcBitsArenas迭代，如用next替换current等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextMarkBitArenaEpoch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lock(&amp;gcBitsArenas.lock)</span><br><span class="line">    <span class="comment">// 用previous替换free</span></span><br><span class="line">    <span class="keyword">if</span> gcBitsArenas.previous != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果free为nil，放到free</span></span><br><span class="line">        <span class="keyword">if</span> gcBitsArenas.free == <span class="literal">nil</span> &#123;</span><br><span class="line">            gcBitsArenas.free = gcBitsArenas.previous</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// free不为nil，previous放到free前，作为新的free</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到previous最后一个元素</span></span><br><span class="line">            last := gcBitsArenas.previous</span><br><span class="line">            <span class="keyword">for</span> last = gcBitsArenas.previous; last.next != <span class="literal">nil</span>; last = last.next &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// previous链接free</span></span><br><span class="line">            last.next = gcBitsArenas.free</span><br><span class="line">            <span class="comment">// 替换free</span></span><br><span class="line">            gcBitsArenas.free = gcBitsArenas.previous</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用current替换previous</span></span><br><span class="line">    gcBitsArenas.previous = gcBitsArenas.current</span><br><span class="line">    <span class="comment">// 用next替换current</span></span><br><span class="line">    gcBitsArenas.current = gcBitsArenas.next</span><br><span class="line">    <span class="comment">// next置为nil</span></span><br><span class="line">    atomic.StorepNoWB(unsafe.Pointer(&amp;gcBitsArenas.next), <span class="literal">nil</span>)</span><br><span class="line">    unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引扫描指定的根对象，扫描的字节数除了返回还会累计到gcController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markroot</span><span class="params">(gcw *gcWork, i <span class="type">uint32</span>, flushBgCredit <span class="type">bool</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> workDone <span class="type">int64</span></span><br><span class="line">    <span class="keyword">var</span> workCounter *atomic.Int64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> work.baseData &lt;= i &amp;&amp; i &lt; work.baseBSS: <span class="comment">// data段</span></span><br><span class="line">        workCounter = &amp;gcController.globalsScanWork</span><br><span class="line">        <span class="comment">// 遍历所有go module、动态库、plugin</span></span><br><span class="line">        <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">            <span class="comment">// 扫描bss/data内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            workDone += markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, <span class="type">int</span>(i-work.baseData))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> work.baseBSS &lt;= i &amp;&amp; i &lt; work.baseSpans: <span class="comment">// bss段</span></span><br><span class="line">        workCounter = &amp;gcController.globalsScanWork</span><br><span class="line">        <span class="comment">// // 遍历所有go module、动态库、plugin</span></span><br><span class="line">        <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">            <span class="comment">// 扫描bss/data内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            workDone += markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, <span class="type">int</span>(i-work.baseBSS))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> i == fixedRootFinalizers: <span class="comment">// i为0</span></span><br><span class="line">        <span class="comment">// 遍历finalizer链表</span></span><br><span class="line">        <span class="keyword">for</span> fb := allfin; fb != <span class="literal">nil</span>; fb = fb.alllink &#123;</span><br><span class="line">            <span class="comment">// 总数</span></span><br><span class="line">            cnt := <span class="type">uintptr</span>(atomic.Load(&amp;fb.cnt))</span><br><span class="line">            <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;fb.fin[<span class="number">0</span>])), cnt*unsafe.Sizeof(fb.fin[<span class="number">0</span>]), &amp;finptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> i == fixedRootFreeGStacks: <span class="comment">// i为1</span></span><br><span class="line">        <span class="comment">// 运行markrootFreeGStacks</span></span><br><span class="line">        <span class="comment">// 将gFree.stack的所有g的栈释放掉，然后放回gFree.noStack</span></span><br><span class="line">        systemstack(markrootFreeGStacks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> work.baseSpans &lt;= i &amp;&amp; i &lt; work.baseStacks: <span class="comment">// mspan</span></span><br><span class="line">        <span class="comment">// 扫描specials内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">        markrootSpans(gcw, <span class="type">int</span>(i-work.baseSpans))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// stack</span></span><br><span class="line">        <span class="comment">// stack扫描字节数</span></span><br><span class="line">        workCounter = &amp;gcController.stackScanWork</span><br><span class="line">        <span class="comment">// 不在stack索引范围</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; work.baseStacks || work.baseEnd &lt;= i &#123;</span><br><span class="line">            printlock()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: markroot index &quot;</span>, i, <span class="string">&quot; not in stack roots range [&quot;</span>, work.baseStacks, <span class="string">&quot;, &quot;</span>, work.baseEnd, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;markroot: bad index&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据索引找到g</span></span><br><span class="line">        gp := work.stackRoots[i-work.baseStacks]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取g.atomicstatus状态，当前非scan状态</span></span><br><span class="line">        status := readgstatus(gp)</span><br><span class="line">        <span class="comment">// 阻塞时，纪录开始时刻</span></span><br><span class="line">        <span class="keyword">if</span> (status == _Gwaiting || status == _Gsyscall) &amp;&amp; gp.waitsince == <span class="number">0</span> &#123;</span><br><span class="line">            gp.waitsince = work.tstart</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 汇编，切换到g0运行，扫描stack需要切换到系统stack下运行</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// g</span></span><br><span class="line">            userG := getg().m.curg</span><br><span class="line">            <span class="comment">// 扫描自身</span></span><br><span class="line">            selfScan := gp == userG &amp;&amp; readgstatus(userG) == _Grunning</span><br><span class="line">            <span class="comment">// 防止死锁</span></span><br><span class="line">            <span class="keyword">if</span> selfScan &#123;</span><br><span class="line">                <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">                casGToWaitingForGC(userG, _Grunning, waitReasonGarbageCollectionScan)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// g运行中则抢占使其停止，否则改为_Gscan状态</span></span><br><span class="line">            stopped := suspendG(gp)</span><br><span class="line">            <span class="comment">// g的状态为_Gdead</span></span><br><span class="line">            <span class="keyword">if</span> stopped.dead &#123;</span><br><span class="line">                <span class="comment">// 已经完成栈扫描</span></span><br><span class="line">                gp.gcscandone = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 异常状态</span></span><br><span class="line">            <span class="keyword">if</span> gp.gcscandone &#123;</span><br><span class="line">                throw(<span class="string">&quot;g already scanned&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 扫描栈帧内指针、defer链、panic、state.buf队列</span></span><br><span class="line">            workDone += scanstack(gp, gcw)</span><br><span class="line">            <span class="comment">// 已经完成栈扫描</span></span><br><span class="line">            gp.gcscandone = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 移除_Gscan状态，如果被抢占停止则唤醒g</span></span><br><span class="line">            resumeG(stopped)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复状态</span></span><br><span class="line">            <span class="keyword">if</span> selfScan &#123;</span><br><span class="line">                <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">                casgstatus(userG, _Gwaiting, _Grunning)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除非i&lt;2，否则下面的条件一般都满足</span></span><br><span class="line">    <span class="keyword">if</span> workCounter != <span class="literal">nil</span> &amp;&amp; workDone != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 累计到gcController对应的字段如globalsScanWork、stackScanWork</span></span><br><span class="line">        workCounter.Add(workDone)</span><br><span class="line">        <span class="comment">// 一般都为true</span></span><br><span class="line">        <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">            <span class="comment">// 根据额度唤醒一批g，额度有剩余就累计到全局额度bgScanCredit（与gcParkAssist成对使用）</span></span><br><span class="line">            gcFlushBgCredit(workDone)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将gFree.stack的所有g的栈释放掉，然后放回gFree.noStack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markrootFreeGStacks</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器gFree加锁</span></span><br><span class="line">    lock(&amp;sched.gFree.lock)</span><br><span class="line">    <span class="comment">// 有栈</span></span><br><span class="line">    list := sched.gFree.stack</span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    sched.gFree.stack = gList&#123;&#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.gFree.lock)</span><br><span class="line">    <span class="comment">// 为空</span></span><br><span class="line">    <span class="keyword">if</span> list.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换类型</span></span><br><span class="line">    q := gQueue&#123;list.head, list.head&#125;</span><br><span class="line">    <span class="comment">// 遍历gFree链表</span></span><br><span class="line">    <span class="keyword">for</span> gp := list.head.ptr(); gp != <span class="literal">nil</span>; gp = gp.schedlink.ptr() &#123;</span><br><span class="line">        <span class="comment">// 释放栈</span></span><br><span class="line">        stackfree(gp.stack)</span><br><span class="line">        gp.stack.lo = <span class="number">0</span></span><br><span class="line">        gp.stack.hi = <span class="number">0</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        q.tail.set(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器gFree加锁</span></span><br><span class="line">    lock(&amp;sched.gFree.lock)</span><br><span class="line">    <span class="comment">// 无栈</span></span><br><span class="line">    sched.gFree.noStack.pushAll(q)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.gFree.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描specials内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markrootSpans</span><span class="params">(gcw *gcWork, shard <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// sweepgen</span></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从allArenas快照找到arenaIdx =markArenas[shard/16]</span></span><br><span class="line">    ai := mheap_.markArenas[shard/(pagesPerArena/pagesPerSpanRoot)]</span><br><span class="line">    <span class="comment">// 根据arenaIdx找到heapArena</span></span><br><span class="line">    ha := mheap_.arenas[ai.l1()][ai.l2()]</span><br><span class="line">    <span class="comment">// =shard*512%8192</span></span><br><span class="line">    arenaPage := <span class="type">uint</span>(<span class="type">uintptr</span>(shard) * pagesPerSpanRoot % pagesPerArena)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specials的bitmap</span></span><br><span class="line">    specialsbits := ha.pageSpecials[arenaPage/<span class="number">8</span>:]</span><br><span class="line">    specialsbits = specialsbits[:pagesPerSpanRoot/<span class="number">8</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> specialsbits &#123;</span><br><span class="line">        <span class="comment">// 8个位</span></span><br><span class="line">        specials := atomic.Load8(&amp;specialsbits[i])</span><br><span class="line">        <span class="comment">// 8个位全为0</span></span><br><span class="line">        <span class="keyword">if</span> specials == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历8个位</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="type">uint</span>(<span class="number">0</span>); j &lt; <span class="number">8</span>; j++ &#123;</span><br><span class="line">            <span class="comment">// 该位为0</span></span><br><span class="line">            <span class="keyword">if</span> specials&amp;(<span class="number">1</span>&lt;&lt;j) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据页索引找到mspan</span></span><br><span class="line">            s := ha.spans[arenaPage+<span class="type">uint</span>(i)*<span class="number">8</span>+j]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 状态必须是mSpanInUse</span></span><br><span class="line">            <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;s.state = &quot;</span>, state, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                throw(<span class="string">&quot;non in-use span found with specials bit set&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 确保mspan已经清理</span></span><br><span class="line">            <span class="keyword">if</span> !useCheckmark &amp;&amp; !(s.sweepgen == sg || s.sweepgen == sg+<span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;sweep &quot;</span>, s.sweepgen, <span class="string">&quot; &quot;</span>, sg, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                throw(<span class="string">&quot;gc: unswept span&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁，防止special在遍历时被移除</span></span><br><span class="line">            lock(&amp;s.speciallock)</span><br><span class="line">            <span class="comment">// 遍历specials</span></span><br><span class="line">            <span class="keyword">for</span> sp := s.specials; sp != <span class="literal">nil</span>; sp = sp.next &#123;</span><br><span class="line">                <span class="keyword">switch</span> sp.kind &#123;</span><br><span class="line">                <span class="keyword">case</span> _KindSpecialFinalizer: <span class="comment">// finalizer</span></span><br><span class="line">                    <span class="comment">// 不标记、只扫描</span></span><br><span class="line">                    spf := (*specialfinalizer)(unsafe.Pointer(sp))</span><br><span class="line">                    <span class="comment">// 找到这个对象</span></span><br><span class="line">                    p := s.base() + <span class="type">uintptr</span>(spf.special.offset)/s.elemsize*s.elemsize</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 标记从这个对象出发可达的所有对象（不包括当前对象）</span></span><br><span class="line">                    <span class="keyword">if</span> !s.spanclass.noscan() &#123;</span><br><span class="line">                        <span class="comment">// 扫描一个对象（最多128KB，剩余放到任务缓冲区）内所有指针，设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                        scanobject(p, gcw)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// special本身是一个根对象</span></span><br><span class="line">                    <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                    scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;spf.fn)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">                <span class="keyword">case</span> _KindSpecialWeakHandle: <span class="comment">// weak handle</span></span><br><span class="line">                    spw := (*specialWeakHandle)(unsafe.Pointer(sp))</span><br><span class="line">                    <span class="comment">// special本身是一个根对象</span></span><br><span class="line">                    <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                    scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;spw.handle)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">                <span class="keyword">case</span> _KindSpecialCleanup: <span class="comment">// cleanup</span></span><br><span class="line">                    spc := (*specialCleanup)(unsafe.Pointer(sp))</span><br><span class="line">                    <span class="comment">// special本身是一个根对象</span></span><br><span class="line">                    <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                    scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;spc.fn)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;s.speciallock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描bss/data内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markrootBlock</span><span class="params">(b0, n0 <span class="type">uintptr</span>, ptrmask0 *<span class="type">uint8</span>, gcw *gcWork, shard <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 256KB =&gt; 262144</span></span><br><span class="line">    <span class="keyword">if</span> rootBlockBytes%(<span class="number">8</span>*goarch.PtrSize) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;rootBlockBytes must be a multiple of 8*ptrSize&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shard =&gt; bss/data块的起始索引，每个块有256KB，用于迅速定位内存块</span></span><br><span class="line">    off := <span class="type">uintptr</span>(shard) * rootBlockBytes</span><br><span class="line">    <span class="comment">// b0 =&gt; bss/data内存起始地址，n0 =&gt; bss/data内存终止地址</span></span><br><span class="line">    <span class="keyword">if</span> off &gt;= n0 &#123;</span><br><span class="line">        <span class="comment">// 越界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 块起始地址</span></span><br><span class="line">    b := b0 + off</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个块的bitmap起始地址（整个bss/data区域有4KB的bitmap）</span></span><br><span class="line">    ptrmask := (*<span class="type">uint8</span>)(add(unsafe.Pointer(ptrmask0), <span class="type">uintptr</span>(shard)*(rootBlockBytes/(<span class="number">8</span>*goarch.PtrSize))))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 256KB</span></span><br><span class="line">    n := <span class="type">uintptr</span>(rootBlockBytes)</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">if</span> off+n &gt; n0 &#123;</span><br><span class="line">        <span class="comment">// 调整要扫描的字节数，=min(n0-off, 256KB)</span></span><br><span class="line">        n = n0 - off</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">    scanblock(b, n, ptrmask, gcw, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanblock</span><span class="params">(b0, n0 <span class="type">uintptr</span>, ptrmask *<span class="type">uint8</span>, gcw *gcWork, stk *stackScanState)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 复制，debug时可以查看初始值，用于参考</span></span><br><span class="line">    b := b0</span><br><span class="line">    n := n0</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描n个字节</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; &#123;</span><br><span class="line">        <span class="comment">// 调整指针指向正确的mask =&gt; ptrmask+i/64，uint8扩展成uint32</span></span><br><span class="line">        bits := <span class="type">uint32</span>(*addb(ptrmask, i/(goarch.PtrSize*<span class="number">8</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8个对象都不是指针类型</span></span><br><span class="line">        <span class="keyword">if</span> bits == <span class="number">0</span> &#123;</span><br><span class="line">            i += goarch.PtrSize * <span class="number">8</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8个对象中，至少有一个是指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历uint8的8个位</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">8</span> &amp;&amp; i &lt; n; j++ &#123;</span><br><span class="line">            <span class="comment">// 该对象是指针</span></span><br><span class="line">            <span class="keyword">if</span> bits&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 下面同scanobject</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 读取指针位置的内容</span></span><br><span class="line">                p := *(*<span class="type">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line">                <span class="keyword">if</span> p != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 需要进一步判断是不是指针类型</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 根据p查找mspan，找到了返回对象在mspan内的位置和对象起始地址</span></span><br><span class="line">                    <span class="keyword">if</span> obj, span, objIndex := findObject(p, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                        greyobject(obj, b, i, span, gcw, objIndex)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> stk != <span class="literal">nil</span> &amp;&amp; p &gt;= stk.stack.lo &amp;&amp; p &lt; stk.stack.hi &#123;</span><br><span class="line">                        <span class="comment">// 如果在mspan内找不到，检查这个地址是不是在栈内</span></span><br><span class="line">                        <span class="comment">// 在栈内则把指针放到stk.buf队列</span></span><br><span class="line">                        stk.putPtr(p, <span class="literal">false</span>)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 不管是heap管理还是手动管理的mspan都没找到</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右移1位</span></span><br><span class="line">            bits &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="comment">// 指针大小</span></span><br><span class="line">            i += goarch.PtrSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描一个对象（最多128KB，剩余放到任务缓冲区）内所有指针，设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanobject</span><span class="params">(b <span class="type">uintptr</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 提前加载数据到CPU缓存</span></span><br><span class="line">    sys.Prefetch(b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据地址找到heapArena再找到mspan</span></span><br><span class="line">    s := spanOfUnchecked(b)</span><br><span class="line">    <span class="comment">// 对象大小</span></span><br><span class="line">    n := s.elemsize</span><br><span class="line">    <span class="comment">// 为0，异常</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;scanobject n == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// noscan，不需要扫描</span></span><br><span class="line">    <span class="keyword">if</span> s.spanclass.noscan() &#123;</span><br><span class="line">        throw(<span class="string">&quot;scanobject of a noscan object&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tp typePointers</span><br><span class="line">    <span class="comment">// 大对象 elemsize&gt;128KB =&gt; 131072</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">        <span class="comment">// 先将整个mspan切块</span></span><br><span class="line">        <span class="keyword">if</span> b == s.base() &#123;</span><br><span class="line">            <span class="comment">// 按128KB分块，保留第一个块，剩下放到wbuf</span></span><br><span class="line">            <span class="keyword">for</span> oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes &#123;</span><br><span class="line">                <span class="comment">// 将对象放到wbuf-任务缓冲区，未初始化或已满直接返回</span></span><br><span class="line">                <span class="keyword">if</span> !gcw.putFast(oblet) &#123;</span><br><span class="line">                    <span class="comment">// 将对象放到wbuf-任务缓冲区，已满则从work.empty获取一个wbuf替换用</span></span><br><span class="line">                    gcw.put(oblet)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b到limit的字节数</span></span><br><span class="line">        n = s.base() + s.elemsize - b</span><br><span class="line">        <span class="comment">// n最多128KB =min(n,131072)</span></span><br><span class="line">        n = min(n, maxObletBytes)</span><br><span class="line">        <span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息</span></span><br><span class="line">        tp = s.typePointersOfUnchecked(s.base())</span><br><span class="line">        <span class="comment">// 地址往后移动n字节，获取实际对象地址和bitmap</span></span><br><span class="line">        tp = tp.fastForward(b-tp.addr, b+n)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// elemsize&lt;=128KB</span></span><br><span class="line">        <span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息</span></span><br><span class="line">        tp = s.typePointersOfUnchecked(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> scanSize <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> addr <span class="type">uintptr</span></span><br><span class="line">        <span class="comment">// 将mask第一个uint64内的第一个指针的位置为0，返回修改后的tp和指针地址</span></span><br><span class="line">        <span class="keyword">if</span> tp, addr = tp.nextFast(); addr == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// uint64没数据了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// mask第一个uint64不为0则调用nextFast，否则移动下一个uint64再重新判断</span></span><br><span class="line">            <span class="keyword">if</span> tp, addr = tp.next(b + n); addr == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 扫描到末尾还是没有</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已扫描字节数 =addr-b+8 =&gt; =scalar类型占用的字节数+8字节指针</span></span><br><span class="line">        scanSize = addr - b + goarch.PtrSize</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象指针</span></span><br><span class="line">        obj := *(*<span class="type">uintptr</span>)(unsafe.Pointer(addr))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指针不为0 and 超过对象大小或超过一个块大小</span></span><br><span class="line">        <span class="keyword">if</span> obj != <span class="number">0</span> &amp;&amp; obj-b &gt;= n &#123;</span><br><span class="line">            <span class="comment">// 指针不为0时需要进一步判断是不是指针类型</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据p查找mspan，找到了返回对象在mspan内的位置和对象起始地址</span></span><br><span class="line">            <span class="keyword">if</span> obj, span, objIndex := findObject(obj, b, addr-b); obj != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                greyobject(obj, b, addr-b, span, gcw, objIndex)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被标记的字节总数</span></span><br><span class="line">    gcw.bytesMarked += <span class="type">uint64</span>(n)</span><br><span class="line">    <span class="comment">// 被扫描字节数</span></span><br><span class="line">    gcw.heapScanWork += <span class="type">int64</span>(scanSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据p查找mspan，找到了返回对象在mspan内的位置和对象起始地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findObject</span><span class="params">(p, refBase, refOff <span class="type">uintptr</span>)</span></span> (base <span class="type">uintptr</span>, s *mspan, objIndex <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据地址找到heapArena再找到mspan</span></span><br><span class="line">    s = spanOf(p)</span><br><span class="line">    <span class="comment">// p可能在data、bss段上或已释放或其他内存区域如mmap共享内存</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (GOARCH == <span class="string">&quot;amd64&quot;</span> || GOARCH == <span class="string">&quot;arm64&quot;</span>) &amp;&amp; p == clobberdeadPtr &amp;&amp; debug.invalidptr != <span class="number">0</span> &#123;</span><br><span class="line">            badPointer(s, p, refBase, refOff)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动管理内存（栈上的引用） or 指针不在mspan管理范围</span></span><br><span class="line">    <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse || p &lt; s.base() || p &gt;= s.limit &#123;</span><br><span class="line">        <span class="comment">// 手动管理内存</span></span><br><span class="line">        <span class="keyword">if</span> state == mSpanManual &#123;</span><br><span class="line">            <span class="comment">// 此时base、objIndex为0</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面三种情况之一，不管</span></span><br><span class="line">        <span class="comment">// 1. mspan是被释放的heap空间</span></span><br><span class="line">        <span class="comment">// 2. 是某个goroutine的栈</span></span><br><span class="line">        <span class="comment">// 3. 是通过unsafe操作、channel发送，临时出现在其他栈上的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> debug.invalidptr != <span class="number">0</span> &#123;</span><br><span class="line">            badPointer(s, p, refBase, refOff)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象在mspan内的位置</span></span><br><span class="line">    <span class="comment">// =(p-s.base)/s.elemsize</span></span><br><span class="line">    objIndex = s.objIndex(p)</span><br><span class="line">    <span class="comment">// 对象起始地址</span></span><br><span class="line">    base = s.base() + objIndex*s.elemsize</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greyobject</span><span class="params">(obj, base, off <span class="type">uintptr</span>, span *mspan, gcw *gcWork, objIndex <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//base和off用于debug，可以忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象是否是8的倍数</span></span><br><span class="line">    <span class="keyword">if</span> obj&amp;(goarch.PtrSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;greyobject: obj not pointer-aligned&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取该对象的bitmap（从gcmarkBits获取，第几个字节、字节内第几位）</span></span><br><span class="line">    mbits := span.markBitsForIndex(objIndex)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> useCheckmark &#123;</span><br><span class="line">        <span class="comment">// debug.gccheckmark不为0</span></span><br><span class="line">        <span class="keyword">if</span> setCheckmark(obj, base, off, mbits) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 看这里</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &amp;&amp; span.isFree(objIndex) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: marking free object &quot;</span>, hex(obj), <span class="string">&quot; found at *(&quot;</span>, hex(base), <span class="string">&quot;+&quot;</span>, hex(off), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">            gcDumpObject(<span class="string">&quot;base&quot;</span>, base, off)</span><br><span class="line">            gcDumpObject(<span class="string">&quot;obj&quot;</span>, obj, ^<span class="type">uintptr</span>(<span class="number">0</span>))</span><br><span class="line">            getg().m.traceback = <span class="number">2</span></span><br><span class="line">            throw(<span class="string">&quot;marking free object&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该位是否已经设置为1</span></span><br><span class="line">        <span class="keyword">if</span> mbits.isMarked() &#123;</span><br><span class="line">            <span class="comment">// 已设置，不处理</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该位设置为1（只要用mask跟gcmarkBits按位或）</span></span><br><span class="line">        mbits.setMarked()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据mspan起始地址获取heapArena、页索引、页bitmap位置</span></span><br><span class="line">        arena, pageIdx, pageMask := pageIndexOf(span.base())</span><br><span class="line">        <span class="comment">// 将这个页的bitmap设置为1（粗略，只设置一页，不是所有页，此外，pageMarks在GC启动时清0）</span></span><br><span class="line">        <span class="keyword">if</span> arena.pageMarks[pageIdx]&amp;pageMask == <span class="number">0</span> &#123;</span><br><span class="line">            atomic.Or8(&amp;arena.pageMarks[pageIdx], pageMask)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mspan是scalar类型，到这里结束，否则放进wbuf缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> span.spanclass.noscan() &#123;</span><br><span class="line">            <span class="comment">// 对象大小累计到bytesMarked-被标记的字节总数</span></span><br><span class="line">            gcw.bytesMarked += <span class="type">uint64</span>(span.elemsize)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前加载数据到CPU缓存</span></span><br><span class="line">    sys.Prefetch(obj)</span><br><span class="line">    <span class="comment">// 将对象放到wbuf-任务缓冲区，未初始化或已满直接返回</span></span><br><span class="line">    <span class="keyword">if</span> !gcw.putFast(obj) &#123;</span><br><span class="line">        <span class="comment">// 将对象放到wbuf-任务缓冲区，已满则从work.empty获取一个wbuf替换用</span></span><br><span class="line">        gcw.put(obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清扫器相关"><a href="#清扫器相关" class="headerlink" title="清扫器相关"></a>清扫器相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数器加1，返回mheap_.sweepgen及sweepDrainedMask标记是否已设置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *activeSweep)</span></span> begin() sweepLocker &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := a.state.Load()</span><br><span class="line">        <span class="comment">// 最高位不为0，队列已经没有sweeper</span></span><br><span class="line">        <span class="keyword">if</span> state&amp;sweepDrainedMask != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sweepLocker&#123;mheap_.sweepgen, <span class="literal">false</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器+1</span></span><br><span class="line">        <span class="keyword">if</span> a.state.CompareAndSwap(state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="keyword">return</span> sweepLocker&#123;mheap_.sweepgen, <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 失败重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *activeSweep)</span></span> end(sl sweepLocker) &#123;</span><br><span class="line">    <span class="keyword">if</span> sl.sweepGen != mheap_.sweepgen &#123;</span><br><span class="line">        throw(<span class="string">&quot;sweeper left outstanding across sweep generations&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := a.state.Load()</span><br><span class="line">        <span class="comment">// 丢弃最高位后减1</span></span><br><span class="line">        <span class="keyword">if</span> (state&amp;^sweepDrainedMask)<span class="number">-1</span> &gt;= sweepDrainedMask &#123;</span><br><span class="line">            throw(<span class="string">&quot;mismatched begin/end of activeSweep&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器减1</span></span><br><span class="line">        <span class="keyword">if</span> a.state.CompareAndSwap(state, state<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="comment">// 下面跟debug有关，忽略</span></span><br><span class="line">            <span class="keyword">if</span> state != sweepDrainedMask &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// debug，忽略</span></span><br><span class="line">            <span class="keyword">if</span> debug.gcpacertrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">                live := gcController.heapLive.Load()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;pacer: sweep done at heap size &quot;</span>, live&gt;&gt;<span class="number">20</span>, <span class="string">&quot;MB; allocated &quot;</span>, (live-mheap_.sweepHeapLiveBasis)&gt;&gt;<span class="number">20</span>, <span class="string">&quot;MB during sweep; swept &quot;</span>, mheap_.pagesSwept.Load(), <span class="string">&quot; pages at &quot;</span>, mheap_.sweepPagesPerByte, <span class="string">&quot; pages/byte\n&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 失败重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置sweepDrainedMask标记，表示sweep已完成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *activeSweep)</span></span> markDrained() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := a.state.Load()</span><br><span class="line">        <span class="comment">// 已设置</span></span><br><span class="line">        <span class="keyword">if</span> state&amp;sweepDrainedMask != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置sweepDrainedMask</span></span><br><span class="line">        <span class="keyword">if</span> a.state.CompareAndSwap(state, state|sweepDrainedMask) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获得mspan的所有权</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *sweepLocker)</span></span> tryAcquire(s *mspan) (sweepLocked, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// sweepDrainedMask标记已设置（表示sweeper队列为空）</span></span><br><span class="line">    <span class="keyword">if</span> !l.valid &#123;</span><br><span class="line">        throw(<span class="string">&quot;use of invalid sweepLocker&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态不符</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;s.sweepgen) != l.sweepGen<span class="number">-2</span> &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="keyword">return</span> sweepLocked&#123;&#125;, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从sweepGen-2改为sweepGen-1</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;s.sweepgen, l.sweepGen<span class="number">-2</span>, l.sweepGen<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新失败</span></span><br><span class="line">        <span class="keyword">return</span> sweepLocked&#123;&#125;, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新成功</span></span><br><span class="line">    <span class="keyword">return</span> sweepLocked&#123;s&#125;, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理一个mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sweepLocked)</span></span> sweep(preserve <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 禁止抢占标记</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.locks == <span class="number">0</span> &amp;&amp; gp.m.mallocing == <span class="number">0</span> &amp;&amp; gp != gp.m.g0 &#123;</span><br><span class="line">        throw(<span class="string">&quot;mspan.sweep: m is not locked&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s := sl.mspan</span><br><span class="line">    <span class="comment">// 如果不保留（一般情况下都是不保留，除了mcentral.cacheSpan）</span></span><br><span class="line">    <span class="keyword">if</span> !preserve &#123;</span><br><span class="line">        <span class="comment">// 释放所有权</span></span><br><span class="line">        sl.mspan = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sweepgen := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// 状态异常</span></span><br><span class="line">    <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse || s.sweepgen != sweepgen<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;mspan.sweep: state=&quot;</span>, state, <span class="string">&quot; sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; mheap.sweepgen=&quot;</span>, sweepgen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;mspan.sweep: bad span state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    mheap_.pagesSwept.Add(<span class="type">int64</span>(s.npages))</span><br><span class="line"></span><br><span class="line">    spc := s.spanclass</span><br><span class="line">    size := s.elemsize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 一个对象可同时拥有finalizer、profile，finalizer会加入队列，而profile则会被保留</span></span><br><span class="line">    <span class="comment">// 2. tiny对象可以有多个finalizer作用在不同的offset，需要一次性将所有finalizer加入队列</span></span><br><span class="line">    hadSpecials := s.specials != <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 纪录specials</span></span><br><span class="line">    siter := newSpecialsIter(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specials不为nil</span></span><br><span class="line">    <span class="keyword">for</span> siter.valid() &#123;</span><br><span class="line">        <span class="comment">// 对象起始索引</span></span><br><span class="line">        objIndex := <span class="type">uintptr</span>(siter.s.offset) / size</span><br><span class="line">        <span class="comment">// 对象起始地址</span></span><br><span class="line">        p := s.base() + objIndex*size</span><br><span class="line">        <span class="comment">// 获取该对象的bitmap（从gcmarkBits获取，第几个字节、字节内第几位）</span></span><br><span class="line">        mbits := s.markBitsForIndex(objIndex)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该位为0</span></span><br><span class="line">        <span class="keyword">if</span> !mbits.isMarked() &#123;</span><br><span class="line">            <span class="comment">// 检查是否有finalizer</span></span><br><span class="line">            hasFinAndRevived := <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 终止地址的offset</span></span><br><span class="line">            endOffset := p - s.base() + size</span><br><span class="line">            <span class="comment">// 寻找finalizer</span></span><br><span class="line">            <span class="keyword">for</span> tmp := siter.s; tmp != <span class="literal">nil</span> &amp;&amp; <span class="type">uintptr</span>(tmp.offset) &lt; endOffset; tmp = tmp.next &#123;</span><br><span class="line">                <span class="comment">// 找到有finalizer</span></span><br><span class="line">                <span class="keyword">if</span> tmp.kind == _KindSpecialFinalizer &#123;</span><br><span class="line">                    <span class="comment">// bitmap该位设置为1（复活这个对象）</span></span><br><span class="line">                    mbits.setMarkedNonAtomic()</span><br><span class="line">                    hasFinAndRevived = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有finalizer</span></span><br><span class="line">            <span class="keyword">if</span> hasFinAndRevived &#123;</span><br><span class="line">                <span class="comment">// 把所有finalizer加入队列，清除所有weak handle</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扫描所有与对象相关的special纪录</span></span><br><span class="line">                <span class="keyword">for</span> siter.valid() &amp;&amp; <span class="type">uintptr</span>(siter.s.offset) &lt; endOffset &#123;</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    special := siter.s</span><br><span class="line">                    <span class="comment">// 对象地址</span></span><br><span class="line">                    p := s.base() + <span class="type">uintptr</span>(special.offset)</span><br><span class="line">                    <span class="comment">// finalizer or weak handle</span></span><br><span class="line">                    <span class="keyword">if</span> special.kind == _KindSpecialFinalizer || special.kind == _KindSpecialWeakHandle &#123;</span><br><span class="line">                        <span class="comment">// 把当前节点从链表里移除</span></span><br><span class="line">                        siter.unlinkAndNext()</span><br><span class="line">                        <span class="comment">// 释放special（不同类型的处理方式不同，有些实际上不需要释放）</span></span><br><span class="line">                        <span class="comment">// 如果是finalizer，则将finalizer信息加入队列，然后释放</span></span><br><span class="line">                        <span class="comment">// 如果是weak handle，则重置相关字段，然后释放</span></span><br><span class="line">                        freeSpecial(special, unsafe.Pointer(p), size)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 保留，其他类型的special都只会在对象释放时执行</span></span><br><span class="line">                        siter.next()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有finalizer</span></span><br><span class="line">                <span class="comment">// 对象已死，释放所有special</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扫描所有与对象相关的special纪录</span></span><br><span class="line">                <span class="keyword">for</span> siter.valid() &amp;&amp; <span class="type">uintptr</span>(siter.s.offset) &lt; endOffset &#123;</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    special := siter.s</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    p := s.base() + <span class="type">uintptr</span>(special.offset)</span><br><span class="line">                    <span class="comment">// 把当前节点从链表里移除</span></span><br><span class="line">                    siter.unlinkAndNext()</span><br><span class="line">                    <span class="comment">// 释放special（不同类型的处理方式不同，有些实际上不需要释放）</span></span><br><span class="line">                    freeSpecial(special, unsafe.Pointer(p), size)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果该位为1，寻找reachable类型的special</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果找到的是reachable（对象仍然存活）</span></span><br><span class="line">            <span class="keyword">if</span> siter.s.kind == _KindSpecialReachable &#123;</span><br><span class="line">                <span class="comment">// 把当前节点从链表里移除</span></span><br><span class="line">                special := siter.unlinkAndNext()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 以下两行代码更新reachable和done字段，不需要释放</span></span><br><span class="line">                (*specialReachable)(unsafe.Pointer(special)).reachable = <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 释放special（不同类型的处理方式不同，有些实际上不需要释放）</span></span><br><span class="line">                freeSpecial(special, unsafe.Pointer(p), size)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 扫描下一个</span></span><br><span class="line">                siter.next()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// special已全部释放</span></span><br><span class="line">    <span class="keyword">if</span> hadSpecials &amp;&amp; s.specials == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 更新pageSpecials</span></span><br><span class="line">        spanHasNoSpecials(s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查僵尸对象</span></span><br><span class="line">    <span class="keyword">if</span> s.freeindex &lt; s.nelems &#123;</span><br><span class="line">        <span class="comment">// &lt;freeindex的对象不能是僵尸对象</span></span><br><span class="line"></span><br><span class="line">        obj := <span class="type">uintptr</span>(s.freeindex)</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (*s.gcmarkBits.bytep(obj / <span class="number">8</span>)&amp;^*s.allocBits.bytep(obj / <span class="number">8</span>))&gt;&gt;(obj%<span class="number">8</span>) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 打印mspann内标记但已释放的对象并抛出异常</span></span><br><span class="line">            s.reportZombies()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查剩余字节</span></span><br><span class="line">        <span class="keyword">for</span> i := obj/<span class="number">8</span> + <span class="number">1</span>; i &lt; divRoundUp(<span class="type">uintptr</span>(s.nelems), <span class="number">8</span>); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> *s.gcmarkBits.bytep(i)&amp;^*s.allocBits.bytep(i) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 打印mspann内标记但已释放的对象并抛出异常</span></span><br><span class="line">                s.reportZombies()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过gcmarkBits计算已用对象数</span></span><br><span class="line">    nalloc := <span class="type">uint16</span>(s.countAlloc())</span><br><span class="line">    <span class="comment">// 释放的对象数量</span></span><br><span class="line">    nfreed := s.allocCount - nalloc</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> nalloc &gt; s.allocCount &#123;</span><br><span class="line">        <span class="comment">// 僵尸对象检查应该已经解决这个问题</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: nelems=&quot;</span>, s.nelems, <span class="string">&quot; nalloc=&quot;</span>, nalloc, <span class="string">&quot; previous allocCount=&quot;</span>, s.allocCount, <span class="string">&quot; nfreed=&quot;</span>, nfreed, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;sweep increased allocation count&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    s.allocCount = nalloc</span><br><span class="line">    s.freeindex = <span class="number">0</span></span><br><span class="line">    s.freeIndexForScan = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用gcmarkBits替换allocBits</span></span><br><span class="line">    s.allocBits = s.gcmarkBits</span><br><span class="line">    <span class="comment">// 从gcBitsArenas分配足以容纳nelems个位的内存（64的倍数向上取整）</span></span><br><span class="line">    s.gcmarkBits = newMarkBits(<span class="type">uintptr</span>(s.nelems))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// refresh pinnerBits if they exists</span></span><br><span class="line">    <span class="keyword">if</span> s.pinnerBits != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.refreshPinnerBits()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从s.allocBits分配8个字节替换为新的s.allocCache</span></span><br><span class="line">    s.refillAllocCache(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sweepgen更新前检查</span></span><br><span class="line">    <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse || s.sweepgen != sweepgen<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;mspan.sweep: state=&quot;</span>, state, <span class="string">&quot; sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; mheap.sweepgen=&quot;</span>, sweepgen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;mspan.sweep: bad span state after sweep&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.sweepgen == sweepgen+<span class="number">1</span> || s.sweepgen == sweepgen+<span class="number">3</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;swept cached span&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新为mheap.sweepgen</span></span><br><span class="line">    atomic.Store(&amp;s.sweepgen, sweepgen)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归属于arena包，用户手动管理，暂时忽略</span></span><br><span class="line">    <span class="keyword">if</span> s.isUserArenaChunk &#123;</span><br><span class="line">        <span class="comment">// 保留，异常</span></span><br><span class="line">        <span class="keyword">if</span> preserve &#123;</span><br><span class="line">            throw(<span class="string">&quot;sweep: tried to preserve a user arena span&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> nalloc &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// mspan还有指针、未释放，放入full swept链表</span></span><br><span class="line">            mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nalloc为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        mheap_.pagesInUse.Add(-s.npages)</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        s.state.set(mSpanDead)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从quarantineList移除，放入readyList</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            <span class="keyword">if</span> s.list != &amp;mheap_.userArena.quarantineList &#123;</span><br><span class="line">                throw(<span class="string">&quot;user arena span is on the wrong list&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            lock(&amp;mheap_.lock)</span><br><span class="line">            mheap_.userArena.quarantineList.remove(s)</span><br><span class="line">            mheap_.userArena.readyList.insert(s)</span><br><span class="line">            unlock(&amp;mheap_.lock)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap管理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小对象</span></span><br><span class="line">    <span class="keyword">if</span> spc.sizeclass() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 有nfreed个对象被释放</span></span><br><span class="line">        <span class="keyword">if</span> nfreed &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 标记为需要清0</span></span><br><span class="line">            s.needzero = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            stats := memstats.heapStats.acquire()</span><br><span class="line">            atomic.Xadd64(&amp;stats.smallFreeCount[spc.sizeclass()], <span class="type">int64</span>(nfreed))</span><br><span class="line">            memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            gcController.totalFree.Add(<span class="type">int64</span>(nfreed) * <span class="type">int64</span>(s.elemsize))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不保留</span></span><br><span class="line">        <span class="keyword">if</span> !preserve &#123;</span><br><span class="line">            <span class="comment">// 全部对象都已释放</span></span><br><span class="line">            <span class="keyword">if</span> nalloc == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 释放页和mspan</span></span><br><span class="line">                mheap_.freeSpan(s)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nalloc == s.nelems &#123;</span><br><span class="line">                <span class="comment">// mspan已满</span></span><br><span class="line">                <span class="comment">// 放入full swept链表</span></span><br><span class="line">                mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mspan未满</span></span><br><span class="line">                <span class="comment">// 放入partial swept链表</span></span><br><span class="line">                mheap_.central[spc].mcentral.partialSwept(sweepgen).push(s)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !preserve &#123;</span><br><span class="line">        <span class="comment">// 大对象 and 不保留</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有nfreed个对象被释放</span></span><br><span class="line">        <span class="keyword">if</span> nfreed != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            stats := memstats.heapStats.acquire()</span><br><span class="line">            atomic.Xadd64(&amp;stats.largeFreeCount, <span class="number">1</span>)</span><br><span class="line">            atomic.Xadd64(&amp;stats.largeFree, <span class="type">int64</span>(size))</span><br><span class="line">            memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            gcController.totalFree.Add(<span class="type">int64</span>(size))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// debug，忽略</span></span><br><span class="line">            <span class="keyword">if</span> debug.efence &gt; <span class="number">0</span> &#123;</span><br><span class="line">                s.limit = <span class="number">0</span> <span class="comment">// prevent mlookup from finding this span</span></span><br><span class="line">                sysFault(unsafe.Pointer(s.base()), size)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 释放页和mspan</span></span><br><span class="line">                mheap_.freeSpan(s)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无对象释放</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入full swept链表</span></span><br><span class="line">        mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大对象 and 保留</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存回收器相关"><a href="#内存回收器相关" class="headerlink" title="内存回收器相关"></a>内存回收器相关</h3><h4 id="scavengerState-节奏调度器"><a href="#scavengerState-节奏调度器" class="headerlink" title="scavengerState-节奏调度器"></a>scavengerState-节奏调度器</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scavenger初始化，绑定g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> init() &#123;</span><br><span class="line">    <span class="keyword">if</span> s.g != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;scavenger state is already wired&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    lockInit(&amp;s.lock, lockRankScavenge)</span><br><span class="line">    <span class="comment">// 绑定g</span></span><br><span class="line">    s.g = getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器</span></span><br><span class="line">    s.timer = <span class="built_in">new</span>(timer)</span><br><span class="line">    <span class="comment">// 过期函数</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(s any, _ <span class="type">uintptr</span>, _ <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 重置scavenger状态，修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">        s.(*scavengerState).wake()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mu/f/arg参数初始化</span></span><br><span class="line">    s.timer.init(f, s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    s.sleepController = piController&#123;</span><br><span class="line">        <span class="comment">// Tuned loosely via Ziegler-Nichols process.</span></span><br><span class="line">        kp: <span class="number">0.3375</span>,</span><br><span class="line">        ti: <span class="number">3.2e6</span>,</span><br><span class="line">        tt: <span class="number">1e9</span>,    <span class="comment">// 1s</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        min: <span class="number">0.001</span>,  <span class="comment">// 1:1000</span></span><br><span class="line">        max: <span class="number">1000.0</span>, <span class="comment">// 1000:1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =0.001</span></span><br><span class="line">    s.sleepRatio = startingScavSleepRatio</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="keyword">if</span> s.scavenge == <span class="literal">nil</span> &#123;</span><br><span class="line">        s.scavenge = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">uintptr</span>)</span></span> (<span class="type">uintptr</span>, <span class="type">int64</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前时刻</span></span><br><span class="line">            start := nanotime()</span><br><span class="line">            <span class="comment">// func (p *pageAlloc) scavenge(nbytes uintptr, shouldStop func() bool, force bool) uintptr</span></span><br><span class="line">            <span class="comment">// 回收指定字节数量的内存（扫描时是从高地址向低地址进行搜索）</span></span><br><span class="line">            r := mheap_.pages.scavenge(n, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">            <span class="comment">// 当前时刻</span></span><br><span class="line">            end := nanotime()</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">                <span class="keyword">return</span> r, <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            scavenge.backgroundTime.Add(end - start)</span><br><span class="line">            <span class="keyword">return</span> r, end - start</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scavenger是否需要停止</span></span><br><span class="line">    <span class="keyword">if</span> s.shouldStop == <span class="literal">nil</span> &#123;</span><br><span class="line">        s.shouldStop = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="comment">// heap内存没有超过GC触发临界点 and 总内存没有超过限制</span></span><br><span class="line">            <span class="keyword">return</span> heapRetained() &lt;= scavenge.gcPercentGoal.Load() &amp;&amp;</span><br><span class="line">                gcController.mappedReady.Load() &lt;= scavenge.memoryLimitGoal.Load()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试用</span></span><br><span class="line">    <span class="keyword">if</span> s.gomaxprocs == <span class="literal">nil</span> &#123;</span><br><span class="line">        s.gomaxprocs = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gomaxprocs</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scavenger让出CPU挂起休眠</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> park() &#123;</span><br><span class="line">    lock(&amp;s.lock)</span><br><span class="line">    <span class="comment">// 其他g调用</span></span><br><span class="line">    <span class="keyword">if</span> getg() != s.g &#123;</span><br><span class="line">        throw(<span class="string">&quot;tried to park scavenger from another goroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示挂起</span></span><br><span class="line">    s.parked = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 当前g让出CPU，g0执行调度运行其他g（在内部g、m解除绑定后会解锁lock）</span></span><br><span class="line">    goparkunlock(&amp;s.lock, waitReasonGCScavengeWait, traceBlockSystemGoroutine, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知sysmon唤醒scavenger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> ready() &#123;</span><br><span class="line">    s.sysmonWake.Store(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置scavenger状态，修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> wake() &#123;</span><br><span class="line">    lock(&amp;s.lock)</span><br><span class="line">    <span class="comment">// scavenger是否挂起休眠中</span></span><br><span class="line">    <span class="keyword">if</span> s.parked &#123;</span><br><span class="line">        <span class="comment">// 重置sysmonWake</span></span><br><span class="line">        s.sysmonWake.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置parked</span></span><br><span class="line">        s.parked = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> list gList</span><br><span class="line">        list.push(s.g)</span><br><span class="line">        <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">        injectglist(&amp;list)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;s.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让出CPU挂起一段时间，更新sleepRatio等信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> sleep(worked <span class="type">float64</span>) &#123;</span><br><span class="line">    lock(&amp;s.lock)</span><br><span class="line">    <span class="keyword">if</span> getg() != s.g &#123;</span><br><span class="line">        throw(<span class="string">&quot;tried to sleep scavenger from another goroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// worked最低为1ms</span></span><br><span class="line">    <span class="keyword">if</span> worked &lt; minScavWorkTime &#123;</span><br><span class="line">        worked = minScavWorkTime</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =worked*1.7</span></span><br><span class="line">    worked *= <span class="number">1</span> + scavengeCostRatio</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =worked/sleepRatio =&gt; sleepRatio默认初始值为0.001</span></span><br><span class="line">    sleepTime := <span class="type">int64</span>(worked / s.sleepRatio)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> slept <span class="type">int64</span></span><br><span class="line">    <span class="comment">// 一般情况下都是nil</span></span><br><span class="line">    <span class="keyword">if</span> s.sleepStub == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 设置定时器</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始时刻</span></span><br><span class="line">        start := nanotime()</span><br><span class="line">        <span class="comment">// 重置，设置睡眠时间</span></span><br><span class="line">        s.timer.reset(start+sleepTime, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示挂起</span></span><br><span class="line">        s.parked = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 当前g让出CPU，g0执行调度运行其他g（在内部g、m解除绑定后会解锁lock）</span></span><br><span class="line">        goparkunlock(&amp;s.lock, waitReasonSleep, traceBlockSleep, <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算休眠耗时</span></span><br><span class="line">        slept = nanotime() - start</span><br><span class="line"></span><br><span class="line">        lock(&amp;s.lock)</span><br><span class="line">        <span class="comment">// 停止定时器，不管是否成功</span></span><br><span class="line">        s.timer.stop()</span><br><span class="line">        unlock(&amp;s.lock)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        unlock(&amp;s.lock)</span><br><span class="line">        slept = s.sleepStub(sleepTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> s.controllerCooldown &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        t := slept + <span class="type">int64</span>(worked)</span><br><span class="line">        <span class="keyword">if</span> t &gt; s.controllerCooldown &#123;</span><br><span class="line">            s.controllerCooldown = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.controllerCooldown -= t</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =1/100</span></span><br><span class="line">    idealFraction := <span class="type">float64</span>(scavengePercent) / <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算CPU耗时</span></span><br><span class="line">    cpuFraction := worked / ((<span class="type">float64</span>(slept) + worked) * <span class="type">float64</span>(s.gomaxprocs()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    s.sleepRatio, ok = s.sleepController.next(cpuFraction, idealFraction, <span class="type">float64</span>(slept)+worked)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="comment">// =0.001</span></span><br><span class="line">        s.sleepRatio = startingScavSleepRatio</span><br><span class="line">        <span class="comment">// 5秒</span></span><br><span class="line">        s.controllerCooldown = <span class="number">5e9</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将printControllerReset置为true</span></span><br><span class="line">        s.controllerFailed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行mheap_.pages.scavenge，直到heap耗尽</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> run() (released <span class="type">uintptr</span>, worked <span class="type">float64</span>) &#123;</span><br><span class="line">    lock(&amp;s.lock)</span><br><span class="line">    <span class="keyword">if</span> getg() != s.g &#123;</span><br><span class="line">        throw(<span class="string">&quot;tried to run scavenger from another goroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;s.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;1ms</span></span><br><span class="line">    <span class="keyword">for</span> worked &lt; minScavWorkTime &#123;</span><br><span class="line">        <span class="comment">// 如果scavenger需要停止</span></span><br><span class="line">        <span class="keyword">if</span> s.shouldStop() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 64KB</span></span><br><span class="line">        <span class="keyword">const</span> scavengeQuantum = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行mheap_.pages.scavenge，回收指定字节数量的内存，统计累计耗时</span></span><br><span class="line">        r, duration := s.scavenge(scavengeQuantum)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设每个物理页需耗时10µs</span></span><br><span class="line">        <span class="keyword">const</span> approxWorkedNSPerPhysicalPage = <span class="number">10e3</span></span><br><span class="line">        <span class="keyword">if</span> duration == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 耗时为0</span></span><br><span class="line">            <span class="comment">// 总耗时+=10µs*r/physPageSize</span></span><br><span class="line">            worked += approxWorkedNSPerPhysicalPage * <span class="type">float64</span>(r/physPageSize)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 耗时不为0</span></span><br><span class="line">            <span class="comment">// 直接累计</span></span><br><span class="line">            worked += <span class="type">float64</span>(duration)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放字节数</span></span><br><span class="line">        released += r</span><br><span class="line"></span><br><span class="line">        <span class="comment">// r&lt;64KB</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; scavengeQuantum &#123;</span><br><span class="line">            <span class="comment">// heap已经耗尽</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用faketime时，只执行一次</span></span><br><span class="line">        <span class="keyword">if</span> faketime != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 期望是整页，这里不足1页，异常</span></span><br><span class="line">    <span class="keyword">if</span> released &gt; <span class="number">0</span> &amp;&amp; released &lt; physPageSize &#123;</span><br><span class="line">        throw(<span class="string">&quot;released less than one physical page of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="scavengeIndex-回收索引"><a href="#scavengeIndex-回收索引" class="headerlink" title="scavengeIndex-回收索引"></a>scavengeIndex-回收索引</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> init(test <span class="type">bool</span>, sysStat *sysMemStat) <span class="type">uintptr</span> &#123;</span><br><span class="line">    s.searchAddrBg.Clear()    <span class="comment">// 设为0</span></span><br><span class="line">    s.searchAddrForce.Clear() <span class="comment">// 设为0</span></span><br><span class="line">    s.freeHWM = minOffAddr    <span class="comment">// 最小地址0xffff800000000000</span></span><br><span class="line">    s.test = test</span><br><span class="line">    <span class="comment">// 从系统申请内存（Reserved）初始化chunks（512MB）</span></span><br><span class="line">    <span class="keyword">return</span> s.sysInit(test, sysStat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从系统申请内存（Reserved）初始化chunks（512MB）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> sysInit(test <span class="type">bool</span>, sysStat *sysMemStat) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// =1&lt;&lt;48/4194304 =&gt; 最大地址能分多少个chunk =&gt; 64M个chunk</span></span><br><span class="line">    n := <span class="type">uintptr</span>(<span class="number">1</span>&lt;&lt;heapAddrBits) / pallocChunkBytes</span><br><span class="line">    <span class="comment">// =n*8 =&gt; 512MB</span></span><br><span class="line">    nbytes := n * unsafe.Sizeof(atomicScavChunkData&#123;&#125;)</span><br><span class="line">    <span class="comment">// 向系统申请内存（Reserved）</span></span><br><span class="line">    r := sysReserve(<span class="literal">nil</span>, nbytes)</span><br><span class="line">    sl := notInHeapSlice&#123;(*notInHeap)(r), <span class="type">int</span>(n), <span class="type">int</span>(n)&#125;</span><br><span class="line">    s.chunks = *(*[]atomicScavChunkData)(unsafe.Pointer(&amp;sl))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新minHeapIdx，分配/映射物理内存使地址变为可用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> grow(base, limit <span class="type">uintptr</span>, sysStat *sysMemStat) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 更新minHeapIdx</span></span><br><span class="line">    minHeapIdx := s.minHeapIdx.Load()</span><br><span class="line">    <span class="keyword">if</span> baseIdx := <span class="type">uintptr</span>(chunkIndex(base)); minHeapIdx == <span class="number">0</span> || baseIdx &lt; minHeapIdx &#123;</span><br><span class="line">        <span class="comment">// 不为0时=min(minHeapIdx,baseIdx)</span></span><br><span class="line">        s.minHeapIdx.Store(baseIdx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在指定的虚拟地址范围内分配/映射物理内存，让该地址变为可用</span></span><br><span class="line">    <span class="keyword">return</span> s.sysGrow(base, limit, sysStat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定的虚拟地址范围内分配/映射物理内存，让该地址变为可用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> sysGrow(base, limit <span class="type">uintptr</span>, sysStat *sysMemStat) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 4MB对齐</span></span><br><span class="line">    <span class="keyword">if</span> base%pallocChunkBytes != <span class="number">0</span> || limit%pallocChunkBytes != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: base = &quot;</span>, hex(base), <span class="string">&quot;, limit = &quot;</span>, hex(limit), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;sysGrow bounds not aligned to pallocChunkBytes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sc大小</span></span><br><span class="line">    scSize := unsafe.Sizeof(atomicScavChunkData&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    haveMin := s.min.Load()</span><br><span class="line">    haveMax := s.max.Load()</span><br><span class="line">    <span class="comment">// 向下取整</span></span><br><span class="line">    needMin := alignDown(<span class="type">uintptr</span>(chunkIndex(base)), physPageSize/scSize)</span><br><span class="line">    <span class="comment">// 向上取整</span></span><br><span class="line">    needMax := alignUp(<span class="type">uintptr</span>(chunkIndex(limit)), physPageSize/scSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> needMax &lt; haveMin &#123;</span><br><span class="line">        needMax = haveMin</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> haveMax != <span class="number">0</span> &amp;&amp; needMin &gt; haveMax &#123;</span><br><span class="line">        needMin = haveMax</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个chunk</span></span><br><span class="line">    chunksBase := <span class="type">uintptr</span>(unsafe.Pointer(&amp;s.chunks[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment">// 封装base、limit</span></span><br><span class="line">    have := makeAddrRange(chunksBase+haveMin*scSize, chunksBase+haveMax*scSize)</span><br><span class="line">    need := makeAddrRange(chunksBase+needMin*scSize, chunksBase+needMax*scSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 根据地址计算出起始、终止索引</span></span><br><span class="line">    <span class="comment">// 2. need根据have的地址范围调整base和limit</span></span><br><span class="line">    need = need.subtract(have)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果need的地址范围被包含在have的地址范围内时，base和limit设置为0</span></span><br><span class="line">    <span class="keyword">if</span> need.size() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 使用sysMap直接映射，内存状态从Reserved改为Prepared</span></span><br><span class="line">        sysMap(unsafe.Pointer(need.base.addr()), need.size(), sysStat)</span><br><span class="line">        <span class="comment">// 内存状态从Prepared改为Ready</span></span><br><span class="line">        sysUsed(unsafe.Pointer(need.base.addr()), need.size(), need.size())</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> haveMax == <span class="number">0</span> || needMin &lt; haveMin &#123;</span><br><span class="line">            s.min.Store(needMin)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> needMax &gt; haveMax &#123;</span><br><span class="line">            s.max.Store(needMax)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容字节大小</span></span><br><span class="line">    <span class="keyword">return</span> need.size()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可能含有可清理页的chunk的最大索引（扫描时是从高地址向低地址进行搜索）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> find(force <span class="type">bool</span>) (chunkIdx, <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据force选择搜索地址</span></span><br><span class="line">    cursor := &amp;s.searchAddrBg</span><br><span class="line">    <span class="keyword">if</span> force &#123;</span><br><span class="line">        cursor = &amp;s.searchAddrForce</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面负数表示marked，绝对值为地址</span></span><br><span class="line">    searchAddr, marked := cursor.Load()</span><br><span class="line">    <span class="comment">// 如果是最小地址0xffff800000000000</span></span><br><span class="line">    <span class="keyword">if</span> searchAddr == minOffAddr.addr() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gen := s.gen</span><br><span class="line">    <span class="comment">// 最小chunk索引</span></span><br><span class="line">    min := chunkIdx(s.minHeapIdx.Load())</span><br><span class="line">    <span class="comment">// 搜索地址chunk索引</span></span><br><span class="line">    start := chunkIndex(searchAddr)</span><br><span class="line">    <span class="comment">// 从高到低扫描</span></span><br><span class="line">    <span class="keyword">for</span> i := start; i &gt;= min; i-- &#123;</span><br><span class="line">        <span class="comment">// chunk不需要回收内存</span></span><br><span class="line">        <span class="keyword">if</span> !s.chunks[i].load().shouldScavenge(gen, force) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个</span></span><br><span class="line">        <span class="keyword">if</span> i == start &#123;</span><br><span class="line">            <span class="comment">// i, 位于512位bitmap的位置</span></span><br><span class="line">            <span class="keyword">return</span> i, chunkPageIndex(searchAddr)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =searchAddr+4MB-8KB</span></span><br><span class="line">        newSearchAddr := chunkBase(i) + pallocChunkBytes - pageSize</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> marked &#123;</span><br><span class="line">            <span class="comment">// 替换为newSearchAddr（负数-&gt;正数）</span></span><br><span class="line">            cursor.StoreUnmark(searchAddr, newSearchAddr)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 替换为newSearchAddr（正数-&gt;正数）</span></span><br><span class="line">            cursor.StoreMin(newSearchAddr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i,511</span></span><br><span class="line">        <span class="keyword">return</span> i, pallocChunkPages - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// searchAddrBg或searchAddrForce设为0</span></span><br><span class="line">    cursor.Clear()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等。防止scavenger错误回收已分配的页</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> alloc(ci chunkIdx, npages <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取scavChunkData</span></span><br><span class="line">    sc := s.chunks[ci].load()</span><br><span class="line">    <span class="comment">// 更新元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">    sc.alloc(npages, s.gen)</span><br><span class="line">    <span class="comment">// 回写</span></span><br><span class="line">    s.chunks[ci].store(sc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> free(ci chunkIdx, page, npages <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// chunk</span></span><br><span class="line">    sc := s.chunks[ci].load()</span><br><span class="line">    <span class="comment">// 更新元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">    sc.free(npages, s.gen)</span><br><span class="line">    <span class="comment">// 回写</span></span><br><span class="line">    s.chunks[ci].store(sc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新freeHWM</span></span><br><span class="line">    <span class="comment">// =chunk起始地址+(页索引+n-1)*8192</span></span><br><span class="line">    addr := chunkBase(ci) + <span class="type">uintptr</span>(page+npages<span class="number">-1</span>)*pageSize</span><br><span class="line">    <span class="keyword">if</span> s.freeHWM.lessThan(offAddr&#123;addr&#125;) &#123;</span><br><span class="line">        s.freeHWM = offAddr&#123;addr&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面负数表示marked，绝对值为地址</span></span><br><span class="line">    <span class="comment">// 更新searchAddrForce</span></span><br><span class="line">    searchAddr, _ := s.searchAddrForce.Load()</span><br><span class="line">    <span class="keyword">if</span> (offAddr&#123;searchAddr&#125;).lessThan(offAddr&#123;addr&#125;) &#123;</span><br><span class="line">        s.searchAddrForce.StoreMarked(addr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新scavengeIndex版本计数器、searchAddr、freeHWM</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> nextGen() &#123;</span><br><span class="line">    <span class="comment">// 版本计数器+=1</span></span><br><span class="line">    s.gen++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面负数表示marked，绝对值为地址</span></span><br><span class="line">    <span class="comment">// searchAddrBg=max(searchAddrBg,freeHWM)</span></span><br><span class="line">    searchAddr, _ := s.searchAddrBg.Load()</span><br><span class="line">    <span class="keyword">if</span> (offAddr&#123;searchAddr&#125;).lessThan(s.freeHWM) &#123;</span><br><span class="line">        s.searchAddrBg.StoreMarked(s.freeHWM.addr())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基地址 0xffff800000000000</span></span><br><span class="line">    s.freeHWM = minOffAddr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *scavChunkData)</span></span> alloc(npages <span class="type">uint</span>, newGen <span class="type">uint32</span>) &#123;</span><br><span class="line">    <span class="comment">// 超过512个页</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uint</span>(sc.inUse)+npages &gt; pallocChunkPages &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: inUse=&quot;</span>, sc.inUse, <span class="string">&quot; npages=&quot;</span>, npages, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;too many pages allocated in chunk?&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 版本不一致</span></span><br><span class="line">    <span class="keyword">if</span> sc.gen != newGen &#123;</span><br><span class="line">        <span class="comment">// 纪录历史版本</span></span><br><span class="line">        sc.lastInUse = sc.inUse</span><br><span class="line">        <span class="comment">// 同步</span></span><br><span class="line">        sc.gen = newGen</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sc.inUse += <span class="type">uint16</span>(npages)</span><br><span class="line">    <span class="comment">// ==512</span></span><br><span class="line">    <span class="keyword">if</span> sc.inUse == pallocChunkPages &#123;</span><br><span class="line">        <span class="comment">// 清除scavChunkHasFree标志</span></span><br><span class="line">        sc.setEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *scavChunkData)</span></span> free(npages <span class="type">uint</span>, newGen <span class="type">uint32</span>) &#123;</span><br><span class="line">    <span class="comment">// 相减会小于0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uint</span>(sc.inUse) &lt; npages &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: inUse=&quot;</span>, sc.inUse, <span class="string">&quot; npages=&quot;</span>, npages, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;allocated pages below zero?&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    <span class="keyword">if</span> sc.gen != newGen &#123;</span><br><span class="line">        <span class="comment">// 纪录上一个inUse</span></span><br><span class="line">        sc.lastInUse = sc.inUse</span><br><span class="line">        <span class="comment">// 更新版本</span></span><br><span class="line">        sc.gen = newGen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回收n页</span></span><br><span class="line">    sc.inUse -= <span class="type">uint16</span>(npages)</span><br><span class="line">    <span class="comment">// 设置scavChunkHasFree标志</span></span><br><span class="line">    sc.setNonEmpty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chunk是否需要回收内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc scavChunkData)</span></span> shouldScavenge(currGen <span class="type">uint32</span>, force <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 没有scavChunkHasFree标志</span></span><br><span class="line">    <span class="keyword">if</span> sc.isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制性</span></span><br><span class="line">    <span class="keyword">if</span> force &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本一致</span></span><br><span class="line">    <span class="keyword">if</span> sc.gen == currGen &#123;</span><br><span class="line">        <span class="comment">// &lt;496</span></span><br><span class="line">        <span class="keyword">return</span> sc.inUse &lt; scavChunkHiOccPages &amp;&amp; sc.lastInUse &lt; scavChunkHiOccPages</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本不一致</span></span><br><span class="line">    <span class="comment">// &lt;496</span></span><br><span class="line">    <span class="keyword">return</span> sc.inUse &lt; scavChunkHiOccPages</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存管理相关"><a href="#内存管理相关" class="headerlink" title="内存管理相关"></a>内存管理相关</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据centralIndex获取mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> nextSpanForSweep() *mspan &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sg := h.sweepgen</span><br><span class="line">    <span class="comment">// centralIndex &lt; 272</span></span><br><span class="line">    <span class="keyword">for</span> sc := sweep.centralIndex.load(); sc &lt; numSweepClasses; sc++ &#123;</span><br><span class="line">        <span class="comment">// spc = sweepClass&gt;&gt;1; full = sweepClass&amp;1==0</span></span><br><span class="line">        spc, full := sc.split()</span><br><span class="line">        <span class="comment">// 获取mcentral</span></span><br><span class="line">        c := &amp;h.central[spc].mcentral</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> s *mspan</span><br><span class="line">        <span class="keyword">if</span> full &#123;</span><br><span class="line">            <span class="comment">// full类型</span></span><br><span class="line">            <span class="comment">// 从full[1-sweepgen/2%2]尾部获取一个mspan</span></span><br><span class="line">            s = c.fullUnswept(sg).pop()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// partial类型</span></span><br><span class="line">            <span class="comment">// 从partial[1-sweepgen/2%2]尾部获取一个mspan</span></span><br><span class="line">            s = c.partialUnswept(sg).pop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取mspan成功</span></span><br><span class="line">        <span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// func (s *sweepClass) update(sNew sweepClass)</span></span><br><span class="line">            <span class="comment">// 用sc替换centralIndex（前提：sc &lt; centralIndex）</span></span><br><span class="line">            sweep.centralIndex.update(sc)</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到这里，没有找到任何mspan</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (s *sweepClass) update(sNew sweepClass)</span></span><br><span class="line">    <span class="comment">// 32位全设置为1</span></span><br><span class="line">    sweep.centralIndex.update(sweepClassDone)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用sNew替换s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sweepClass)</span></span> update(sNew sweepClass) &#123;</span><br><span class="line">    <span class="comment">// 旧值</span></span><br><span class="line">    sOld := s.load()</span><br><span class="line">    <span class="comment">// 只有旧值比新值小才替换</span></span><br><span class="line">    <span class="keyword">for</span> sOld &lt; sNew &amp;&amp; !atomic.Cas((*<span class="type">uint32</span>)(s), <span class="type">uint32</span>(sOld), <span class="type">uint32</span>(sNew)) &#123;</span><br><span class="line">        sOld = s.load()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新pageSpecials</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spanHasNoSpecials</span><span class="params">(s *mspan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// arena内第几个页</span></span><br><span class="line">    arenaPage := (s.base() / pageSize) % pagesPerArena</span><br><span class="line">    <span class="comment">// arena索引</span></span><br><span class="line">    ai := arenaIndex(s.base())</span><br><span class="line">    <span class="comment">// 找到heapArena</span></span><br><span class="line">    ha := mheap_.arenas[ai.l1()][ai.l2()]</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    atomic.And8(&amp;ha.pageSpecials[arenaPage/<span class="number">8</span>], ^(<span class="type">uint8</span>(<span class="number">1</span>) &lt;&lt; (arenaPage % <span class="number">8</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过gcmarkBits计算已用对象数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span></span> countAlloc() <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 按8的倍数向上取整</span></span><br><span class="line">    bytes := divRoundUp(<span class="type">uintptr</span>(s.nelems), <span class="number">8</span>)</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bytes; i += <span class="number">8</span> &#123;</span><br><span class="line">        mrkBits := *(*<span class="type">uint64</span>)(unsafe.Pointer(s.gcmarkBits.bytep(i)))</span><br><span class="line">        <span class="comment">// 不区分大端/小端，只计算有多少个1</span></span><br><span class="line">        count += sys.OnesCount64(mrkBits)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息（大对象）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> typePointersOfType(typ *abi.Type, addr <span class="type">uintptr</span>) typePointers &#123;</span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">const</span> doubleCheck = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> doubleCheck &amp;&amp; typ == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad type passed to typePointersOfType&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// noscan类型</span></span><br><span class="line">    <span class="keyword">if</span> span.spanclass.noscan() &#123;</span><br><span class="line">        <span class="keyword">return</span> typePointers&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据类型的GCMask</span></span><br><span class="line">    gcmask := getGCMask(typ)</span><br><span class="line">    <span class="comment">// 这里应该是大对象才有</span></span><br><span class="line">    <span class="keyword">return</span> typePointers&#123;elem: addr, addr: addr, mask: readUintptr(gcmask), typ: typ&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息（小对象/对象内部）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> typePointersOf(addr, size <span class="type">uintptr</span>) typePointers &#123;</span><br><span class="line">    <span class="comment">// 从mspan内地址转全局地址</span></span><br><span class="line">    base := span.objBase(addr)</span><br><span class="line">    <span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息</span></span><br><span class="line">    tp := span.typePointersOfUnchecked(base)</span><br><span class="line">    <span class="keyword">if</span> base == addr &amp;&amp; size == span.elemsize &#123;</span><br><span class="line">        <span class="keyword">return</span> tp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明是在对象内部，需要重新定位</span></span><br><span class="line">    <span class="comment">// 地址往后移动n字节，获取实际对象地址和bitmap</span></span><br><span class="line">    <span class="keyword">return</span> tp.fastForward(addr-tp.addr, addr+size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> typePointersOfUnchecked(addr <span class="type">uintptr</span>) typePointers &#123;</span><br><span class="line">    <span class="keyword">const</span> doubleCheck = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">if</span> doubleCheck &amp;&amp; span.objBase(addr) != addr &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: addr=&quot;</span>, addr, <span class="string">&quot; base=&quot;</span>, span.objBase(addr), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;typePointersOfUnchecked consisting of non-base-address for object&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spc := span.spanclass</span><br><span class="line"></span><br><span class="line">    <span class="comment">// noscan =&gt; scalar没有bitmap信息（这里只判断小对象）</span></span><br><span class="line">    <span class="keyword">if</span> spc.noscan() &#123;</span><br><span class="line">        <span class="keyword">return</span> typePointers&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是scan类型或大对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象大小 &lt;=512B</span></span><br><span class="line">    <span class="keyword">if</span> heapBitsInSpan(span.elemsize) &#123;</span><br><span class="line">        <span class="comment">// bitmap共64~128个bit</span></span><br><span class="line">        <span class="keyword">return</span> typePointers&#123;elem: addr, addr: addr, mask: span.heapBitsSmallForAddr(addr)&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象大小 &gt;512B</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> typ *_type</span><br><span class="line">    <span class="keyword">if</span> spc.sizeclass() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 小对象</span></span><br><span class="line">        <span class="comment">// 头8个字节为header</span></span><br><span class="line">        typ = *(**_type)(unsafe.Pointer(addr))</span><br><span class="line">        <span class="comment">// 起始地址往后移动8个字节</span></span><br><span class="line">        addr += mallocHeaderSize</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 大对象</span></span><br><span class="line">        <span class="comment">// type在mspan.largeType</span></span><br><span class="line">        typ = span.largeType</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// noscan为nil，或者因为延迟扫描时，暂时不扫描</span></span><br><span class="line">            <span class="keyword">return</span> typePointers&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// type Example struct &#123;</span></span><br><span class="line">    <span class="comment">//     a *int8   // 8B (指针)</span></span><br><span class="line">    <span class="comment">//     b int16   // 2B (非指针，编译器会对齐b为8字节)</span></span><br><span class="line">    <span class="comment">//     c *int32  // 8B (指针)</span></span><br><span class="line">    <span class="comment">//     d float64 // 8B (非指针)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据类型的GCMask，如上为0b0101</span></span><br><span class="line">    gcmask := getGCMask(typ)</span><br><span class="line">    <span class="comment">// 大对象才有typ字段信息</span></span><br><span class="line">    <span class="keyword">return</span> typePointers&#123;elem: addr, addr: addr, mask: readUintptr(gcmask), typ: typ&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将mask第一个uint64内的第一个指针的位置为0，返回修改后的tp和指针地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp typePointers)</span></span> nextFast() (typePointers, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> tp.mask == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tp, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">        <span class="comment">// 二进制数尾部0个数</span></span><br><span class="line">        i = sys.TrailingZeros64(<span class="type">uint64</span>(tp.mask))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = sys.TrailingZeros32(<span class="type">uint32</span>(tp.mask))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mask内第i位置为0，表示这个指针已经被扫描</span></span><br><span class="line">    tp.mask ^= <span class="type">uintptr</span>(<span class="number">1</span>) &lt;&lt; (i &amp; (ptrBits - <span class="number">1</span>))</span><br><span class="line">    <span class="comment">// tp，指针地址</span></span><br><span class="line">    <span class="keyword">return</span> tp, tp.addr + <span class="type">uintptr</span>(i)*goarch.PtrSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mask第一个uint64不为0则调用nextFast，否则移动下一个uint64再重新判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp typePointers)</span></span> next(limit <span class="type">uintptr</span>) (typePointers, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// mask不为0</span></span><br><span class="line">        <span class="keyword">if</span> tp.mask != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 将mask第一个uint64内的第一个指针的位置为0，返回修改后的tp和指针地址</span></span><br><span class="line">            <span class="keyword">return</span> tp.nextFast()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面mask为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有类型信息-对象&lt;512B或scalar或延迟设置</span></span><br><span class="line">        <span class="keyword">if</span> tp.typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> typePointers&#123;&#125;, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象&gt;512B</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// addr+8*64 &gt; PtrBytes =&gt; 表示后面的数据非指针，不用扫描</span></span><br><span class="line">        <span class="keyword">if</span> tp.addr+goarch.PtrSize*ptrBits &gt;= tp.elem+tp.typ.PtrBytes &#123;</span><br><span class="line">            <span class="comment">// 指向下一个对象</span></span><br><span class="line">            tp.elem += tp.typ.Size_</span><br><span class="line">            tp.addr = tp.elem</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对象内部扫描</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动512字节</span></span><br><span class="line">            tp.addr += ptrBits * goarch.PtrSize</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 越界</span></span><br><span class="line">        <span class="keyword">if</span> tp.addr &gt;= limit &#123;</span><br><span class="line">            <span class="keyword">return</span> typePointers&#123;&#125;, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到addr所在到bitmap字节</span></span><br><span class="line">        tp.mask = readUintptr(addb(getGCMask(tp.typ), (tp.addr-tp.elem)/goarch.PtrSize/<span class="number">8</span>))</span><br><span class="line">        <span class="comment">// addr+8*64 &gt; limit =&gt; 越界，丢弃limit后的位</span></span><br><span class="line">        <span class="keyword">if</span> tp.addr+goarch.PtrSize*ptrBits &gt; limit &#123;</span><br><span class="line">            <span class="comment">// 多余的位</span></span><br><span class="line">            bits := (tp.addr + goarch.PtrSize*ptrBits - limit) / goarch.PtrSize</span><br><span class="line">            <span class="comment">// 移除高bits位</span></span><br><span class="line">            tp.mask &amp;^= ((<span class="number">1</span> &lt;&lt; (bits)) - <span class="number">1</span>) &lt;&lt; (ptrBits - bits)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址往后移动n字节，获取实际对象地址和bitmap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp typePointers)</span></span> fastForward(n, limit <span class="type">uintptr</span>) typePointers &#123;</span><br><span class="line">    <span class="comment">// 对象起始地址</span></span><br><span class="line">    target := tp.addr + n</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">if</span> target &gt;= limit &#123;</span><br><span class="line">        <span class="keyword">return</span> typePointers&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有类型信息（从源码看，是小对象&lt;=512B）</span></span><br><span class="line">    <span class="keyword">if</span> tp.typ == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// =1&lt;&lt;(n/8)-1 =&gt; 丢弃target前的位</span></span><br><span class="line">        tp.mask &amp;^= (<span class="number">1</span> &lt;&lt; ((target - tp.addr) / goarch.PtrSize)) - <span class="number">1</span></span><br><span class="line">        <span class="comment">// addr+8*64 &gt; limit =&gt; 越界，丢弃limit后的位</span></span><br><span class="line">        <span class="keyword">if</span> tp.addr+goarch.PtrSize*ptrBits &gt; limit &#123;</span><br><span class="line">            <span class="comment">// 多余的位</span></span><br><span class="line">            bits := (tp.addr + goarch.PtrSize*ptrBits - limit) / goarch.PtrSize</span><br><span class="line">            <span class="comment">// 移除高bits位</span></span><br><span class="line">            tp.mask &amp;^= ((<span class="number">1</span> &lt;&lt; (bits)) - <span class="number">1</span>) &lt;&lt; (ptrBits - bits)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有类型信息（大对象&gt;512B）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有多个对象</span></span><br><span class="line">    <span class="keyword">if</span> n &gt;= tp.typ.Size_ &#123;</span><br><span class="line">        <span class="comment">// 起始地址</span></span><br><span class="line">        oldelem := tp.elem</span><br><span class="line">        <span class="comment">// +=n/type_size*type_size =&gt; 按type_size的倍数取整，对齐</span></span><br><span class="line">        tp.elem += (tp.addr - tp.elem + n) / tp.typ.Size_ * tp.typ.Size_</span><br><span class="line">        <span class="comment">// 到这里tp.elem-oldelem &lt;= n</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际地址按512的倍数向下取整（tp.addr &gt;= tp.elem） =&gt; 实际地址addr可能在对象内部</span></span><br><span class="line">        tp.addr = tp.elem + alignDown(n-(tp.elem-oldelem), ptrBits*goarch.PtrSize)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// n &lt; type_size =&gt; 单个对象内部</span></span><br><span class="line">        <span class="comment">// +=n按512的倍数向下取整（tp.elem不变）</span></span><br><span class="line">        tp.addr += alignDown(n, ptrBits*goarch.PtrSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示addr后面的数据非指针，不用扫描</span></span><br><span class="line">    <span class="keyword">if</span> tp.addr-tp.elem &gt;= tp.typ.PtrBytes &#123;</span><br><span class="line">        <span class="comment">// 指向下一个对象</span></span><br><span class="line">        tp.elem += tp.typ.Size_</span><br><span class="line">        tp.addr = tp.elem</span><br><span class="line">        <span class="comment">// 获取数据类型的GCMask</span></span><br><span class="line">        tp.mask = readUintptr(getGCMask(tp.typ))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 越界</span></span><br><span class="line">        <span class="keyword">if</span> tp.addr &gt;= limit &#123;</span><br><span class="line">            <span class="keyword">return</span> typePointers&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对象内部扫描</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到addr所在到bitmap字节</span></span><br><span class="line">        tp.mask = readUintptr(addb(getGCMask(tp.typ), (tp.addr-tp.elem)/goarch.PtrSize/<span class="number">8</span>))</span><br><span class="line">        <span class="comment">// 丢弃target前的位</span></span><br><span class="line">        tp.mask &amp;^= (<span class="number">1</span> &lt;&lt; ((target - tp.addr) / goarch.PtrSize)) - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// addr+8*64 &gt; limit =&gt; 越界，丢弃limit后的位</span></span><br><span class="line">    <span class="keyword">if</span> tp.addr+goarch.PtrSize*ptrBits &gt; limit &#123;</span><br><span class="line">        <span class="comment">// 多余的位</span></span><br><span class="line">        bits := (tp.addr + goarch.PtrSize*ptrBits - limit) / goarch.PtrSize</span><br><span class="line">        <span class="comment">// 移除高bits位</span></span><br><span class="line">        tp.mask &amp;^= ((<span class="number">1</span> &lt;&lt; (bits)) - <span class="number">1</span>) &lt;&lt; (ptrBits - bits)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并other链表的mspan数据到list链表前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *mSpanList)</span></span> takeAll(other *mSpanList) &#123;</span><br><span class="line">    <span class="comment">// 链表为空</span></span><br><span class="line">    <span class="keyword">if</span> other.isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有mspan纪录list指针（debug用）</span></span><br><span class="line">    <span class="keyword">for</span> s := other.first; s != <span class="literal">nil</span>; s = s.next &#123;</span><br><span class="line">        s.list = list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list链表为空</span></span><br><span class="line">    <span class="keyword">if</span> list.isEmpty() &#123;</span><br><span class="line">        *list = *other</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不为空，other在前，list在后</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新next指针</span></span><br><span class="line">        other.last.next = list.first</span><br><span class="line">        <span class="comment">// 更新prev指针</span></span><br><span class="line">        list.first.prev = other.last</span><br><span class="line">        <span class="comment">// 更新first指针</span></span><br><span class="line">        list.first = other.first</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表字段重置</span></span><br><span class="line">    other.first, other.last = <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据地址返回对象的bitmap（64~128个bit）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> heapBitsSmallForAddr(addr <span class="type">uintptr</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 只有对象大小 &lt;=512B才会访问这个函数，因此需要64个指针的bitmap（1个uint64，最多2个uint64）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan总字节数</span></span><br><span class="line">    spanSize := span.npages * pageSize</span><br><span class="line">    <span class="comment">// bitmap大小</span></span><br><span class="line">    bitmapSize := spanSize / goarch.PtrSize / <span class="number">8</span></span><br><span class="line">    <span class="comment">// 定位到bitmap起始地址</span></span><br><span class="line">    hbits := (*<span class="type">byte</span>)(unsafe.Pointer(span.base() + spanSize - bitmapSize))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第几个uint64</span></span><br><span class="line">    i := (addr - span.base()) / goarch.PtrSize / ptrBits</span><br><span class="line">    <span class="comment">// 具体bit位置</span></span><br><span class="line">    j := (addr - span.base()) / goarch.PtrSize % ptrBits</span><br><span class="line">    <span class="comment">// 指针数量</span></span><br><span class="line">    bits := span.elemsize / goarch.PtrSize</span><br><span class="line">    <span class="comment">// 第1个uint64</span></span><br><span class="line">    word0 := (*<span class="type">uintptr</span>)(unsafe.Pointer(addb(hbits, goarch.PtrSize*(i+<span class="number">0</span>))))</span><br><span class="line">    <span class="comment">// 第2个uint64</span></span><br><span class="line">    word1 := (*<span class="type">uintptr</span>)(unsafe.Pointer(addb(hbits, goarch.PtrSize*(i+<span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> read <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">if</span> j+bits &gt; ptrBits &#123;</span><br><span class="line">        <span class="comment">// 需要访问两个uint64</span></span><br><span class="line">        <span class="comment">// 第1个uint64要访问的位数量</span></span><br><span class="line">        bits0 := ptrBits - j</span><br><span class="line">        <span class="comment">// 第2个uint64要访问的位数量</span></span><br><span class="line">        bits1 := bits - bits0</span><br><span class="line">        read = *word0 &gt;&gt; j</span><br><span class="line">        read |= (*word1 &amp; ((<span class="number">1</span> &lt;&lt; bits1) - <span class="number">1</span>)) &lt;&lt; bits0</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 单个uint64足以容纳</span></span><br><span class="line">        read = (*word0 &gt;&gt; j) &amp; ((<span class="number">1</span> &lt;&lt; bits) - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> read</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置空的spanSet，清理残留的block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *spanSet)</span></span> reset() &#123;</span><br><span class="line">    <span class="comment">// 头部、尾部索引</span></span><br><span class="line">    head, tail := b.index.load().split()</span><br><span class="line">    <span class="comment">// 不为空</span></span><br><span class="line">    <span class="keyword">if</span> head &lt; tail &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;head = &quot;</span>, head, <span class="string">&quot;, tail = &quot;</span>, tail, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;attempt to clear non-empty span set&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spanSet.spine第一维索引 = head/512</span></span><br><span class="line">    top := head / spanSetBlockEntries</span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(top) &lt; b.spineLen.Load() &#123;</span><br><span class="line">        <span class="comment">// spine数组第二维，spanSetBlock， =spine[top]</span></span><br><span class="line">        blockp := b.spine.Load().lookup(<span class="type">uintptr</span>(top))</span><br><span class="line">        block := blockp.Load()</span><br><span class="line">        <span class="comment">// 第二维有数据</span></span><br><span class="line">        <span class="keyword">if</span> block != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 没有执行过pop操作</span></span><br><span class="line">            <span class="keyword">if</span> block.popped.Load() == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 不应该为0</span></span><br><span class="line">                throw(<span class="string">&quot;span set block with unpopped elements found in reset&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ==512</span></span><br><span class="line">            <span class="keyword">if</span> block.popped.Load() == spanSetBlockEntries &#123;</span><br><span class="line">                <span class="comment">// 也不应该为512，最后一次pop会将指针置为nil</span></span><br><span class="line">                throw(<span class="string">&quot;fully empty unfreed span set block found in reset&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Clear the pointer to the block.</span></span><br><span class="line">            blockp.StoreNoWB(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// popped置为0，block放回池子里</span></span><br><span class="line">            spanSetBlockPool.free(block)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 置为0</span></span><br><span class="line">    b.index.reset()</span><br><span class="line">    <span class="comment">// 置为0</span></span><br><span class="line">    b.spineLen.Store(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据统计数据调整栈的初始大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcComputeStartingStackSize</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 默认为1</span></span><br><span class="line">    <span class="keyword">if</span> debug.adaptivestackstart == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> scannedStackSize <span class="type">uint64</span></span><br><span class="line">    <span class="keyword">var</span> scannedStacks <span class="type">uint64</span></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        scannedStackSize += p.scannedStackSize</span><br><span class="line">        scannedStacks += p.scannedStacks</span><br><span class="line"></span><br><span class="line">        p.scannedStackSize = <span class="number">0</span></span><br><span class="line">        p.scannedStacks = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为0</span></span><br><span class="line">    <span class="keyword">if</span> scannedStacks == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 设置为2KB</span></span><br><span class="line">        startingStackSize = fixedStack</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平均值=x+928（stackGuard确保不会出发扩容）</span></span><br><span class="line">    avg := scannedStackSize/scannedStacks + stackGuard</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能超过1GB</span></span><br><span class="line">    <span class="keyword">if</span> avg &gt; <span class="type">uint64</span>(maxstacksize) &#123;</span><br><span class="line">        avg = <span class="type">uint64</span>(maxstacksize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能低于2KB</span></span><br><span class="line">    <span class="keyword">if</span> avg &lt; fixedStack &#123;</span><br><span class="line">        avg = fixedStack</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按2的倍数取整</span></span><br><span class="line">    startingStackSize = <span class="type">uint32</span>(round2(<span class="type">int32</span>(avg)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mcache清理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> prepareForSweep() &#123;</span><br><span class="line">    <span class="comment">// sweepgen</span></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// flushGen</span></span><br><span class="line">    flushGen := c.flushGen.Load()</span><br><span class="line">    <span class="comment">// 相等，返回</span></span><br><span class="line">    <span class="keyword">if</span> flushGen == sg &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> flushGen != sg<span class="number">-2</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;bad flushGen&quot;</span>, flushGen, <span class="string">&quot;in prepareForSweep; sweepgen&quot;</span>, sg)</span><br><span class="line">        throw(<span class="string">&quot;bad flushGen&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// alloc列表mspan放到partial或full链表、tiny区域清空</span></span><br><span class="line">    c.releaseAll()</span><br><span class="line">    <span class="comment">// 清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</span></span><br><span class="line">    stackcache_clear(c)</span><br><span class="line">    <span class="comment">// sweepgen快照，gcStart前同步</span></span><br><span class="line">    c.flushGen.Store(mheap_.sweepgen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tiny、alloc重置并释放mspan，更新内存统计信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> releaseAll() &#123;</span><br><span class="line">    <span class="comment">// 快照，需要被GC扫描的字节数</span></span><br><span class="line">    scanAlloc := <span class="type">int64</span>(c.scanAlloc)</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    c.scanAlloc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// 累计存活字节数</span></span><br><span class="line">    dHeapLive := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 所有mpsan清空</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c.alloc &#123;</span><br><span class="line">        <span class="comment">// mspan</span></span><br><span class="line">        s := c.alloc[i]</span><br><span class="line">        <span class="comment">// 不为空</span></span><br><span class="line">        <span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">            <span class="comment">// 已分配对象数</span></span><br><span class="line">            slotsUsed := <span class="type">int64</span>(s.allocCount) - <span class="type">int64</span>(s.allocCountBeforeCache)</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            s.allocCountBeforeCache = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">            <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">            stats := memstats.heapStats.acquire()</span><br><span class="line">            <span class="comment">// 累计到全局计数器</span></span><br><span class="line">            atomic.Xadd64(&amp;stats.smallAllocCount[spanClass(i).sizeclass()], slotsUsed)</span><br><span class="line">            <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">            memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 累计已分配字节数</span></span><br><span class="line">            gcController.totalAlloc.Add(slotsUsed * <span class="type">int64</span>(s.elemsize))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未过期</span></span><br><span class="line">            <span class="keyword">if</span> s.sweepgen != sg+<span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// -=剩余可用字节数</span></span><br><span class="line">                dHeapLive -= <span class="type">int64</span>(s.nelems-s.allocCount) * <span class="type">int64</span>(s.elemsize)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// mspan已过期则清理，未过期则根据是否mspan释放有剩余放到partial或full链表</span></span><br><span class="line">            mheap_.central[i].mcentral.uncacheSpan(s)</span><br><span class="line">            <span class="comment">// 设置为空的mspan</span></span><br><span class="line">            c.alloc[i] = &amp;emptymspan</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tiny区域清理</span></span><br><span class="line">    c.tiny = <span class="number">0</span></span><br><span class="line">    c.tinyoffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    <span class="comment">// 累计到全局tiny计数器</span></span><br><span class="line">    atomic.Xadd64(&amp;stats.tinyAllocCount, <span class="type">int64</span>(c.tinyAllocs))</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    c.tinyAllocs = <span class="number">0</span></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计heap存活字节数，如果GC未启动则累计heap扫描字节数，否则重新计算辅助GC的工作量转换参数</span></span><br><span class="line">    gcController.update(dHeapLive, scanAlloc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回收指定字节数量的内存（扫描时是从高地址向低地址进行搜索）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> scavenge(nbytes <span class="type">uintptr</span>, shouldStop <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>, force <span class="type">bool</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">    released := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 回收的内存字节数没有达到指定值</span></span><br><span class="line">    <span class="keyword">for</span> released &lt; nbytes &#123;</span><br><span class="line">        <span class="comment">// 返回可能含有可清理页的chunk的最大索引（扫描时是从高地址向低地址进行搜索）</span></span><br><span class="line">        ci, pageIdx := p.scav.index.find(force)</span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">if</span> ci == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回g0执行</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 在指定chunk内回收一定数量的页</span></span><br><span class="line">            released += p.scavengeOne(ci, pageIdx, nbytes-released)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果scavenger需要停止</span></span><br><span class="line">        <span class="keyword">if</span> shouldStop != <span class="literal">nil</span> &amp;&amp; shouldStop() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> released</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定chunk内回收一定数量的页</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> scavengeOne(ci chunkIdx, searchIdx <span class="type">uint</span>, max <span class="type">uintptr</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 页数最大值=max/8192</span></span><br><span class="line">    maxPages := max / pageSize</span><br><span class="line">    <span class="comment">// 有溢出</span></span><br><span class="line">    <span class="keyword">if</span> max%pageSize != <span class="number">0</span> &#123;</span><br><span class="line">        maxPages++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页数最小值=physPageSize/8192</span></span><br><span class="line">    minPages := physPageSize / pageSize</span><br><span class="line">    <span class="comment">// 最低1个页</span></span><br><span class="line">    <span class="keyword">if</span> minPages &lt; <span class="number">1</span> &#123;</span><br><span class="line">        minPages = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(p.mheapLock)</span><br><span class="line">    <span class="comment">// x = p.summary[4][ci] =&gt; pallocSum取max部份 (下面条件一般都符合)</span></span><br><span class="line">    <span class="keyword">if</span> p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][ci].max() &gt;= <span class="type">uint</span>(minPages) &#123;</span><br><span class="line">        <span class="comment">// 从pallocData中找到并返回未回收且可用的连续页起始索引以及页数</span></span><br><span class="line">        base, npages := p.chunkOf(ci).findScavengeCandidate(searchIdx, minPages, maxPages)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到n个页</span></span><br><span class="line">        <span class="keyword">if</span> npages != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 起始地址</span></span><br><span class="line">            addr := chunkBase(ci) + <span class="type">uintptr</span>(base)*pageSize</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先标记为分配，防止其他g获得这片区域</span></span><br><span class="line">            <span class="comment">// pallocBits、scavenged更新</span></span><br><span class="line">            p.chunkOf(ci).allocRange(base, npages)</span><br><span class="line">            <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">            p.update(addr, <span class="type">uintptr</span>(npages), <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接下来安全了</span></span><br><span class="line">            unlock(p.mheapLock)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非测试</span></span><br><span class="line">            <span class="keyword">if</span> !p.test &#123;</span><br><span class="line">                <span class="comment">// 将这片内存释放回系统（Ready-&gt;Prepared）</span></span><br><span class="line">                sysUnused(unsafe.Pointer(addr), <span class="type">uintptr</span>(npages)*pageSize)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 统计数据更新</span></span><br><span class="line">                nbytes := <span class="type">int64</span>(npages * pageSize)</span><br><span class="line">                <span class="comment">// 累计到heap内存释放量（释放回OS）</span></span><br><span class="line">                gcController.heapReleased.add(nbytes)</span><br><span class="line">                <span class="comment">// 累计到heap内存可复用量（非free都是减少）</span></span><br><span class="line">                gcController.heapFree.add(-nbytes)</span><br><span class="line"></span><br><span class="line">                stats := memstats.heapStats.acquire()</span><br><span class="line">                atomic.Xaddint64(&amp;stats.committed, -nbytes)</span><br><span class="line">                atomic.Xaddint64(&amp;stats.released, nbytes)</span><br><span class="line">                memstats.heapStats.release()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新加锁</span></span><br><span class="line">            lock(p.mheapLock)</span><br><span class="line">            <span class="comment">// searchAddr更新</span></span><br><span class="line">            <span class="keyword">if</span> b := (offAddr&#123;addr&#125;); b.lessThan(p.searchAddr) &#123;</span><br><span class="line">                p.searchAddr = b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// pallocData.pallocBits更新，指定位置为0</span></span><br><span class="line">            p.chunkOf(ci).free(base, npages)</span><br><span class="line">            <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">            p.update(addr, <span class="type">uintptr</span>(npages), <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// pallocData.scavenged更新，指定位置为1</span></span><br><span class="line">            p.chunkOf(ci).scavenged.setRange(base, npages)</span><br><span class="line">            unlock(p.mheapLock)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放回系统的内存大小</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">uintptr</span>(npages) * pageSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除scavChunkHasFree标志</span></span><br><span class="line">    p.scav.index.setEmpty(ci)</span><br><span class="line">    unlock(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从pallocData中找到并返回未回收且可用的连续页起始索引以及页数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *pallocData)</span></span> findScavengeCandidate(searchIdx <span class="type">uint</span>, minimum, max <span class="type">uintptr</span>) (<span class="type">uint</span>, <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// 非2的倍数 or 为0</span></span><br><span class="line">    <span class="keyword">if</span> minimum&amp;(minimum<span class="number">-1</span>) != <span class="number">0</span> || minimum == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: min = &quot;</span>, minimum, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;min must be a non-zero power of 2&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> minimum &gt; maxPagesPerPhysPage &#123; <span class="comment">// 超过64</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: min = &quot;</span>, minimum, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;min too large&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minimum -&gt; [1,64]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> max == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 最小为minimum</span></span><br><span class="line">        max = minimum</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 按minimum的倍数取整</span></span><br><span class="line">        max = alignUp(max, minimum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// searchIdx =&gt; [0,511]</span></span><br><span class="line">    <span class="comment">// i =&gt; 64的倍数 =&gt; [0,7]</span></span><br><span class="line">    i := <span class="type">int</span>(searchIdx / <span class="number">64</span>)</span><br><span class="line">    <span class="comment">// 跳过已使用或已回收的页，从高位往低位扫描</span></span><br><span class="line">    <span class="keyword">for</span> ; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 两个64位数按位或，按minimum个位填充1</span></span><br><span class="line">        <span class="comment">// 如fillAligned(0x0100a3, 8) == 0xff00ff =&gt; 每8个位有1的全部填充为1</span></span><br><span class="line">        <span class="comment">// scavenged中1为已回收，pallocBits中1为已使用，所以，x中0表示未回收且可用</span></span><br><span class="line">        x := fillAligned(m.scavenged[i]|m.pallocBits[i], <span class="type">uint</span>(minimum))</span><br><span class="line">        <span class="comment">// 存在未回收且可用的数据</span></span><br><span class="line">        <span class="keyword">if</span> x != ^<span class="type">uint64</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找失败</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到未回收且可用的页</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// double-check ???</span></span><br><span class="line">    x := fillAligned(m.scavenged[i]|m.pallocBits[i], <span class="type">uint</span>(minimum))</span><br><span class="line">    <span class="comment">// x取反算出前导0个数（minimum的倍数）</span></span><br><span class="line">    z1 := <span class="type">uint</span>(sys.LeadingZeros64(^x))</span><br><span class="line">    <span class="comment">// 连续0个数，最后一个0出现的位置</span></span><br><span class="line">    run, end := <span class="type">uint</span>(<span class="number">0</span>), <span class="type">uint</span>(i)*<span class="number">64</span>+(<span class="number">64</span>-z1)</span><br><span class="line">    <span class="comment">// 丢弃高z1位后不为0</span></span><br><span class="line">    <span class="keyword">if</span> x&lt;&lt;z1 != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 低位有为1的数据</span></span><br><span class="line">        <span class="comment">// 丢弃高z1位后前导0的个数</span></span><br><span class="line">        run = <span class="type">uint</span>(sys.LeadingZeros64(x &lt;&lt; z1))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 丢弃高z1位后为0</span></span><br><span class="line">        <span class="comment">// 低位0的个数</span></span><br><span class="line">        run = <span class="number">64</span> - z1</span><br><span class="line">        <span class="comment">// 扩展，继续扫描i之前的位置</span></span><br><span class="line">        <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            x := fillAligned(m.scavenged[j]|m.pallocBits[j], <span class="type">uint</span>(minimum))</span><br><span class="line">            <span class="comment">// 高位0个数</span></span><br><span class="line">            run += <span class="type">uint</span>(sys.LeadingZeros64(x))</span><br><span class="line">            <span class="comment">// 存在已回收或已使用的页</span></span><br><span class="line">            <span class="keyword">if</span> x != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取最小值</span></span><br><span class="line">    size := min(run, <span class="type">uint</span>(max))</span><br><span class="line">    <span class="comment">// 0的起始位置</span></span><br><span class="line">    start := end - size</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保不会破坏huge page的边界，不讨论</span></span><br><span class="line">    <span class="keyword">if</span> physHugePageSize &gt; pageSize &amp;&amp; physHugePageSize &gt; physPageSize &#123;</span><br><span class="line">        pagesPerHugePage := physHugePageSize / pageSize</span><br><span class="line">        hugePageAbove := <span class="type">uint</span>(alignUp(<span class="type">uintptr</span>(start), pagesPerHugePage))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hugePageAbove &lt;= end &#123;</span><br><span class="line">            hugePageBelow := <span class="type">uint</span>(alignDown(<span class="type">uintptr</span>(start), pagesPerHugePage))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> hugePageBelow &gt;= end-run &#123;</span><br><span class="line">                size = size + (start - hugePageBelow)</span><br><span class="line">                start = hugePageBelow</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓冲区-1"><a href="#缓冲区-1" class="headerlink" title="缓冲区"></a>缓冲区</h3><h4 id="任务缓冲区"><a href="#任务缓冲区" class="headerlink" title="任务缓冲区"></a>任务缓冲区</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化wbuf1、wbuf2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> init() &#123;</span><br><span class="line">    <span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line">    w.wbuf1 = getempty()</span><br><span class="line">    <span class="comment">// 尝试从work.full获取一个wbuf</span></span><br><span class="line">    wbuf2 := trygetfull()</span><br><span class="line">    <span class="keyword">if</span> wbuf2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line">        wbuf2 = getempty()</span><br><span class="line">    &#125;</span><br><span class="line">    w.wbuf2 = wbuf2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象放到wbuf-任务缓冲区，已满则从work.empty获取一个wbuf替换用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> put(obj <span class="type">uintptr</span>) &#123;</span><br><span class="line">    flushed := <span class="literal">false</span></span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// workType、mheap加锁</span></span><br><span class="line">    lockWithRankMayAcquire(&amp;work.wbufSpans.lock, lockRankWbufSpans)</span><br><span class="line">    lockWithRankMayAcquire(&amp;mheap_.lock, lockRankMheap)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf1、wbuf2未初始化</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化wbuf1、wbuf2</span></span><br><span class="line">        w.init()</span><br><span class="line">        <span class="comment">// 重新读一遍wbuf1</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line">        <span class="comment">// wbuf1已满</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换wbuf1、wbuf2</span></span><br><span class="line">        w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1</span><br><span class="line">        <span class="comment">// 重新读一遍wbuf1（实际是wbuf2）</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf2也满了</span></span><br><span class="line">        <span class="keyword">if</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line">            <span class="comment">// wbuf2放到work.full</span></span><br><span class="line">            putfull(wbuf)</span><br><span class="line">            <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">            w.flushedWork = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line">            wbuf = getempty()</span><br><span class="line">            <span class="comment">// 优先放到wbuf1</span></span><br><span class="line">            w.wbuf1 = wbuf</span><br><span class="line">            <span class="comment">// 同flushedWork</span></span><br><span class="line">            flushed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到obj数组末尾</span></span><br><span class="line">    wbuf.obj[wbuf.nobj] = obj</span><br><span class="line">    <span class="comment">// 索引往后移</span></span><br><span class="line">    wbuf.nobj++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动更多标记线程</span></span><br><span class="line">    <span class="keyword">if</span> flushed &amp;&amp; gcphase == _GCmark &#123;</span><br><span class="line">        <span class="comment">// 如果需要更多的专用标记线程，随机抢占一个p运行</span></span><br><span class="line">        gcController.enlistWorker()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象放到wbuf-任务缓冲区，未初始化或已满直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> putFast(obj <span class="type">uintptr</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line">    <span class="comment">// wbuf1、wbuf2未初始化 or wbuf1已满</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> || wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到obj数组末尾</span></span><br><span class="line">    wbuf.obj[wbuf.nobj] = obj</span><br><span class="line">    <span class="comment">// 索引往后移</span></span><br><span class="line">    wbuf.nobj++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一批对象放到wbuf-任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> putBatch(obj []<span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 空数组</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(obj) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flushed := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// wbuf1</span></span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf1、wbuf2未初始化</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化wbuf1、wbuf2</span></span><br><span class="line">        w.init()</span><br><span class="line">        <span class="comment">// 重新读一遍wbuf1</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个处理</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(obj) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// wbuf1已满</span></span><br><span class="line">        <span class="keyword">for</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line">            <span class="comment">// wbuf放到work.full</span></span><br><span class="line">            putfull(wbuf)</span><br><span class="line">            <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">            w.flushedWork = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// wbuf2替换wbuf1，从work.empty链表获取1个空的wbuf替换wbuf2</span></span><br><span class="line">            w.wbuf1, w.wbuf2 = w.wbuf2, getempty()</span><br><span class="line">            <span class="comment">// 重新读一遍wbuf1（实际是wbuf2）</span></span><br><span class="line">            wbuf = w.wbuf1</span><br><span class="line">            <span class="comment">// 同flushedWork</span></span><br><span class="line">            flushed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制n个obj</span></span><br><span class="line">        n := <span class="built_in">copy</span>(wbuf.obj[wbuf.nobj:], obj)</span><br><span class="line">        <span class="comment">// 索引更新</span></span><br><span class="line">        wbuf.nobj += n</span><br><span class="line">        <span class="comment">// 剩余量</span></span><br><span class="line">        obj = obj[n:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动更多标记线程</span></span><br><span class="line">    <span class="keyword">if</span> flushed &amp;&amp; gcphase == _GCmark &#123;</span><br><span class="line">        <span class="comment">// 如果需要更多的专用标记线程，随机抢占一个p运行</span></span><br><span class="line">        gcController.enlistWorker()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从wbuf获取一个obj</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> tryGet() <span class="type">uintptr</span> &#123;</span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line">    <span class="comment">// wbuf1、wbuf2未初始化</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化wbuf1、wbuf2</span></span><br><span class="line">        w.init()</span><br><span class="line">        <span class="comment">// 重新读一遍wbuf1</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组为空</span></span><br><span class="line">    <span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 交换wbuf1、wbuf2</span></span><br><span class="line">        w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1</span><br><span class="line">        <span class="comment">// 重新读一遍wbuf1（实际是wbuf2）</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 仍然为空</span></span><br><span class="line">        <span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 旧</span></span><br><span class="line">            owbuf := wbuf</span><br><span class="line">            <span class="comment">// 新</span></span><br><span class="line">            <span class="comment">// 尝试从work.full获取一个wbuf</span></span><br><span class="line">            wbuf = trygetfull()</span><br><span class="line">            <span class="comment">// 没有数据，返回</span></span><br><span class="line">            <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// wbuf放到work.empty</span></span><br><span class="line">            putempty(owbuf)</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            w.wbuf1 = wbuf</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引往前移</span></span><br><span class="line">    wbuf.nobj--</span><br><span class="line">    <span class="comment">// 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> wbuf.obj[wbuf.nobj]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从wbuf获取一个obj，未初始化或为空直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> tryGetFast() <span class="type">uintptr</span> &#123;</span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line">    <span class="comment">// wbuf1、wbuf2未初始化 or wbuf1为空</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> || wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引往前移</span></span><br><span class="line">    wbuf.nobj--</span><br><span class="line">    <span class="comment">// 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> wbuf.obj[wbuf.nobj]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wbuf1、wbuf2根据容量选择放入work.empty或work.full队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> dispose() &#123;</span><br><span class="line">    <span class="comment">// wbuf1已初始化</span></span><br><span class="line">    <span class="keyword">if</span> wbuf := w.wbuf1; wbuf != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 为空</span></span><br><span class="line">        <span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// wbuf放到work.empty</span></span><br><span class="line">            putempty(wbuf)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不为空</span></span><br><span class="line">            <span class="comment">// wbuf放到work.full</span></span><br><span class="line">            putfull(wbuf)</span><br><span class="line">            <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">            w.flushedWork = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置为nil</span></span><br><span class="line">        w.wbuf1 = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf2</span></span><br><span class="line">        wbuf = w.wbuf2</span><br><span class="line">        <span class="comment">// 为空</span></span><br><span class="line">        <span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// wbuf放到work.empty</span></span><br><span class="line">            putempty(wbuf)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不为空</span></span><br><span class="line">            <span class="comment">// wbuf放到work.full</span></span><br><span class="line">            putfull(wbuf)</span><br><span class="line">            <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">            w.flushedWork = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置为nil</span></span><br><span class="line">        w.wbuf2 = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> w.bytesMarked != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 加到work.bytesMarked</span></span><br><span class="line">        atomic.Xadd64(&amp;work.bytesMarked, <span class="type">int64</span>(w.bytesMarked))</span><br><span class="line">        <span class="comment">// 清0</span></span><br><span class="line">        w.bytesMarked = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> w.heapScanWork != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 加到gcController.heapScanWork</span></span><br><span class="line">        gcController.heapScanWork.Add(w.heapScanWork)</span><br><span class="line">        <span class="comment">// 清0</span></span><br><span class="line">        w.heapScanWork = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wbuf2不为空则全部放入work.full，否则将wbuf1的一半放到work.full</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> balance() &#123;</span><br><span class="line">    <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="keyword">if</span> w.wbuf1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf2不为空</span></span><br><span class="line">    <span class="keyword">if</span> wbuf := w.wbuf2; wbuf.nobj != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// wbuf2放到work.full</span></span><br><span class="line">        putfull(wbuf)</span><br><span class="line">        <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">        w.flushedWork = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line">        w.wbuf2 = getempty()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> wbuf := w.wbuf1; wbuf.nobj &gt; <span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">// wbuf1数量&gt;4</span></span><br><span class="line">        <span class="comment">// 从wbuf拿走末尾一半数据创建新的wbuf，剩下的放到work.full</span></span><br><span class="line">        w.wbuf1 = handoff(wbuf)</span><br><span class="line">        <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">        w.flushedWork = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wbuf1为空或对象数量不足4</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记阶段</span></span><br><span class="line">    <span class="keyword">if</span> gcphase == _GCmark &#123;</span><br><span class="line">        <span class="comment">// 如果需要更多的专用标记线程，随机抢占一个p运行</span></span><br><span class="line">        gcController.enlistWorker()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getempty</span><span class="params">()</span></span> *workbuf &#123;</span><br><span class="line">    <span class="keyword">var</span> b *workbuf</span><br><span class="line">    <span class="comment">// work.empty有数据</span></span><br><span class="line">    <span class="keyword">if</span> work.empty != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取work.empty第1个</span></span><br><span class="line">        b = (*workbuf)(work.empty.pop())</span><br><span class="line">        <span class="comment">// 有数据</span></span><br><span class="line">        <span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 确保wbuf为空</span></span><br><span class="line">            b.checkempty()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// workType、mheap加锁</span></span><br><span class="line">    lockWithRankMayAcquire(&amp;work.wbufSpans.lock, lockRankWbufSpans)</span><br><span class="line">    lockWithRankMayAcquire(&amp;mheap_.lock, lockRankMheap)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有从empty拿到数据</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s *mspan</span><br><span class="line"></span><br><span class="line">        <span class="comment">// free链表有数据</span></span><br><span class="line">        <span class="keyword">if</span> work.wbufSpans.free.first != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            lock(&amp;work.wbufSpans.lock)</span><br><span class="line">            <span class="comment">// free链表第一个</span></span><br><span class="line">            s = work.wbufSpans.free.first</span><br><span class="line">            <span class="comment">// double-check</span></span><br><span class="line">            <span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// mspan从free迁移到busy</span></span><br><span class="line">                work.wbufSpans.free.remove(s)</span><br><span class="line">                work.wbufSpans.busy.insert(s)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            unlock(&amp;work.wbufSpans.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有从free链表拿到数据</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="comment">// 获取mspan、分配n个页面、更新元信息</span></span><br><span class="line">                <span class="comment">// 手动分配4个页，type为spanAllocWorkBuf-3</span></span><br><span class="line">                s = mheap_.allocManual(workbufAlloc/pageSize, spanAllocWorkBuf)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内存不足</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            lock(&amp;work.wbufSpans.lock)</span><br><span class="line">            <span class="comment">// mspan放到busy</span></span><br><span class="line">            work.wbufSpans.busy.insert(s)</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            unlock(&amp;work.wbufSpans.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i从0开始，步进为2048，边界为32768</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i+_WorkbufSize &lt;= workbufAlloc; i += _WorkbufSize &#123;</span><br><span class="line">            <span class="comment">// 分配2KB内存创建workbuf</span></span><br><span class="line">            newb := (*workbuf)(unsafe.Pointer(s.base() + i))</span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            newb.nobj = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 校验地址，如果node地址非法，则抛出异常</span></span><br><span class="line">            lfnodeValidate(&amp;newb.node)</span><br><span class="line">            <span class="comment">// 第1个wbuf</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 直接使用</span></span><br><span class="line">                b = newb</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 剩余的wbuf</span></span><br><span class="line">                <span class="comment">// wbuf放到work.empty</span></span><br><span class="line">                putempty(newb)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wbuf放到work.empty</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putempty</span><span class="params">(b *workbuf)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 确保wbuf为空</span></span><br><span class="line">    b.checkempty()</span><br><span class="line">    <span class="comment">// 放到work.empty</span></span><br><span class="line">    work.empty.push(&amp;b.node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wbuf放到work.full</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putfull</span><span class="params">(b *workbuf)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 确保wbuf不为空</span></span><br><span class="line">    b.checknonempty()</span><br><span class="line">    <span class="comment">// 放到work.full</span></span><br><span class="line">    work.full.push(&amp;b.node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从work.full获取一个wbuf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trygetfull</span><span class="params">()</span></span> *workbuf &#123;</span><br><span class="line">    <span class="comment">// 获取work.full第1个</span></span><br><span class="line">    b := (*workbuf)(work.full.pop())</span><br><span class="line">    <span class="comment">// 有数据</span></span><br><span class="line">    <span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 确保wbuf不为空</span></span><br><span class="line">        b.checknonempty()</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从wbuf拿走末尾一半数据创建新的wbuf，剩下的放到work.full</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoff</span><span class="params">(b *workbuf)</span></span> *workbuf &#123;</span><br><span class="line">    <span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line">    b1 := getempty()</span><br><span class="line">    <span class="comment">// 拿走一半</span></span><br><span class="line">    n := b.nobj / <span class="number">2</span></span><br><span class="line">    b.nobj -= n</span><br><span class="line">    b1.nobj = n</span><br><span class="line">    <span class="comment">// 复制数据</span></span><br><span class="line">    memmove(unsafe.Pointer(&amp;b1.obj[<span class="number">0</span>]), unsafe.Pointer(&amp;b.obj[b.nobj]), <span class="type">uintptr</span>(n)*unsafe.Sizeof(b1.obj[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf放到work.full</span></span><br><span class="line">    putfull(b)</span><br><span class="line">    <span class="keyword">return</span> b1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空empty链表，将busy链表数据搬到free链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareFreeWorkbufs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    lock(&amp;work.wbufSpans.lock)</span><br><span class="line">    <span class="comment">// work.full链表不为空</span></span><br><span class="line">    <span class="keyword">if</span> work.full != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;cannot free workbufs when work.full != 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf都在empty链表，不关心其mspan归属，直接清空链表，把所有mspan搬到free链表</span></span><br><span class="line">    work.empty = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 合并busy链表的mspan数据到free链表前</span></span><br><span class="line">    work.wbufSpans.free.takeAll(&amp;work.wbufSpans.busy)</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    unlock(&amp;work.wbufSpans.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wbuf的free链表清理64个mspan、mspan内存释放回mheap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freeSomeWbufs</span><span class="params">(preemptible <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 一次性只处理64个mspan，每个mspan耗时~1–2 µs</span></span><br><span class="line">    <span class="keyword">const</span> batchSize = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">    lock(&amp;work.wbufSpans.lock)</span><br><span class="line">    <span class="comment">// 非_GCoff阶段 or free链表为空</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff || work.wbufSpans.free.isEmpty() &#123;</span><br><span class="line">        unlock(&amp;work.wbufSpans.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// g</span></span><br><span class="line">        gp := getg().m.curg</span><br><span class="line">        <span class="comment">// 释放64个mspan，如果遇到抢占则提前退出循环</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; batchSize &amp;&amp; !(preemptible &amp;&amp; gp.preempt); i++ &#123;</span><br><span class="line">            <span class="comment">// free链表第一个</span></span><br><span class="line">            span := work.wbufSpans.free.first</span><br><span class="line">            <span class="comment">// 没数据</span></span><br><span class="line">            <span class="keyword">if</span> span == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移除指定mspan</span></span><br><span class="line">            work.wbufSpans.free.remove(span)</span><br><span class="line">            <span class="comment">// 释放页和mspan，type为spanAllocWorkBuf-3</span></span><br><span class="line">            mheap_.freeManual(span, spanAllocWorkBuf)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// free链表是否还有数据</span></span><br><span class="line">    more := !work.wbufSpans.free.isEmpty()</span><br><span class="line">    unlock(&amp;work.wbufSpans.lock)</span><br><span class="line">    <span class="keyword">return</span> more</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写屏障缓冲区"><a href="#写屏障缓冲区" class="headerlink" title="写屏障缓冲区"></a>写屏障缓冲区</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重置wbBuf的next、end指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *wbBuf)</span></span> reset() &#123;</span><br><span class="line">    <span class="comment">// 起始地址</span></span><br><span class="line">    start := <span class="type">uintptr</span>(unsafe.Pointer(&amp;b.buf[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment">// 重置next</span></span><br><span class="line">    b.next = start</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认为false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> testSmallBuf &#123;</span><br><span class="line">        <span class="comment">// = &amp;b.buf[9]</span></span><br><span class="line">        b.end = <span class="type">uintptr</span>(unsafe.Pointer(&amp;b.buf[wbMaxEntriesPerCall+<span class="number">1</span>]))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 边界，指向最后一个元素的末尾</span></span><br><span class="line">        b.end = start + <span class="type">uintptr</span>(<span class="built_in">len</span>(b.buf))*unsafe.Sizeof(b.buf[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有对齐</span></span><br><span class="line">    <span class="keyword">if</span> (b.end-b.next)%unsafe.Sizeof(b.buf[<span class="number">0</span>]) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad write barrier buffer bounds&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写屏障缓冲区可写入位置（容量为1个指针）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *wbBuf)</span></span> get1() *[<span class="number">1</span>]<span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 越界，缓冲区已满</span></span><br><span class="line">    <span class="keyword">if</span> b.next+goarch.PtrSize &gt; b.end &#123;</span><br><span class="line">        <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">        wbBufFlush()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p指向next位置</span></span><br><span class="line">    p := (*[<span class="number">1</span>]<span class="type">uintptr</span>)(unsafe.Pointer(b.next))</span><br><span class="line">    <span class="comment">// 指向下一个可写入位置</span></span><br><span class="line">    b.next += goarch.PtrSize</span><br><span class="line">    <span class="comment">// 返回缓冲区指针</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写屏障缓冲区可写入位置（容量为2个指针）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *wbBuf)</span></span> get2() *[<span class="number">2</span>]<span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 越界，缓冲区已满</span></span><br><span class="line">    <span class="keyword">if</span> b.next+<span class="number">2</span>*goarch.PtrSize &gt; b.end &#123;</span><br><span class="line">        <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">        wbBufFlush()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p指向next位置</span></span><br><span class="line">    p := (*[<span class="number">2</span>]<span class="type">uintptr</span>)(unsafe.Pointer(b.next))</span><br><span class="line">    <span class="comment">// 指向下一个可写入位置</span></span><br><span class="line">    b.next += <span class="number">2</span> * goarch.PtrSize</span><br><span class="line">    <span class="comment">// 返回缓冲区指针</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wbBufFlush</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 发生panic</span></span><br><span class="line">    <span class="keyword">if</span> getg().m.dying &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// wbBuf的next字段指向buf数组开头</span></span><br><span class="line">        getg().m.p.ptr().wbBuf.discard()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到g0执行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">        wbBufFlush1(getg().m.p.ptr())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wbBufFlush1</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 起始地址</span></span><br><span class="line">    start := <span class="type">uintptr</span>(unsafe.Pointer(&amp;pp.wbBuf.buf[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment">// 总数量</span></span><br><span class="line">    n := (pp.wbBuf.next - start) / unsafe.Sizeof(pp.wbBuf.buf[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 获取所有指针</span></span><br><span class="line">    ptrs := pp.wbBuf.buf[:n]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为0，防止有新的数据入队</span></span><br><span class="line">    pp.wbBuf.next = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug.debug.gccheckmark默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> useCheckmark &#123;</span><br><span class="line">        <span class="comment">// 遍历wbBuf</span></span><br><span class="line">        <span class="keyword">for</span> _, ptr := <span class="keyword">range</span> ptrs &#123;</span><br><span class="line">            <span class="comment">// 根据指针获取对象起始地址、mspan、offset，设置gcmarkBits，放入wbuf队列</span></span><br><span class="line">            shade(ptr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置wbBuf的next、end指针</span></span><br><span class="line">        pp.wbBuf.reset()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcw是wbuf</span></span><br><span class="line">    gcw := &amp;pp.gcw</span><br><span class="line">    pos := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 遍历wbBuf-写屏障缓冲</span></span><br><span class="line">    <span class="keyword">for</span> _, ptr := <span class="keyword">range</span> ptrs &#123;</span><br><span class="line">        <span class="comment">// &lt;4096 =&gt; 比合法指针还要小</span></span><br><span class="line">        <span class="keyword">if</span> ptr &lt; minLegalPointer &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据p查找mspan，找到了返回对象在mspan内的位置和对象起始地址</span></span><br><span class="line">        obj, span, objIndex := findObject(ptr, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 在mspan开头</span></span><br><span class="line">        <span class="keyword">if</span> obj == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// ？？？</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取该对象的bitmap（从gcmarkBits获取，第几个字节、字节内第几位）</span></span><br><span class="line">        mbits := span.markBitsForIndex(objIndex)</span><br><span class="line">        <span class="comment">// 该位是否已经设置为1</span></span><br><span class="line">        <span class="keyword">if</span> mbits.isMarked() &#123;</span><br><span class="line">            <span class="comment">// 已设置，不处理</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该位设置为1（只要用mask跟gcmarkBits按位或）</span></span><br><span class="line">        mbits.setMarked()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据mspan起始地址获取heapArena、页索引、页bitmap位置</span></span><br><span class="line">        arena, pageIdx, pageMask := pageIndexOf(span.base())</span><br><span class="line">        <span class="comment">// 将这个页的bitmap设置为1（粗略，只设置一页，不是所有页，此外，pageMarks在GC启动时清0）</span></span><br><span class="line">        <span class="keyword">if</span> arena.pageMarks[pageIdx]&amp;pageMask == <span class="number">0</span> &#123;</span><br><span class="line">            atomic.Or8(&amp;arena.pageMarks[pageIdx], pageMask)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象不包含指针</span></span><br><span class="line">        <span class="keyword">if</span> span.spanclass.noscan() &#123;</span><br><span class="line">            <span class="comment">// 对象大小累计到bytesMarked-被标记的字节总数</span></span><br><span class="line">            gcw.bytesMarked += <span class="type">uint64</span>(span.elemsize)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放回写屏障缓冲</span></span><br><span class="line">        ptrs[pos] = obj</span><br><span class="line">        <span class="comment">// 索引调整</span></span><br><span class="line">        pos++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一批对象放到wbuf-任务缓冲区</span></span><br><span class="line">    gcw.putBatch(ptrs[:pos])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置wbBuf的next、end指针</span></span><br><span class="line">    pp.wbBuf.reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcControllerState-垃圾回收节奏控制"><a href="#gcControllerState-垃圾回收节奏控制" class="headerlink" title="gcControllerState-垃圾回收节奏控制"></a>gcControllerState-垃圾回收节奏控制</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置GC启动阈值、计算目标heap大小和跑道大小，计算辅助GC的工作量转换参数，计算GC触发阈值和目标heap大小，更新sweeper、scavenger的pacing参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcControllerCommit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置GC启动阈值、计算目标heap大小和跑道大小</span></span><br><span class="line">    gcController.commit(isSweepDone())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC运行中</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">        <span class="comment">// 计算辅助GC的工作量转换参数</span></span><br><span class="line">        gcController.revise()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算GC触发阈值和目标heap大小</span></span><br><span class="line">    trigger, heapGoal := gcController.trigger()</span><br><span class="line">    <span class="comment">// 更新sweeper的pacing参数</span></span><br><span class="line">    gcPaceSweeper(trigger)</span><br><span class="line">    <span class="comment">// 更新scavenger的pacing参数</span></span><br><span class="line">    gcPaceScavenger(gcController.memoryLimit.Load(), heapGoal, gcController.lastHeapGoal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新sweeper的pacing参数</span></span><br><span class="line"><span class="comment">// 标记终止阶段调用，或GCPercent/MemoryLimit有变动时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcPaceSweeper</span><span class="params">(trigger <span class="type">uint64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sweeper数量为0</span></span><br><span class="line">    <span class="keyword">if</span> isSweepDone() &#123;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// sweeper数量不为0 =&gt; 还在清扫中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// heap存活字节数</span></span><br><span class="line">        heapLiveBasis := gcController.heapLive.Load()</span><br><span class="line">        <span class="comment">// 距离GC触发的剩余堆大小=触发临界点-heap存活字节数</span></span><br><span class="line">        heapDistance := <span class="type">int64</span>(trigger) - <span class="type">int64</span>(heapLiveBasis)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加边距，防止有页未被清理</span></span><br><span class="line">        heapDistance -= <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">        <span class="comment">// 最低为8192</span></span><br><span class="line">        <span class="keyword">if</span> heapDistance &lt; _PageSize &#123;</span><br><span class="line">            heapDistance = _PageSize</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已完成清扫的页数量</span></span><br><span class="line">        pagesSwept := mheap_.pagesSwept.Load()</span><br><span class="line">        <span class="comment">// heap内存页使用量（mSpanInUse）</span></span><br><span class="line">        pagesInUse := mheap_.pagesInUse.Load()</span><br><span class="line">        <span class="comment">// 剩余待清扫页数量</span></span><br><span class="line">        sweepDistancePages := <span class="type">int64</span>(pagesInUse) - <span class="type">int64</span>(pagesSwept)</span><br><span class="line">        <span class="keyword">if</span> sweepDistancePages &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不能为负数，重置为0</span></span><br><span class="line">            mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 还没清扫完</span></span><br><span class="line">            <span class="comment">// 每分配1字节需要清扫的页数=剩余待清扫页数量/距离GC触发的剩余堆大小</span></span><br><span class="line">            mheap_.sweepPagesPerByte = <span class="type">float64</span>(sweepDistancePages) / <span class="type">float64</span>(heapDistance)</span><br><span class="line">            <span class="comment">// 纪录heapLive快照</span></span><br><span class="line">            mheap_.sweepHeapLiveBasis = heapLiveBasis</span><br><span class="line">            <span class="comment">// 纪录pagesSwept快照-已完成清扫的页数量</span></span><br><span class="line">            mheap_.pagesSweptBasis.Store(pagesSwept)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新scavenger的pacing参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcPaceScavenger</span><span class="params">(memoryLimit <span class="type">int64</span>, heapGoal, lastHeapGoal <span class="type">uint64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memoryLimit*0.95</span></span><br><span class="line">    memoryLimitGoal := <span class="type">uint64</span>(<span class="type">float64</span>(memoryLimit) * (<span class="number">1</span> - reduceExtraPercent/<span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已映射且可用的内存量（总内存）</span></span><br><span class="line">    mappedReady := gcController.mappedReady.Load()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总内存没有超过限制</span></span><br><span class="line">    <span class="keyword">if</span> mappedReady &lt;= memoryLimitGoal &#123;</span><br><span class="line">        <span class="comment">// 设置为最大值=2^64-1</span></span><br><span class="line">        scavenge.memoryLimitGoal.Store(^<span class="type">uint64</span>(<span class="number">0</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 总内存超过限制</span></span><br><span class="line">        <span class="comment">// 设置为当前值</span></span><br><span class="line">        scavenge.memoryLimitGoal.Store(memoryLimitGoal)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次GC还没完成，没有足够的信息，停止清理</span></span><br><span class="line">    <span class="keyword">if</span> lastHeapGoal == <span class="number">0</span> &#123;</span><br><span class="line">        scavenge.gcPercentGoal.Store(^<span class="type">uint64</span>(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算scavenging goal</span></span><br><span class="line">    goalRatio := <span class="type">float64</span>(heapGoal) / <span class="type">float64</span>(lastHeapGoal)</span><br><span class="line">    gcPercentGoal := <span class="type">uint64</span>(<span class="type">float64</span>(memstats.lastHeapInUse) * goalRatio)</span><br><span class="line">    <span class="comment">// += gcPercentGoal/10 =&gt; 这里的retainExtraPercent作用是为了得到更好的被除数</span></span><br><span class="line">    gcPercentGoal += gcPercentGoal / (<span class="number">1.0</span> / (retainExtraPercent / <span class="number">100.0</span>))</span><br><span class="line">    <span class="comment">// 按物理页的大小对齐</span></span><br><span class="line">    gcPercentGoal = (gcPercentGoal + <span class="type">uint64</span>(physPageSize) - <span class="number">1</span>) &amp;^ (<span class="type">uint64</span>(physPageSize) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =heapInUse+heapFree（gcController）</span></span><br><span class="line">    heapRetainedNow := heapRetained()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果小于等于goal or 差值在一个物理页内</span></span><br><span class="line">    <span class="keyword">if</span> heapRetainedNow &lt;= gcPercentGoal || heapRetainedNow-gcPercentGoal &lt; <span class="type">uint64</span>(physPageSize) &#123;</span><br><span class="line">        <span class="comment">// 停止清理</span></span><br><span class="line">        scavenge.gcPercentGoal.Store(^<span class="type">uint64</span>(<span class="number">0</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        scavenge.gcPercentGoal.Store(gcPercentGoal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> init(gcPercent <span class="type">int32</span>, memoryLimit <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// heap最小为4MB</span></span><br><span class="line">    c.heapMinimum = defaultHeapMinimum</span><br><span class="line">    <span class="comment">// ^uint64(0) =&gt; 64位全为1</span></span><br><span class="line">    c.triggered = ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 设置gcPercent并返回旧值（gcPercent从GOGC环境变量获取，默认为100）</span></span><br><span class="line">    c.setGCPercent(gcPercent)</span><br><span class="line">    <span class="comment">// 设置memoryLimit（memoryLimit从GOMEMLIMIT环境变量获取，默认2^64-1）</span></span><br><span class="line">    c.setMemoryLimit(memoryLimit)</span><br><span class="line">    <span class="comment">// 设置GC启动阈值、计算目标heap大小和跑道大小</span></span><br><span class="line">    c.commit(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置gcPercent并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> setGCPercent(in <span class="type">int32</span>) <span class="type">int32</span> &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> !c.test &#123;</span><br><span class="line">        assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前值</span></span><br><span class="line">    out := c.gcPercent.Load()</span><br><span class="line">    <span class="comment">// 最小为-1</span></span><br><span class="line">    <span class="keyword">if</span> in &lt; <span class="number">0</span> &#123;</span><br><span class="line">        in = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =4MB*GCPercent/100 =&gt; GCPercent默认100</span></span><br><span class="line">    c.heapMinimum = defaultHeapMinimum * <span class="type">uint64</span>(in) / <span class="number">100</span></span><br><span class="line">    <span class="comment">// 纪录GCPercent</span></span><br><span class="line">    c.gcPercent.Store(in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置GC启动阈值、计算目标heap大小和跑道大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> commit(isSweepDone <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> !c.test &#123;</span><br><span class="line">        <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">        assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isSweepDone &#123;</span><br><span class="line">        <span class="comment">// sweeper数量为0 =&gt; 清扫阶段已结束，可以随时启动GC</span></span><br><span class="line">        <span class="comment">// =0</span></span><br><span class="line">        c.sweepDistMinTrigger.Store(<span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// sweeper数量不为0 =&gt; 还在清扫，设置一个阈值，避免GC过早启动</span></span><br><span class="line">        <span class="comment">// =heapLive+1MB</span></span><br><span class="line">        c.sweepDistMinTrigger.Store(c.heapLive.Load() + sweepMinHeapDistance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算目标heap大小，可以粗略地认为是2倍heap大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始值设为64位数最大值</span></span><br><span class="line">    gcPercentHeapGoal := ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// gcPercent默认为100</span></span><br><span class="line">    <span class="keyword">if</span> gcPercent := c.gcPercent.Load(); gcPercent &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//目标heap大小 =上一次GC后heap存活字节数 + (上一次GC后stack扫描字节数+全部模块的bss+data段大小)*100/100</span></span><br><span class="line">        gcPercentHeapGoal = c.heapMarked + (c.heapMarked+c.lastStackScan.Load()+c.globalsScan.Load())*<span class="type">uint64</span>(gcPercent)/<span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低为4MB</span></span><br><span class="line">    <span class="keyword">if</span> gcPercentHeapGoal &lt; c.heapMinimum &#123;</span><br><span class="line">        gcPercentHeapGoal = c.heapMinimum</span><br><span class="line">    &#125;</span><br><span class="line">    c.gcPercentHeapGoal.Store(gcPercentHeapGoal)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算runway大小，默认情况下为根对象大小的3倍</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =consMark*(1-0.25)/0.25*(heap扫描字节数+stack扫描字节数+全部模块的bss+data段大小)</span></span><br><span class="line">    c.runway.Store(<span class="type">uint64</span>((c.consMark * (<span class="number">1</span> - gcGoalUtilization) / (gcGoalUtilization)) * <span class="type">float64</span>(c.lastHeapScan+c.lastStackScan.Load()+c.globalsScan.Load())))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算GC触发阈值和目标heap大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> trigger() (<span class="type">uint64</span>, <span class="type">uint64</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）、最小目标heap大小</span></span><br><span class="line">    <span class="comment">// goal介于上一次GC后heap存活字节数和2*上一次GC后heap存活字节数</span></span><br><span class="line">    <span class="comment">// minTrigger为0或heap存活字节数+1MB</span></span><br><span class="line">    goal, minTrigger := c.heapGoalInternal()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一次GC后heap存活字节数 &gt;= 目标heap大小</span></span><br><span class="line">    <span class="keyword">if</span> c.heapMarked &gt;= goal &#123;</span><br><span class="line">        <span class="comment">// goal不应该小于heapMarked</span></span><br><span class="line">        <span class="keyword">return</span> goal, goal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c.heapMarked &lt; goal</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =max(最小目标heap大小,上一次GC后heap存活字节数)</span></span><br><span class="line">    <span class="keyword">if</span> minTrigger &lt; c.heapMarked &#123;</span><br><span class="line">        minTrigger = c.heapMarked</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低为70%触发</span></span><br><span class="line">    <span class="comment">// =(目标heap大小-上一次GC后heap存活字节数)/64*45 + 上一次GC后heap存活字节数</span></span><br><span class="line">    triggerLowerBound := ((goal-c.heapMarked)/triggerRatioDen)*minTriggerRatioNum + c.heapMarked</span><br><span class="line">    <span class="keyword">if</span> minTrigger &lt; triggerLowerBound &#123;</span><br><span class="line">        minTrigger = triggerLowerBound</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最高为95%触发</span></span><br><span class="line">    <span class="comment">// =(目标heap大小-上一次GC后heap存活字节数)/64*61 + 上一次GC后heap存活字节数</span></span><br><span class="line">    maxTrigger := ((goal-c.heapMarked)/triggerRatioDen)*maxTriggerRatioNum + c.heapMarked</span><br><span class="line">    <span class="comment">// 目标heap大小&gt;4MB and 目标heap大小-4MB&gt;maxTrigger</span></span><br><span class="line">    <span class="keyword">if</span> goal &gt; defaultHeapMinimum &amp;&amp; goal-defaultHeapMinimum &gt; maxTrigger &#123;</span><br><span class="line">        <span class="comment">// =目标heap大小-4MB</span></span><br><span class="line">        maxTrigger = goal - defaultHeapMinimum</span><br><span class="line">    &#125;</span><br><span class="line">    maxTrigger = max(maxTrigger, minTrigger)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发阈值</span></span><br><span class="line">    <span class="keyword">var</span> trigger <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 飞机起飞前需要滑行的距离，默认情况下为根对象大小的3倍</span></span><br><span class="line">    runway := c.runway.Load()</span><br><span class="line">    <span class="keyword">if</span> runway &gt; goal &#123;</span><br><span class="line">        <span class="comment">// 容错空间比目标heap大</span></span><br><span class="line">        <span class="comment">// 取最小目标heap大小</span></span><br><span class="line">        trigger = minTrigger</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 容错空间比目标heap小</span></span><br><span class="line">        <span class="comment">// 取剩余量</span></span><br><span class="line">        trigger = goal - runway</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最小为minTrigger</span></span><br><span class="line">    trigger = max(trigger, minTrigger)</span><br><span class="line">    <span class="comment">// 最大为maxTrigger</span></span><br><span class="line">    trigger = min(trigger, maxTrigger)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可能</span></span><br><span class="line">    <span class="keyword">if</span> trigger &gt; goal &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;trigger=&quot;</span>, trigger, <span class="string">&quot; heapGoal=&quot;</span>, goal, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;minTrigger=&quot;</span>, minTrigger, <span class="string">&quot; maxTrigger=&quot;</span>, maxTrigger, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;produced a trigger greater than the heap goal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trigger, goal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置相关字段，计算不同模式的标记工作线程目标，设置最大标记工作线程数，计算辅助GC的工作量转换参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> startCycle(markStartTime <span class="type">int64</span>, procs <span class="type">int</span>, trigger gcTrigger) &#123;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    c.heapScanWork.Store(<span class="number">0</span>)</span><br><span class="line">    c.stackScanWork.Store(<span class="number">0</span>)</span><br><span class="line">    c.globalsScanWork.Store(<span class="number">0</span>)</span><br><span class="line">    c.bgScanCredit.Store(<span class="number">0</span>)</span><br><span class="line">    c.assistTime.Store(<span class="number">0</span>)</span><br><span class="line">    c.dedicatedMarkTime.Store(<span class="number">0</span>)</span><br><span class="line">    c.fractionalMarkTime.Store(<span class="number">0</span>)</span><br><span class="line">    c.idleMarkTime.Store(<span class="number">0</span>)</span><br><span class="line">    c.markStartTime = markStartTime <span class="comment">// 开始时间</span></span><br><span class="line">    c.triggered = c.heapLive.Load() <span class="comment">// heap存活字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC设置25%的CPU使用率（GOGC=100时）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用率目标 =procs*0.25（假设为6核处理器，则结果为1.5）</span></span><br><span class="line">    totalUtilizationGoal := <span class="type">float64</span>(procs) * gcBackgroundUtilization</span><br><span class="line">    <span class="comment">// 四舍五入（假设为6核处理器，则结果为2）</span></span><br><span class="line">    dedicatedMarkWorkersNeeded := <span class="type">int64</span>(totalUtilizationGoal + <span class="number">0.5</span>)</span><br><span class="line">    <span class="comment">// （假设为6核处理器，则结果为0.333）</span></span><br><span class="line">    utilError := <span class="type">float64</span>(dedicatedMarkWorkersNeeded)/totalUtilizationGoal - <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> maxUtilError = <span class="number">0.3</span></span><br><span class="line">    <span class="comment">// 分数的绝对值超过0.3</span></span><br><span class="line">    <span class="keyword">if</span> utilError &lt; -maxUtilError || utilError &gt; maxUtilError &#123;</span><br><span class="line">        <span class="comment">// 目标值25%，实际超过30%，启动比例标记线程（GOMAXPROCS&lt;=3 or GOMAXPROCS=6时）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">float64</span>(dedicatedMarkWorkersNeeded) &gt; totalUtilizationGoal &#123;</span><br><span class="line">            <span class="comment">// 减少专用标记线程（假设为6核处理器，则结果为1）</span></span><br><span class="line">            dedicatedMarkWorkersNeeded--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// （假设为6核处理器，则结果为=(1.5-1)/6=0.083）</span></span><br><span class="line">        c.fractionalUtilizationGoal = (totalUtilizationGoal - <span class="type">float64</span>(dedicatedMarkWorkersNeeded)) / <span class="type">float64</span>(procs)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分数的绝对值小于等于0.3</span></span><br><span class="line">        <span class="comment">// 设为0</span></span><br><span class="line">        c.fractionalUtilizationGoal = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcstoptheworld默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debug.gcstoptheworld &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// STW时，只需要专用标记线程</span></span><br><span class="line">        dedicatedMarkWorkersNeeded = <span class="type">int64</span>(procs)</span><br><span class="line">        c.fractionalUtilizationGoal = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// 重置时间</span></span><br><span class="line">        p.gcAssistTime = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 比例标记任务耗时</span></span><br><span class="line">        p.gcFractionalMarkTime = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时触发</span></span><br><span class="line">    <span class="keyword">if</span> trigger.kind == gcTriggerTime &#123;</span><br><span class="line">        <span class="comment">// 减少空闲标记线程数量，某些场景下至少有一个专用标记线程</span></span><br><span class="line">        <span class="keyword">if</span> dedicatedMarkWorkersNeeded &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 大于0</span></span><br><span class="line">            <span class="comment">// 设置最大空闲标记线程数，不超过2^31</span></span><br><span class="line">            <span class="comment">// 如果此时idleMarkWorkers=3，那么这个值就是最大值</span></span><br><span class="line">            c.setMaxIdleMarkWorkers(<span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为0</span></span><br><span class="line">            <span class="comment">// 设置最大空闲标记线程数，不超过2^32</span></span><br><span class="line">            c.setMaxIdleMarkWorkers(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// heap触发或手动/强制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置最大空闲标记线程数（假设为6核处理器，则结果为5）</span></span><br><span class="line">        c.setMaxIdleMarkWorkers(<span class="type">int32</span>(procs) - <span class="type">int32</span>(dedicatedMarkWorkersNeeded))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录专用标记线程数量</span></span><br><span class="line">    c.dedicatedMarkWorkersNeeded.Store(dedicatedMarkWorkersNeeded)</span><br><span class="line">    <span class="comment">// 计算辅助GC的工作量转换参数</span></span><br><span class="line">    c.revise()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大空闲标记线程数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> setMaxIdleMarkWorkers(max <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := c.idleMarkWorkers.Load()</span><br><span class="line">        n := <span class="type">int32</span>(old &amp; <span class="type">uint64</span>(^<span class="type">uint32</span>(<span class="number">0</span>)))</span><br><span class="line">        <span class="comment">// 溢出（超过2^31)</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n, <span class="string">&quot; max=&quot;</span>, max, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;negative idle mark workers&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不超过2^31</span></span><br><span class="line">        <span class="built_in">new</span> := <span class="type">uint64</span>(<span class="type">uint32</span>(n)) | (<span class="type">uint64</span>(max) &lt;&lt; <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">if</span> c.idleMarkWorkers.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算辅助GC的工作量转换参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> revise() &#123;</span><br><span class="line">    <span class="comment">// GC参数</span></span><br><span class="line">    gcPercent := c.gcPercent.Load()</span><br><span class="line">    <span class="comment">// GOGC为负数，被禁用，但是用户强制执行GC</span></span><br><span class="line">    <span class="keyword">if</span> gcPercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">        gcPercent = <span class="number">100000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap相关参数</span></span><br><span class="line">    live := c.heapLive.Load() <span class="comment">// heap存活字节数</span></span><br><span class="line">    scan := c.heapScan.Load() <span class="comment">// heap扫描字节数 - 待扫描</span></span><br><span class="line">    <span class="comment">// 已扫描字节数 =heap扫描字节数+栈扫描字节数+bss/data段扫描字节数</span></span><br><span class="line">    work := c.heapScanWork.Load() + c.stackScanWork.Load() + c.globalsScanWork.Load()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）</span></span><br><span class="line">    heapGoal := <span class="type">int64</span>(c.heapGoal())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预期的扫描工作量 =heap扫描字节数+栈扫描字节数+全部模块的bss+data段大小</span></span><br><span class="line">    scanWorkExpected := <span class="type">int64</span>(c.lastHeapScan + c.lastStackScan.Load() + c.globalsScan.Load())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =累计所有的栈字节数</span></span><br><span class="line">    maxStackScan := c.maxStackScan.Load()</span><br><span class="line">    <span class="comment">// 最坏情况下的扫描量 =heap扫描字节数+累计所有的栈字节数+全部模块的bss+data段大小</span></span><br><span class="line">    maxScanWork := <span class="type">int64</span>(scan + maxStackScan + c.globalsScan.Load())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整目标heap大小</span></span><br><span class="line">    <span class="keyword">if</span> work &gt; scanWorkExpected &#123;</span><br><span class="line">        <span class="comment">// 软限制</span></span><br><span class="line">        <span class="comment">// =(heapGoal-triggered)/scanWorkExpected*maxScanWork+triggered</span></span><br><span class="line">        extHeapGoal := <span class="type">int64</span>(<span class="type">float64</span>(heapGoal-<span class="type">int64</span>(c.triggered))/<span class="type">float64</span>(scanWorkExpected)*<span class="type">float64</span>(maxScanWork)) + <span class="type">int64</span>(c.triggered)</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        scanWorkExpected = maxScanWork</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 硬限制</span></span><br><span class="line">        <span class="comment">// 2倍的heapGoal（GOGC=100时）</span></span><br><span class="line">        hardGoal := <span class="type">int64</span>((<span class="number">1.0</span> + <span class="type">float64</span>(gcPercent)/<span class="number">100.0</span>) * <span class="type">float64</span>(heapGoal))</span><br><span class="line">        <span class="comment">// 以硬限制为准</span></span><br><span class="line">        <span class="keyword">if</span> extHeapGoal &gt; hardGoal &#123;</span><br><span class="line">            extHeapGoal = hardGoal</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        heapGoal = extHeapGoal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存活对象已经超过目标heap大小</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">int64</span>(live) &gt; heapGoal &#123;</span><br><span class="line">        <span class="comment">// 放宽，允许超出10%</span></span><br><span class="line">        <span class="keyword">const</span> maxOvershoot = <span class="number">1.1</span></span><br><span class="line">        heapGoal = <span class="type">int64</span>(<span class="type">float64</span>(heapGoal) * maxOvershoot)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        scanWorkExpected = maxScanWork</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余扫描工作量=预计的总扫描工作量-已完成的扫描工作 =&gt; bss+data 或 bss+data+stack</span></span><br><span class="line">    scanWorkRemaining := scanWorkExpected - work</span><br><span class="line">    <span class="comment">// 最低为1000</span></span><br><span class="line">    <span class="keyword">if</span> scanWorkRemaining &lt; <span class="number">1000</span> &#123;</span><br><span class="line">        scanWorkRemaining = <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余heap空间 =&gt; heapGoal-heap存活字节数</span></span><br><span class="line">    heapRemaining := heapGoal - <span class="type">int64</span>(live)</span><br><span class="line">    <span class="keyword">if</span> heapRemaining &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 不应该发生，为防止除以0，设置为1</span></span><br><span class="line">        heapRemaining = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每分配1字节需要辅助完成多少GC工作量</span></span><br><span class="line">    assistWorkPerByte := <span class="type">float64</span>(scanWorkRemaining) / <span class="type">float64</span>(heapRemaining)</span><br><span class="line">    <span class="comment">// 每完成1单位GC工作量可以分配多少字节</span></span><br><span class="line">    assistBytesPerWork := <span class="type">float64</span>(heapRemaining) / <span class="type">float64</span>(scanWorkRemaining)</span><br><span class="line">    c.assistWorkPerByte.Store(assistWorkPerByte)</span><br><span class="line">    c.assistBytesPerWork.Store(assistBytesPerWork)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算目标heap大小和并发标记进度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> endCycle(now <span class="type">int64</span>, procs <span class="type">int</span>, userForced <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）</span></span><br><span class="line">    gcController.lastHeapGoal = c.heapGoal()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记阶段耗时</span></span><br><span class="line">    assistDuration := now - c.markStartTime</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC利用率 =0.25</span></span><br><span class="line">    utilization := gcBackgroundUtilization</span><br><span class="line">    <span class="comment">// 防止除以0</span></span><br><span class="line">    <span class="keyword">if</span> assistDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// += 助攻积分/总耗时</span></span><br><span class="line">        utilization += <span class="type">float64</span>(c.assistTime.Load()) / <span class="type">float64</span>(assistDuration*<span class="type">int64</span>(procs))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap存活字节数 &lt;= GC启动前heap存活字节数</span></span><br><span class="line">    <span class="keyword">if</span> c.heapLive.Load() &lt;= c.triggered &#123;</span><br><span class="line">        <span class="comment">// 不应该发生</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲GC利用率</span></span><br><span class="line">    idleUtilization := <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">if</span> assistDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// =闲标记耗时/总耗时</span></span><br><span class="line">        idleUtilization = <span class="type">float64</span>(c.idleMarkTime.Load()) / <span class="type">float64</span>(assistDuration*<span class="type">int64</span>(procs))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总扫描字节数 =heap扫描字节数+stack扫描字节数+bss/data扫描字节数</span></span><br><span class="line">    scanWork := c.heapScanWork.Load() + c.stackScanWork.Load() + c.globalsScanWork.Load()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前并发标记进度 =(heap存活字节数-GC启动前heap存活字节数)*(GC利用率+空闲GC利用率)/(总扫描字节数*(1-GC利用率))</span></span><br><span class="line">    currentConsMark := (<span class="type">float64</span>(c.heapLive.Load()-c.triggered) * (utilization + idleUtilization)) /</span><br><span class="line">        (<span class="type">float64</span>(scanWork) * (<span class="number">1</span> - utilization))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// currentConsMark &gt; 1.0 =&gt; GC当前落后于内存分配速度，会启用更激进的GC策略</span></span><br><span class="line">    <span class="comment">// currentConsMark &lt; 1.0 =&gt; GC当前标记进度是健康的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一次并发标记进度</span></span><br><span class="line">    oldConsMark := c.consMark</span><br><span class="line">    c.consMark = currentConsMark</span><br><span class="line">    <span class="comment">// 遍历历史4个consMark，已最大的为准</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c.lastConsMark &#123;</span><br><span class="line">        <span class="keyword">if</span> c.lastConsMark[i] &gt; c.consMark &#123;</span><br><span class="line">            c.consMark = c.lastConsMark[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 丢弃最旧的一个</span></span><br><span class="line">    <span class="built_in">copy</span>(c.lastConsMark[:], c.lastConsMark[<span class="number">1</span>:])</span><br><span class="line">    <span class="comment">// 放到第一个位置</span></span><br><span class="line">    c.lastConsMark[<span class="built_in">len</span>(c.lastConsMark)<span class="number">-1</span>] = currentConsMark</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记终止时，纪录快照，重置heapLive、heapMarked等字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> resetLive(bytesMarked <span class="type">uint64</span>) &#123;</span><br><span class="line">    c.heapMarked = bytesMarked</span><br><span class="line">    c.heapLive.Store(bytesMarked)</span><br><span class="line">    c.heapScan.Store(<span class="type">uint64</span>(c.heapScanWork.Load()))</span><br><span class="line">    c.lastHeapScan = <span class="type">uint64</span>(c.heapScanWork.Load())</span><br><span class="line">    c.lastStackScan.Store(<span class="type">uint64</span>(c.stackScanWork.Load()))</span><br><span class="line">    c.triggered = ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> heapGoal() <span class="type">uint64</span> &#123;</span><br><span class="line">    <span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）、最小目标heap大小</span></span><br><span class="line">    goal, _ := c.heapGoalInternal()</span><br><span class="line">    <span class="keyword">return</span> goal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）、最小目标heap大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> heapGoalInternal() (goal, minTrigger <span class="type">uint64</span>) &#123;</span><br><span class="line">    <span class="comment">// 目标heap大小，可以粗略的认为是2*上一次GC后heap存活字节数</span></span><br><span class="line">    goal = c.gcPercentHeapGoal.Load()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据总内存限制计算目标heap大小，最小为上一次GC后heap存活字节数</span></span><br><span class="line">    <span class="keyword">if</span> newGoal := c.memoryLimitHeapGoal(); newGoal &lt; goal &#123;</span><br><span class="line">        goal = newGoal</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// newGoal &gt;= 目标heap大小</span></span><br><span class="line">        <span class="comment">// 一般情况下，memoryLimit不设置，所以都会走到这里</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清扫阶段已结束为0，否则为heap存活字节数+1MB</span></span><br><span class="line">        sweepDistTrigger := c.sweepDistMinTrigger.Load()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标heap大小 =max(goal,sweepDistTrigger)</span></span><br><span class="line">        <span class="keyword">if</span> sweepDistTrigger &gt; goal &#123;</span><br><span class="line">            goal = sweepDistTrigger</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最小目标heap大小</span></span><br><span class="line">        minTrigger = sweepDistTrigger</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> minRunway = <span class="number">64</span> &lt;&lt; <span class="number">10</span> <span class="comment">// 容错量=64KB</span></span><br><span class="line">        <span class="comment">// GC已启动 and 目标heap大小 &lt; 上一次GC后heap存活字节数+64KB</span></span><br><span class="line">        <span class="keyword">if</span> c.triggered != ^<span class="type">uint64</span>(<span class="number">0</span>) &amp;&amp; goal &lt; c.triggered+minRunway &#123;</span><br><span class="line">            goal = c.triggered + minRunway</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// goal介于上一次GC后heap存活字节数和2*上一次GC后heap存活字节数</span></span><br><span class="line">    <span class="comment">// minTrigger为0或heap存活字节数+1MB</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据总内存限制计算目标heap大小，最小为上一次GC后heap存活字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> memoryLimitHeapGoal() <span class="type">uint64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> heapFree, heapAlloc, mappedReady <span class="type">uint64</span></span><br><span class="line">    <span class="comment">// 确认当前内存状态一致、合法</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        heapFree = c.heapFree.load()                         <span class="comment">// heap内存可复用量</span></span><br><span class="line">        heapAlloc = c.totalAlloc.Load() - c.totalFree.Load() <span class="comment">// 累计已分配字节数-累计回收量</span></span><br><span class="line">        mappedReady = c.mappedReady.Load()                   <span class="comment">// 已映射且可用的内存量（总内存）</span></span><br><span class="line">        <span class="keyword">if</span> heapFree+heapAlloc &lt;= mappedReady &#123;</span><br><span class="line">            <span class="comment">// 一切正常</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不可能发生，因为部份更新的缘故，需要重试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总内存限制 = heap+nonHeap</span></span><br><span class="line">    memoryLimit := <span class="type">uint64</span>(c.memoryLimit.Load())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非heap内存 =总内存-heap内存可复用量-累计已分配字节数</span></span><br><span class="line">    nonHeapMemory := mappedReady - heapFree - heapAlloc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> overage <span class="type">uint64</span></span><br><span class="line">    <span class="comment">// 总内存超过限制</span></span><br><span class="line">    <span class="keyword">if</span> mappedReady &gt; memoryLimit &#123;</span><br><span class="line">        <span class="comment">// 超出部份</span></span><br><span class="line">        overage = mappedReady - memoryLimit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非heap内存+内存超出部份 &gt;= memoryLimit</span></span><br><span class="line">    <span class="keyword">if</span> nonHeapMemory+overage &gt;= memoryLimit &#123;</span><br><span class="line">        <span class="comment">// 上一次GC后heap存活字节数 =&gt; 立即回收</span></span><br><span class="line">        <span class="keyword">return</span> c.heapMarked</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 距离内存限制剩余量</span></span><br><span class="line">    goal := memoryLimit - (nonHeapMemory + overage)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容错空间 =3%的goal，最低为1MB</span></span><br><span class="line">    headroom := goal / <span class="number">100</span> * memoryLimitHeapGoalHeadroomPercent</span><br><span class="line">    <span class="keyword">if</span> headroom &lt; memoryLimitMinHeapGoalHeadroom &#123;</span><br><span class="line">        headroom = memoryLimitMinHeapGoalHeadroom</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;容错空间 or &lt;2倍的容错空间</span></span><br><span class="line">    <span class="keyword">if</span> goal &lt; headroom || goal-headroom &lt; headroom &#123;</span><br><span class="line">        goal = headroom</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        goal = goal - headroom</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// goal &gt;= headroom</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低为上一次GC后heap存活字节数</span></span><br><span class="line">    <span class="keyword">if</span> goal &lt; c.heapMarked &#123;</span><br><span class="line">        goal = c.heapMarked</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> goal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累计标记耗时、复原计数器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> markWorkerStop(mode gcMarkWorkerMode, duration <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> mode &#123;</span><br><span class="line">    <span class="keyword">case</span> gcMarkWorkerDedicatedMode:  <span class="comment">// 专用标记任务</span></span><br><span class="line">        <span class="comment">// 累计标记耗时</span></span><br><span class="line">        c.dedicatedMarkTime.Add(duration)</span><br><span class="line">        <span class="comment">// 重置，启动worker时-1，复原时+1</span></span><br><span class="line">        c.dedicatedMarkWorkersNeeded.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">case</span> gcMarkWorkerFractionalMode: <span class="comment">// 比例标记任务</span></span><br><span class="line">        <span class="comment">// 累计标记耗时</span></span><br><span class="line">        c.fractionalMarkTime.Add(duration)</span><br><span class="line">    <span class="keyword">case</span> gcMarkWorkerIdleMode:       <span class="comment">// 空闲标记任务</span></span><br><span class="line">        <span class="comment">// 累计标记耗时</span></span><br><span class="line">        c.idleMarkTime.Add(duration)</span><br><span class="line">        <span class="comment">// idleMarkWorkers计数器减1</span></span><br><span class="line">        c.removeIdleMarkWorker()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        throw(<span class="string">&quot;markWorkerStop: unknown mark worker mode&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累计heap存活字节数，如果GC未启动则累计heap扫描字节数，否则重新计算辅助GC的工作量转换参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> update(dHeapLive, dHeapScan <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> dHeapLive != <span class="number">0</span> &#123;</span><br><span class="line">        live := gcController.heapLive.Add(dHeapLive)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC未启动/停止</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 需要被GC扫描的字节数不为0 =&gt; scan类型</span></span><br><span class="line">        <span class="keyword">if</span> dHeapScan != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 累计到heapScan</span></span><br><span class="line">            gcController.heapScan.Add(dHeapScan)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算辅助GC的工作量转换参数</span></span><br><span class="line">        c.revise()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲标记线程数量是否超过最大限制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> needIdleMarkWorker() <span class="type">bool</span> &#123;</span><br><span class="line">    p := c.idleMarkWorkers.Load()</span><br><span class="line">    <span class="comment">// 低32位，高32位</span></span><br><span class="line">    n, max := <span class="type">int32</span>(p&amp;<span class="type">uint64</span>(^<span class="type">uint32</span>(<span class="number">0</span>))), <span class="type">int32</span>(p&gt;&gt;<span class="number">32</span>)</span><br><span class="line">    <span class="comment">// 空闲标记线程数量是否超过最大限制</span></span><br><span class="line">    <span class="keyword">return</span> n &lt; max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲标记线程数量加1，超过最大限制时失败</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> addIdleMarkWorker() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := c.idleMarkWorkers.Load()</span><br><span class="line">        <span class="comment">// 低32位，高32位</span></span><br><span class="line">        n, max := <span class="type">int32</span>(old&amp;<span class="type">uint64</span>(^<span class="type">uint32</span>(<span class="number">0</span>))), <span class="type">int32</span>(old&gt;&gt;<span class="number">32</span>)</span><br><span class="line">        <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">if</span> n &gt;= max &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n, <span class="string">&quot; max=&quot;</span>, max, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;negative idle mark workers&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器加1</span></span><br><span class="line">        <span class="built_in">new</span> := <span class="type">uint64</span>(<span class="type">uint32</span>(n+<span class="number">1</span>)) | (<span class="type">uint64</span>(max) &lt;&lt; <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">if</span> c.idleMarkWorkers.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 失败，重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idleMarkWorkers计数器减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> removeIdleMarkWorker() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := c.idleMarkWorkers.Load()</span><br><span class="line">        <span class="comment">// 低32位，高32位</span></span><br><span class="line">        n, max := <span class="type">int32</span>(old&amp;<span class="type">uint64</span>(^<span class="type">uint32</span>(<span class="number">0</span>))), <span class="type">int32</span>(old&gt;&gt;<span class="number">32</span>)</span><br><span class="line">        <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">if</span> n<span class="number">-1</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n, <span class="string">&quot; max=&quot;</span>, max, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;negative idle mark workers&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器减1</span></span><br><span class="line">        <span class="built_in">new</span> := <span class="type">uint64</span>(<span class="type">uint32</span>(n<span class="number">-1</span>)) | (<span class="type">uint64</span>(max) &lt;&lt; <span class="number">32</span>)</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">if</span> c.idleMarkWorkers.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 失败，重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要更多的专用标记线程，随机抢占一个p运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> enlistWorker() &#123;</span><br><span class="line">    <span class="comment">// 已经不需要新的空闲标记线程了</span></span><br><span class="line">    <span class="keyword">if</span> c.dedicatedMarkWorkersNeeded.Load() &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要更多的专用标记线程，抢占一个p运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有1个CPU</span></span><br><span class="line">    <span class="keyword">if</span> gomaxprocs &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> || gp.m == <span class="literal">nil</span> || gp.m.p == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p的索引</span></span><br><span class="line">    myID := gp.m.p.ptr().id</span><br><span class="line">    <span class="comment">// 随机挑选一个p抢占</span></span><br><span class="line">    <span class="keyword">for</span> tries := <span class="number">0</span>; tries &lt; <span class="number">5</span>; tries++ &#123;</span><br><span class="line">        id := <span class="type">int32</span>(cheaprandn(<span class="type">uint32</span>(gomaxprocs - <span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">if</span> id &gt;= myID &#123;</span><br><span class="line">            id++</span><br><span class="line">        &#125;</span><br><span class="line">        p := allp[id]</span><br><span class="line">        <span class="comment">// 运行中，重试</span></span><br><span class="line">        <span class="keyword">if</span> p.status != _Prunning &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置g、p抢占标志、发送抢占信号给m</span></span><br><span class="line">        <span class="keyword">if</span> preemptone(p) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从gcBgMarkWorkerPool获取一个g，符合条件则返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> findRunnableGCWorker(pp *p, now <span class="type">int64</span>) (*g, <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// GC未启动/停止</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcControllerState.findRunnable: blackening not enabled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 耗时超过10ms则需要更新</span></span><br><span class="line">    <span class="keyword">if</span> gcCPULimiter.needUpdate(now) &#123;</span><br><span class="line">        <span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">        gcCPULimiter.update(now)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）</span></span><br><span class="line">    <span class="keyword">if</span> !gcMarkWorkAvailable(pp) &#123;</span><br><span class="line">        <span class="comment">// 没有任务可执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要新的专用标记线程以及比例标记线程</span></span><br><span class="line">    <span class="keyword">if</span> c.dedicatedMarkWorkersNeeded.Load() &lt;= <span class="number">0</span> &amp;&amp; c.fractionalUtilizationGoal == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 返回nil</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从gcBgMarkWorkerPool拿一个g</span></span><br><span class="line">    node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">    <span class="comment">// 没有数据</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v&gt;0时，减1</span></span><br><span class="line">    decIfPositive := <span class="function"><span class="keyword">func</span><span class="params">(val *atomic.Int64)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            v := val.Load()</span><br><span class="line">            <span class="keyword">if</span> v &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> val.CompareAndSwap(v, v<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动标记线程，dedicatedMarkWorkersNeeded-=1，线程退出时会加回来</span></span><br><span class="line">    <span class="keyword">if</span> decIfPositive(&amp;c.dedicatedMarkWorkersNeeded) &#123;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 专用标记任务</span></span><br><span class="line">        pp.gcMarkWorkerMode = gcMarkWorkerDedicatedMode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.fractionalUtilizationGoal == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 比例标记任务利用率目标为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放回池子</span></span><br><span class="line">        gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 比例标记任务利用率目标不为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记阶段耗时</span></span><br><span class="line">        delta := now - c.markStartTime</span><br><span class="line">        <span class="comment">// 比例标记任务下的标记耗时/总耗时 &gt; 比例标记任务利用率目标</span></span><br><span class="line">        <span class="keyword">if</span> delta &gt; <span class="number">0</span> &amp;&amp; <span class="type">float64</span>(pp.gcFractionalMarkTime)/<span class="type">float64</span>(delta) &gt; c.fractionalUtilizationGoal &#123;</span><br><span class="line">            <span class="comment">// 超过比例标记任务利用率目标</span></span><br><span class="line">            <span class="comment">// g放回池子</span></span><br><span class="line">            gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有超过比例标记任务利用率目标</span></span><br><span class="line">        <span class="comment">// 启动一个比例标记线程</span></span><br><span class="line">        pp.gcMarkWorkerMode = gcMarkWorkerFractionalMode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    gp := node.gp.ptr()</span><br><span class="line">    <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gp, now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcCPULimiterState-CPU限制器"><a href="#gcCPULimiterState-CPU限制器" class="headerlink" title="gcCPULimiterState-CPU限制器"></a>gcCPULimiterState-CPU限制器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// enabled为true =&gt; 限制GC运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> limiting() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> l.enabled.Load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时超过10ms则需要更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> needUpdate(now <span class="type">int64</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// now-lastUpdate &gt; 10e6 </span></span><br><span class="line">    <span class="keyword">return</span> now-l.lastUpdate.Load() &gt; gcCPULimiterUpdatePeriod</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步gcEnabled、标记当前处于过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> startGCTransition(enableGC <span class="type">bool</span>, now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 原子更新lock，0-&gt;1</span></span><br><span class="line">    <span class="keyword">if</span> !l.tryLock() &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        throw(<span class="string">&quot;failed to acquire lock to start a GC transition&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跟传入的参数一样，状态没有发生变更</span></span><br><span class="line">    <span class="keyword">if</span> l.gcEnabled == enableGC &#123;</span><br><span class="line">        throw(<span class="string">&quot;transitioning GC to the same state as before?&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行</span></span><br><span class="line">    l.updateLocked(now)</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    l.gcEnabled = enableGC</span><br><span class="line">    <span class="comment">// 标记当前处于过渡状态</span></span><br><span class="line">    l.transitioning = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> finishGCTransition(now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 状态不对，处于非过渡状态</span></span><br><span class="line">    <span class="keyword">if</span> !l.transitioning &#123;</span><br><span class="line">        throw(<span class="string">&quot;finishGCTransition called without starting one?&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 纪录耗时</span></span><br><span class="line">    <span class="keyword">if</span> lastUpdate := l.lastUpdate.Load(); now &gt;= lastUpdate &#123;</span><br><span class="line">        <span class="comment">// 根据mutator耗时跟gc耗时判断是否需要限制GC运行</span></span><br><span class="line">        l.accumulate(<span class="number">0</span>, (now-lastUpdate)*<span class="type">int64</span>(l.nprocs))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步now</span></span><br><span class="line">    l.lastUpdate.Store(now)</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    l.transitioning = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    l.unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> update(now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 原子更新lock，0-&gt;1</span></span><br><span class="line">    <span class="keyword">if</span> !l.tryLock() &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常，处于过渡状态中，已经在调整了</span></span><br><span class="line">    <span class="keyword">if</span> l.transitioning &#123;</span><br><span class="line">        throw(<span class="string">&quot;update during transition&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行</span></span><br><span class="line">    l.updateLocked(now)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    l.unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> updateLocked(now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 上一次update时的now参数</span></span><br><span class="line">    lastUpdate := l.lastUpdate.Load()</span><br><span class="line">    <span class="comment">// 过期不处理</span></span><br><span class="line">    <span class="keyword">if</span> now &lt; lastUpdate &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU总耗时</span></span><br><span class="line">    windowTotalTime := (now - lastUpdate) * <span class="type">int64</span>(l.nprocs)</span><br><span class="line">    <span class="comment">// 纪录now</span></span><br><span class="line">    l.lastUpdate.Store(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将助攻积分清0</span></span><br><span class="line">    assistTime := l.assistTimePool.Load()</span><br><span class="line">    <span class="keyword">if</span> assistTime != <span class="number">0</span> &#123;</span><br><span class="line">        l.assistTimePool.Add(-assistTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将p的空闲辅助标记耗时清0</span></span><br><span class="line">    idleTime := l.idleTimePool.Load()</span><br><span class="line">    <span class="keyword">if</span> idleTime != <span class="number">0</span> &#123;</span><br><span class="line">        l.idleTimePool.Add(-idleTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非测试</span></span><br><span class="line">    <span class="keyword">if</span> !l.test &#123;</span><br><span class="line">        <span class="comment">// 禁止抢占</span></span><br><span class="line">        mp := acquirem()</span><br><span class="line">        <span class="comment">// 遍历所有p</span></span><br><span class="line">        <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            typ, duration := pp.limiterEvent.consume(now)</span><br><span class="line">            <span class="keyword">switch</span> typ &#123;</span><br><span class="line">            <span class="keyword">case</span> limiterEventIdleMarkWork:   <span class="comment">// 空闲辅助标记</span></span><br><span class="line">                <span class="keyword">fallthrough</span></span><br><span class="line">            <span class="keyword">case</span> limiterEventIdle:           <span class="comment">// 空闲</span></span><br><span class="line">                idleTime += duration</span><br><span class="line">                sched.idleTime.Add(duration)</span><br><span class="line">            <span class="keyword">case</span> limiterEventMarkAssist:     <span class="comment">// 辅助标记</span></span><br><span class="line">                <span class="keyword">fallthrough</span></span><br><span class="line">            <span class="keyword">case</span> limiterEventScavengeAssist: <span class="comment">// 辅助回收</span></span><br><span class="line">                assistTime += duration</span><br><span class="line">            <span class="keyword">case</span> limiterEventNone:           <span class="comment">// 无</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                throw(<span class="string">&quot;invalid limiter event type found&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        releasem(mp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 助攻积分 =&gt; 花费在GC上的时间</span></span><br><span class="line">    windowGCTime := assistTime</span><br><span class="line">    <span class="comment">// 还在标记阶段</span></span><br><span class="line">    <span class="keyword">if</span> l.gcEnabled &#123;</span><br><span class="line">        <span class="comment">// =助攻积分+25%的总耗时</span></span><br><span class="line">        windowGCTime += <span class="type">int64</span>(<span class="type">float64</span>(windowTotalTime) * gcBackgroundUtilization)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 总耗时-=p空闲辅助标记耗时</span></span><br><span class="line">    windowTotalTime -= idleTime</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据mutator耗时跟gc耗时判断是否需要限制GC运行</span></span><br><span class="line">    <span class="comment">// 总耗时-助攻积分（耗时） =&gt; 剩下的就是非GC耗时，助攻积分（GC耗时）</span></span><br><span class="line">    l.accumulate(windowTotalTime-windowGCTime, windowGCTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据mutator耗时跟gc耗时判断是否需要限制GC运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> accumulate(mutatorTime, gcTime <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 整个逻辑有点像TCP的慢启动、拥塞避免</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统发放的额度，范围：[0,fill]</span></span><br><span class="line">    headroom := l.bucket.capacity - l.bucket.fill</span><br><span class="line">    <span class="comment">// fill==capacity =&gt; 额度为0</span></span><br><span class="line">    enabled := headroom == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欠债=gc耗时-mutator耗时</span></span><br><span class="line">    change := gcTime - mutatorTime</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gc耗时超过mutator耗时 and 额度不足</span></span><br><span class="line">    <span class="keyword">if</span> change &gt; <span class="number">0</span> &amp;&amp; headroom &lt;= <span class="type">uint64</span>(change) &#123;</span><br><span class="line">        <span class="comment">// 超额累计到overflow</span></span><br><span class="line">        l.overflow += <span class="type">uint64</span>(change) - headroom</span><br><span class="line">        <span class="comment">// 水桶满了</span></span><br><span class="line">        l.bucket.fill = l.bucket.capacity</span><br><span class="line">        <span class="comment">// 以前没限速过</span></span><br><span class="line">        <span class="keyword">if</span> !enabled &#123;</span><br><span class="line">            <span class="comment">// 开启限速 </span></span><br><span class="line">            l.enabled.Store(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// 记录限速开始的GC轮次</span></span><br><span class="line">            l.lastEnabledCycle.Store(memstats.numgc + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gc耗时小于或等于mutator耗时（回收额度） or 额度足够</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止fill小于0</span></span><br><span class="line">    <span class="keyword">if</span> change &lt; <span class="number">0</span> &amp;&amp; l.bucket.fill &lt;= <span class="type">uint64</span>(-change) &#123;</span><br><span class="line">        <span class="comment">// 直接清0</span></span><br><span class="line">        l.bucket.fill = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 继续释放额度</span></span><br><span class="line">        l.bucket.fill -= <span class="type">uint64</span>(-change)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前是限速状态</span></span><br><span class="line">    <span class="keyword">if</span> change != <span class="number">0</span> &amp;&amp; enabled &#123;</span><br><span class="line">        <span class="comment">// 取消限速</span></span><br><span class="line">        l.enabled.Store(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GMP调度相关"><a href="#GMP调度相关" class="headerlink" title="GMP调度相关"></a>GMP调度相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发起GC时，已经有其他G运行（同一个周期），挂起等待（_GCmarktermination时唤醒）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcWaitOnMark</span><span class="params">(n <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock(&amp;work.sweepWaiters.lock)</span><br><span class="line">        <span class="comment">// 正在执行的周期</span></span><br><span class="line">        nMarks := work.cycles.Load()</span><br><span class="line">        <span class="comment">// GC还没发起</span></span><br><span class="line">        <span class="keyword">if</span> gcphase != _GCmark &#123;</span><br><span class="line">            <span class="comment">// 预判下一个周期</span></span><br><span class="line">            nMarks++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否是同一个周期</span></span><br><span class="line">        <span class="keyword">if</span> nMarks &gt; n &#123;</span><br><span class="line">            <span class="comment">// 可以继续执行</span></span><br><span class="line">            unlock(&amp;work.sweepWaiters.lock)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个周期</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把g放到链表</span></span><br><span class="line">        work.sweepWaiters.list.push(getg())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前g让出CPU，g0执行调度运行其他g</span></span><br><span class="line">        <span class="comment">// 在内部g、m解除绑定后会解锁sweepWaiters.lock</span></span><br><span class="line">        goparkunlock(&amp;work.sweepWaiters.lock, waitReasonWaitForGCCycle, traceBlockUntilGCEnds, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步标记，如果允许user类型g运行则把阻塞的g全部放回全局队列并尝试获取p绑定m唤醒运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedEnableUser</span><span class="params">(enable <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 已经设置了</span></span><br><span class="line">    <span class="keyword">if</span> sched.disable.user == !enable &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    sched.disable.user = !enable</span><br><span class="line">    <span class="comment">// 如果是允许user类型g运行</span></span><br><span class="line">    <span class="keyword">if</span> enable &#123;</span><br><span class="line">        <span class="comment">// g数量</span></span><br><span class="line">        n := sched.disable.n</span><br><span class="line">        sched.disable.n = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 把一批g放到全局队列</span></span><br><span class="line">        globrunqputbatch(&amp;sched.disable.runnable, n)</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 如果g数量不为0 and 空闲p数量也不为0</span></span><br><span class="line">        <span class="keyword">for</span> ; n != <span class="number">0</span> &amp;&amp; sched.npidle.Load() != <span class="number">0</span>; n-- &#123;</span><br><span class="line">             <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">            startm(<span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新p、调度器状态，把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcstopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态不一致</span></span><br><span class="line">    <span class="keyword">if</span> !sched.gcwaiting.Load() &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcstopm: not waiting for gc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m自旋中</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.spinning &#123;</span><br><span class="line">        <span class="comment">// 重置spinning</span></span><br><span class="line">        gp.m.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 复原，nmspinning-=1</span></span><br><span class="line">        <span class="keyword">if</span> sched.nmspinning.Add(<span class="number">-1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 小于0，异常</span></span><br><span class="line">            throw(<span class="string">&quot;gcstopm: negative nmspinning&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">    pp := releasep()</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// p的状态设置为_Pgcstop</span></span><br><span class="line">    pp.status = _Pgcstop</span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    pp.gcStopTime = nanotime()</span><br><span class="line">    <span class="comment">// 计数器stopwait-=1</span></span><br><span class="line">    sched.stopwait--</span><br><span class="line">    <span class="comment">// 所有的p都放到空闲队列了</span></span><br><span class="line">    <span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒GC相关的m（m放在stopnote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.stopnote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">    stopm()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列为空时执行netpoll轮询，检查有g返回true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pollWork</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    p := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// 本地队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> !runqempty(p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// netpoll已初始化 and 挂起的g数量不为0 and 当前没有进行轮询</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; netpollAnyWaiters() &amp;&amp; sched.lastpoll.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 平台相关</span></span><br><span class="line">        <span class="comment">// 执行epollWait检查，0-没有数据立即返回</span></span><br><span class="line">        <span class="keyword">if</span> list, delta := netpoll(<span class="number">0</span>); !list.empty() &#123;</span><br><span class="line">            <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">            netpollAdjustWaiters(delta)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断标记工作线程是否需要自我抢占，超过目标值返回true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pollFractionalWorkerExit</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 当前周期GC耗时</span></span><br><span class="line">    delta := now - gcController.markStartTime</span><br><span class="line">    <span class="comment">// 防御性编程</span></span><br><span class="line">    <span class="keyword">if</span> delta &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    p := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// 比例标记线程会多次启动、暂停，gcFractionalMarkTime是历史累计，gcMarkWorkerStartTime是当前运行耗时，相当于最后一次纪录</span></span><br><span class="line">    <span class="comment">// 当前周期内的总耗时=比例标记任务下的耗时+当前比例标记线程的耗时</span></span><br><span class="line">    selfTime := p.gcFractionalMarkTime + (now - p.gcMarkWorkerStartTime)</span><br><span class="line">    <span class="comment">// 当前周期内的总耗时/当前周期GC耗时 &gt; 1.2*比例标记任务利用率目标 =&gt; 比例标记任务的CPU使用率是否超过目标值的1.2倍</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(selfTime)/<span class="type">float64</span>(delta) &gt; <span class="number">1.2</span>*gcController.fractionalUtilizationGoal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据额度唤醒一批g，额度有剩余就累计到全局额度bgScanCredit（与gcParkAssist成对使用）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcFlushBgCredit</span><span class="params">(scanWork <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// assist队列为空</span></span><br><span class="line">    <span class="keyword">if</span> work.assistQueue.q.empty() &#123;</span><br><span class="line">        <span class="comment">// 额度累计到全局bgScanCredit</span></span><br><span class="line">        gcController.bgScanCredit.Add(scanWork)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换参数</span></span><br><span class="line">    assistBytesPerWork := gcController.assistBytesPerWork.Load()</span><br><span class="line">    <span class="comment">// 额度转换为字节数</span></span><br><span class="line">    scanBytes := <span class="type">int64</span>(<span class="type">float64</span>(scanWork) * assistBytesPerWork)</span><br><span class="line"></span><br><span class="line">    lock(&amp;work.assistQueue.lock)</span><br><span class="line">    <span class="comment">// assist队列不为空 and 额度大于0</span></span><br><span class="line">    <span class="keyword">for</span> !work.assistQueue.q.empty() &amp;&amp; scanBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 拿走队列第一个g</span></span><br><span class="line">        gp := work.assistQueue.q.pop()</span><br><span class="line">        <span class="comment">// &gt;=0 =&gt; 额度为正，不欠债</span></span><br><span class="line">        <span class="keyword">if</span> scanBytes+gp.gcAssistBytes &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// g的欠债，字节数</span></span><br><span class="line">            scanBytes += gp.gcAssistBytes</span><br><span class="line">            <span class="comment">// 重置，不欠债</span></span><br><span class="line">            gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 将g放到p.runq队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">            <span class="comment">// 放到队列尾部，降低优先级。这个g是gcParkAssist导致挂起的</span></span><br><span class="line">            ready(gp, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 额度还有数据，继续找下一个g</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &lt;0，g还是欠债状态</span></span><br><span class="line">            <span class="comment">// 更新g的额度</span></span><br><span class="line">            gp.gcAssistBytes += scanBytes</span><br><span class="line">            <span class="comment">// 额度用完了</span></span><br><span class="line">            scanBytes = <span class="number">0</span></span><br><span class="line">            <span class="comment">// g放回队列，继续挂起等待</span></span><br><span class="line">            work.assistQueue.q.pushBack(gp)</span><br><span class="line">            <span class="comment">// 额度用完了，剩下的g也不用处理了，退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要么队列为空 or 要么额度不足</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 额度还有，那就是队列为空</span></span><br><span class="line">    <span class="keyword">if</span> scanBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 转换参数</span></span><br><span class="line">        assistWorkPerByte := gcController.assistWorkPerByte.Load()</span><br><span class="line">        <span class="comment">// 字节转换成额度</span></span><br><span class="line">        scanWork = <span class="type">int64</span>(<span class="type">float64</span>(scanBytes) * assistWorkPerByte)</span><br><span class="line">        <span class="comment">// 剩余的额度累计到全局bgScanCredit</span></span><br><span class="line">        gcController.bgScanCredit.Add(scanWork)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;work.assistQueue.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈相关"><a href="#栈相关" class="headerlink" title="栈相关"></a>栈相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackfree</span><span class="params">(stk stack)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// stk.lo</span></span><br><span class="line">    v := unsafe.Pointer(stk.lo)</span><br><span class="line">    <span class="comment">// 栈空间大小</span></span><br><span class="line">    n := stk.hi - stk.lo</span><br><span class="line">    <span class="comment">// 非2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> n&amp;(n<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;stack not a power of 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> stk.lo+n &lt; stk.hi &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad stack size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;stackfree&quot;</span>, v, n)</span><br><span class="line">        memclrNoHeapPointers(v, n) <span class="comment">// for testing, clobber stack data</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug.efence默认为0、stackFromSystem默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debug.efence != <span class="number">0</span> || stackFromSystem != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> debug.efence != <span class="number">0</span> || stackFaultOnFree != <span class="number">0</span> &#123;</span><br><span class="line">            sysFault(v, n)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sysFree(v, n, &amp;memstats.stacks_sys)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n &lt; 2KB*2^4 and n &lt; 32KB（一样的条件）</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; fixedStack&lt;&lt;_NumStackOrders &amp;&amp; n &lt; _StackCacheSize &#123;</span><br><span class="line">        <span class="comment">// order索引，linux下有4个层级</span></span><br><span class="line">        order := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">        n2 := n</span><br><span class="line">        <span class="comment">// &gt;2KB</span></span><br><span class="line">        <span class="keyword">for</span> n2 &gt; fixedStack &#123;</span><br><span class="line">            order++</span><br><span class="line">            n2 &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// stk.lo</span></span><br><span class="line">        x := gclinkptr(v)</span><br><span class="line">        <span class="comment">// stackNoCache默认为0 or 没有p or 禁止抢占</span></span><br><span class="line">        <span class="keyword">if</span> stackNoCache != <span class="number">0</span> || gp.m.p == <span class="number">0</span> || gp.m.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            lock(&amp;stackpool[order].item.mu)</span><br><span class="line">            <span class="comment">// 纪录mspan到stackpool、栈放回mspan.manualFreeList，符合条件则将mspan释放回系统</span></span><br><span class="line">            stackpoolfree(x, order)</span><br><span class="line">            unlock(&amp;stackpool[order].item.mu)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有p and 可抢占</span></span><br><span class="line">            c := gp.m.p.ptr().mcache</span><br><span class="line">            <span class="comment">// &gt;= 32KB</span></span><br><span class="line">            <span class="keyword">if</span> c.stackcache[order].size &gt;= _StackCacheSize &#123;</span><br><span class="line">                <span class="comment">// 将一半的数据使用stackpoolfree释放</span></span><br><span class="line">                stackcacherelease(c, order)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 放回stackcache</span></span><br><span class="line">            x.ptr().next = c.stackcache[order].list</span><br><span class="line">            c.stackcache[order].list = x</span><br><span class="line">            c.stackcache[order].size += n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// n &gt;= 32KB</span></span><br><span class="line">        <span class="comment">// 根据地址找到heapArena再找到mspan</span></span><br><span class="line">        s := spanOfUnchecked(<span class="type">uintptr</span>(v))</span><br><span class="line">        <span class="comment">// 非手动管理，异常</span></span><br><span class="line">        <span class="keyword">if</span> s.state.get() != mSpanManual &#123;</span><br><span class="line">            <span class="built_in">println</span>(hex(s.base()), v)</span><br><span class="line">            throw(<span class="string">&quot;bad span state&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> gcphase == _GCoff &#123;</span><br><span class="line">            <span class="comment">// 清理阶段</span></span><br><span class="line">            <span class="comment">// 释放栈</span></span><br><span class="line">            osStackFree(s)</span><br><span class="line">            mheap_.freeManual(s, spanAllocStack)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// GC运行中</span></span><br><span class="line">            <span class="comment">// mspan可能被重用，状态修改可能跟GC冲突，直接放到stackLarge即可</span></span><br><span class="line">            log2npage := stacklog2(s.npages)</span><br><span class="line">            lock(&amp;stackLarge.lock)</span><br><span class="line">            stackLarge.free[log2npage].insert(s)</span><br><span class="line">            unlock(&amp;stackLarge.lock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描栈帧内指针、defer链、panic、state.buf队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanstack</span><span class="params">(gp *g, gcw *gcWork)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 判断g的状态是不是_Gscanrunnable、_Gscansyscall、_Gscanwaiting</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有_Gscan标志，异常</span></span><br><span class="line">    <span class="keyword">if</span> readgstatus(gp)&amp;_Gscan == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime:scanstack: gp=&quot;</span>, gp, <span class="string">&quot;, goid=&quot;</span>, gp.goid, <span class="string">&quot;, gp-&gt;atomicstatus=&quot;</span>, hex(readgstatus(gp)), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;scanstack - bad status&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消_Gscan标志后检查</span></span><br><span class="line">    <span class="keyword">switch</span> readgstatus(gp) &amp;^ _Gscan &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: gp=&quot;</span>, gp, <span class="string">&quot;, goid=&quot;</span>, gp.goid, <span class="string">&quot;, gp-&gt;atomicstatus=&quot;</span>, readgstatus(gp), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;mark - bad status&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _Gdead:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> _Grunning:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: gp=&quot;</span>, gp, <span class="string">&quot;, goid=&quot;</span>, gp.goid, <span class="string">&quot;, gp-&gt;atomicstatus=&quot;</span>, readgstatus(gp), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;scanstack: goroutine not stopped&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _Grunnable, _Gsyscall, _Gwaiting:</span><br><span class="line">        <span class="comment">// 目标状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g0执行</span></span><br><span class="line">    <span class="keyword">if</span> gp == getg() &#123;</span><br><span class="line">        throw(<span class="string">&quot;can&#x27;t scan our own stack&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈指针</span></span><br><span class="line">    <span class="keyword">var</span> sp <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallsp != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 处于系统调用</span></span><br><span class="line">        sp = gp.syscallsp</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一般情况下</span></span><br><span class="line">        sp = gp.sched.sp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已使用栈大小</span></span><br><span class="line">    scannedSize := gp.stack.hi - sp</span><br><span class="line"></span><br><span class="line">    p := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// 累计扫描栈大小</span></span><br><span class="line">    p.scannedStackSize += <span class="type">uint64</span>(scannedSize)</span><br><span class="line">    <span class="comment">// 累计扫描栈数量</span></span><br><span class="line">    p.scannedStacks++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否允许栈缩小</span></span><br><span class="line">    <span class="keyword">if</span> isShrinkStackSafe(gp) &#123;</span><br><span class="line">        <span class="comment">// 缩小栈（暂不深入研究）</span></span><br><span class="line">        shrinkstack(gp)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不允许缩小：g处于系统调用、异步安全点、挂起在channel、tracing开启并在等待用于GC</span></span><br><span class="line">        <span class="comment">// 在下一个同步安全点缩小</span></span><br><span class="line">        gp.preemptShrink = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> state stackScanState</span><br><span class="line">    state.stack = gp.stack</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stackTraceDebug默认false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> stackTraceDebug &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;stack trace goroutine&quot;</span>, gp.goid)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debugScanConservative默认false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugScanConservative &amp;&amp; gp.asyncSafePoint &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;scanning async preempted goroutine &quot;</span>, gp.goid, <span class="string">&quot; stack [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描并保存ctxt寄存器</span></span><br><span class="line">    <span class="keyword">if</span> gp.sched.ctxt != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">        scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;gp.sched.ctxt)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描栈</span></span><br><span class="line">    <span class="keyword">var</span> u unwinder</span><br><span class="line">    <span class="keyword">for</span> u.init(gp, <span class="number">0</span>); u.valid(); u.next() &#123;</span><br><span class="line">        <span class="comment">// （暂不深入研究）</span></span><br><span class="line">        scanframeworker(&amp;u.frame, &amp;state, gcw)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是defer跟panic扫描</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// defer链</span></span><br><span class="line">    <span class="keyword">for</span> d := gp._defer; d != <span class="literal">nil</span>; d = d.link &#123;</span><br><span class="line">        <span class="comment">// 扫描函数值</span></span><br><span class="line">        <span class="keyword">if</span> d.fn != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 放在栈上的闭包函数</span></span><br><span class="line">            <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;d.fn)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可能指向一个heap上分配的defer</span></span><br><span class="line">        <span class="keyword">if</span> d.link != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;d.link)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规方法无法访问的defer</span></span><br><span class="line">        <span class="keyword">if</span> d.heap &#123;</span><br><span class="line">            <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;d)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic</span></span><br><span class="line">    <span class="keyword">if</span> gp._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// panic只会在栈上分配</span></span><br><span class="line">        <span class="comment">// 指针放到state.buf队列</span></span><br><span class="line">        state.putPtr(<span class="type">uintptr</span>(unsafe.Pointer(gp._panic)), <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并扫描所有可达的栈对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造BST树</span></span><br><span class="line">    state.buildIndex()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 返回cbuf数组最后一个元素</span></span><br><span class="line">        p, conservative := state.getPtr()</span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据指针找到对象</span></span><br><span class="line">        obj := state.findObject(p)</span><br><span class="line">        <span class="keyword">if</span> obj == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        r := obj.r</span><br><span class="line">        <span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 已扫描</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// obj.r = nil =&gt; 防止重复扫描</span></span><br><span class="line">        obj.setRecord(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// stackTraceDebug默认false，忽略</span></span><br><span class="line">        <span class="keyword">if</span> stackTraceDebug &#123;</span><br><span class="line">            printlock()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;  live stkobj at&quot;</span>, hex(state.stack.lo+<span class="type">uintptr</span>(obj.off)), <span class="string">&quot;of size&quot;</span>, obj.size)</span><br><span class="line">            <span class="keyword">if</span> conservative &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot; (conservative)&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">println</span>()</span><br><span class="line">            printunlock()</span><br><span class="line">        &#125;</span><br><span class="line">        ptrBytes, gcData := r.gcdata()</span><br><span class="line">        b := state.stack.lo + <span class="type">uintptr</span>(obj.off)</span><br><span class="line">        <span class="keyword">if</span> conservative &#123;</span><br><span class="line">            scanConservative(b, ptrBytes, gcData, gcw, &amp;state)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            scanblock(b, ptrBytes, gcData, gcw, &amp;state)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放对象缓冲区（上一个循环中，指针缓冲区已释放）</span></span><br><span class="line">    <span class="keyword">for</span> state.head != <span class="literal">nil</span> &#123;</span><br><span class="line">        x := state.head</span><br><span class="line">        state.head = x.next</span><br><span class="line">        <span class="comment">// stackTraceDebug默认false，忽略</span></span><br><span class="line">        <span class="keyword">if</span> stackTraceDebug &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; x.nobj; i++ &#123;</span><br><span class="line">                obj := &amp;x.obj[i]</span><br><span class="line">                <span class="keyword">if</span> obj.r == <span class="literal">nil</span> &#123; <span class="comment">// reachable</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;  dead stkobj at&quot;</span>, hex(gp.stack.lo+<span class="type">uintptr</span>(obj.off)), <span class="string">&quot;of size&quot;</span>, obj.r.size)</span><br><span class="line">                <span class="comment">// Note: not necessarily really dead - only reachable-from-ptr dead.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x.nobj = <span class="number">0</span></span><br><span class="line">        <span class="comment">// wbuf放到work.empty</span></span><br><span class="line">        putempty((*workbuf)(unsafe.Pointer(x)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有残留</span></span><br><span class="line">    <span class="keyword">if</span> state.buf != <span class="literal">nil</span> || state.cbuf != <span class="literal">nil</span> || state.freeBuf != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;remaining pointer buffers&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(scannedSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bitmap操作相关"><a href="#bitmap操作相关" class="headerlink" title="bitmap操作相关"></a>bitmap操作相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从gcBitsArenas分配足以容纳nelems个位的内存（64的倍数向上取整）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMarkBits</span><span class="params">(nelems <span class="type">uintptr</span>)</span></span> *gcBits &#123;</span><br><span class="line">    <span class="comment">// 计算需要多少个块</span></span><br><span class="line">    blocksNeeded := (nelems + <span class="number">63</span>) / <span class="number">64</span></span><br><span class="line">    <span class="comment">// 每个块8个字节（64位）</span></span><br><span class="line">    bytesNeeded := blocksNeeded * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前arena</span></span><br><span class="line">    head := (*gcBitsArena)(atomic.Loadp(unsafe.Pointer(&amp;gcBitsArenas.next)))</span><br><span class="line">    <span class="comment">// 尝试从head分配bytesNeeded个字节</span></span><br><span class="line">    <span class="keyword">if</span> p := head.tryAlloc(bytesNeeded); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 分配成功</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配失败，head要么为nil，要么空间不足，新建一个新的arena</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;gcBitsArenas.lock)</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="keyword">if</span> p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 分配成功</span></span><br><span class="line">        unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定空间不足</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从gcBitsArenas申请一个arena，没有则向系统申请64KB大小内存用作新的arena（期间会解锁）</span></span><br><span class="line">    fresh := newArenaMayUnlock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="keyword">if</span> p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 把新的arena放到free链表</span></span><br><span class="line">        fresh.next = gcBitsArenas.free</span><br><span class="line">        gcBitsArenas.free = fresh</span><br><span class="line">        unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从新的arena分配</span></span><br><span class="line">    p := fresh.tryAlloc(bytesNeeded)</span><br><span class="line">    <span class="comment">// 分配失败</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;markBits overflow&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新的arena放到next链表</span></span><br><span class="line">    fresh.next = gcBitsArenas.next</span><br><span class="line">    <span class="comment">// gcBitsArenas.next = fresh</span></span><br><span class="line">    atomic.StorepNoWB(unsafe.Pointer(&amp;gcBitsArenas.next), unsafe.Pointer(fresh))</span><br><span class="line"></span><br><span class="line">    unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从gcBitsArenas申请一个arena，没有则向系统申请64KB大小内存用作新的arena</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newArenaMayUnlock</span><span class="params">()</span></span> *gcBitsArena &#123;</span><br><span class="line">    <span class="keyword">var</span> result *gcBitsArena</span><br><span class="line">    <span class="comment">// free链表没有足够空间</span></span><br><span class="line">    <span class="keyword">if</span> gcBitsArenas.free == <span class="literal">nil</span> &#123;</span><br><span class="line">        unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">        <span class="comment">// 向系统申请64KB大小内存（Reserved），最低64MB，创建arenaHint、heapArena</span></span><br><span class="line">        result = (*gcBitsArena)(sysAlloc(gcBitsChunkBytes, &amp;memstats.gcMiscSys))</span><br><span class="line">        <span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">if</span> result == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: cannot allocate memory&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        lock(&amp;gcBitsArenas.lock)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// free链表还有足够空间</span></span><br><span class="line">        <span class="comment">// 拿走free链表第一个节点</span></span><br><span class="line">        result = gcBitsArenas.free</span><br><span class="line">        gcBitsArenas.free = gcBitsArenas.free.next</span><br><span class="line">        <span class="comment">// 清0</span></span><br><span class="line">        memclrNoHeapPointers(unsafe.Pointer(result), gcBitsChunkBytes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置next指针</span></span><br><span class="line">    result.next = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 偏移量设置8字节对齐</span></span><br><span class="line">    <span class="keyword">if</span> unsafe.Offsetof(gcBitsArena&#123;&#125;.bits)&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">        result.free = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.free = <span class="number">8</span> - (<span class="type">uintptr</span>(unsafe.Pointer(&amp;result.bits[<span class="number">0</span>])) &amp; <span class="number">7</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://betterprogramming.pub/memory-optimization-and-garbage-collector-management-in-go-71da4612a960">Memory Optimization and Garbage Collector Management in Go</a><br><a href="https://tip.golang.org/doc/gc-guide">A Guide to the Go Garbage Collector</a><br><a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976">Go: How Does the Garbage Collector Mark the Memory?</a><br><a href="https://itnext.io/go-does-not-need-a-java-style-gc-ac99b8d26c60">Go Does Not Need a Java Style GC</a><br><a href="https://xargin.com/impl-of-go-gc/">Go 语言的 GC 实现分析</a><br><a href="https://community.apinto.com/d/34057-golang-gc">一文弄懂 Golang GC、三色标记、混合写屏障机制</a><br><a href="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/">Golang垃圾回收(GC)介绍</a><br><a href="https://groups.google.com/g/golang-dev/c/oUFIOm7IMxo">How does go GC identify GC roots</a><br><a href="https://www.quora.com/What-is-a-garbage-collection-GC-root">What is a garbage collection (GC) root?</a><br><a href="https://mp.weixin.qq.com/s/eDd212DhjIRGpytBkgfzAg">关于Golang GC的一些误解–真的比Java算法更领先吗？</a><br><a href="https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%86%99%E5%B1%8F%E9%9A%9C/2020/07/24/gc5.html">golang 垃圾回收（五）混合写屏障</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-singleflight</title>
    <url>/golang-series-sync-singleflight/</url>
    <content><![CDATA[<p>在使用redis&#x2F;memcached缓存系统时，可能会遇到以下三个问题</p>
<ol>
<li>cache penetration(缓存穿透) - 数据既不在cache中也不在db中，可以用布龙过滤器处理</li>
<li>cache avalanche(缓存雪崩) - 同一时刻出现大量的key失效，可以将过期时间随机化或者不设置过期时间</li>
<li>cache breakdown(缓存击穿)&#x2F;cache stampede(缓存踩踏) - 热门的key过期，客户端加锁或者不设置过期时间</li>
</ol>
<p>缓存击穿问题中，客户端加锁使穿行化访问是一个值得考虑的解决方法，可以降低服务器（cache&#x2F;db）的压力。但另一方面，这也会让大量的请求被阻塞，吞吐量下降。实际上，同一时刻的请求可以共享响应数据，这就是singleflight解决的问题</p>
<p>singleflight不是标准库的一部份，但go的internal目录内复制了一份singleflight源码，该源码也是本文在讨论的</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/singleflight&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callCount atomic.Int32</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟db请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    callCount.Add(<span class="number">1</span>)</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="comment">// 返回的数据是随机的</span></span><br><span class="line">    <span class="keyword">return</span> rand.Intn(<span class="number">100</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装fetchData和singleflight</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchDataWrapper</span><span class="params">(g *singleflight.Group, id <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Duration(id) * <span class="number">40</span> * time.Millisecond)</span><br><span class="line">    v, err, shared := g.Do(<span class="string">&quot;key-fetch-data&quot;</span>, fetchData)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Goroutine %d: result: %v, shared: %v\n&quot;</span>, id, v, shared)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> g singleflight.Group</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> numGoroutines = <span class="number">5</span></span><br><span class="line">    wg.Add(numGoroutines)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟：发起5个请求访问db</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGoroutines; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> fetchDataWrapper(&amp;g, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Function was called %d times\n&quot;</span>, callCount.Load())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下，结果是随机的</span></span><br><span class="line"><span class="comment"># Goroutine 1: result: 2, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 0: result: 2, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 2: result: 2, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 3: result: 94, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 4: result: 94, shared: true</span></span><br><span class="line"><span class="comment"># Function was called 2 times</span></span><br></pre></td></tr></table></figure>

<p>可以看到，G0、G1、G2共享result&#x3D;2，G3、G4共享result&#x3D;94</p>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>singleflight数据结构如下所示，其中</p>
<ul>
<li><code>Group</code>  - 由mutex和map组成，本质就是map，因为map不允许并发读写，所以才加了mutex</li>
<li><code>call</code>   - 是响应数据的封装，与请求key关联在一起，因为内部的dup计数器，或许可以将其按上下文来理解</li>
<li><code>Result</code> - 也是响应数据的封装，跟channel搭配使用</li>
</ul>
<p>响应数据的封装方式有两种</p>
<ol>
<li>通过函数返回值返回</li>
<li>通过channel返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/internal/singleflight/singleflight.go</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex           <span class="comment">// 锁，map不能并发读写</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="type">string</span>]*call     <span class="comment">// 关联key跟结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应数据封装</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    val any                    <span class="comment">// 结果值</span></span><br><span class="line">    err <span class="type">error</span>                <span class="comment">// 异常值</span></span><br><span class="line">    dups  <span class="type">int</span>                <span class="comment">// 计数器（等待中的goroutine），同时用来判断是否共享</span></span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    chans []<span class="keyword">chan</span>&lt;- Result    <span class="comment">// 结果值/异常值/是否共享（通过channel传递）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应数据封装，与channel搭配</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val    any                <span class="comment">// 结果值</span></span><br><span class="line">    Err    <span class="type">error</span>            <span class="comment">// 异常值</span></span><br><span class="line">    Shared <span class="type">bool</span>                <span class="comment">// 是否共享</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>核心的方法有Do、DoChan、ForgetUnshared，具体看下面描述</p>
<h3 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h3><p>具体逻辑如下</p>
<ol>
<li>如果key已存在，挂起等待，唤醒后读取响应数据</li>
<li>如果key不存在，为key创建响应数据封装，写入map，然后调用doCall获取响应数据</li>
<li>删除key</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (any, <span class="type">error</span>)) (v any, err <span class="type">error</span>, shared <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 为key与结果创建关联</span></span><br><span class="line"></span><br><span class="line">    g.mu.Lock() <span class="comment">// map不能并发读写，需要加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1. 相同的请求已存在，等待结果返回</span></span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        c.dups++</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        c.wg.Wait()        <span class="comment">// 挂起等待</span></span><br><span class="line">        <span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2. 新请求，创建结果并关联</span></span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 调用函数获取结果</span></span><br><span class="line">    g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> doCall(c *call, key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (any, <span class="type">error</span>)) &#123;</span><br><span class="line">    <span class="comment">// 1. 拿到结果</span></span><br><span class="line">    c.val, c.err = fn()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. map删除该key</span></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    c.wg.Done()</span><br><span class="line">    <span class="keyword">if</span> g.m[key] == c &#123;</span><br><span class="line">        <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是通过channel传递数据</span></span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">        ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DoChan"><a href="#DoChan" class="headerlink" title="DoChan"></a>DoChan</h3><p>具体逻辑同Do，只是响应数据是通过channel传递的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> DoChan(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (any, <span class="type">error</span>)) &lt;-<span class="keyword">chan</span> Result &#123;</span><br><span class="line">    <span class="comment">// 1. 为key与结果创建关联</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置容量，使当前goroutine不阻塞</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    g.mu.Lock() <span class="comment">// map不能并发读写，需要加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1. 相同的请求已存在，等待结果返回</span></span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        c.dups++</span><br><span class="line">        c.chans = <span class="built_in">append</span>(c.chans, ch)</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> ch</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2. 新请求，创建结果并关联</span></span><br><span class="line">    c := &amp;call&#123;chans: []<span class="keyword">chan</span>&lt;- Result&#123;ch&#125;&#125;</span><br><span class="line">    c.wg.Add(<span class="number">1</span>) <span class="comment">// 如果Do和DoChan混用还是需要使用到wg，否则异常</span></span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 调用函数获取结果</span></span><br><span class="line">    <span class="keyword">go</span> g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ForgetUnshared"><a href="#ForgetUnshared" class="headerlink" title="ForgetUnshared"></a>ForgetUnshared</h3><p>删除指定key，如果该key已经有其他goroutine等待，不处理</p>
<p>具体逻辑如下</p>
<ol>
<li>key不存在，返回true</li>
<li>key存在，如果dup等于0，删除并返回true，否则不处理，返回false</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> ForgetUnshared(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// map加锁</span></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">    c, ok := g.m[key]</span><br><span class="line">    <span class="comment">// key不存在</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key存在但没有共享</span></span><br><span class="line">    <span class="keyword">if</span> c.dups == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://victoriametrics.com/blog/go-singleflight/index.html">Go Singleflight Melts in Your Code, Not in Your DB</a><br><a href="https://www.dragonflydb.io/blog/developing-with-dragonfly-part-02-solve-caching-problems">Developing with Dragonfly: Solve Caching Problems</a><br><a href="https://philosophyotaku.medium.com/a-complete-beginner-guide-for-cache-penetration-stampede-avalanche-ecadd7f16009">A Complete Beginner Guide for Cache Penetration, Stampede, and Avalanche</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-sync.Waitgroup</title>
    <url>/golang-series-sync-waitgroup/</url>
    <content><![CDATA[<p>并发情况下，如果需要等待所有的goroutine完成任务，需要使用Waitgroup等待</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>先简单列举一个使用案例，了解Waitgroup的使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d starting\n&quot;</span>, id)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// counter++</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// counter--</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            worker(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码执行后，系统输出如下，可以看到系统等待5个goroutine完成任务后才退出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># Worker 5 starting</span></span><br><span class="line"><span class="comment"># Worker 2 starting</span></span><br><span class="line"><span class="comment"># Worker 1 starting</span></span><br><span class="line"><span class="comment"># Worker 3 starting</span></span><br><span class="line"><span class="comment"># Worker 4 starting</span></span><br><span class="line"><span class="comment"># Worker 4 done</span></span><br><span class="line"><span class="comment"># Worker 5 done</span></span><br><span class="line"><span class="comment"># Worker 2 done</span></span><br><span class="line"><span class="comment"># Worker 3 done</span></span><br><span class="line"><span class="comment"># Worker 1 done</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>Waitgroup的数据结构由noCopy、state、sema三个字段组成，其中state是goroutine、waiter的计数器，sema使waiter陷入等待</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    state atomic.Uint64 <span class="comment">// high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line">    sema  <span class="type">uint32</span>        <span class="comment">// semaphore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>state的高32位：正在运行中的goroutine数量<br>state低低32为：等待中的goroutine数量</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>WaitGroup只提供了Add、Done、Wait三个方法</p>
<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>Add方法的大概逻辑如下</p>
<ol>
<li>counter+&#x3D;delta</li>
<li>counter小于0，数值异常</li>
<li>发现goroutine出现并发调用Add、Wait，异常</li>
<li>有正在运行的goroutine或者没有等待的goroutine，返回（成功）</li>
<li>唤醒所有等待中的goroutine</li>
</ol>
<p>具体源代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) &#123;</span><br><span class="line">    state := wg.state.Add(<span class="type">uint64</span>(delta) &lt;&lt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">// counter：还在运行中的goroutine数量</span></span><br><span class="line">    w := <span class="type">uint32</span>(state)      <span class="comment">// waiter_counter：等待中的goroutine数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// counter不能为负，只能大于等于0</span></span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常，这个场景不好想象，先忽略</span></span><br><span class="line">    <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="type">int32</span>(delta) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有正在运行的goroutine or 没有等待的goroutine</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有等待中的goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> wg.state.Load() != state &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性将waiter_counter清零</span></span><br><span class="line">    wg.state.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有等待中的goroutine</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(&amp;wg.sema, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h3><p>Done方法时add方法的一种封装，不多介绍，见Add</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// counter--</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() &#123;</span><br><span class="line">    wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><p>Wait本质是一个无限循环，一直等待sema释放</p>
<ol>
<li>counter&#x3D;&#x3D;0，不需要等待，返回</li>
<li>waiter_counter++，当前goroutine挂起等待</li>
<li>被唤醒后直接返回</li>
</ol>
<p>具体源代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wait blocks until the [WaitGroup] counter is zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := wg.state.Load()</span><br><span class="line"></span><br><span class="line">        v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)     <span class="comment">// counter：还在运行中的goroutine数量</span></span><br><span class="line">        w := <span class="type">uint32</span>(state)          <span class="comment">// waiter_counter：等待中的goroutine数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有在运行中的goroutine，不需要等待</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// waiter_counter++</span></span><br><span class="line">        <span class="keyword">if</span> wg.state.CompareAndSwap(state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试获取wg.sema，失败则挂起等待</span></span><br><span class="line">            runtime_SemacquireWaitGroup(&amp;wg.sema)</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            <span class="keyword">if</span> wg.state.Load() != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_SemacquireWaitGroup sync.runtime_SemacquireWaitGroup</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_SemacquireWaitGroup</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    semacquire1(addr, <span class="literal">false</span>, semaBlockProfile, <span class="number">0</span>, waitReasonSyncWaitGroupWait)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://victoriametrics.com/blog/go-sync-waitgroup/index.html">Go sync.WaitGroup and The Alignment Problem</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样从公网访问k8s服务</title>
    <url>/how-to-access-k8s-service-from-public-network/</url>
    <content><![CDATA[<p>默认情况下，k8s创建的服务是无法对公网提供访问的，如果要从公网访问k8s服务，一般有三种方式，NodePort、LoadBalancer、Ingress，下面简单介绍NodePort、LoadBalancer，着重讲解Ingress</p>
<p>本文使用的deployment同官方教程<a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">nginx-deployment</a>，图片是从ingress-nginx官方文档拷贝过来借用，如侵必删</p>
<h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p><img src="/images/nodeport.jpg" alt="nodeport"></p>
<p>如上图所示，客户端访问集群内任意机器端口30100，k8s自动将请求转发到对应的服务</p>
<ol>
<li>创建NodePort类型的service（不指定nodeport的情况下，默认从30000-32767中挑选一个端口使用）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment nginx-deployment --<span class="built_in">type</span>=<span class="string">&quot;NodePort&quot;</span> --port 80</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看service <code>kubectl get svc</code>，输出如下</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes         ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP        12d</span><br><span class="line">nginx-deployment   NodePort    10.110.255.135   &lt;none&gt;        80:31402/TCP   4s</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证</li>
</ol>
<p>外部客户端先访问集群内任意节点端口31402，然后节点会转发到与端口关联的k8s内部服务nginx-deployment。</p>
<p>在物理机上访问服务<code>curl http://vm1:31402</code>，对比在虚拟机如vm1上执行<code>curl http://10.110.255.135</code>，两者的输出是一致的</p>
<ol start="4">
<li>删除service</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete svc nginx-deployment</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：考虑到线上一般是直接通过域名访问，如果不想在域名后还要添加端口访问服务，如<code>www.noname.io:31402</code>，那么还需要使用nginx&#x2F;haproxy建立一个反向代理的网关进行管理</p>
<span id="more"></span>

<h2 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h2><p><img src="/images/metallb.jpg" alt="metallb"></p>
<p>如上图所示，客户端的请求抵达LoadBalancer指定的IP（这里的IP有点奇怪，应该是与节点IP同一个CIDR但被保留的IP才对，看下面metallb），然后机器将流量转发到对应的服务</p>
<p>一般情况下，各个云服务厂商有提供专门支持k8s的LoadBalancer，本文依赖的k8s是自建的裸集群（bare-metal），默认不支持LoadBalancer，因此需要先安装metallb</p>
<h3 id="metallb安装"><a href="#metallb安装" class="headerlink" title="metallb安装"></a>metallb安装</h3><ol>
<li>下载配置文件，修改image地址，然后使用kubectl执行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ./metallb-native.yaml</span><br><span class="line"><span class="comment"># 如果你的网络正常</span></span><br><span class="line"><span class="comment"># kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.14.8/config/manifests/metallb-native.yaml</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看pod运行状态</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n metallb-system -o wide</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP                NODE   NOMINATED NODE   READINESS GATES</span><br><span class="line">controller-f6d7bd7b-7kg47   1/1     Running   0          51s   10.0.2.19         vm3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">speaker-8fgzx               1/1     Running   0          51s   192.168.122.235   vm3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">speaker-bfbtk               1/1     Running   0          51s   192.168.122.11    vm1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">speaker-t4lv8               1/1     Running   0          51s   192.168.122.126   vm2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置IP池</li>
</ol>
<p>配置IP池用于LoadBalancer分配，注意，要确保这部分IP不要被dhcp分配给其他任何机器</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi ip-address-pool.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">metallb.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IPAddressPool</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metallb-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.122</span><span class="number">.20</span><span class="number">-192.168</span><span class="number">.122</span><span class="number">.25</span></span><br><span class="line">  <span class="attr">autoAssign:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">metallb.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">L2Advertisement</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metallb-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ipAddressPools:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>

<p>执行命令<code>kubectl apply -f ip-address-pool.yaml</code></p>
<p>到这里就创建好了</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ol>
<li>创建LoadBalancer类型的service</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment nginx-deployment --<span class="built_in">type</span>=<span class="string">&quot;LoadBalancer&quot;</span> --port 80</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看service <code>kubectl get svc</code>，输出如下</li>
</ol>
<p>192.168.122.20这个地址不是节点IP，而是从IP池里挑选的未被使用的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME               TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)        AGE</span><br><span class="line">kubernetes         ClusterIP      10.96.0.1        &lt;none&gt;           443/TCP        12d</span><br><span class="line">nginx-deployment   LoadBalancer   10.111.110.163   192.168.122.20   80:30804/TCP   8s</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证</li>
</ol>
<p>在物理机上访问服务<code>curl -D- http://192.168.122.20 -H &#39;Host: www.noname.io&#39;</code>，对比在虚拟机上执行<code>curl -D- http://10.111.110.163</code>，两者的输出是一致的</p>
<ol start="4">
<li>删除service</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete svc nginx-deployment</span><br></pre></td></tr></table></figure>

<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>Ingress在整个k8s架构中扮演着集群网关的角色，提供了如负载均衡、SSL终结和基于名称的虚拟托管功能，当然，你可以用在a&#x2F;b测试、版本升级这种用途，目前支持的协议是http，后续的继任者Gateway提供了更强大的功能，如支持更多协议、流量管理、更灵活的配置等，但这里暂不做过多介绍</p>
<p>Ingress的运行方式有好几种，其中比较常见的是NodePort以及LoadBalancer。其工作原理是：客户端通过NodePort或者LoadBalancer的方式访问ingress，ingress再通过路由转发到指定的k8s内部服务</p>
<p>本文使用的ingress是ingress-nginx，当然，你也可以选择envoy或higress等</p>
<h3 id="ingress-nginx"><a href="#ingress-nginx" class="headerlink" title="ingress-nginx"></a>ingress-nginx</h3><p>将repo下载到本地，地址：<a href="https://github.com/kubernetes/ingress-nginx%EF%BC%8Ck8s%E4%BE%9D%E8%B5%96%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%60deploy/static/provider/%60%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8CNodePort%E6%96%B9%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%60baremetal%60%EF%BC%8C%E8%80%8CLoadBalancer%E6%96%B9%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%60cloud%60">https://github.com/kubernetes/ingress-nginx，k8s依赖的部署文件放在`deploy/static/provider/`目录下，NodePort方式的文件放在`baremetal`，而LoadBalancer方式的文件放在`cloud`</a></p>
<ol>
<li><p>拷贝文件夹<code>baremetal</code>或<code>cloud</code>，修改deploy.yaml中的image地址</p>
</li>
<li><p>执行命令<code>kubectl apply -k .</code></p>
</li>
<li><p>查看pod运行状况</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -o wide -n ingress-nginx</span><br></pre></td></tr></table></figure>

<p>输出如下，前两个是一次性的job，忽略</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME                                        READY   STATUS      RESTARTS   AGE     IP           NODE   NOMINATED NODE   READINESS GATES</span><br><span class="line">ingress-nginx-admission-create-6mmd6        0/1     Completed   0          2m33s   10.0.2.178   vm3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-admission-patch-clnr4         0/1     Completed   0          2m33s   10.0.1.235   vm2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-controller-5989548bf5-tjv5t   1/1     Running     0          2m33s   10.0.2.12    vm3    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查看controller运行状况</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get svc ingress-nginx-controller -n ingress-nginx</span><br></pre></td></tr></table></figure>

<p>如果你执行的是<code>cloud</code>配置，也就是<code>LoadBalancer</code>方式，输出如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME                       TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller   LoadBalancer   10.109.74.112   192.168.122.20   80:31608/TCP,443:30939/TCP   77m</span><br></pre></td></tr></table></figure>

<p>如果你执行的是<code>baremetal</code>配置，也就是<code>NodePort</code>方式，输出如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME                       TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller   NodePort   10.104.202.43   &lt;none&gt;        80:31880/TCP,443:30184/TCP   3m27s</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>验证</li>
</ol>
<p>访问ingress地址</p>
<p><code>LoadBalancer</code>方式如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LoadBalancer如下</span></span><br><span class="line">curl -D- http://192.168.122.20 -H <span class="string">&#x27;Host: www.noname.io&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NodePort如下</span></span><br><span class="line">curl -D- http://vm1:31880 -H <span class="string">&#x27;Host: www.noname.io&#x27;</span></span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Date: Wed, 28 Aug 2024 04:09:19 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 146</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>到这里，ingress安装完成</p>
<h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><ol>
<li>创建默认类型为ClusterIP的服务（该服务无法在集群外部访问，适合验证我们创建的ingress）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment nginx-deployment</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看service <code>kubectl get svc</code>，输出如下</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NAME               TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes         ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP   12d</span><br><span class="line">nginx-deployment   ClusterIP   10.106.19.73   &lt;none&gt;        80/TCP    12m</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置ingress规则</li>
</ol>
<p>该规则指定<a href="http://www.noname.io的所有流量都转发到nginx-deployment服务/">www.noname.io的所有流量都转发到nginx-deployment服务</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example-ingress.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">example-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">rules:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.noname.io</span></span><br><span class="line">   <span class="attr">http:</span></span><br><span class="line">     <span class="attr">paths:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">       <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">       <span class="attr">backend:</span></span><br><span class="line">         <span class="attr">service:</span></span><br><span class="line">           <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">           <span class="attr">port:</span></span><br><span class="line">             <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>验证</li>
</ol>
<p>访问ingress地址，仅展示LoadBalancer方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -D- http://192.168.122.20 -H <span class="string">&#x27;Host: www.noname.io&#x27;</span></span><br></pre></td></tr></table></figure>

<p>done</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://medium.com/@seanlinsanity/how-to-expose-applications-running-in-kubernetes-cluster-to-public-access-65c2fa959a3b">3 Ways to Expose Applications Running in Kubernetes Cluster to Public Access</a><br><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">Ingress</a><br><a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/ingress-minikube/">在 Minikube 环境中使用 NGINX Ingress 控制器配置 Ingress</a><br><a href="https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/baremetal.md">Bare-metal considerations</a><br><a href="https://medium.com/tektutor/using-nginx-ingress-controller-in-kubernetes-bare-metal-setup-890eb4e7772">Using Nginx Ingress Controller in Kubernetes bare-metal setup</a><br><a href="https://medium.com/tektutor/using-metal-lb-on-a-bare-metal-onprem-kubernetes-setup-6d036af1d20c">Using Metal LB on a bare-metal(OnPrem) Kubernetes Setup</a></p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-time</title>
    <url>/golang-series-time/</url>
    <content><![CDATA[<p>time涉及的内容较多，如生成&#x2F;存储时间、比较时间、获取时间信息、时区、夏令时等，本文仅介绍一些自己感兴趣的地方</p>
<p>日历计算基于格里高利历（公历），1年有365天（闰年有366天）。同时支持墙上时钟（wall clock）和单调时钟（monotonic clock），其中墙上时钟用于时间同步、报时（time-telling），单调时钟用于时间测量（time-measuring）。并不是所有函数都支持单调时钟，如字符串编码&#x2F;解码函数就会舍弃单调时钟数据</p>
<p>注意：</p>
<ol>
<li>时间精确度：纳秒</li>
<li>大部分都是线程安全，除了<ul>
<li>GobDecode</li>
<li>UnmarshalBinary</li>
<li>UnmarshalJSON</li>
<li>UnmarshalText</li>
</ul>
</li>
<li>有些系统会在进程休眠时停止单调时钟，会导致一些函数计算异常，如<ul>
<li>Sub</li>
<li>Since</li>
<li>Until</li>
<li>Before</li>
<li>After</li>
<li>Add</li>
<li>Equal</li>
<li>Compare</li>
</ul>
</li>
<li>字符串编码时，保存的是Location的offset，会导致dst-夏令时丢失，相关函数<ul>
<li>GobEncode</li>
<li>MarshalBinary</li>
<li>AppendBinary</li>
<li>MarshalJSON</li>
<li>MarshalText</li>
<li>AppendText</li>
</ul>
</li>
<li>字符串编码&#x2F;解码时，会丢弃单调时钟信息</li>
</ol>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := fmt.Println</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := time.Now()</span><br><span class="line">    p(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定时刻</span></span><br><span class="line">    then := time.Date(</span><br><span class="line">        <span class="number">2009</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">651387237</span>, time.UTC)</span><br><span class="line">    p(then)</span><br><span class="line"></span><br><span class="line">    p(then.Year())          <span class="comment">// 年</span></span><br><span class="line">    p(then.Month())         <span class="comment">// 月</span></span><br><span class="line">    p(then.Day())           <span class="comment">// 日</span></span><br><span class="line">    p(then.Hour())          <span class="comment">// 时</span></span><br><span class="line">    p(then.Minute())        <span class="comment">// 分</span></span><br><span class="line">    p(then.Second())        <span class="comment">// 秒</span></span><br><span class="line">    p(then.Nanosecond())    <span class="comment">// 纳秒</span></span><br><span class="line">    p(then.Location())      <span class="comment">// 时区</span></span><br><span class="line"></span><br><span class="line">    p(then.Weekday())       <span class="comment">// 星期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个时刻先后顺序</span></span><br><span class="line">    p(then.Before(now))</span><br><span class="line">    p(then.After(now))</span><br><span class="line">    p(then.Equal(now))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时长/时刻差值</span></span><br><span class="line">    diff := now.Sub(then)</span><br><span class="line">    p(diff)</span><br><span class="line"></span><br><span class="line">    p(diff.Hours())         <span class="comment">// 转换成总小时数</span></span><br><span class="line">    p(diff.Minutes())       <span class="comment">// 转换成总分钟数</span></span><br><span class="line">    p(diff.Seconds())       <span class="comment">// 转换成总秒数</span></span><br><span class="line">    p(diff.Nanoseconds())   <span class="comment">// 转换成总纳秒数</span></span><br><span class="line"></span><br><span class="line">    p(then.Add(diff))</span><br><span class="line">    p(then.Add(-diff))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2025-02-22 10:30:14.247195 +0800 CST m=+0.000103986  # 当前时刻</span></span><br><span class="line"><span class="comment"># 2009-11-17 20:34:58.651387237 +0000 UTC              # 指定时刻</span></span><br><span class="line"><span class="comment"># 2009                                                 # 年</span></span><br><span class="line"><span class="comment"># November                                             # 月</span></span><br><span class="line"><span class="comment"># 17                                                   # 日</span></span><br><span class="line"><span class="comment"># 20                                                   # 时</span></span><br><span class="line"><span class="comment"># 34                                                   # 分</span></span><br><span class="line"><span class="comment"># 58                                                   # 秒</span></span><br><span class="line"><span class="comment"># 651387237                                            # 纳秒</span></span><br><span class="line"><span class="comment"># UTC                                                  # 时区</span></span><br><span class="line"><span class="comment"># Tuesday                                              # 星期</span></span><br><span class="line"><span class="comment"># true</span></span><br><span class="line"><span class="comment"># false</span></span><br><span class="line"><span class="comment"># false</span></span><br><span class="line"><span class="comment"># 133805h55m15.595807763s                              # 时长/时刻差值</span></span><br><span class="line"><span class="comment"># 133805.9209988355                                    # 总小时数</span></span><br><span class="line"><span class="comment"># 8.028355259930129e+06                                # 总分钟数</span></span><br><span class="line"><span class="comment"># 4.817013155958078e+08                                # 总秒数</span></span><br><span class="line"><span class="comment"># 481701315595807763                                   # 总纳秒数</span></span><br><span class="line"><span class="comment"># 2025-02-22 02:30:14.247195 +0000 UTC</span></span><br><span class="line"><span class="comment"># 1994-08-13 14:39:43.055579474 +0000 UTC</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>时间由Time数据结构表示，具体如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/time/time.go</span></span><br><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    wall <span class="type">uint64</span>      <span class="comment">// 1位表示flag，33位表示秒数，30位表示纳秒数</span></span><br><span class="line">    ext  <span class="type">int64</span>       <span class="comment">// wall与ext组合表示：秒数（墙上时钟）+纳秒数（墙上时钟）+纳秒数（单调时钟）【可选】</span></span><br><span class="line">    loc *Location    <span class="comment">// 时区，为nil时表示UTC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间存储"><a href="#时间存储" class="headerlink" title="时间存储"></a>时间存储</h3><p>Time结构使用wall和ext两个字段来存储时间，具体表示如下</p>
<ol>
<li>当wall第一位即flag为0时，表示没有单调时钟数据，wall和ext存储内容如下</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wall -&gt; | 1bit | 33bit                     | 30bit                     |</span></span><br><span class="line"><span class="comment">//         | 0    | 0                         | def(ns) -&gt; [0, 999999999] |</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// ext  -&gt; | 64bit                                                        |</span></span><br><span class="line"><span class="comment">//         | abc(s) =&gt; int64                                              |</span></span><br></pre></td></tr></table></figure>

<p>其中，abc伪数据表示秒数，从1年1月1日开始算起；def伪数据表示纳秒数，范围[0, 999999999]</p>
<ol start="2">
<li>当wall第一位为1时，表示有单调时钟数据，wall和ext存储内容如下</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wall -&gt; | 1bit | 33bit                     | 30bit                     |</span></span><br><span class="line"><span class="comment">//         | 1    | abc(s) =&gt; unsigned        | def(ns) -&gt; [0, 999999999] |</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// ext  -&gt; | 64bit                                                        |</span></span><br><span class="line"><span class="comment">//         | xyz(ns) =&gt; int64                                             |</span></span><br></pre></td></tr></table></figure>

<p>其中，abc伪数据表示秒数，def伪数据表示纳秒数，范围[0, 999999999]，xyz为单调时钟的纳秒数，从进程启动开始计时</p>
<p>此时，墙上时钟能表示的时间范围是[1885, 2157]</p>
<h2 id="获取时间对象Time"><a href="#获取时间对象Time" class="headerlink" title="获取时间对象Time"></a>获取时间对象Time</h2><h3 id="当前时刻Now"><a href="#当前时刻Now" class="headerlink" title="当前时刻Now"></a>当前时刻Now</h3><p>Now返回系统时间，返回的Time一般包含单调时钟数据</p>
<p>具体逻辑</p>
<ol>
<li>从系统获取时间数据（通过VDSO或clock_gettime获取）</li>
<li>如果返回的时间没有单调时钟数据，按墙上时钟格式存储</li>
<li>如果秒数出现溢出的情况，按墙上时钟格式存储</li>
<li>存储墙上时钟和单调时钟</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回本地当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 从系统获取时间数据</span></span><br><span class="line">    sec, nsec, mono := runtimeNow()</span><br><span class="line">    <span class="comment">// 没有单调时间</span></span><br><span class="line">    <span class="keyword">if</span> mono == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// unix时间戳存储时都要加上unixToInternal</span></span><br><span class="line">        <span class="keyword">return</span> Time&#123;<span class="type">uint64</span>(nsec), sec + unixToInternal, Local&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减去进程启动时获取的nanotime</span></span><br><span class="line">    mono -= startNano</span><br><span class="line">    <span class="comment">// 检测是否会溢出，2157年3月16日耗尽所有bit</span></span><br><span class="line">    sec += unixToInternal - minWall</span><br><span class="line">    <span class="comment">// 溢出？丢弃单调时钟，只存墙上时钟</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uint64</span>(sec)&gt;&gt;<span class="number">33</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Time&#123;<span class="type">uint64</span>(nsec), sec + minWall, Local&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 墙上时钟+单调时钟</span></span><br><span class="line">    <span class="keyword">return</span> Time&#123;hasMonotonic | <span class="type">uint64</span>(sec)&lt;&lt;nsecShift | <span class="type">uint64</span>(nsec), mono, Local&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程启动时初始化该变量</span></span><br><span class="line"><span class="keyword">var</span> startNano <span class="type">int64</span> = runtimeNano() - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">time_runtimeNow</span><span class="params">()</span></span> (sec <span class="type">int64</span>, nsec <span class="type">int32</span>, mono <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> sg := getg().syncGroup; sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        sec = sg.now / (<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>)</span><br><span class="line">        nsec = <span class="type">int32</span>(sg.now % (<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>))</span><br><span class="line">        <span class="keyword">return</span> sec, nsec, sg.now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time_now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/timestub.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">time_now</span><span class="params">()</span></span> (sec <span class="type">int64</span>, nsec <span class="type">int32</span>, mono <span class="type">int64</span>) &#123;</span><br><span class="line">    sec, nsec = walltime() <span class="comment">// 通过VDSO或clock_gettime获取</span></span><br><span class="line">    <span class="keyword">return</span> sec, nsec, nanotime()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">time_runtimeNano</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp.syncGroup.now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nanotime()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time_nofake.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nanotime</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// linux+amd64看相关汇编代码 src/runtime/sys_linux_amd64.s</span></span><br><span class="line">    <span class="keyword">return</span> nanotime1() <span class="comment">// 通过VDSO或clock_gettime获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unix时间戳转换"><a href="#Unix时间戳转换" class="headerlink" title="Unix时间戳转换"></a>Unix时间戳转换</h3><p>根据秒数、纳秒数返回一个从1970年1月1日开始计时的unix时间戳的Time，该Time不包含单调时钟数据。按参数精度分为Unix&#x2F;UnixMilli&#x2F;UnixMicro</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精度：秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unix</span><span class="params">(sec <span class="type">int64</span>, nsec <span class="type">int64</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 负数或超过1e9</span></span><br><span class="line">    <span class="keyword">if</span> nsec &lt; <span class="number">0</span> || nsec &gt;= <span class="number">1e9</span> &#123;</span><br><span class="line">        n := nsec / <span class="number">1e9</span></span><br><span class="line">        sec += n           <span class="comment">// 溢出部份换算成秒，加到sec</span></span><br><span class="line">        nsec -= n * <span class="number">1e9</span>    <span class="comment">// 移除溢出部份</span></span><br><span class="line">        <span class="keyword">if</span> nsec &lt; <span class="number">0</span> &#123;      <span class="comment">// 负数</span></span><br><span class="line">            nsec += <span class="number">1e9</span>    <span class="comment">// 从sec拿1s加上，使其为正</span></span><br><span class="line">            sec--          <span class="comment">// sec减去1s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unixTime(sec, <span class="type">int32</span>(nsec))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unixTime</span><span class="params">(sec <span class="type">int64</span>, nsec <span class="type">int32</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 存储时加上一个预设值unixToInternal，读取的时候减掉</span></span><br><span class="line">    <span class="keyword">return</span> Time&#123;<span class="type">uint64</span>(nsec), sec + unixToInternal, Local&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixMilli</span><span class="params">(msec <span class="type">int64</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="keyword">return</span> Unix(msec/<span class="number">1e3</span>, (msec%<span class="number">1e3</span>)*<span class="number">1e6</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：微秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixMicro</span><span class="params">(usec <span class="type">int64</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="keyword">return</span> Unix(usec/<span class="number">1e6</span>, (usec%<span class="number">1e6</span>)*<span class="number">1e3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Date获取指定时刻"><a href="#Date获取指定时刻" class="headerlink" title="Date获取指定时刻"></a>Date获取指定时刻</h3><p>根据提供的时间信息如：年&#x2F;月&#x2F;日&#x2F;时&#x2F;分&#x2F;秒以及时区获得指定时刻，具体逻辑如下</p>
<ol>
<li>规范化后计算出一个unix时间戳</li>
<li>根据时区的偏移量调整unix时间戳</li>
<li>生成Time示例</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date</span><span class="params">(year <span class="type">int</span>, month Month, day, hour, min, sec, nsec <span class="type">int</span>, loc *Location)</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 时区不能为空</span></span><br><span class="line">    <span class="keyword">if</span> loc == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: missing Location in call to Date&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规范月份，溢出值加到年上</span></span><br><span class="line">    m := <span class="type">int</span>(month) - <span class="number">1</span></span><br><span class="line">    year, m = norm(year, m, <span class="number">12</span>)</span><br><span class="line">    month = Month(m) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规范nsec, sec, min, hour, 溢出值加到天上</span></span><br><span class="line">    sec, nsec = norm(sec, nsec, <span class="number">1e9</span>)</span><br><span class="line">    min, sec = norm(min, sec, <span class="number">60</span>)</span><br><span class="line">    hour, min = norm(hour, min, <span class="number">60</span>)</span><br><span class="line">    day, hour = norm(day, hour, <span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为绝对时间，然后转换为unix时间戳</span></span><br><span class="line">    unix := <span class="type">int64</span>(dateToAbsDays(<span class="type">int64</span>(year), month, day))*secondsPerDay +</span><br><span class="line">        <span class="type">int64</span>(hour*secondsPerHour+min*secondsPerMinute+sec) +</span><br><span class="line">        absoluteToUnix</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时区偏移量</span></span><br><span class="line">    _, offset, start, end, _ := loc.lookup(unix)</span><br><span class="line">    <span class="keyword">if</span> offset != <span class="number">0</span> &#123;</span><br><span class="line">        utc := unix - <span class="type">int64</span>(offset)</span><br><span class="line">        <span class="keyword">if</span> utc &lt; start || utc &gt;= end &#123;</span><br><span class="line">            _, offset, _, _, _ = loc.lookup(utc)</span><br><span class="line">        &#125;</span><br><span class="line">        unix -= <span class="type">int64</span>(offset)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unix时间戳</span></span><br><span class="line">    t := unixTime(unix, <span class="type">int32</span>(nsec))</span><br><span class="line">    t.setLoc(loc)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi * base + lo == nhi * base + nlo</span></span><br><span class="line"><span class="comment">// 0 &lt;= nlo &lt; base</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">norm</span><span class="params">(hi, lo, base <span class="type">int</span>)</span></span> (nhi, nlo <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span> &#123;</span><br><span class="line">        n := (-lo<span class="number">-1</span>)/base + <span class="number">1</span></span><br><span class="line">        hi -= n</span><br><span class="line">        lo += n * base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lo &gt;= base &#123;</span><br><span class="line">        n := lo / base</span><br><span class="line">        hi += n</span><br><span class="line">        lo -= n * base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hi, lo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为天数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dateToAbsDays</span><span class="params">(year <span class="type">int64</span>, month Month, day <span class="type">int</span>)</span></span> absDays &#123;</span><br><span class="line">    amonth := <span class="type">uint32</span>(month)</span><br><span class="line">    janFeb := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> amonth &lt; <span class="number">3</span> &#123;</span><br><span class="line">        janFeb = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是1月和2月，再加12个月</span></span><br><span class="line">    amonth += <span class="number">12</span> * janFeb</span><br><span class="line">    <span class="comment">// year-janFeb+292277022400</span></span><br><span class="line">    y := <span class="type">uint64</span>(year) - <span class="type">uint64</span>(janFeb) + absoluteYears</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果3 &lt;= amonth &lt;= 14</span></span><br><span class="line">    <span class="comment">// ayday := (153*amonth - 457) / 5</span></span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="comment">// ayday := (979*amonth - 2919) &gt;&gt; 5</span></span><br><span class="line">    ayday := (<span class="number">979</span>*amonth - <span class="number">2919</span>) &gt;&gt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    century := y / <span class="number">100</span></span><br><span class="line">    cyear := <span class="type">uint32</span>(y % <span class="number">100</span>)</span><br><span class="line">    cday := <span class="number">1461</span> * cyear / <span class="number">4</span></span><br><span class="line">    centurydays := <span class="number">146097</span> * century / <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// absDays =&gt; uint64的别名</span></span><br><span class="line">    <span class="keyword">return</span> absDays(centurydays + <span class="type">uint64</span>(<span class="type">int64</span>(cday+ayday)+<span class="type">int64</span>(day)<span class="number">-1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增加时长获取指定时刻"><a href="#增加时长获取指定时刻" class="headerlink" title="增加时长获取指定时刻"></a>增加时长获取指定时刻</h3><h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><p>时刻t增加时长d，获得指定时刻，该方法会同时更新墙上时钟和单调时钟</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Add(d Duration) Time &#123;</span><br><span class="line">    dsec := <span class="type">int64</span>(d / <span class="number">1e9</span>)            <span class="comment">// 秒数</span></span><br><span class="line">    nsec := t.nsec() + <span class="type">int32</span>(d%<span class="number">1e9</span>)   <span class="comment">// 纳秒数</span></span><br><span class="line">    <span class="keyword">if</span> nsec &gt;= <span class="number">1e9</span> &#123;</span><br><span class="line">        dsec++</span><br><span class="line">        nsec -= <span class="number">1e9</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nsec &lt; <span class="number">0</span> &#123;</span><br><span class="line">        dsec--</span><br><span class="line">        nsec += <span class="number">1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.wall = t.wall&amp;^nsecMask | <span class="type">uint64</span>(nsec) <span class="comment">// 更新纳秒数</span></span><br><span class="line">    t.addSec(dsec)</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        te := t.ext + <span class="type">int64</span>(d)</span><br><span class="line">        <span class="keyword">if</span> d &lt; <span class="number">0</span> &amp;&amp; te &gt; t.ext || d &gt; <span class="number">0</span> &amp;&amp; te &lt; t.ext &#123;</span><br><span class="line">            <span class="comment">// 单调时钟溢出，降级成墙上时钟</span></span><br><span class="line">            t.stripMono()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t.ext = te</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> addSec(d <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        sec := <span class="type">int64</span>(t.wall &lt;&lt; <span class="number">1</span> &gt;&gt; (nsecShift + <span class="number">1</span>))</span><br><span class="line">        dsec := sec + d</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= dsec &amp;&amp; dsec &lt;= <span class="number">1</span>&lt;&lt;<span class="number">33</span><span class="number">-1</span> &#123;</span><br><span class="line">            t.wall = t.wall&amp;nsecMask | <span class="type">uint64</span>(dsec)&lt;&lt;nsecShift | hasMonotonic</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 秒数溢出，把单调时钟数据移除，降级为墙上时钟</span></span><br><span class="line">        t.stripMono()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 墙上时钟</span></span><br><span class="line">    sum := t.ext + d</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; t.ext) == (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        t.ext = sum</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> d &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t.ext = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.ext = -(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除mono时钟数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> stripMono() &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        t.ext = t.sec()     <span class="comment">// 复制秒数到ext</span></span><br><span class="line">        t.wall &amp;= nsecMask    <span class="comment">// 移除flag</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AddDate"><a href="#AddDate" class="headerlink" title="AddDate"></a>AddDate</h4><p>Time根据提供的年数&#x2F;月数&#x2F;日数获得目标指定时刻，底层实际调用的是Date方法，只更新wall clock</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> AddDate(years <span class="type">int</span>, months <span class="type">int</span>, days <span class="type">int</span>) Time &#123;</span><br><span class="line">    year, month, day := t.Date()</span><br><span class="line">    hour, min, sec := t.Clock()</span><br><span class="line">    <span class="keyword">return</span> Date(year+years, month+Month(months), day+days, hour, min, sec, <span class="type">int</span>(t.nsec()), t.Location())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串转换成Time"><a href="#字符串转换成Time" class="headerlink" title="字符串转换成Time"></a>字符串转换成Time</h3><p>常用的layout有：</p>
<table>
<thead>
<tr>
<th align="left">constant</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DateTime</td>
<td align="left">“2006-01-02 15:04:05”</td>
</tr>
<tr>
<td align="left">DateOnly</td>
<td align="left">“2006-01-02”</td>
</tr>
<tr>
<td align="left">TimeOnly</td>
<td align="left">“15:04:05”</td>
</tr>
</tbody></table>
<h4 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h4><p>解析字符串获得Time对象以及异常信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="type">string</span>)</span></span> (Time, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// RFC3339 =&gt; 2006-01-02T15:04:05Z07:00</span></span><br><span class="line">    <span class="keyword">if</span> layout == RFC3339 || layout == RFC3339Nano &#123;</span><br><span class="line">        <span class="keyword">if</span> t, ok := parseRFC3339(value, Local); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parse函数太长了，有兴趣可以看源码</span></span><br><span class="line">    <span class="keyword">return</span> parse(layout, value, UTC, Local)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ParseInLocation"><a href="#ParseInLocation" class="headerlink" title="ParseInLocation"></a>ParseInLocation</h4><p>指定时区，解析字符串获得Time对象以及异常信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInLocation</span><span class="params">(layout, value <span class="type">string</span>, loc *Location)</span></span> (Time, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// RFC3339 =&gt; 2006-01-02T15:04:05Z07:00</span></span><br><span class="line">    <span class="keyword">if</span> layout == RFC3339 || layout == RFC3339Nano &#123;</span><br><span class="line">        <span class="keyword">if</span> t, ok := parseRFC3339(value, loc); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parse函数太长了，有兴趣可以看源码</span></span><br><span class="line">    <span class="keyword">return</span> parse(layout, value, loc, loc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算两个时刻的差值"><a href="#计算两个时刻的差值" class="headerlink" title="计算两个时刻的差值"></a>计算两个时刻的差值</h2><h3 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h3><p>计算t时刻-u时刻的差值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Sub(u Time) Duration &#123;</span><br><span class="line">    <span class="comment">// 两个时刻都有单调时钟</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subMono(t.ext, u.ext)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 秒数+纳秒数</span></span><br><span class="line">    d := Duration(t.sec()-u.sec())*Second + Duration(t.nsec()-u.nsec())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> u.Add(d).Equal(t):</span><br><span class="line">        <span class="keyword">return</span> d <span class="comment">// d is correct</span></span><br><span class="line">    <span class="keyword">case</span> t.Before(u):</span><br><span class="line">        <span class="keyword">return</span> minDuration <span class="comment">// t - u is negative out of range</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> maxDuration <span class="comment">// t - u is positive out of range</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subMono</span><span class="params">(t, u <span class="type">int64</span>)</span></span> Duration &#123;</span><br><span class="line">    d := Duration(t - u)</span><br><span class="line">    <span class="keyword">if</span> d &lt; <span class="number">0</span> &amp;&amp; t &gt; u &#123;</span><br><span class="line">        <span class="keyword">return</span> maxDuration <span class="comment">// t - u is positive out of range</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> d &gt; <span class="number">0</span> &amp;&amp; t &lt; u &#123;</span><br><span class="line">        <span class="keyword">return</span> minDuration <span class="comment">// t - u is negative out of range</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Since"><a href="#Since" class="headerlink" title="Since"></a>Since</h3><p>计算从指定时刻（过去）到现在时刻的差值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Since</span><span class="params">(t Time)</span></span> Duration &#123;</span><br><span class="line">    <span class="comment">// 目标时刻有单调时钟数据</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subMono(runtimeNano()-startNano, t.ext)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Now().Sub(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Until"><a href="#Until" class="headerlink" title="Until"></a>Until</h3><p>计算从现在时刻到指定时刻（将来）的差值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Until</span><span class="params">(t Time)</span></span> Duration &#123;</span><br><span class="line">    <span class="comment">// 目标时刻有单调时钟数据</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subMono(t.ext, runtimeNano()-startNano)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.Sub(Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比较两个时刻的先后顺序"><a href="#比较两个时刻的先后顺序" class="headerlink" title="比较两个时刻的先后顺序"></a>比较两个时刻的先后顺序</h2><p>如果两个Time都包含wall clock和mono clock，则只比较mono clock，否则比较wall clock</p>
<h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><p>判断t时刻是否先于u时刻</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Before(u Time) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.ext &lt; u.ext</span><br><span class="line">    &#125;</span><br><span class="line">    ts := t.sec()</span><br><span class="line">    us := u.sec()</span><br><span class="line">    <span class="keyword">return</span> ts &lt; us || ts == us &amp;&amp; t.nsec() &lt; u.nsec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><p>判断t时刻是否晚于u时刻</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> After(u Time) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.ext &gt; u.ext</span><br><span class="line">    &#125;</span><br><span class="line">    ts := t.sec()</span><br><span class="line">    us := u.sec()</span><br><span class="line">    <span class="keyword">return</span> ts &gt; us || ts == us &amp;&amp; t.nsec() &gt; u.nsec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h3><p>判断t时刻与u时刻是否相等</p>
<p>注意：时刻比较不要使用<code>==</code>，因为<code>==</code>会比较整个Time结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Equal(u Time) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.ext == u.ext</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.sec() == u.sec() &amp;&amp; t.nsec() == u.nsec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IsZero"><a href="#IsZero" class="headerlink" title="IsZero"></a>IsZero</h3><p>判断t时刻是否是零值。</p>
<p>注意：零值是UTC时间1年1月1日0时0分0秒</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> IsZero() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.sec() == <span class="number">0</span> &amp;&amp; t.nsec() == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h3><p>比较两个时刻</p>
<ol>
<li>如果t时刻先于u时刻，返回-1</li>
<li>如果t时刻晚与u时刻，返回+1</li>
<li>如果t时刻与u时刻相等，返回0</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Compare(u Time) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tc, uc <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        tc, uc = t.ext, u.ext</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tc, uc = t.sec(), u.sec()</span><br><span class="line">        <span class="keyword">if</span> tc == uc &#123;</span><br><span class="line">            tc, uc = <span class="type">int64</span>(t.nsec()), <span class="type">int64</span>(u.nsec())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> tc &lt; uc:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">case</span> tc &gt; uc:</span><br><span class="line">        <span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><h3 id="转换时区"><a href="#转换时区" class="headerlink" title="转换时区"></a>转换时区</h3><p>时区不会改变Time存储的数值，影响的是数据输出&#x2F;表示</p>
<h4 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h4><p>切换为本机时区</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Local() Time &#123;</span><br><span class="line">    t.setLoc(Local)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> setLoc(loc *Location) &#123;</span><br><span class="line">    <span class="comment">// nil表示UTC</span></span><br><span class="line">    <span class="keyword">if</span> loc == &amp;utcLoc &#123;</span><br><span class="line">        loc = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.stripMono()</span><br><span class="line">    t.loc = loc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h4><p>切换为UTC时区</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> utcLoc = Location&#123;name: <span class="string">&quot;UTC&quot;</span>&#125; <span class="comment">// 启动时初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UTC() Time &#123;</span><br><span class="line">    t.setLoc(&amp;utcLoc)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指定时区"><a href="#指定时区" class="headerlink" title="指定时区"></a>指定时区</h4><p>切换为指定时区</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> In(loc *Location) Time &#123;</span><br><span class="line">    <span class="keyword">if</span> loc == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: missing Location in call to Time.In&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.setLoc(loc)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取报时信息"><a href="#获取报时信息" class="headerlink" title="获取报时信息"></a>获取报时信息</h2><h3 id="获取Unix时间戳"><a href="#获取Unix时间戳" class="headerlink" title="获取Unix时间戳"></a>获取Unix时间戳</h3><p>获取从1970年1月1日开始到现在的秒数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精度：秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Unix() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.unixSec()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UnixMilli() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.unixSec()*<span class="number">1e3</span> + <span class="type">int64</span>(t.nsec())/<span class="number">1e6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：微秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UnixMicro() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.unixSec()*<span class="number">1e6</span> + <span class="type">int64</span>(t.nsec())/<span class="number">1e3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：纳秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UnixNano() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (t.unixSec())*<span class="number">1e9</span> + <span class="type">int64</span>(t.nsec())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含秒数和纳秒数</span></span><br><span class="line"><span class="comment">// unix时间戳读取时都要加上internalToUnix（也就是减去unixToInternal）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> unixSec() <span class="type">int64</span> &#123; <span class="keyword">return</span> t.sec() + internalToUnix &#125;</span><br></pre></td></tr></table></figure>

<h3 id="提取日期等信息"><a href="#提取日期等信息" class="headerlink" title="提取日期等信息"></a>提取日期等信息</h3><p>业务逻辑经常需要判断两个时刻是否处在同一天&#x2F;同一周等，此外，也需要获取当前周&#x2F;当前月等的起止时刻，列举如下依赖方法</p>
<table>
<thead>
<tr>
<th align="left">method</th>
<th align="left">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Date</td>
<td align="left">获取年月日</td>
</tr>
<tr>
<td align="left">Clock</td>
<td align="left">获取时分秒</td>
</tr>
<tr>
<td align="left">ISOWeek</td>
<td align="left">获取年和周数</td>
</tr>
<tr>
<td align="left">Year</td>
<td align="left">获取年</td>
</tr>
<tr>
<td align="left">Month</td>
<td align="left">获取月</td>
</tr>
<tr>
<td align="left">Day</td>
<td align="left">获取天</td>
</tr>
<tr>
<td align="left">Hour</td>
<td align="left">获取时</td>
</tr>
<tr>
<td align="left">Minute</td>
<td align="left">获取分</td>
</tr>
<tr>
<td align="left">Second</td>
<td align="left">获取秒</td>
</tr>
<tr>
<td align="left">Round</td>
<td align="left">获取秒</td>
</tr>
<tr>
<td align="left">Truncate</td>
<td align="left">按给定时长截断</td>
</tr>
<tr>
<td align="left">Round</td>
<td align="left">按给定时长向上取整</td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 两个时刻是否是同一天</span></span><br><span class="line">NewDate(t1.Date()) == NewDate(t2.Date())</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Date <span class="keyword">struct</span> &#123;</span><br><span class="line">    YearMonth</span><br><span class="line">    day <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDate</span><span class="params">(year <span class="type">int</span>, month time.Month, day <span class="type">int</span>)</span></span> Date &#123;</span><br><span class="line">    <span class="keyword">return</span> Date&#123;</span><br><span class="line">        YearMonth: YearMonth&#123;</span><br><span class="line">            year:  year,</span><br><span class="line">            month: month,</span><br><span class="line">        &#125;,</span><br><span class="line">        day: day,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取当月开始和结束时刻</span></span><br><span class="line">startOfMonth := time.Date(t1.Year(), t1.Month(), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, t1.Location())</span><br><span class="line">endOfMonth := startOfMonth.AddDate(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>).Add(<span class="number">-1</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取当个星期的开始和结束时刻</span></span><br><span class="line"><span class="comment">// 从星期天开始计起</span></span><br><span class="line">tmp := t1.Truncate(<span class="number">7</span> * <span class="number">24</span> * time.Hour)</span><br><span class="line">startOfWeek := time.Date(tmp.Year(), tmp.Month(), tmp.Day(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, tmp.Location())</span><br><span class="line">endOfWeek := startOfWeek.AddDate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>).Add(<span class="number">-1</span> * time.Second)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>如何下载网站视频</title>
    <url>/how-to-download-online-video/</url>
    <content><![CDATA[<p>现在的在线视频网站为了打击盗版、保护资源&#x2F;网络流量，不再直接使用mp4等视频格式，而是转而使用m3u8文件（播放索引列表）+ts文件（视频分段技术），其中有的视频还用了加密，下面简单展示下如何下载ts文件并合并为mp4</p>
<h2 id="m3u8索引"><a href="#m3u8索引" class="headerlink" title="m3u8索引"></a>m3u8索引</h2><p>从浏览器的dev tool找到m3u8文件的连接并下载，该m3u8文件内有所有的ts文件列表，你可以将他们复制出来，通过编辑器补全制作成完整的url，通过下载器批量下载</p>
<h2 id="未加密"><a href="#未加密" class="headerlink" title="未加密"></a>未加密</h2><p>如果视频没有加密（m3u8文件中#EXT-X-KEY字段为空），那么在下载所有ts文件后，可以直接用linux命令合并</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ts段一般都有固定格式，如example_1.ts</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;ts_link_in_m3u8_file_&#x27;</span>&#123;number_first..number_end&#125;.ts | <span class="built_in">tr</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;\n&quot;</span> &gt; tslist</span><br><span class="line"><span class="comment"># 将所有相关的ts文件合并</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> <span class="built_in">cat</span> <span class="variable">$line</span> &gt;&gt; the_final_video.mp4; <span class="keyword">done</span> &lt; tslist</span><br></pre></td></tr></table></figure>

<p>到这里就不需要再往下看了</p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>如果视频加密（m3u8文件中#EXT-X-KEY字段不为空），如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:3</span><br><span class="line">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://hentai.com/xxxxxx&quot;,IV=0xa746ff934e7fff621ba2cf5a32608914</span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class="line">#EXT-X-TARGETDURATION:6</span><br><span class="line">#EXTINF:5.881,</span><br><span class="line">https://hentai.com/xxxxxxyyyyyyyy.ts</span><br></pre></td></tr></table></figure>

<p>处理步骤：</p>
<ol>
<li>下载必须的文件</li>
<li>修改m3u8文件</li>
<li>使用ffmpeg合并</li>
</ol>
<span id="more"></span>

<h3 id="下载必须的文件"><a href="#下载必须的文件" class="headerlink" title="下载必须的文件"></a>下载必须的文件</h3><ol>
<li>通过浏览器dev tool找到m3u8文件url</li>
<li>复制m3u8文件内所有ts文件地址到下载器下载，这里可能还需要通过编辑器补全url</li>
<li>复制m3u8文件内记录的key的地址（从EXT-X-KEY字段获取链接）到下载器下载，可进一步重命名，如改为crypt.key，该文件文件大小一般是16字节</li>
</ol>
<h3 id="修改m3u8文件"><a href="#修改m3u8文件" class="headerlink" title="修改m3u8文件"></a>修改m3u8文件</h3><ol>
<li>修改key的地址，将url改为本地文件路径</li>
<li>如果ts文件url是http链接，那么也改为本地文件路径</li>
</ol>
<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:3</span><br><span class="line">#EXT-X-KEY:METHOD=AES-128,URI=&quot;crypt.key&quot;,IV=0xa746ff934e7fff621ba2cf5a32608914</span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class="line">#EXT-X-TARGETDURATION:6</span><br><span class="line">#EXTINF:5.881,</span><br><span class="line">xxxxxxyyyyyyyy.ts</span><br></pre></td></tr></table></figure>

<h3 id="使用ffmpeg合并"><a href="#使用ffmpeg合并" class="headerlink" title="使用ffmpeg合并"></a>使用ffmpeg合并</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -allowed_extensions ALL -protocol_whitelist <span class="string">&quot;file,http,crypto,tcp&quot;</span> -i example.m3u8 -c copy the_final_video.mp4</span><br></pre></td></tr></table></figure>

<p>done</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/warcraft/p/13388280.html">记一次加密的ts视频下载</a></p>
]]></content>
      <tags>
        <tag>ffmpeg</tag>
        <tag>hls</tag>
      </tags>
  </entry>
  <entry>
    <title>生成火焰图分析php代码</title>
    <url>/how-to-generate-php-flamegraphs/</url>
    <content><![CDATA[<p>flamegraph是一款可视化工具，用户分析程序堆栈调用，x轴堆栈轨迹，y轴堆栈深度，x轴长度越长，占用更多cpu时间。下面简单介绍如何使用xdebug以及flamegraph生成火焰图</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>配置xdebug参数</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">xdebug.trace_output_name</span> = xdebug.trace.%t.%s</span><br><span class="line"><span class="attr">xdebug.trace_enable_trigger</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.trace_output_dir</span> = /tmp</span><br><span class="line"><span class="attr">xdebug.trace_enable_trigger_value</span> = <span class="string">&quot;&lt;secret key&gt;&quot;</span></span><br><span class="line"><span class="attr">xdebug.trace_format</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>下载flamegraph，<code>git clone https://github.com/brendangregg/FlameGraph.git</code>，放置在任意位置</p>
<h2 id="flamegraph"><a href="#flamegraph" class="headerlink" title="flamegraph"></a>flamegraph</h2><p>获取堆栈数据</p>
<p>请求页面&#x2F;接口url，在url后面增加<code>?XDEBUG_TRACE=&lt;secret key&gt;</code>，获取php堆栈数据 <code>curl http://youdomain.com?XDEBUG_TRACE=&lt;secret key&gt;</code>，如果是命令行命令，则在php命令后使用参数<code>php -d xdebug.auto_trace=1</code></p>
<p>转换堆栈数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./stackcollapse-xdebug.php /tmp/xdebug.trace.1579703170._data_www_yii2_web_index_php.xt &gt; out.folded</span><br></pre></td></tr></table></figure>

<p>生成火焰图</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./flamegraph.pl out.folded &gt; out.svg</span><br></pre></td></tr></table></figure>

<p>示例</p>
<p><img src="/images/yii2-flamegraph-example.svg" alt="yii2 flamegraph example"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://daniellockyer.com/php-flame-graphs/">How to generate PHP Flamegraphs</a><br><a href="https://github.com/brendangregg/FlameGraph">Flame Graphs visualize profiled code</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>flamegraph</tag>
        <tag>profiling</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在ubuntu服务器上管理Wi-Fi</title>
    <url>/how-to-manage-wifi-on-ubuntu-server/</url>
    <content><![CDATA[<p>当没有桌面时，ubuntu服务器该如何连接宽带、共享Wi-Fi热点，就像一台路由器一样运作，或者如何连接Wi-Fi，以下简单介绍这几个操作的过程</p>
<h2 id="连接宽带"><a href="#连接宽带" class="headerlink" title="连接宽带"></a>连接宽带</h2><h3 id="PPPOE方式"><a href="#PPPOE方式" class="headerlink" title="PPPOE方式"></a>PPPOE方式</h3><p>使用nmcli输入pppoe账号密码，这时会打开一个交互式的命令行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli con edit <span class="built_in">type</span> pppoe con-name <span class="string">&quot;Connection name&quot;</span></span><br></pre></td></tr></table></figure>

<p>输入保存宽带账户相关信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入账号名密码</span></span><br><span class="line"><span class="built_in">set</span> pppoe.username &lt;username&gt;</span><br><span class="line"><span class="built_in">set</span> pppoe.password &lt;password&gt;</span><br><span class="line"><span class="comment"># 保存并推出</span></span><br><span class="line">save</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<h2 id="连接Wi-Fi"><a href="#连接Wi-Fi" class="headerlink" title="连接Wi-Fi"></a>连接Wi-Fi</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有Wi-Fi热点</span></span><br><span class="line"><span class="built_in">sudo</span> nmcli dev wifi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接Wi-Fi热点</span></span><br><span class="line"><span class="built_in">sudo</span> nmcli dev wifi connect &lt;SSID&gt; &lt;password&gt;</span><br></pre></td></tr></table></figure>

<h2 id="共享Wi-Fi"><a href="#共享Wi-Fi" class="headerlink" title="共享Wi-Fi"></a>共享Wi-Fi</h2><p>禁用cloud-init</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&quot;echo &#x27;network: &#123;config: disabled&#125;&#x27; &gt; /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg&quot;</span></span><br></pre></td></tr></table></figure>

<p>创建Netplan配置</p>
<p><code>sudo vi /etc/netplan/10-my-config.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">renderer:</span> <span class="string">NetworkManager</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">eth0:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">optional:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wifis:</span></span><br><span class="line">    <span class="attr">wlan0:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">optional:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">access-points:</span></span><br><span class="line">        <span class="attr">&quot;Connection Name&quot;:</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">&quot;you wifi password&quot;</span></span><br><span class="line">          <span class="attr">mode:</span> <span class="string">ap</span>  <span class="comment"># 如果是作为客户端使用，移除这一行</span></span><br></pre></td></tr></table></figure>

<p>Netplan配置生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> netplan generate</span><br><span class="line"><span class="built_in">sudo</span> netplan apply</span><br></pre></td></tr></table></figure>

<p><a href="https://raspberrypi.stackexchange.com/questions/109425/ubuntu-server-18-wifi-hotspot-setup">Ubuntu Server 18 Wifi Hotspot setup</a></p>
]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>hotspot</tag>
      </tags>
  </entry>
  <entry>
    <title>如何配置wireguard服务端及客户端</title>
    <url>/how-to-setup-wireguard-vpn-server/</url>
    <content><![CDATA[<p>从19年开始，ss流量已经能被gfw识别并屏蔽，原本打算切换到v2ray，但配置混淆需要域名反而会暴露出更多信息，此外，网上一篇文章指出v2ray开发者失联的同时一项v2ray流量识别的专利被注册，因此决定放弃v2ray并转向另一个被linus盛赞的wireguard。</p>
<p>wireguard是非常简单、现代化、快速的vpn，使用最新的加密技术，udp传输，支持ip漫游等。wireguard没有服务端、客户端的区分，每一台设备都是一个<code>peer</code>。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>添加wireguard的PPA源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:wireguard/wireguard</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install wireguard</span><br></pre></td></tr></table></figure>

<p>wireguard作为linux内核模块方式加载，内核更新wireguard也会自动重新编译，重启系统或使用<code>modprobe</code>开启模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe wireguard</span><br></pre></td></tr></table></figure>

<p>检查wireguard模块是否成功加载，成功输出与下面类似</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant@bionic:~$ lsmod | grep wireguard</span><br><span class="line">wireguard             221184  0</span><br><span class="line">ip6_udp_tunnel         16384  1 wireguard</span><br><span class="line">udp_tunnel             16384  1 wireguard</span><br></pre></td></tr></table></figure>

<h2 id="生成keys"><a href="#生成keys" class="headerlink" title="生成keys"></a>生成keys</h2><p>wireguard提供了两个命令行工具<code>wg</code>以及<code>wg-quick</code>，使用<code>wg</code>生成公钥和私钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> 077</span><br><span class="line">wg genkey | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/wireguard/privatekey | wg pubkey | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/wireguard/publickey</span><br></pre></td></tr></table></figure>

<p>类似ssh，需要为每台设备生成一对publickey&#x2F;privatekey</p>
<span id="more"></span>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>我们需要生成一个虚拟网卡，名称可以按个人喜好选择，这里选择用<code>wg0</code>，IP网段使用<code>10.10.0.1/24</code>，确保该网段没有被你的家庭或公司网络使用，编辑文件<code>/etc/wireguard/wg0.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">PrivateKey = &lt;your server private key here&gt;</span><br><span class="line">Address = 10.10.0.1/24</span><br><span class="line">Address = fd86:ea04:1111::1/64</span><br><span class="line">SaveConfig = true</span><br><span class="line">PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE; ip6tables -A FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o enp0s3 -j MASQUERADE; ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o enp0s3 -j MASQUERADE</span><br><span class="line">ListenPort = 51820</span><br></pre></td></tr></table></figure>

<p><code>PrivateKey</code>填上一步生成的私钥，填入你选择的<code>Address</code>，这里配置了两个IP4&#x2F;6的地址，<code>enp0s3</code>是你服务器主要的网络设备，使用<code>ifconfig</code>或<code>ip a</code>查看你的主设备名，<code>ListenPort</code>默认为51820，建议修改</p>
<p>要注意的是<code>SaveConfig</code>设置，wireguard配置后不需要<code>restart</code>或<code>reload</code>，使用<code>wg</code>命令添加<code>peer</code>即可立即生效。但是，这些操作都是直接写入到内存中而不是磁盘，因此如果你重启系统或服务，那么你就会失去添加的配置，所以这里设置为<code>true</code>，自动保存配置。但这个配置有时候也会让人非常困扰，你可能添加配置后重启服务，然后你发现添加的配置不见了，需要先停止服务再添加配置最后重启。</p>
<p>添加网络配置，使得内核可以正确路由我们的NAT流量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&#x27;cat &lt;&lt; EOF &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward=1</span></span><br><span class="line"><span class="string">net.ipv6.conf.all.forwarding=1</span></span><br><span class="line"><span class="string">EOF&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl -p</span><br></pre></td></tr></table></figure>

<p>运行命令，开启wg0设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wg-quick up wg0</span><br></pre></td></tr></table></figure>

<p>如果一切顺利，那么运行下面命令你将看到类似的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant@bionic:~$ <span class="built_in">sudo</span> wg</span><br><span class="line">interface: wg0</span><br><span class="line">  public key: Td4IBZg2s2bMSjewD0h4oBhlbaJteygxjT83xeM7uTY=</span><br><span class="line">  private key: (hidden)</span><br><span class="line">  listening port: 51820</span><br></pre></td></tr></table></figure>

<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>客户端配置与服务端类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">Address = 10.10.0.2/32</span><br><span class="line">Address = fd86:ea04:1111::2/128</span><br><span class="line">SaveConfig = true</span><br><span class="line">PrivateKey = &lt;your client private key here&gt;</span><br><span class="line">DNS = 8.8.8.8</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = &lt;your server public key here&gt;</span><br><span class="line">Endpoint = &lt;your server public ip&gt;:51820</span><br><span class="line">AllowedIPs = 0.0.0.0/0, ::/0</span><br></pre></td></tr></table></figure>

<p>填写服务器的publickey、ip、端口，配置<code>0.0.0.0/0, ::/0</code>将所有流量传输到服务端</p>
<p>在服务端添加客户端配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wg <span class="built_in">set</span> wg0 peer &lt;client-public-key&gt; allowed-ips 10.10.0.2/32,fd86:ea04:1111::2/128</span><br></pre></td></tr></table></figure>

<p>以上的操作针对的是linux系统，官方推出了可用的iOS&#x2F;MacOS&#x2F;Android&#x2F;Windows图形界面软件，其中有一个选项要注意的是<code>On-Demand</code>，有<code>Ethernet</code>和<code>Wi-Fi</code>选项，如果勾选，那么会在选中网络中会自动开启vpn</p>
<h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><p>如果你的系统使用systemd,如ubuntu，设置wireguard开机启动命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> wg-quick@wg0</span><br></pre></td></tr></table></figure>

<h2 id="开放防火墙"><a href="#开放防火墙" class="headerlink" title="开放防火墙"></a>开放防火墙</h2><h3 id="UFW"><a href="#UFW" class="headerlink" title="UFW"></a>UFW</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 51820/udp</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.wireguard.com/">WireGuard: fast, modern, secure VPN tunnel</a><br><a href="https://securityespresso.org/tutorials/2019/03/22/vpn-server-using-wireguard-on-ubuntu/">How to setup your own VPN server using WireGuard on Ubuntu</a><br><a href="https://medium.com/@aveek/setting-up-pihole-wireguard-vpn-server-and-client-ubuntu-server-fc88f3f38a0a">Setting Up PiHole, Wireguard VPN server and Client (Ubuntu Server)</a></p>
]]></content>
      <tags>
        <tag>wireguard</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu上安装containerd和nerdctl</title>
    <url>/install-containerd-and-nerdctl-on-ubuntu24/</url>
    <content><![CDATA[<p>以<code>Ubuntu 24.04</code>为例，安装<code>nerdctl</code>以及<code>containerd</code></p>
<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><ul>
<li>安装uidmap</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install -y uidmap</span><br></pre></td></tr></table></figure>

<ul>
<li>AppArmor配置</li>
</ul>
<p>由于懒人安装方式跟单独安装方式bin目录不一致，配置内容会有些许差异，放在下面章节各自介绍</p>
<h3 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h3><ul>
<li><a href="https://github.com/containerd/nerdctl">nerdctl</a>（懒人安装下载nerdctl-full即可，该软件包已包含下方所列软件）</li>
<li><a href="https://github.com/containerd/containerd">containerd</a></li>
<li><a href="https://github.com/rootless-containers/rootlesskit">rootlesskit</a> &amp; <a href="https://github.com/rootless-containers/slirp4netns">slirp4netns</a></li>
<li><a href="https://github.com/moby/buildkit">buildkit</a></li>
<li><a href="https://github.com/containernetworking/cni">cni</a></li>
</ul>
<span id="more"></span>

<h2 id="懒人安装"><a href="#懒人安装" class="headerlink" title="懒人安装"></a>懒人安装</h2><p>解压缩<code>nerdctl-full-2.0.3-linux-amd64.tar.gz</code>到<code>~/.local</code>，并将<code>~/.local/bin</code>目录添加到<code>PATH</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxf nerdctl-full-2.0.3-linux-amd64.tar.gz -C ~/.local</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.local/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>看起来已完成安装，但还不行，当你执行<code>nerdctl</code>，这里将会看到一些报错，以下报错表示先需要安装运行rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nerdctl</span><br><span class="line"><span class="comment"># FATA[0000] rootless containerd not running? (hint: use `containerd-rootless-setuptool.sh install` to start rootless containerd): stat /run/user/1000/containerd-rootless: no such file or directory</span></span><br></pre></td></tr></table></figure>

<p>安装rootless containerd第一次尝试，以下报错是因为ubuntu 24.04加强了应用限制，需要通过AppArmor配置非特权用户命名空间应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br><span class="line"><span class="comment"># [INFO] Checking RootlessKit functionality</span></span><br><span class="line"><span class="comment"># [rootlesskit:parent] error: failed to start the child: fork/exec /proc/self/exe: operation not permitted</span></span><br><span class="line"><span class="comment"># [ERROR] RootlessKit failed, see the error messages and https://rootlesscontaine.rs/getting-started/common/ .</span></span><br></pre></td></tr></table></figure>

<p>配置apparmor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rootlesskit放在了~/.local/bin目录</span></span><br><span class="line">filename=$(<span class="built_in">echo</span> <span class="variable">$HOME</span>/.local/bin/rootlesskit | sed -e s@^/@@ -e s@/@.@g)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; ~/$&#123;filename&#125;</span></span><br><span class="line"><span class="string">abi &lt;abi/4.0&gt;,</span></span><br><span class="line"><span class="string">include &lt;tunables/global&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;$HOME/.local/bin/rootlesskit&quot; flags=(unconfined) &#123;</span></span><br><span class="line"><span class="string">  userns,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  include if exists &lt;local/$&#123;filename&#125;&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> ~/<span class="variable">$&#123;filename&#125;</span> /etc/apparmor.d/<span class="variable">$&#123;filename&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart apparmor.service</span><br></pre></td></tr></table></figure>

<p>安装并启动rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br><span class="line"></span><br><span class="line"><span class="comment"># [INFO] Checking RootlessKit functionality</span></span><br><span class="line"><span class="comment"># [INFO] Checking cgroup v2</span></span><br><span class="line"><span class="comment"># [INFO] Checking overlayfs</span></span><br><span class="line"><span class="comment"># [INFO] Requirements are satisfied</span></span><br><span class="line"><span class="comment"># [INFO] Creating &quot;/home/vagrant/.config/systemd/user/containerd.service&quot;</span></span><br><span class="line"><span class="comment"># [INFO] Starting systemd unit &quot;containerd.service&quot;</span></span><br><span class="line"><span class="comment"># + systemctl --user start containerd.service</span></span><br><span class="line"><span class="comment"># + sleep 3</span></span><br><span class="line"><span class="comment"># + systemctl --user --no-pager --full status containerd.service</span></span><br><span class="line"><span class="comment"># ● containerd.service - containerd (Rootless)</span></span><br><span class="line"><span class="comment">#      Loaded: loaded (/home/vagrant/.config/systemd/user/containerd.service; disabled; preset: enabled)</span></span><br><span class="line"><span class="comment">#      Active: active (running) since Sat 2025-02-08 09:10:49 CST; 3s ago</span></span><br><span class="line"><span class="comment">#    Main PID: 3535 (rootlesskit)</span></span><br><span class="line"><span class="comment">#       Tasks: 28</span></span><br><span class="line"><span class="comment">#      Memory: 15.2M (peak: 19.2M)</span></span><br><span class="line"><span class="comment">#         CPU: 287ms</span></span><br><span class="line"><span class="comment">#      CGroup: /user.slice/user-1000.slice/user@1000.service/app.slice/containerd.service</span></span><br><span class="line"><span class="comment">#              ├─3535 rootlesskit --state-dir=/run/user/1000/containerd-rootless --net=slirp4netns --mtu=65520 --slirp4netns-sandbox=auto --slirp4netns-seccomp=auto --disable-host-loopback --port-driver=builtin --copy-up=/etc --copy-up=/run --copy-up=/var/lib --propagation=rslave --detach-netns /home/vagrant/.local/bin/containerd-rootless.sh</span></span><br><span class="line"><span class="comment">#              ├─3553 /proc/self/exe --state-dir=/run/user/1000/containerd-rootless --net=slirp4netns --mtu=65520 --slirp4netns-sandbox=auto --slirp4netns-seccomp=auto --disable-host-loopback --port-driver=builtin --copy-up=/etc --copy-up=/run --copy-up=/var/lib --propagation=rslave --detach-netns /home/vagrant/.local/bin/containerd-rootless.sh</span></span><br><span class="line"><span class="comment">#              ├─3574 slirp4netns --mtu 65520 -r 3 --disable-host-loopback --enable-seccomp --userns-path=/proc/3553/ns/user --netns-type=path /proc/3553/root/run/user/1000/containerd-rootless/netns tap0</span></span><br><span class="line"><span class="comment">#              └─3582 containerd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684164811+08:00&quot; level=info msg=&quot;Start recovering state&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684269626+08:00&quot; level=info msg=serving... address=/run/containerd/containerd.sock</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684288884+08:00&quot; level=info msg=&quot;Start event monitor&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684345921+08:00&quot; level=info msg=&quot;Start cni network conf syncer for default&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684355097+08:00&quot; level=info msg=&quot;Start streaming server&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684362261+08:00&quot; level=info msg=&quot;Registered namespace \&quot;k8s.io\&quot; with NRI&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684406574+08:00&quot; level=info msg=&quot;runtime interface starting up...&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684412963+08:00&quot; level=info msg=&quot;starting plugins...&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684427341+08:00&quot; level=info msg=&quot;Synchronizing NRI (plugin) with current runtime state&quot;</span></span><br><span class="line"><span class="comment"># Feb 08 09:10:49 noble containerd-rootless.sh[3582]: time=&quot;2025-02-08T09:10:49.684492554+08:00&quot; level=info msg=&quot;containerd successfully booted in 0.037003s&quot;</span></span><br><span class="line"><span class="comment"># + systemctl --user enable containerd.service</span></span><br><span class="line"><span class="comment"># Created symlink /home/vagrant/.config/systemd/user/default.target.wants/containerd.service → /home/vagrant/.config/systemd/user/containerd.service.</span></span><br><span class="line"><span class="comment"># [INFO] Installed &quot;containerd.service&quot; successfully.</span></span><br><span class="line"><span class="comment"># [INFO] To control &quot;containerd.service&quot;, run: `systemctl --user (start|stop|restart) containerd.service`</span></span><br><span class="line"><span class="comment"># [INFO] To run &quot;containerd.service&quot; on system startup automatically, run: `sudo loginctl enable-linger vagrant`</span></span><br><span class="line"><span class="comment"># [INFO] ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># [INFO] Use `nerdctl` to connect to the rootless containerd.</span></span><br><span class="line"><span class="comment"># [INFO] You do NOT need to specify $CONTAINERD_ADDRESS explicitly.</span></span><br></pre></td></tr></table></figure>

<p>为<code>nerdctl build</code>安装并运行buildkit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nerdctl build</span></span><br><span class="line"><span class="comment"># ERRO[0000] `buildctl` needs to be installed and `buildkitd` needs to be running, see https://github.com/moby/buildkit , and `containerd-rootless-setuptool.sh install-buildkit` for OCI worker or `containerd-rootless-setuptool.sh install-buildkit-containerd` for containerd worker  error=&quot;failed to ping to host unix:///run/user/1000/buildkit-default/buildkitd.sock: exit status 1\nfailed to ping to host unix:///run/user/1000/buildkit/buildkitd.sock: exit status 1&quot;</span></span><br><span class="line"><span class="comment"># FATA[0000] no buildkit host is available, tried 2 candidates: failed to ping to host unix:///run/user/1000/buildkit-default/buildkitd.sock: exit status 1</span></span><br><span class="line"><span class="comment"># failed to ping to host unix:///run/user/1000/buildkit/buildkitd.sock: exit status 1</span></span><br><span class="line"></span><br><span class="line">containerd-rootless-setuptool.sh install-buildkit</span><br></pre></td></tr></table></figure>

<p>到这里，nerdctl以及containerd已经基本可用了</p>
<h2 id="单独安装"><a href="#单独安装" class="headerlink" title="单独安装"></a>单独安装</h2><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>安装containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxf /vagrant/containerd-2.0.2-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> ./bin/* /usr/local/bin/</span><br><span class="line"></span><br><span class="line">tree /usr/local/bin</span><br><span class="line"><span class="comment"># 输出如下所示</span></span><br><span class="line"><span class="comment"># /usr/local/bin</span></span><br><span class="line"><span class="comment"># ├── containerd</span></span><br><span class="line"><span class="comment"># ├── containerd-shim-runc-v2</span></span><br><span class="line"><span class="comment"># ├── containerd-stress</span></span><br><span class="line"><span class="comment"># └── ctr</span></span><br></pre></td></tr></table></figure>

<p>安装nerdctl</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装到/usr/local/bin/</span></span><br><span class="line"><span class="built_in">sudo</span> tar zxf nerdctl-2.0.3-linux-amd64.tar.gz -C /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">tree /usr/local/bin</span><br><span class="line"><span class="comment"># 输出如下所示</span></span><br><span class="line"><span class="comment"># /usr/local/bin</span></span><br><span class="line"><span class="comment"># ├── containerd</span></span><br><span class="line"><span class="comment"># ├── containerd-rootless-setuptool.sh</span></span><br><span class="line"><span class="comment"># ├── containerd-rootless.sh</span></span><br><span class="line"><span class="comment"># ├── containerd-shim-runc-v2</span></span><br><span class="line"><span class="comment"># ├── containerd-stress</span></span><br><span class="line"><span class="comment"># ├── ctr</span></span><br><span class="line"><span class="comment"># └── nerdctl</span></span><br></pre></td></tr></table></figure>

<p>安装rootlesskit以及slirp4netns</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装到/usr/local/bin/</span></span><br><span class="line"><span class="built_in">sudo</span> tar zxf rootlesskit-x86_64.tar.gz -C /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x slirp4netns</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> slirp4netns /usr/local/bin</span><br></pre></td></tr></table></figure>

<p>安装buildkit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxf buildkit-v0.19.0.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> ./bin/* /usr/local/bin/</span><br></pre></td></tr></table></figure>

<p>安装cni</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cni安装目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /opt/cni/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> tar zxf cni-plugins-linux-amd64-v1.6.2.tgz -C /opt/cni/bin/</span><br><span class="line"></span><br><span class="line">tree /opt/cni/bin</span><br><span class="line"><span class="comment"># /opt/cni/bin</span></span><br><span class="line"><span class="comment"># ├── LICENSE</span></span><br><span class="line"><span class="comment"># ├── README.md</span></span><br><span class="line"><span class="comment"># ├── bandwidth</span></span><br><span class="line"><span class="comment"># ├── bridge</span></span><br><span class="line"><span class="comment"># ├── dhcp</span></span><br><span class="line"><span class="comment"># ├── dummy</span></span><br><span class="line"><span class="comment"># ├── firewall</span></span><br><span class="line"><span class="comment"># ├── host-device</span></span><br><span class="line"><span class="comment"># ├── host-local</span></span><br><span class="line"><span class="comment"># ├── ipvlan</span></span><br><span class="line"><span class="comment"># ├── loopback</span></span><br><span class="line"><span class="comment"># ├── macvlan</span></span><br><span class="line"><span class="comment"># ├── portmap</span></span><br><span class="line"><span class="comment"># ├── ptp</span></span><br><span class="line"><span class="comment"># ├── sbr</span></span><br><span class="line"><span class="comment"># ├── static</span></span><br><span class="line"><span class="comment"># ├── tap</span></span><br><span class="line"><span class="comment"># ├── tuning</span></span><br><span class="line"><span class="comment"># ├── vlan</span></span><br><span class="line"><span class="comment"># └── vrf</span></span><br></pre></td></tr></table></figure>

<h3 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h3><p>执行<code>nerdctl</code>，报错需要安装运行rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nerdctl</span><br><span class="line"><span class="comment"># FATA[0000] rootless containerd not running? (hint: use `containerd-rootless-setuptool.sh install` to start rootless containerd): stat /run/user/1000/containerd-rootless: no such file or directory</span></span><br></pre></td></tr></table></figure>

<p>安装rootless containerd第一次尝试，报错表示需要配置AppArmor授权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br><span class="line"><span class="comment"># [INFO] Checking RootlessKit functionality</span></span><br><span class="line"><span class="comment"># [rootlesskit:parent] error: failed to start the child: fork/exec /proc/self/exe: operation not permitted</span></span><br><span class="line"><span class="comment"># [ERROR] RootlessKit failed, see the error messages and https://rootlesscontaine.rs/getting-started/common/ .</span></span><br></pre></td></tr></table></figure>

<p>配置apparmor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rootlesskit放在了/usr/local/bin目录</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOT | sudo tee &quot;/etc/apparmor.d/usr.local.bin.rootlesskit&quot;</span></span><br><span class="line"><span class="string">abi &lt;abi/4.0&gt;,</span></span><br><span class="line"><span class="string">include &lt;tunables/global&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/usr/local/bin/rootlesskit flags=(unconfined) &#123;</span></span><br><span class="line"><span class="string">  userns,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # Site-specific additions and overrides. See local/README for details.</span></span><br><span class="line"><span class="string">  include if exists &lt;local/usr.local.bin.rootlesskit&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOT</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart apparmor.service</span><br></pre></td></tr></table></figure>

<p>安装并启动rootless containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install</span><br></pre></td></tr></table></figure>

<p>为<code>nerdctl build</code>安装并运行buildkit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd-rootless-setuptool.sh install-buildkit</span><br></pre></td></tr></table></figure>

<p>完成安装！</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/containerd/nerdctl">nerdctl</a><br><a href="https://rootlesscontaine.rs/getting-started/common/">Common steps (Read first!)</a><br><a href="https://docs.docker.com/engine/security/rootless/">Rootless mode</a></p>
]]></content>
      <tags>
        <tag>containerd</tag>
        <tag>nerdctl</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s config和secret配置教程</title>
    <url>/k8s-config-and-secret-setup-tutorial/</url>
    <content><![CDATA[<p>简单的配置管理，可以把信息写入文件放在项目里，然后打包发布，但这样会有信息泄露的安全风险，经常会看到谁谁谁把项目上传到github，然后公司数据库&#x2F;敏感密钥泄漏等。所以，现在的公司一般会自建发布平台，通过发布平台管理配置，流程：配置修改-&gt;审核-&gt;发布。了解到这背景，我们就知道config跟secret在整个软件开发过程中扮演的角色，接下来就学习如何配置config&#x2F;secret并使用</p>
<blockquote>
<p>当然，一般情况下，配置管理没有那么简单，要考虑多种环境如dev&#x2F;test&#x2F;release以及地区区分，操作需小心谨慎，一不小心就出现遗漏、错配，此外，还有多人开发时配置冲突等，这些都是开发过程中要注意的问题</p>
</blockquote>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>以下展示configMap的简单配置，必须字段apiVersion、kind、metadata、data&#x2F;binaryData。data可以是key-value键值对，也可以是文件名-文件内容，数据的大小不能超过1MB，具体可以查看官网api描述文档</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># game-demo.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">game-demo</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># 1. key-value</span></span><br><span class="line">  <span class="attr">player_initial_lives:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">  <span class="attr">ui_properties_file_name:</span> <span class="string">&quot;user-interface.properties&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 2. filename-content</span></span><br><span class="line">  <span class="attr">game.properties:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    enemy.types=aliens,monsters</span></span><br><span class="line"><span class="string">    player.maximum-lives=5    </span></span><br><span class="line"><span class="string"></span>  <span class="attr">user-interface.properties:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    color.good=purple</span></span><br><span class="line"><span class="string">    color.bad=yellow</span></span><br><span class="line"><span class="string">    allow.textmode=true </span></span><br></pre></td></tr></table></figure>

<p>执行命令写入k8s，查看并验证配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入k8s</span></span><br><span class="line">kubectl apply -f game-demo.yam</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">kubectl get cm game-demo</span><br><span class="line"><span class="comment"># 查看config数据</span></span><br><span class="line">kubectl describe cm game-demo</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>有了配置信息，怎么搭配container使用？有4种使用方式可供参考</p>
<ol>
<li>在容器命令和参数内</li>
<li>容器的环境变量</li>
<li>在只读卷里面添加一个文件，让应用来读取</li>
<li>编写代码在 Pod 中运行，使用 Kubernetes API 来读取 ConfigMap</li>
</ol>
<p>以下启动一个pod，在启动时打印输出config信息，主要展示的是环境变量跟配置文件两种方式，也就是上面的2和3</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-demo-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">registry.noname.io:5000/alpine:3.20.1</span></span><br><span class="line">      <span class="attr">command:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">          echo $PLAYER_INITIAL_LIVES;</span></span><br><span class="line"><span class="string">          echo $UI_PROPERTIES_FILE_NAME;</span></span><br><span class="line"><span class="string">          ls -l /config/game.properties;</span></span><br><span class="line"><span class="string">          cat /config/game.properties;</span></span><br><span class="line"><span class="string">          ls -l /config/user-interface.properties;</span></span><br><span class="line"><span class="string">          cat /config/user-interface.properties;</span></span><br><span class="line"><span class="string"></span>      <span class="comment"># 方式2：configMap-&gt;环境变量</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="comment"># 定义环境变量</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PLAYER_INITIAL_LIVES</span>    <span class="comment"># 请注意这里和 ConfigMap 中的键名是不一样的</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">game-demo</span>           <span class="comment"># 这个值来自 ConfigMap</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">player_initial_lives</span> <span class="comment"># 需要取值的键</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">UI_PROPERTIES_FILE_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">game-demo</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">ui_properties_file_name</span></span><br><span class="line">      <span class="comment"># 方式3：configMap-&gt;文件</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">&quot;/config&quot;</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="comment"># 你可以在 Pod 级别设置卷，然后将其挂载到 Pod 内的容器中</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="comment"># ConfigMap的名字</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">game-demo</span></span><br><span class="line">      <span class="comment"># 指定key创建为path文件</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;game.properties&quot;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;game.properties&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;user-interface.properties&quot;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;user-interface.properties&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">kubectl apply -f configmap-demo-pod.yaml</span><br><span class="line"><span class="comment"># 查看configmap-demo-pod运行情况</span></span><br><span class="line">kubectl get pod | grep configmap-demo-pod</span><br><span class="line"><span class="comment"># pod是否有其他异常</span></span><br><span class="line">kubectl describe pod configmap-demo-pod</span><br><span class="line"><span class="comment"># 查看command输出日志</span></span><br><span class="line">kubectl logs configmap-demo-pod</span><br><span class="line"><span class="comment"># 清理config、pod</span></span><br><span class="line">kubectl delete -f game-demo.yaml</span><br><span class="line">kubectl delete -f configmap-demo-pod.yaml</span><br></pre></td></tr></table></figure>

<h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>secret的应用场景想到的只有数据库密码，如果真的要跟数据库其他配置分离也挺蛋疼的，以下简单展示如何使用</p>
<p>secret与config非常相似，有如下相同点</p>
<ol>
<li>key&#x2F;value 的形式</li>
<li>属于某个特定的 namespace</li>
<li>可以导出到环境变量</li>
<li>可以通过目录&#x2F;文件形式挂载 (支持挂载所有 key 和部分 key)</li>
</ol>
<p>不同点：</p>
<ol>
<li>secret 可以被 ServerAccount 关联 (使用)</li>
<li>secret 可以存储 register 的鉴权信息，用在 ImagePullSecret 参数中，用于拉取私有仓库的镜像</li>
<li>secret 支持 Base64 加密</li>
<li>secret 文件存储在 tmpfs 文件系统中，Pod删除后secret文件也会对应的删除</li>
</ol>
<p>配置secret</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dotfile-secret.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dotfile-secret</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">.secret-file:</span> <span class="string">dmFsdWUtMg0KDQo=</span></span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get secret dotfile-secret -o json | jq <span class="string">&#x27;.data | map_values(@base64d)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用secret，有以下几种方式</p>
<ol>
<li>作为挂载到一个或多个容器上的卷中的文件</li>
<li>作为容器的环境变量</li>
<li>由kubelet在为Pod拉取镜像时使用</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># secret-dotfiles-pod.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-dotfiles-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">dotfile-secret</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dotfile-test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">registry.noname.io:5000/alpine:3.20.1</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;-la&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;/etc/secret-volume&quot;</span></span><br><span class="line">      <span class="comment"># /etc/secret-volume/.secret-file</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">&quot;/etc/secret-volume&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">kubectl apply -f secret-dotfiles-pod.yaml</span><br><span class="line"><span class="comment"># 查看secret-dotfiles-pod运行情况</span></span><br><span class="line">kubectl get pod | grep secret-dotfiles-pod</span><br><span class="line"><span class="comment"># pod是否有其他异常</span></span><br><span class="line">kubectl describe pod secret-dotfiles-pod</span><br><span class="line"><span class="comment"># 查看command输出日志</span></span><br><span class="line">kubectl logs secret-dotfiles-pod</span><br><span class="line"><span class="comment"># 清理config、pod</span></span><br><span class="line">kubectl delete -f dotfile-secret.yaml</span><br><span class="line">kubectl delete -f secret-dotfiles-pod.yaml</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kubernetes.io/docs/concepts/configuration/configmap/">ConfigMaps</a><br><a href="https://kubernetes.io/docs/concepts/configuration/secret/">Secrets</a></p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s pv配置教程</title>
    <url>/k8s-pv-setup-tutorial/</url>
    <content><![CDATA[<p>在Kubernetes官网的学习教程：<a href="https://kubernetes.io/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/">wordpress</a>中，我尝试了手动创建pv并绑定pvc，但是每次申请pvc都要手动添加pv并绑定是一件很麻烦且很容易出错的事情，官方也早就意识到这个问题，提出了动态存储分配，只需要通过storageclass即可实现</p>
<p>本文使用了nfs作为集群存储用于实践，线上建议考虑使用ceph等分布式文件存储系统，nfs搭建教程参考：<a href="https://www.tecmint.com/install-nfs-server-on-ubuntu/">How to Install NFS Server and Client on Ubuntu 22.04</a></p>
<h2 id="安装nfs-provisioner"><a href="#安装nfs-provisioner" class="headerlink" title="安装nfs provisioner"></a>安装nfs provisioner</h2><ol>
<li>确认nfs服务器在集群节点中可以正常访问</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装客户端</span></span><br><span class="line"><span class="built_in">sudo</span> apt install nfs-common</span><br><span class="line"><span class="comment"># 执行命令挂载，确认可正常使用</span></span><br><span class="line"><span class="built_in">sudo</span> mount 192.168.0.105:/mnt/nfs_share /mnt/nfs_clientshare</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建一个目录如nfs-example，创建<code>kustomization.yaml</code>文件</li>
</ol>
<p>鉴于gfw的影响，建议下载github.com&#x2F;kubernetes-sigs&#x2F;nfs-subdir-external-provisioner仓库，并将deploy文件夹提取出来，里面主要是账户创建、角色绑定、命名空间、deployment等配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kustomization.yaml</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">nfs-provisioner</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="comment">#   - github.com/kubernetes-sigs/nfs-subdir-external-provisioner//deploy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./deploy</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建命名空间nfs-provisioner</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># namespace.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-provisioner</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="4">
<li>创建nfs deployment的patch，主要修改image地址、nfs信息，用于后续的合并</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># patch_nfs_details.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.noname.io:5000/sig-storage/nfs-subdir-external-provisioner:v4.0.2</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_SERVER</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&lt;YOUR_NFS_SERVER_IP&gt;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_PATH</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&lt;YOUR_NFS_SERVER_SHARE&gt;</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="string">&lt;YOUR_NFS_SERVER_IP&gt;</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&lt;YOUR_NFS_SERVER_SHARE&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>添加资源并发布</li>
</ol>
<p>汇总后的<code>kustomization.yaml</code>内容如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kustomization.yaml</span></span><br><span class="line">namespace: nfs-provisioner</span><br><span class="line">resources:</span><br><span class="line">  - ./deploy</span><br><span class="line">  - namespace.yaml</span><br><span class="line">patches:</span><br><span class="line">  - path: patch_nfs_details.yaml</span><br><span class="line">    target:</span><br><span class="line">      kind: Deployment</span><br><span class="line">      labelSelector: app=nfs-client-provisioner</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发布到集群中</span></span><br><span class="line">kubectl apply -k .</span><br><span class="line"><span class="comment"># 查看pod nfs-client-provisioner是否正常运行</span></span><br><span class="line">kubectl get pods -n nfs-provisioner</span><br></pre></td></tr></table></figure>

<p>到这里，基于nfs的动态存储分配基本可用</p>
<h2 id="wordpress实践"><a href="#wordpress实践" class="headerlink" title="wordpress实践"></a>wordpress实践</h2><p>从教程：<a href="https://kubernetes.io/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/">wordpress</a>下载相关yaml配置</p>
<p>修改<code>wordpress-deployment.yaml</code>以及<code>mysql-deployment.yaml</code>的pvc配置，在spec下添加<code>storageClassName: nfs-client</code></p>
<p>当然，如果不添加上述命令，可以将storageclass：nfs-client设置成默认，这样一来就不需要改任何配置了</p>
<h3 id="修改nfs-client为默认"><a href="#修改nfs-client为默认" class="headerlink" title="修改nfs-client为默认"></a>修改nfs-client为默认</h3><ol>
<li>通过patch修改</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch storageclass nfs-client -p <span class="string">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改storageclass的配置文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">storageclass.kubernetes.io/is-default-class:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>其他操作不再赘述，到这里就结束了</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol>
<li>chown: changing ownership of ‘&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;‘: Operation not permitted</li>
</ol>
<p>这是因为nfs需要添加<code>no_root_squash</code>权限，修改<code>/etc/exports</code>添加，这个权限太大，不适合线上使用</p>
<ol start="2">
<li>mount: &#x2F;mnt&#x2F;nfs_clientshare: bad option; for several filesystems (e.g. nfs, cifs) you might need a &#x2F;sbin&#x2F;mount.<type> helper program.</li>
</ol>
<p>节点没有安装nfs客户端导致的，安装nfs-common即可</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner">nfs-subdir-external-provisioner</a></p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ubuntu系统monospace字体显示异常的问题</title>
    <url>/linux-monofonts-render-incorrectly/</url>
    <content><![CDATA[<p>很长的一段时间，被xubuntu下的一个monospace字体显示问题困扰着，在网上找了很多方法也没有解决问题，在一次误打误撞的情况下解决了，简单把自己问题的过程记录下来，希望给一些小伙伴们帮助</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>xubuntu下monospace在浏览器以及vscode下显示异常，具体如下图所示</p>
<p>浏览器chrome&#x2F;firefox下的monospace</p>
<p><img src="/images/monofont_display_incorrect_in_browser.png" alt="monofont display incorrect in browser"></p>
<p>vscode下的monospace</p>
<p><img src="/images/monofont_display_incorrect_in_vscode.png" alt="monofont display incorrect in vscode"></p>
<p>网上搜索结果大部分指示，是由于libfreetype6 2.8.1-2ubuntu2的一个bug导致，需要升级到最新的libfreetype2.9或者降级到libfreetype2.8.0，按照搜索的文档进行libfreetype的升级&#x2F;降级后，显示效果依旧，问题没有得到解决</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>在我放弃治疗后过了一段时间，突然想起，一直以来都忽略了验证linux的字体信息。首先，获取显示异常的字体font-family，如下图</p>
<p><img src="/images/browser_get_font_family.png" alt="browser get font family"></p>
<p>使用fc-match验证字体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fc-match monospace</span><br><span class="line">DejaVuSansMono.ttf: <span class="string">&quot;DejaVu Sans Mono&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match consolas</span><br><span class="line">DejaVuSansMono.ttf: <span class="string">&quot;DejaVu Sans Mono&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match Menlo</span><br><span class="line">DejaVuSans.ttf: <span class="string">&quot;DejaVu Sans&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match <span class="string">&quot;PingFang SC&quot;</span></span><br><span class="line">DejaVuSans.ttf: <span class="string">&quot;DejaVu Sans&quot;</span> <span class="string">&quot;Book&quot;</span></span><br><span class="line"></span><br><span class="line">$ fc-match <span class="string">&quot;Microsoft YaHei&quot;</span></span><br><span class="line">NotoSansCJK-Regular.ttc: <span class="string">&quot;Noto Sans CJK SC&quot;</span> <span class="string">&quot;Regular&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到Menlo、”PingFang SC”、”Microsoft YaHei”的实际字体跟monospace并不一致，抱着死马当活马医的心态，编辑字体配置文件<code>~/.config/fontconfig/fonts.conf</code>，内容如下，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;fonts.dtd&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>Menlo<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prefer</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>DejaVu Sans Mono<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>退出，重新登录，发现这个困扰了很久的问题终于解决，如下图</p>
<p><img src="/images/monofont_the_correct_view.png" alt="monofont the correct view"></p>
<p>vscode可以通过更改font-family恢复正常的显示效果</p>
<p><strong>注意</strong></p>
<p>ubuntu&#x2F;xubuntu、中文&#x2F;英文的系统默认的字体会有些许差异，以上的操作可能不一定生效，可以新增<code>~/.config/fontconfig/conf.d/00-menlo.conf</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;fonts.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span> <span class="attr">binding</span>=<span class="string">&quot;same&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Menlo<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">accept</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>DejaVu Sans Mono<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">accept</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/adobe/brackets/issues/14290">[Ubuntu 18.04 LTS] Font not rendering properly</a><br><a href="https://stackoverflow.com/questions/50114376/ubuntu-18-04-lts-font-not-rendering-properly">Ubuntu 18.04 LTS Font not rendering properly</a><br><a href="https://superuser.com/questions/930572/why-doesnt-fc-match-respect-my-match-and-edit-rule-for-courier-when-it-does-for">Why doesn’t fc-match respect my match and edit rule for Courier when it does for Consolas?</a></p>
]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>vscode</tag>
        <tag>monospace fonts</tag>
      </tags>
  </entry>
  <entry>
    <title>使用github pages搭建个人博客</title>
    <url>/personal-blog-using-github-pages/</url>
    <content><![CDATA[<p>简单介绍如何使用github pages服务以及hexo搭建一个免费的个人博客</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个空的仓库，名字固定格式为“username.github.io”，这个名字也是博客的访问的域名</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli           <span class="comment"># 安装hexo命令行工具</span></span><br><span class="line">hexo init blog                    <span class="comment"># 创建blog项目</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next <span class="comment"># 安装next主题，可选</span></span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git --save <span class="comment"># 安装github发布工具</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><p>修改_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础配置</span></span><br><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Y2k38&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">y2k38&#x27;s</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">y2k38</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># URL </span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://y2k38.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 博客主题配置</span></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment"># 可选，若没有安装next主题，则忽略</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># github部署配置</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/Y2k38/y2k38.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment"># 注意，分支固定位master</span></span><br></pre></td></tr></table></figure>

<h3 id="发布github"><a href="#发布github" class="headerlink" title="发布github"></a>发布github</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>完成</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="添加gitalk评论系统"><a href="#添加gitalk评论系统" class="headerlink" title="添加gitalk评论系统"></a>添加gitalk评论系统</h3><blockquote>
<p>[Deprecated] github要求校验方式改为personal access token，待gitalk作者及theme-next作者更新</p>
</blockquote>
<p>新建OAuth application获取id、secret，<a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p>
<p><img src="/images/register_a_new_OAuth_application.png" alt="new oauth app"></p>
<p>配置next主题 <code>themes/next/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># Demo: https://gitalk.github.io</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/gitalk/gitalk, https://github.com/emn178/js-md5</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">y2k38</span> <span class="comment"># GitHub repo owner</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">y2k38.github.io</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">xxxxxxxxxxxxxxxx</span> <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">yyyyyyyyyyyyyyyy</span> <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">Y2k38</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://pages.github.com/">GitHub Pages</a><br><a href="https://gist.github.com/btfak/18938572f5df000ebe06fbd1872e4e39">How to use Hexo and deploy to GitHub Pages</a><br><a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line">Creating a personal access token for the command line</a></p>
]]></content>
      <tags>
        <tag>github pages</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - 类</title>
    <url>/php-extension-writing-classes/</url>
    <content><![CDATA[<p>以下简单介绍如何在C语言层面使用PHP类</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>创建一个PHP对象，对象类似关联数组，对象之上可关联任意多个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(makeObject) &#123;</span><br><span class="line">    object_init(return_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加属性</span></span><br><span class="line">    zend_update_property_string(<span class="literal">NULL</span>, return_value, <span class="string">&quot;prop1&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;prop1&quot;</span>), <span class="string">&quot;val1&quot;</span>);</span><br><span class="line">    zend_update_property_long(<span class="literal">NULL</span>, return_value, <span class="string">&quot;prop2&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;prop2&quot;</span>), <span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数并打印结果<code>var_dump(makeObject());</code>，输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">object(stdClass)#1 (2) &#123;</span><br><span class="line">    [<span class="string">&quot;prop1&quot;</span>]=&gt;</span><br><span class="line">    string(3) <span class="string">&quot;val1&quot;</span></span><br><span class="line">    [<span class="string">&quot;prop2&quot;</span>]=&gt;</span><br><span class="line">    int(123)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>创建一个类模板</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class定义存储于zend_class_entry</span></span><br><span class="line">zend_class_entry *test_ce_myclass;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_methods[] = &#123;</span><br><span class="line">    <span class="comment">// 类方法使用宏指令PHP_ME</span></span><br><span class="line">    <span class="comment">// public function hello()</span></span><br><span class="line">    PHP_ME(MyClass, hello, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC)</span><br><span class="line">    <span class="comment">// 与函数定义相同</span></span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主菜，注册并加载类</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_init_myclass</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    zend_class_entry ce;</span><br><span class="line">    INIT_CLASS_ENTRY(ce, <span class="string">&quot;MyClass&quot;</span>, test_methods);</span><br><span class="line">    <span class="comment">// 注册MyClass类</span></span><br><span class="line">    test_ce_myclass = zend_register_internal_class(&amp;ce);</span><br><span class="line">    <span class="comment">// 添加属性/常量等</span></span><br><span class="line">    <span class="comment">// public $success = true;</span></span><br><span class="line">    zend_declare_property_bool(test_ce_myclass, <span class="string">&quot;success&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;success&quot;</span>)<span class="number">-1</span>, <span class="number">1</span>, ZEND_ACC_PUBLIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法hello</span></span><br><span class="line">PHP_METHOD(MyClass, hello)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_STRING(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，函数<code>test_init_myclass</code>的最后一个参数<code>ZEND_ACC_PUBLIC</code>为访问控制标记之一公共访问，常用的访问控制标记还有以下几个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZEND_ACC_STATIC</span><br><span class="line">ZEND_ACC_PUBLIC</span><br><span class="line">ZEND_ACC_PROTECTED</span><br><span class="line">ZEND_ACC_PRIVATE</span><br><span class="line">ZEND_ACC_CTOR</span><br><span class="line">ZEND_ACC_DTOR</span><br><span class="line">ZEND_ACC_DEPRECATED</span><br></pre></td></tr></table></figure>

<p>一个class定义注册相关逻辑已经完成，要在PHP中使用类MyClass还需要在模块初始化<code>MINIT</code>中添加运行<code>test_init_myclass</code>以加载类MyClass</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    test_init_myclass();</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译<code>test</code>模块并开启后，运行<code>var_dump(new MyClass());</code>，将得到以下类似输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">object(MyClass)#1 (1) &#123;</span><br><span class="line">    [<span class="string">&quot;success&quot;</span>]=&gt;</span><br><span class="line">    bool(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以直接在C层面初始化并生成一个实例化类对象，增加一个工厂方法<code>factory</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_methods[] = &#123;</span><br><span class="line">    PHP_ME(MyClass, hello, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC)</span><br><span class="line">    PHP_ME(MyClass, factory, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)</span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PHP_METHOD(MyClass, factory)</span><br><span class="line">&#123;</span><br><span class="line">    object_init_ex(return_value, test_ce_myclass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们可以使用<code>MyClass::factory()</code>获取一个新的MyClass对象</p>
<p>如果需要对MyClass进行一些操作，像在PHP使用构造方法，在test_methods里添加<code>__construct</code>，如此，PHP在<code>new MyClass()</code>将自动调用构造方法<code>__construct</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_methods[] = &#123;</span><br><span class="line">    <span class="comment">// ZEND_ACC_CTOR</span></span><br><span class="line">    PHP_ME(MyClass, __construct, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)</span><br><span class="line">    PHP_ME(MyClass, hello, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC)</span><br><span class="line">    PHP_ME(MyClass, factory, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)</span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PHP_METHOD(MyClass, __construct)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h2><p>上面，虽然对象在new时会自动调用<code>__construct</code>函数进行初始化，但<code>factory</code>不会自动调用构造函数，仅返回包含默认值的新对象，为此，我们需要在<code>factory</code>内调用构造方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zend_interfaces.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">PHP_METHOD(MyClass, factory)</span><br><span class="line">&#123;</span><br><span class="line">    zval *myzval;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ZVAL(myzval)</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    object_init_ex(return_value, test_ce_myclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zend_call_method，其他的还有</span></span><br><span class="line">    <span class="comment">// zend_call_method_with_0_params</span></span><br><span class="line">    <span class="comment">// zend_call_method_with_1_params</span></span><br><span class="line">    <span class="comment">// zend_call_method_with_2_params</span></span><br><span class="line">    <span class="comment">// ZEND_API zval* zend_call_method(zval *object_pp, zend_class_entry *obj_ce, zend_function **fn_proxy, const char *function_name, size_t function_name_len, zval *retval, int param_count, zval* arg1, zval* arg2);</span></span><br><span class="line">    zend_call_method(return_value, test_ce_myclass, <span class="literal">NULL</span>, <span class="string">&quot;__construct&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;__construct&quot;</span>)<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">1</span>, myzval, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>先前我们已经了解函数返回值<code>return_value</code>的使用，现在，我们来看如何在方法内访问<code>$this</code>，PHP提供<code>getThis()</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_METHOD(MyClass, __construct)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *msg;</span><br><span class="line">    <span class="type">size_t</span> msg_len;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_STRING(msg, msg_len)</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    zend_update_property_string(test_ce_myclass, getThis(), <span class="string">&quot;msg&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;msg&quot;</span>)<span class="number">-1</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关联结构体"><a href="#关联结构体" class="headerlink" title="关联结构体"></a>关联结构体</h2><p>我们构建一个结构体，这个结构体在PHP是无法访问的，但可以在扩展内访问对该结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还不是特别了解</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">test_struct</span> &#123;</span></span><br><span class="line">    zend_object <span class="built_in">std</span>;</span><br><span class="line">    <span class="type">int</span> unknown_id;</span><br><span class="line">    <span class="type">char</span> *unknown_str;</span><br><span class="line">&#125; test_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_object *<span class="title function_">create_test_struct</span><span class="params">(zend_class_entry *class_type)</span> &#123;</span><br><span class="line">    test_struct *intern;</span><br><span class="line"></span><br><span class="line">    intern = ecalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(test_struct) + zend_object_properties_size(class_type));</span><br><span class="line"></span><br><span class="line">    zend_object_std_init(&amp;intern-&gt;<span class="built_in">std</span>, class_type);</span><br><span class="line">    object_properties_init(&amp;intern-&gt;<span class="built_in">std</span>, class_type);</span><br><span class="line"></span><br><span class="line">    intern-&gt;<span class="built_in">std</span>.handlers = zend_get_std_object_handlers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;intern-&gt;<span class="built_in">std</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_test_struct</span><span class="params">(<span class="type">void</span> *object)</span> &#123;</span><br><span class="line">    test_struct *secrets = (test_struct*)object;</span><br><span class="line">    <span class="keyword">if</span> (secrets-&gt;unknown_str) &#123;</span><br><span class="line">        efree(secrets-&gt;unknown_str);</span><br><span class="line">    &#125;</span><br><span class="line">    efree(secrets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问结构体<code>test_struct</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_METHOD(MyClass, attachStruct) &#123;</span><br><span class="line">    test_struct *secrets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    secrets = (test_struct*)getThis();</span><br><span class="line"></span><br><span class="line">    RETURN_LONG(secrets-&gt;unknown_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>PHP的异常继承自<code>Exception</code>，所以下面除了新增一个异常类，还涉及了类的继承</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zend_exceptions.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">zend_class_entry *test_ce_exception;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_init_exception</span><span class="params">()</span> &#123;</span><br><span class="line">    zend_class_entry ce;</span><br><span class="line">    <span class="comment">// 设置第三个参数为NULL，继承Exception所有方法，无自定义行为</span></span><br><span class="line">    INIT_CLASS_ENTRY(ce, <span class="string">&quot;MyException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    test_ce_exception = zend_register_internal_class_ex(&amp;ce, (zend_class_entry*)zend_exception_get_default());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    test_init_myclass();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    test_init_exception();</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法&#x2F;函数中抛出异常</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_METHOD(MyClass, throwExcept) &#123;</span><br><span class="line">    zend_throw_exception(test_ce_exception, <span class="string">&quot;custom exception throw&quot;</span>, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/Y2k38/php_ext_tutorial">php_ext_tutorial</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/bigbes/bigbes.github.io/wiki/PHP-Extensions-Made-Eldrich:-Classes">PHP Extensions Made Eldrich: Classes</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - Part 1</title>
    <url>/php-extension-writing-part1/</url>
    <content><![CDATA[<p>在网上找到几篇基于PHP5的扩展开发的文章，有些古老，与PHP7不完全兼容，自己做了些简单的翻译、修改。</p>
<p>建议开发者先阅读<a href="http://www.phpinternalsbook.com/">PHP Internals Book</a>这份在线文档，里面对PHP做了比较全面的讲解。由于PHP扩展开发的资料比较少，也鲜有PHP开发者触及到这块，编写扩展时如果遇到问题，最好是先查找PHP源代码是否有相关的使用案例，再通过网上论坛、QQ等方式寻求帮助。</p>
<p>本文是PHP扩展开发系列的第一篇，主要介绍如何开发一个简单的PHP扩展、如何获取ini配置参数、如何配置全局变量</p>
<p>前期准备：</p>
<p>PHP编译选项加入<code>--enable-debug</code>以及<code>--enable-maintainer-zts</code>。<code>--enable-debug</code>生成额外的调试符号，并将优化等级设置为<code>-O0</code>，报告内存泄露等错误，使使用gdb进行debug时更为准确；<code>--enable-maintainer-zts</code>启用线程安全，开启<code>ZTS</code>宏定义，配置PHP为TSRM机制，用于编写调试多线程代码</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="扩展目录结构"><a href="#扩展目录结构" class="headerlink" title="扩展目录结构"></a>扩展目录结构</h3><p>你可能会使用PHP源代码自带的脚本<code>ext/ext_skel.php</code>生成扩展骨架，但这里选择极简方式创建一个扩展，最基本的扩展只需要三个文件：配置文件<code>config.m4</code>，头文件<code>php_test.h</code>，源文件<code>test.c</code></p>
<p><code>test</code>扩展目录结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php-7.4.1</span><br><span class="line">└── ext</span><br><span class="line">    └── <span class="built_in">test</span></span><br><span class="line">        ├── config.m4</span><br><span class="line">        ├── php_test.h</span><br><span class="line">        └── test.c</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnl 用于生成configure及其他文件</span><br><span class="line">dnl `dnl`开头的行为注释内容</span><br><span class="line">dnl 若扩展依赖外部库，使用--with，否则默认使用--enable</span><br><span class="line">PHP_ARG_ENABLE(test, whether to enable test support,</span><br><span class="line">[  --enable-test          Enable test support], no)</span><br><span class="line"></span><br><span class="line">if test &quot;$PHP_TEST&quot; != &quot;no&quot;; then</span><br><span class="line">  AC_DEFINE(HAVE_TEST, 1, [ Have test support ])</span><br><span class="line">  PHP_NEW_EXTENSION(test, test.c, $ext_shared)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>头文件默认格式为<code>php_extname.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PHP_TEST_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PHP_TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PHP扩展结构zend_module_entry */</span></span><br><span class="line"><span class="keyword">extern</span> zend_module_entry test_module_entry;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> phpext_test_ptr &amp;test_module_entry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* version扩展版本号 */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PHP_TEST_VERSION <span class="string">&quot;0.1.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义函数声明PHP_FUNCTION(your_function_name) */</span></span><br><span class="line">PHP_FUNCTION(test);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ZTS) &amp;&amp; defined(COMPILE_DL_TEST)</span></span><br><span class="line">ZEND_TSRMLS_CACHE_EXTERN()</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_CONFIG_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php_test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义函数注册，最终*test_functions注册到模块声明test_module_entry */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry test_functions[] = &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 注册`test`函数，格式为PHP_FE(func_name, arg_info)，arg_info声明参数信息，如是否是引用等，这里先忽略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PHP_FE(test, <span class="literal">NULL</span>)</span><br><span class="line">    PHP_FE_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块注册 */</span></span><br><span class="line">zend_module_entry test_module_entry = &#123;</span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,                    <span class="comment">/* 扩展名称 */</span></span><br><span class="line">    test_functions,            <span class="comment">/* 自定义函数注册 */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_MINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_RINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_RSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* PHP_MINFO */</span></span><br><span class="line">    PHP_TEST_VERSION,          <span class="comment">/* version */</span></span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数test */</span></span><br><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_STRING(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_DL_TEST</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ZTS</span></span><br><span class="line">ZEND_TSRMLS_CACHE_DEFINE()</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">ZEND_GET_MODULE(test)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line"><span class="comment"># 除非config.m4有改动，否则只执行以下命令</span></span><br><span class="line">make &amp;&amp; <span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在<code>php.ini</code>添加<code>extension=test.so</code>，执行脚本获取输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;echo test();&quot;</span> <span class="comment"># 输出：Hello World</span></span><br></pre></td></tr></table></figure>

<h2 id="INI参数"><a href="#INI参数" class="headerlink" title="INI参数"></a>INI参数</h2><p>Zend Engine提供了两种方式访问ini参数，以下是第一种较为简单的方式，第二种方式与全局变量搭配使用，后面介绍</p>
<p>我们在PHP的声明周期MINIT阶段注册ini参数，在<code>php_test.h</code>添加MINIT原型声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test模块初始化</span></span><br><span class="line">PHP_MINIT_FUNCTION(test);</span><br><span class="line"><span class="comment">// test模块关闭清理函数</span></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(test);</span><br></pre></td></tr></table></figure>

<p><code>test.c</code>做以下调整，注册MINIT，init参数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php_ini.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">zend_module_entry test_module_entry = &#123;</span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    test_functions,</span><br><span class="line">    PHP_MINIT(test),      <span class="comment">/* 注册MINIT */</span></span><br><span class="line">    PHP_MSHUTDOWN(test),  <span class="comment">/* 注册MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    PHP_TEST_VERSION,</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ini参数获取代码块</span></span><br><span class="line">PHP_INI_BEGIN()</span><br><span class="line">    <span class="comment">// ini参数test.foo声明</span></span><br><span class="line">    PHP_INI_ENTRY(<span class="string">&quot;test.foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, PHP_INI_ALL, <span class="literal">NULL</span>)</span><br><span class="line">PHP_INI_END();</span><br><span class="line"><span class="comment">// 以上宏等同于声明zend_ini_entry_def[]变量</span></span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    REGISTER_INI_ENTRIES();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    UNREGISTER_INI_ENTRIES();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_STRING(INI_STR(<span class="string">&quot;test.foo&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ini参数声明放置在<code>PHP_INI_BEGIN</code>、<code>PHP_INI_END</code>，参数声明使用宏<code>PHP_INI_ENTRY</code>，具体格式为<code>PHP_INI_ENTRY(param_name, default_val, access_mode_modifier, validator)</code></p>
<p><code>access_mode_modifier</code>决定ini参数可在什么地方被修改，主要有</p>
<ul>
<li>PHP_INI_ALL: 值可通过php.ini、.htaccess、ini_set修改</li>
<li>PHP_INI_SYSTEM: 只可通过php.ini修改</li>
<li>PHP_INI_PERDIR: 只可通过.htaccess修改</li>
</ul>
<p><code>validator</code>校验这里先忽略</p>
<p>ini参数值获取方式如下</p>
<table>
<thead>
<tr>
<th align="left">当前值local value</th>
<th align="left">默认值master value</th>
<th align="left">返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INI_STR</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">char *</td>
</tr>
<tr>
<td align="left">INI_INT</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">zend_long</td>
</tr>
<tr>
<td align="left">INI_FLT</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">INI_BOOL</td>
<td align="left">INI_ORIG_STR</td>
<td align="left">zend_bool</td>
</tr>
</tbody></table>
<p>配置PHP，在<code>php.ini</code>添加<code>test.foo=helloworld</code>，执行脚本获取输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;echo test();&quot;</span> <span class="comment"># 输出：helloworld</span></span><br></pre></td></tr></table></figure>

<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>上面部分的ini参数获取代码有几个问题，第一，每次读取ini参数值时，都需要系统扫描ini设置表，并转换成相应的类型；第二，没有校验用户输入，这样用户使用<code>ini_set</code>可以设置任意数据</p>
<p>我们可以配置ini参数到全局变量，避免每次扫描ini设置表，在这之前，先看看如何使用全局变量编写一个计数器</p>
<p>头文件<code>php_test.h</code>添加全局变量声明，并定义一个宏来访问我们的全局变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;TSRM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line">ZEND_BEGIN_MODULE_GLOBALS(test)</span><br><span class="line">    <span class="type">long</span> counter;</span><br><span class="line">ZEND_END_MODULE_GLOBALS(test)</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 上面代码等同</span></span><br><span class="line"><span class="comment"> * typedef struct _zend_pib_globals &#123;</span></span><br><span class="line"><span class="comment"> *     long counter;</span></span><br><span class="line"><span class="comment"> * &#125; zend_test_globals;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 TEST_G - 全局变量访问 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TEST_G(v) TSRMG(test_globals_id, zend_test_globals *, v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TEST_G(v) (test_globals.v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请求初始化 */</span></span><br><span class="line">PHP_MINIT_FUNCTION(test);</span><br></pre></td></tr></table></figure>

<p>源文件初始化全局变量，MINIT只会在进程或线程创建时执行一次，而一个进程可以服务多个请求，我们需要计数器在每个请求开始时清零，需要RINIT函数清零counter</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化zend_test_globals */</span></span><br><span class="line">ZEND_DECLARE_MODULE_GLOBALS(test)</span><br><span class="line"><span class="comment">/* 等同于 zend_test_globals test_globals; */</span></span><br><span class="line"></span><br><span class="line">zend_module_entry test_module_entry = &#123;</span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    test_functions,</span><br><span class="line">    PHP_MINIT(test),</span><br><span class="line">    PHP_MSHUTDOWN(test),</span><br><span class="line">    PHP_RINIT(test),     <span class="comment">/* 注册请求初始化函数 */</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    PHP_TEST_VERSION,</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量初始化，仅在进程/线程创建时初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_init_globals</span><span class="params">(zend_test_globals *test_globals)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求初始化</span></span><br><span class="line">PHP_RINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 因一个进程可服务多个请求，我们需要每个请求都有独立的counter */</span></span><br><span class="line">    TEST_G(counter) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化</span></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 全局变量表注册 */</span></span><br><span class="line">    ZEND_INIT_MODULE_GLOBALS(test, php_test_init_globals, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    REGISTER_INI_ENTRIES();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行PHP脚本获取输出验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;test(); echo test();&quot;</span> <span class="comment"># 输出：2</span></span><br></pre></td></tr></table></figure>

<h2 id="INI注册全局变量"><a href="#INI注册全局变量" class="headerlink" title="INI注册全局变量"></a>INI注册全局变量</h2><p>有了上面的认识，在这里，将ini参数<code>test.direction</code>注册到全局变量，并添加validator校验</p>
<p>头文件添加参数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZEND_BEGIN_MODULE_GLOBALS(test)</span><br><span class="line">    <span class="type">long</span> counter;</span><br><span class="line">    zend_bool direction;</span><br><span class="line">ZEND_END_MODULE_GLOBALS(test)</span><br></pre></td></tr></table></figure>

<p>源文件修改为以下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_INI_BEGIN()</span><br><span class="line">    PHP_INI_ENTRY(<span class="string">&quot;test.foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, PHP_INI_ALL, <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">// STD_PHP_INI_ENTRY(name, default_value, modifiable, on_modify, property_name, struct_type, struct_ptr)</span></span><br><span class="line">    STD_PHP_INI_ENTRY(<span class="string">&quot;test.direction&quot;</span>, <span class="string">&quot;1&quot;</span>, PHP_INI_ALL, OnUpdateBool, direction, zend_test_globals, test_globals)</span><br><span class="line">PHP_INI_END();</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_init_globals</span><span class="params">(zend_test_globals *test_globals)</span> &#123;</span><br><span class="line">    <span class="comment">/* direction初始化，0|1 */</span></span><br><span class="line">    test_globals-&gt;direction = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TEST_G(direction)) &#123;</span><br><span class="line">        TEST_G(counter)++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TEST_G(counter)--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RETURN_LONG(TEST_G(counter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>STD_PHP_INI_ENTRY</code>可以使用更多参数，这里我们将参数写入全局变量<code>test_globals</code>。关联第四个参数<code>on_modify</code>校验输入值，如果成功，写入到全局变量，默认为<code>onUpdateLongGEZero</code>，其他的宏还有<code>OnUpdateLong</code>、<code>OnUpdateBool</code>、<code>OnUpdateReal</code>、<code>OnUpdateString</code>、<code>OnUpdateStringUnempty</code></p>
<p>配置PHP，在<code>php.ini</code>添加<code>test.direction=0</code>，执行脚本获取输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&quot;echo test();&quot;</span> <span class="comment"># 输出：-1</span></span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/Y2k38/php_ext_tutorial">php_ext_tutorial</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://stackoverflow.com/questions/3632160/how-to-make-a-php-extension">How to make a PHP extension</a><br><a href="https://wiki.php.net/phpng-upgrading">Upgrading PHP extensions from PHP5 to NG</a><br><del><a href="https://devzone.zend.com/303/extension-writing-part-i-introduction-to-php-and-zend/">Extension Writing Part I: Introduction to PHP and Zend (已失效)</a></del><br><a href="https://github.com/bigbes/bigbes.github.io/wiki/Extension-Writing-Part-I:-Introduction-to-PHP-and-Zend">Extension Writing Part I: Introduction to PHP and Zend</a><br><a href="http://www.phpinternalsbook.com/">PHP Internals Book</a><br><a href="https://wiki.php.net/internals/references">References about Maintaining and Extending PHP</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - Part 2</title>
    <url>/php-extension-writing-part2/</url>
    <content><![CDATA[<p>PHP扩展开发第二章，主要介绍函数参数获取、zval数据类型、数组及数组遍历以及$GLOBALS全局变量访问</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>扩展自定义函数不需要声明形参，Zend Engine会给每个函数传递一个参数列表<code>zend_execute_data *execute_data</code>，函数参数通过宏块<code>ZEND_PARSE_PARAMETERS_START</code>、<code>ZEND_PARSE_PARAMETERS_END</code>获取，当然，旧的方法<code>zend_parse_parameters</code>也可以使用，只是会更麻烦点</p>
<p>下面示例函数将接收参数name以及打印的次数t_param并打印name</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数1</span></span><br><span class="line">    zend_string *name;</span><br><span class="line">    <span class="comment">// 参数2</span></span><br><span class="line">    zend_long t_param = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> times = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低可接收1个参数，最多2个</span></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name)</span><br><span class="line">        Z_PARAM_OPTIONAL</span><br><span class="line">        <span class="title function_">Z_PARAM_LONG</span><span class="params">(t_param)</span></span><br><span class="line">    <span class="title function_">ZEND_PARSE_PARAMETERS_END</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有传递默认值</span></span><br><span class="line">    <span class="keyword">if</span> (ZEND_NUM_ARGS() == <span class="number">2</span>) &#123;</span><br><span class="line">        times = (<span class="type">int</span>) (t_param &lt; <span class="number">1</span> ? <span class="number">1</span> : t_param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        php_printf(<span class="string">&quot;Hello %s&quot;</span>, ZSTR_VAL(name));</span><br><span class="line">    &#125;</span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用的有数据类型以及参数获取方法有下</p>
<table>
<thead>
<tr>
<th align="left">Variable Type</th>
<th align="left">Macro</th>
</tr>
</thead>
<tbody><tr>
<td align="left">zend_bool</td>
<td align="left">Z_PARAM_BOOL</td>
</tr>
<tr>
<td align="left">zend_long</td>
<td align="left">Z_PARAM_LONG</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Z_PARAM_DOUBLE</td>
</tr>
<tr>
<td align="left">zend_string *</td>
<td align="left">Z_PARAM_STR</td>
</tr>
<tr>
<td align="left">char *</td>
<td align="left">Z_PARAM_STRING</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_RESOURCE</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_ARRAY</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_OBJECT</td>
</tr>
<tr>
<td align="left">zval *</td>
<td align="left">Z_PARAM_ZVAL</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="ZVAL结构"><a href="#ZVAL结构" class="headerlink" title="ZVAL结构"></a>ZVAL结构</h2><p>PHP7的zval相对PHP5做了比较大的改动，zval、zend_string、zend_array重构，bool类型分成了true、false两种类型直接存储在(zval).u1.type_info等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// php7 zval变量结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">zend_value</span> &#123;</span></span><br><span class="line">    zend_long         lval;                <span class="comment">/* long value */</span></span><br><span class="line">    <span class="type">double</span>            dval;                <span class="comment">/* double value */</span></span><br><span class="line">    zend_refcounted  *counted;</span><br><span class="line">    zend_string      *str;</span><br><span class="line">    zend_array       *arr;</span><br><span class="line">    zend_object      *obj;</span><br><span class="line">    zend_resource    *res;</span><br><span class="line">    zend_reference   *ref;</span><br><span class="line">    zend_ast_ref     *ast;</span><br><span class="line">    zval             *zv;</span><br><span class="line">    <span class="type">void</span>             *ptr;</span><br><span class="line">    zend_class_entry *ce;</span><br><span class="line">    zend_function    *func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> w1;</span><br><span class="line">        <span class="type">uint32_t</span> w2;</span><br><span class="line">    &#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">    zend_value        value;            <span class="comment">/* value */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_3(</span><br><span class="line">                zend_uchar    type,            <span class="comment">/* active type */</span></span><br><span class="line">                zend_uchar    type_flags,</span><br><span class="line">                <span class="keyword">union</span> &#123;</span><br><span class="line">                    <span class="type">uint16_t</span>  extra;        <span class="comment">/* not further specified */</span></span><br><span class="line">                &#125; u)</span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="type">uint32_t</span> type_info;</span><br><span class="line">    &#125; u1;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line">        <span class="type">uint32_t</span>     cache_slot;           <span class="comment">/* cache slot (for RECV_INIT) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     opline_num;           <span class="comment">/* opline number (for FAST_CALL) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">        <span class="type">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">        <span class="type">uint32_t</span>     access_flags;         <span class="comment">/* class constant access flags */</span></span><br><span class="line">        <span class="type">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line">        <span class="type">uint32_t</span>     constant_flags;       <span class="comment">/* constant flags */</span></span><br><span class="line">        <span class="type">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>zval类型判断，一般情况下，如果参数与<code>Z_PARAM_*</code>的类型不一致，Zend Engine会进行转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收任意类型参数，最后输出其类型</span></span><br><span class="line">PHP_FUNCTION(test_type)</span><br><span class="line">&#123;</span><br><span class="line">    zval *uservar;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ZVAL(uservar);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (Z_TYPE_P(uservar)) &#123;</span><br><span class="line">        <span class="keyword">case</span> IS_NULL:</span><br><span class="line">            php_printf(<span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_TRUE:</span><br><span class="line">            php_printf(<span class="string">&quot;Boolean: TRUE&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_FALSE:</span><br><span class="line">            php_printf(<span class="string">&quot;Boolean: FALSE&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_LONG:</span><br><span class="line">            php_printf(<span class="string">&quot;Long: %ld&quot;</span>, Z_LVAL_P(uservar));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_DOUBLE:</span><br><span class="line">            php_printf(<span class="string">&quot;Double: %f&quot;</span>, Z_DVAL_P(uservar));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_STRING:</span><br><span class="line">            php_printf(<span class="string">&quot;String: &quot;</span>);</span><br><span class="line">            PHPWRITE(Z_STRVAL_P(uservar), Z_STRLEN_P (uservar));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_RESOURCE:</span><br><span class="line">            php_printf(<span class="string">&quot;Resource&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">            php_printf(<span class="string">&quot;Array&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">            php_printf(<span class="string">&quot;Object&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            php_printf(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印数组内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_again)</span><br><span class="line">&#123;</span><br><span class="line">    zval *zname;</span><br><span class="line">    </span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ZVAL(zname);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将改变原有参数类型</span></span><br><span class="line">    convert_to_string(zname);</span><br><span class="line">    php_printf(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">    PHPWRITE(Z_STRVAL_P(zname), Z_STRLEN_P(zname));</span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_to_*</code>会将参数转换成指定的类型，即改变原始参数类型、数据，在php代码中，原本以传参的形式传递的变量值会被修改。要解决这个问题，可以使用临时变量，也可以使用<code>convert_to_*_ex</code>，该类函数在转换类型前会先调用<code>SEPARATE_ZVAL_IF_NOT_REF</code>，避免修改原始变量</p>
<h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><p>PHP的数组用途非常广泛，类对象属性的存储也依赖数组，数组的底层实现结构为HashTable</p>
<p>下面函数创建一个数据并返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_array)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// $arr = [];</span></span><br><span class="line">    array_init(return_value);</span><br><span class="line">    <span class="comment">// $arr[3] = 123;</span></span><br><span class="line">    add_index_long(return_value, <span class="number">3</span>, <span class="number">123</span>);</span><br><span class="line">    <span class="comment">// $arr[] = &quot;example&quot;;</span></span><br><span class="line">    add_next_index_string(return_value, <span class="string">&quot;example&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *mystr = estrdup(<span class="string">&quot;five&quot;</span>);</span><br><span class="line">    add_next_index_string(return_value, mystr);</span><br><span class="line">    efree(mystr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $arr[&quot;pi&quot;] = 3.1415926;</span></span><br><span class="line">    add_assoc_double(return_value, <span class="string">&quot;pi&quot;</span>, <span class="number">3.1415926</span>);</span><br><span class="line">    </span><br><span class="line">    zval subarr;</span><br><span class="line">    array_init(&amp;subarr);</span><br><span class="line">    add_next_index_string(&amp;subarr, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    add_assoc_zval(return_value, <span class="string">&quot;subarr&quot;</span>, &amp;subarr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>add_next_index_*</code>添加元素进数组，由系统分配一个递增的数字key</li>
<li><code>add_index_*</code>添加元素进数组，由用户指定一个数字类型的key</li>
<li><code>add_assoc_*</code>添加元素进数组，由用户指定的字符串类型key</li>
</ul>
<p>注意：<code>add_assoc_*</code>非二进制安全</p>
<p>扩展函数返回值不使用<code>return</code>语句，配置<code>zval *return_value</code>即可，该变量由宏<code>PHP_FUNCTION</code>提供，返回值<code>RETURN_TRUE</code>也是通过设置<code>return_value</code>完成返回值赋值，默认设置为<code>IS_NULL</code>类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历并打印数组字符串值</span></span><br><span class="line">PHP_FUNCTION(test_array_strings)</span><br><span class="line">&#123;</span><br><span class="line">    zval *arr, *data;</span><br><span class="line">    HashTable *arr_hash;</span><br><span class="line">    HashPosition pointer;</span><br><span class="line">    <span class="type">int</span> array_count;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ARRAY(arr);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    arr_hash = Z_ARRVAL_P(arr);</span><br><span class="line">    array_count = zend_hash_num_elements(arr_hash);</span><br><span class="line"></span><br><span class="line">    php_printf(<span class="string">&quot;The array passed contains %d elements\n&quot;</span>, array_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 可使用宏ZEND_HASH_FOREACH_VAL、ZEND_HASH_FOREACH_END</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">        zend_hash_internal_pointer_reset_ex(arr_hash, &amp;pointer);</span><br><span class="line">        data = zend_hash_get_current_data_ex(arr_hash, &amp;pointer);</span><br><span class="line">        zend_hash_move_forward_ex(arr_hash, &amp;pointer)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// example 1</span></span><br><span class="line">        <span class="comment">// 如果是字符串就打印</span></span><br><span class="line">        <span class="comment">// if (Z_TYPE_P(data) == IS_STRING) &#123;</span></span><br><span class="line">        <span class="comment">//     PHPWRITE(Z_STRVAL_P(data), Z_STRLEN_P(data));</span></span><br><span class="line">        <span class="comment">//     php_printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// example 2</span></span><br><span class="line">        <span class="comment">// 将参数转为字符串打印</span></span><br><span class="line">        <span class="comment">// zval tmp;</span></span><br><span class="line">        <span class="comment">// tmp = *data;</span></span><br><span class="line">        <span class="comment">// zval_copy_ctor(&amp;tmp);</span></span><br><span class="line">        <span class="comment">// convert_to_string(&amp;tmp);</span></span><br><span class="line">        <span class="comment">// PHPWRITE(Z_STRVAL(tmp), Z_STRLEN(tmp));</span></span><br><span class="line">        <span class="comment">// php_printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// zval_dtor(&amp;tmp);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// example 3</span></span><br><span class="line">        <span class="comment">// 打印数组key以及value</span></span><br><span class="line">        <span class="type">int</span> keytype;</span><br><span class="line">        zend_string * str_index;</span><br><span class="line">        zend_ulong num_index;</span><br><span class="line"></span><br><span class="line">        keytype = zend_hash_get_current_key_ex(arr_hash, &amp;str_index, &amp;num_index, &amp;pointer);</span><br><span class="line">        <span class="keyword">if</span> (HASH_KEY_IS_STRING == keytype) &#123;</span><br><span class="line">            <span class="comment">// 字符串类型key</span></span><br><span class="line">            PHPWRITE(ZSTR_VAL(str_index), ZSTR_LEN(str_index));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HASH_KEY_IS_LONG == keytype) &#123;</span><br><span class="line">            <span class="comment">// 数字key</span></span><br><span class="line">            php_printf(<span class="string">&quot;%ld&quot;</span>, num_index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        php_printf(<span class="string">&quot; =&gt; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        zval tmp;</span><br><span class="line">        tmp = *data;</span><br><span class="line">        zval_copy_ctor(&amp;tmp);</span><br><span class="line">        convert_to_string(&amp;tmp);</span><br><span class="line">        PHPWRITE(Z_STRVAL(tmp), Z_STRLEN(tmp));</span><br><span class="line">        php_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        zval_dtor(&amp;tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zend_hash_get_current_key_ex</code>返回的类型有</p>
<ul>
<li><code>HASH_KEY_IS_LONG</code>：整型key</li>
<li><code>HASH_KEY_IS_STRING</code>：字符串型key</li>
<li><code>HASH_KEY_NON_EXISTENT</code>：遍历完整个数组，没有更多元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印数组val</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_array_walk</span><span class="params">(zval *pDest)</span></span><br><span class="line">&#123;</span><br><span class="line">    zval tmp;</span><br><span class="line"></span><br><span class="line">    tmp = *pDest;</span><br><span class="line">    zval_copy_ctor(&amp;tmp);</span><br><span class="line">    convert_to_string(&amp;tmp);</span><br><span class="line">    PHPWRITE(Z_STRVAL(tmp), Z_STRLEN(tmp));</span><br><span class="line">    php_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    zval_dtor(&amp;tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印prefix以及数组val</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_array_walk_arg</span><span class="params">(zval *pDest, <span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_printf(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span> *)argument);</span><br><span class="line">    test_array_walk(pDest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印prefix、数组val以及suffix</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_array_walk_args</span><span class="params">(zval *pDest, <span class="type">int</span> num_args, va_list args, zend_hash_key *hash_key)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_printf(<span class="string">&quot;%s&quot;</span>, va_arg(args, <span class="type">char</span> *));</span><br><span class="line">    test_array_walk(pDest);</span><br><span class="line">    php_printf(<span class="string">&quot;%s\n&quot;</span>, va_arg(args, <span class="type">char</span> *));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line">PHP_FUNCTION(test_array_walk)</span><br><span class="line">&#123;</span><br><span class="line">    zval *arr;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_ARRAY(arr);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的遍历数组处理</span></span><br><span class="line">    zend_hash_apply(Z_ARRVAL_P(arr), (<span class="type">apply_func_t</span>) test_array_walk);</span><br><span class="line">    <span class="comment">// 遍历数组，带一个参数</span></span><br><span class="line">    zend_hash_apply_with_argument(Z_ARRVAL_P(arr), (<span class="type">apply_func_arg_t</span>) test_array_walk_arg, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历数组，带多个参数</span></span><br><span class="line">    zend_hash_apply_with_arguments(Z_ARRVAL_P(arr), (<span class="type">apply_func_args_t</span>) test_array_walk_args, <span class="number">2</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;Welcome to my extension!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>test_array_walk</code>类似<code>array_map</code>，<code>test_array_walk</code>简单遍历数组，<code>test_array_walk_arg</code>遍历数组，可接收一个任意类型的额外参数，下面代码中用作数组元素的前缀，<code>test_array_walk_args</code>遍历数组，可接收任意多个参数，下面代码中用作数组元素的前缀、后缀</p>
<p>返回值类型：</p>
<ul>
<li><code>ZEND_HASH_APPLY_KEEP</code>：维持原有元素，继续遍历数组剩余元素</li>
<li><code>ZEND_HASH_APPLY_REMOVE</code>：删除原有元素，继续遍历数组剩余元素</li>
<li><code>ZEND_HASH_APPLY_STOP</code>：维持原有元素，停止遍历数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回数组指定key的value</span></span><br><span class="line">PHP_FUNCTION(test_array_value)</span><br><span class="line">&#123;</span><br><span class="line">    zval *arr, *offset, *val;</span><br><span class="line">    <span class="type">char</span> * tmp;</span><br><span class="line">    zend_string *str_index = <span class="literal">NULL</span>;</span><br><span class="line">    zend_ulong num_index;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_ARRAY(arr);</span><br><span class="line">        Z_PARAM_ZVAL(offset);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对非integer/string的key进行转换</span></span><br><span class="line">    <span class="keyword">switch</span> (Z_TYPE_P(offset)) &#123;</span><br><span class="line">        <span class="keyword">case</span> IS_NULL:</span><br><span class="line">        <span class="keyword">case</span> IS_FALSE:</span><br><span class="line">            num_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_TRUE:</span><br><span class="line">            num_index = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_DOUBLE:</span><br><span class="line">            num_index = (<span class="type">long</span>) Z_DVAL_P(offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_LONG:</span><br><span class="line">        <span class="keyword">case</span> IS_RESOURCE:</span><br><span class="line">            num_index = Z_LVAL_P(offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_STRING:</span><br><span class="line">            str_index = zval_get_string(offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">            tmp = <span class="string">&quot;Array&quot;</span>;</span><br><span class="line">            str_index = zend_string_init(tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">            tmp = <span class="string">&quot;Object&quot;</span>;</span><br><span class="line">            str_index = zend_string_init(tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            tmp = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">            str_index = zend_string_init(tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str_index &amp;&amp; (val = zend_hash_find(Z_ARRVAL_P(arr), str_index)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!str_index &amp;&amp; (val = zend_hash_index_find(Z_ARRVAL_P(arr), num_index)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *return_value = *val;</span><br><span class="line">    zval_copy_ctor(return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PHP7中zval在栈分配，函数执行完清理，需要深入复制一份给return_value</p>
<h2 id="Symbol-Tables"><a href="#Symbol-Tables" class="headerlink" title="Symbol Tables"></a>Symbol Tables</h2><p>全局变量$GLOBALS的底层存储结构也是HashTable，存储在一个全局结构体Executor Globals(_zend_executor_globals)里，通过EG(symbol_table)访问相关数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问全局变量$GLOBALS</span></span><br><span class="line">PHP_FUNCTION(test_get_global_var)</span><br><span class="line">&#123;</span><br><span class="line">    zval *val;</span><br><span class="line">    zend_string *varname;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_STR(varname);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局变量符号表：EG(symbol_table)</span></span><br><span class="line">    <span class="keyword">if</span> ((val = zend_hash_find(&amp;EG(symbol_table), varname)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_NOTICE, <span class="string">&quot;Undefined variable: %s&quot;</span>, ZSTR_VAL(varname));</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *return_value = *val;</span><br><span class="line">    zval_copy_ctor(return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/Y2k38/php_ext_tutorial">php_ext_tutorial</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><del><a href="https://devzone.zend.com/317/extension-writing-part-ii-parameters-arrays-and-zvals/">Extension Writing Part II: Parameters, Arrays, and ZVALs (Unable To Access)</a></del><br><del><a href="https://devzone.zend.com/318/extension-writing-part-ii-parameters-arrays-and-zvals-continued/">Extension Writing Part II: Parameters, Arrays, and ZVALs [continued] (Unable To Access)</a></del><br><a href="https://github.com/bigbes/bigbes.github.io/wiki/Extension-Writing-Part-II:-Parameters,-Arrays,-and-ZVALs">Extension Writing Part II: Parameters, Arrays, and ZVALs</a><br><a href="https://wiki.php.net/phpng-upgrading">Upgrading PHP extensions from PHP5 to NG</a><br><a href="http://www.phpinternalsbook.com/">PHP Internals Book</a><br><a href="https://wiki.php.net/internals/references">References about Maintaining and Extending PHP</a><br><a href="https://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html">Internal value representation in PHP 7 - Part 1 </a><br><a href="https://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html">Internal value representation in PHP 7 - Part 2</a><br><a href="https://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html">PHP’s new hashtable implementation</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP扩展开发 - Part 3</title>
    <url>/php-extension-writing-part3/</url>
    <content><![CDATA[<p>本文将简单介绍资源类型、资源的创建、访问、销毁操作。不再建议使用资源类型，使用类更为合适</p>
<h2 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h2><p><code>zval</code>可以表示大部分的PHP数据类型，但有一样不能很好的表示其结构：指针。由于不透明的结构、无法使用传统运算符进行操作等，使得指针在PHP的表示变得困难。因此PHP用一个特殊的标记表示指针：资源，为了使资源标记具有意义，必须先注册到zend engine才能使用。</p>
<p>在头文件定义结构体<code>php_test_person</code>以及资源名称，放置在<code>#define</code>语句后，<code>PHP_MINIT_FUNCTION(test);</code>之前</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    zend_string *name;</span><br><span class="line">    zend_long age;</span><br><span class="line">&#125; php_test_person;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHP_TEST_PERSON_RES_NAME <span class="string">&quot;Person Data&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>源文件定义<code>le_*</code>全局变量，MINIT阶段注册，用于获取资源类型、字面意义名称、析构函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> le_test_person;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    le_test_person = zend_register_list_destructors_ex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="初始化资源"><a href="#初始化资源" class="headerlink" title="初始化资源"></a>初始化资源</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_new)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person * person;</span><br><span class="line">    zend_string * name;</span><br><span class="line">    zend_long age;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name);</span><br><span class="line">        Z_PARAM_LONG(age);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_WARNING, <span class="string">&quot;Nonsense age (%ld) given, person resource not created.&quot;</span>, age);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    person = emalloc(<span class="keyword">sizeof</span>(php_test_person));</span><br><span class="line">    person-&gt;name = zend_string_copy(name); <span class="comment">// estrndup + zend_string =&gt; zend_string_copy</span></span><br><span class="line">    person-&gt;age = age;</span><br><span class="line"></span><br><span class="line">    RETURN_RES(zend_register_resource(person, le_test_person));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数接收参数name以及age，参数进行校验通过后，申请一段内存空间并写入数据，<code>return_value</code>返回该资源。PHP不需要知道资源的具体内部表示，只需要获取该资源存储的指针以及资源类型</p>
<h2 id="函数接收资源参数"><a href="#函数接收资源参数" class="headerlink" title="函数接收资源参数"></a>函数接收资源参数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_greet)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person *person;</span><br><span class="line">    zval *zperson;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_RESOURCE(zperson);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    person = (php_test_person *) zend_fetch_resource_ex(zperson, PHP_TEST_PERSON_RES_NAME, le_test_person);</span><br><span class="line"></span><br><span class="line">    php_printf(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">    PHPWRITE(ZSTR_VAL(person-&gt;name), ZSTR_LEN(person-&gt;name));</span><br><span class="line">    php_printf(<span class="string">&quot;!\nAccording to my records, you are %ld years old.\n&quot;</span>, person-&gt;age);</span><br><span class="line"></span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ZEND_FETCH_RESOURCE</code>在PHP7中已被删除，目前获取资源的函数是<code>zend_fetch_resource</code>、<code>zend_fetch_resource_ex</code>。<code>zend_fetch_resource_ex</code>函数需要一个zval、字面意义名称、资源类型，返回一个指针。函数内部切记不要<code>free</code>该指针</p>
<h2 id="销毁资源"><a href="#销毁资源" class="headerlink" title="销毁资源"></a>销毁资源</h2><p>在PHP中使用<code>fopen</code>打开文件并获得一个资源句柄<code>$fp</code>，接下来<code>unset($fp)</code>时文件被关闭，即使没有使用<code>fclose</code>函数。其中的奥秘在<code>zend_register_list_destructors_ex</code>，该函数第一个参数为常规资源的析构函数，第二个为持久化资源的析构函数，当离开资源变量所在作用域时，自动调用清理&#x2F;析构函数，释放内存、关闭连接或执行其他清理操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">le_test_person = zend_register_list_destructors_ex(php_test_person_dtor, <span class="literal">NULL</span>, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_person_dtor</span><span class="params">(zend_resource *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_test_person *person = (php_test_person *) res-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (person) &#123;</span><br><span class="line">        <span class="keyword">if</span> (person-&gt;name) &#123;</span><br><span class="line">            zend_string_release(person-&gt;name); <span class="comment">// efree zend_string =&gt; zend_string_release</span></span><br><span class="line">        &#125;</span><br><span class="line">        efree(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强制销毁资源"><a href="#强制销毁资源" class="headerlink" title="强制销毁资源"></a>强制销毁资源</h2><p>使用<code>zend_list_delete</code>销毁资源，该函数可销毁任何资源类型变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_delete)</span><br><span class="line">&#123;</span><br><span class="line">    zval * zperson;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        Z_PARAM_RESOURCE(zperson);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    zend_list_delete(Z_RES_P(zperson));</span><br><span class="line"></span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="持久化资源"><a href="#持久化资源" class="headerlink" title="持久化资源"></a>持久化资源</h2><p>持久化资源与常规资源不同的地方在析构函数声明注册的位置，数据内存申请使用<code>pemalloc</code>代替<code>emalloc</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> le_test_person_persist;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">    le_test_person = zend_register_list_destructors_ex(php_test_person_dtor, <span class="literal">NULL</span>, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line">    le_test_person_persist = zend_register_list_destructors_ex(<span class="literal">NULL</span>, php_test_person_persist_dtor, PHP_TEST_PERSON_RES_NAME, module_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，<code>php_test_person_dtor</code>会在请求结束后调用，<code>php_test_person_persist_dtor</code>在扩展shutdown阶段调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">php_test_person_persist_dtor</span><span class="params">(zend_resource *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    php_test_person *person = (php_test_person *) res-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (person) &#123;</span><br><span class="line">        <span class="keyword">if</span> (person-&gt;name) &#123;</span><br><span class="line">            zend_string_release(person-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">        pefree(person, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_pnew)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person * person;</span><br><span class="line">    zend_string * name;</span><br><span class="line">    zend_long age;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name);</span><br><span class="line">        Z_PARAM_LONG(age);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_WARNING, <span class="string">&quot;Nonsense age (%ld) given, person resource not created.&quot;</span>, age);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    person = pemalloc(<span class="keyword">sizeof</span>(php_test_person), <span class="number">1</span>);</span><br><span class="line">    person-&gt;name = zend_string_dup(name, <span class="number">1</span>);</span><br><span class="line">    person-&gt;age = age;</span><br><span class="line"></span><br><span class="line">    RETURN_RES(zend_register_resource(person, le_test_person_persist));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>test_person_pnew</code>与<code>test_person_new</code>仅在数据初始化、资源类型方面有差异</p>
<h2 id="查找已存在的持久化资源"><a href="#查找已存在的持久化资源" class="headerlink" title="查找已存在的持久化资源"></a>查找已存在的持久化资源</h2><p>为了可以重用持久化资源，需要将其保存在一个安全的地方，zend engine提供了一个executor global通过<code>EG(persistent_list)</code>访问，该变量类型为<code>HashTable</code></p>
<p>重新修改t<code>est_person_pnew</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(test_person_pnew2)</span><br><span class="line">&#123;</span><br><span class="line">    php_test_person * person;</span><br><span class="line">    <span class="type">char</span> * key_raw;</span><br><span class="line">    <span class="type">size_t</span> key_len;</span><br><span class="line">    zend_string * name, * key;</span><br><span class="line">    zend_long age;</span><br><span class="line">    zval * zperson = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        Z_PARAM_STR(name);</span><br><span class="line">        Z_PARAM_LONG(age);</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span>, E_WARNING, <span class="string">&quot;Nonsense age (%ld) given, person resource not created.&quot;</span>, age);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key_len = spprintf(&amp;key_raw, <span class="number">0</span>, <span class="string">&quot;test_person_%s_%ld\n&quot;</span>, ZSTR_VAL(name), age);</span><br><span class="line">    key = zend_string_init(key_raw, key_len, <span class="number">1</span>);</span><br><span class="line">    efree(key_raw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((zperson = zend_hash_find(&amp;EG(persistent_list), key)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        person = (php_test_person *) zend_fetch_resource_ex(zperson, PHP_TEST_PERSON_RES_NAME, le_test_person_persist);</span><br><span class="line"></span><br><span class="line">        ZVAL_RES(return_value, zend_register_persistent_resource_ex(key, person, le_test_person_persist));</span><br><span class="line">        zend_string_release(key);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    person = pemalloc(<span class="keyword">sizeof</span>(php_test_person), <span class="number">1</span>);</span><br><span class="line">    person-&gt;name = zend_string_copy(name);</span><br><span class="line">    person-&gt;age = age;</span><br><span class="line"></span><br><span class="line">    ZVAL_RES(return_value, zend_register_persistent_resource_ex(key, person, le_test_person_persist));</span><br><span class="line">    zend_string_release(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>test_person_pnew2</code>先确定<code>EG(persistent_list)</code>是否已经存在，已存在则直接使用，不存在则申请内存初始化资源</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><del><a href="https://devzone.zend.com/446/extension-writing-part-iii-resources/">Extension Writing Part III: Resources</a></del><br><a href="https://github.com/bigbes/bigbes.github.io/wiki/Extension-Writing-Part-III:-Resources">Extension Writing Part III: Resources</a><br><a href="https://wiki.php.net/phpng-upgrading">Upgrading PHP extensions from PHP5 to NG</a><br><a href="http://www.phpinternalsbook.com/">PHP Internals Book</a><br><a href="https://wiki.php.net/internals/references">References about Maintaining and Extending PHP</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>php extension</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-定时器Timer和Ticker</title>
    <url>/golang-series-timer-and-ticker/</url>
    <content><![CDATA[<p>Timer-一次性定时器，Ticker-周期性定时器。从1.23版本开始，将异步实现改为同步实现，但你仍然可以使用AfterFunc创建异步定时器，或者通过改变asynctimerchan变量启用异步实现</p>
<p>asynctimerchan变量可选项如下</p>
<table>
<thead>
<tr>
<th align="left">asynctimerchan</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">同步实现，从1.23版本开始启用</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">旧版异步实现</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">同1，异步实现，但修复了1的问题，debug用</td>
</tr>
</tbody></table>
<p>定时器的精确度因系统不同而不同，具体如下</p>
<table>
<thead>
<tr>
<th align="left">OS</th>
<th align="left">resolution</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Unix</td>
<td align="left">~1ms</td>
</tr>
<tr>
<td align="left">&gt;&#x3D; Windows 1803</td>
<td align="left">~0.5ms</td>
</tr>
<tr>
<td align="left">&lt; Windows 1803</td>
<td align="left">~16ms</td>
</tr>
</tbody></table>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>深入了解源代码前，先了解其功能如何使用</p>
<h3 id="Timer-一次性定时器"><a href="#Timer-一次性定时器" class="headerlink" title="Timer-一次性定时器"></a>Timer-一次性定时器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定时器1</span></span><br><span class="line">    timer1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    &lt;-timer1.C</span><br><span class="line">    fmt.Println(<span class="string">&quot;Timer 1 fired&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器2</span></span><br><span class="line">    timer2 := time.NewTimer(time.Second)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-timer2.C</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer 2 fired&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    stop2 := timer2.Stop()</span><br><span class="line">    <span class="keyword">if</span> stop2 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer 2 stopped&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器3</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例代码运行效果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># Timer 1 fired</span></span><br><span class="line"><span class="comment"># Timer 2 stopped</span></span><br></pre></td></tr></table></figure>

<h3 id="Ticker-周期性定时器"><a href="#Ticker-周期性定时器" class="headerlink" title="Ticker-周期性定时器"></a>Ticker-周期性定时器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 每500ms执行一次</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Tick at&quot;</span>, t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起休眠1600ms</span></span><br><span class="line">    time.Sleep(<span class="number">1600</span> * time.Millisecond)</span><br><span class="line">    <span class="comment">// 停止定时器</span></span><br><span class="line">    ticker.Stop()</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Ticker stopped&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例代码运行效果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tick at 2025-02-27 10:41:07.875146141 +0800 CST m=+0.500099485</span></span><br><span class="line"><span class="comment"># Tick at 2025-02-27 10:41:08.37515345 +0800 CST m=+1.000100767</span></span><br><span class="line"><span class="comment"># Tick at 2025-02-27 10:41:08.875159521 +0800 CST m=+1.500100789</span></span><br><span class="line"><span class="comment"># Ticker stopped</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>time.Timer以及time.Ticker数据结构同源，在实际运行时都会转换成runtime的timeTimer，数据结构的字段释义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/time/sleep.go</span></span><br><span class="line"><span class="comment">// time.Timer结构，可以忽略，实际使用会转换成runtime的timeTimer</span></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    C         &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    initTimer <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/time/tick.go</span></span><br><span class="line"><span class="comment">// time.Ticker，可以忽略，实际使用会转换成runtime的timeTimer</span></span><br><span class="line"><span class="keyword">type</span> Ticker <span class="keyword">struct</span> &#123;</span><br><span class="line">    C          &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    initTicker <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time.go</span></span><br><span class="line"><span class="comment">// 下面几个数据结构才是实际使用的</span></span><br><span class="line"><span class="keyword">type</span> timeTimer <span class="keyword">struct</span> &#123;</span><br><span class="line">    c     unsafe.Pointer            <span class="comment">// channel</span></span><br><span class="line">    init  <span class="type">bool</span>                      <span class="comment">// 是否已经初始化</span></span><br><span class="line">    timer                           <span class="comment">// 具体看下方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu        mutex                 <span class="comment">// 锁，保护以下所有字段</span></span><br><span class="line">    astate    atomic.Uint8          <span class="comment">// state字段的复制，modify以及unlock时复制</span></span><br><span class="line">    state     <span class="type">uint8</span>                 <span class="comment">// 状态位，具体见后面的列表</span></span><br><span class="line">    isChan    <span class="type">bool</span>                  <span class="comment">// 同步还是异步（go1.23开始设置为true，除非自己设置asynctimerchan）</span></span><br><span class="line">    isFake    <span class="type">bool</span>                  <span class="comment">// 测试用</span></span><br><span class="line">    blocked   <span class="type">uint32</span>                <span class="comment">// 阻塞在channel中的G数量</span></span><br><span class="line">    when      <span class="type">int64</span>                 <span class="comment">// 目标过期时刻</span></span><br><span class="line">    period    <span class="type">int64</span>                 <span class="comment">// 时长-周期性定时器使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数f内部不能出现阻塞，默认为sendTime，也可以是goroutineReady或用户自定义函数</span></span><br><span class="line">    f         <span class="function"><span class="keyword">func</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span></span><br><span class="line">    <span class="comment">// 当与netpoll一起使用时</span></span><br><span class="line">    <span class="comment">// arg是*pollDesc</span></span><br><span class="line">    <span class="comment">// seq是版本计数器，类似时间戳，确保过期的消息不会被处理，stop以及modify时自增</span></span><br><span class="line">    <span class="comment">// 当作为time包时</span></span><br><span class="line">    <span class="comment">// arg是一个channel（After/NewTicker）或一个函数（AfterFunc）</span></span><br><span class="line">    <span class="comment">// seq同上，但没有使用</span></span><br><span class="line">    arg       any                   <span class="comment">// 见上方解释</span></span><br><span class="line">    seq       <span class="type">uintptr</span>               <span class="comment">// 版本计数器</span></span><br><span class="line"></span><br><span class="line">    ts        *timers               <span class="comment">// 判断timer属于哪个P</span></span><br><span class="line">    </span><br><span class="line">    sendLock  mutex                 <span class="comment">// 用于channel加锁（go1.23开始启用）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于处理运行定时器和停止/重置定时器的冲突检测</span></span><br><span class="line">    <span class="comment">// 只用于同步定时器（isChan == true），周期性定时器不可用</span></span><br><span class="line">    <span class="comment">// 发送数据到channel时isSending++，发送后isSending--</span></span><br><span class="line">    <span class="comment">// t.mu加锁             =&gt; isSending可自增</span></span><br><span class="line">    <span class="comment">// t.sendLock加锁       =&gt; isSending可自减</span></span><br><span class="line">    <span class="comment">// t.mu、t.sendLock加锁 =&gt; 数据只读</span></span><br><span class="line">    isSending atomic.Int32          <span class="comment">// 见上方解释</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆及其元数据，该结构放在p数据结构里（每个P一个timers）</span></span><br><span class="line"><span class="keyword">type</span> timers <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu              mutex           <span class="comment">// 锁，保护下面字段，因为其他P的G可以访问当前P的timers</span></span><br><span class="line">    heap            []timerWhen     <span class="comment">// 最小堆，用于存储timer，按heap[i].when排序</span></span><br><span class="line">    <span class="built_in">len</span>             atomic.Uint32   <span class="comment">// 最小堆中的元素数量 =&gt; len(heap)</span></span><br><span class="line">    zombies         atomic.Int32    <span class="comment">// 最小堆中，timer.state设置了timerZombie位的定时器数量</span></span><br><span class="line">    raceCtx         <span class="type">uintptr</span>         <span class="comment">// 冲突检测用，忽略</span></span><br><span class="line">    minWhenHeap     atomic.Int64    <span class="comment">// 最小堆中的最小when（=heap[0].when），为0时表示heap为空</span></span><br><span class="line">    minWhenModified atomic.Int64    <span class="comment">// 最小堆中的最小when，但仅限timer.state设置了timerModified位的定时器</span></span><br><span class="line">    syncGroup       *synctestGroup  <span class="comment">// 测试用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器及其过期时刻</span></span><br><span class="line"><span class="keyword">type</span> timerWhen <span class="keyword">struct</span> &#123;</span><br><span class="line">    timer *timer                    <span class="comment">// 定时器指针</span></span><br><span class="line">    when  <span class="type">int64</span>                     <span class="comment">// 目标过期时刻</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>timer的state状态总共占用3个位，如下所示</p>
<table>
<thead>
<tr>
<th align="left">state_name</th>
<th align="left">state_value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">timerHeaped</td>
<td align="left">1</td>
<td align="left">定时器已经放在某个P的timers最小堆中</td>
</tr>
<tr>
<td align="left">timerModified</td>
<td align="left">2</td>
<td align="left">t.when被修改但还没更新heap[i].when，如果定时器不在heap，忽略</td>
</tr>
<tr>
<td align="left">timerZombie</td>
<td align="left">4</td>
<td align="left">定时器被停止，但还放在heap里，可以跟timerModified位共存。定时器为zombie时可以发送数据到channel，因为数据不会被读取</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>timerModified和timerZombie的前提都是timerHeaped</li>
<li>无法直接把timer移除出timers.heap，因为别的P可能已经拿到了这个timer</li>
<li>timer有这几个状态位意味着最小堆还没有重新调整，timer还放在之前的位置上（不满足最小堆）</li>
</ol>
<h2 id="创建定时器"><a href="#创建定时器" class="headerlink" title="创建定时器"></a>创建定时器</h2><h3 id="NewTimer-NewTicker"><a href="#NewTimer-NewTicker" class="headerlink" title="NewTimer &amp; NewTicker"></a>NewTimer &amp; NewTicker</h3><p>创建&#x2F;获取定时器，过期时刻为当前时刻加目标时长</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span></span> *Timer &#123;</span><br><span class="line">    <span class="comment">// channel，有缓冲</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    t := (*Timer)(newTimer(when(d), <span class="number">0</span>, sendTime, c, syncTimer(c)))</span><br><span class="line">    <span class="comment">// 定时器绑定channel</span></span><br><span class="line">    t.C = c</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTicker</span><span class="params">(d Duration)</span></span> *Ticker &#123;</span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;non-positive interval for NewTicker&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// channel，有缓冲</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    t := (*Ticker)(unsafe.Pointer(newTimer(when(d), <span class="type">int64</span>(d), sendTime, c, syncTimer(c))))</span><br><span class="line">    <span class="comment">// 定时器绑定channel</span></span><br><span class="line">    t.C = c</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建定时器time.Timer或time.Ticker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTimer</span><span class="params">(when, period <span class="type">int64</span>, f <span class="keyword">func</span>(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span>, arg any, c *hchan) *timeTimer &#123;</span><br><span class="line">    t := <span class="built_in">new</span>(timeTimer)</span><br><span class="line">    <span class="comment">// mu/f/arg参数初始化，这里传nil，后面用t.modify修改</span></span><br><span class="line">    t.timer.init(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;new&quot;</span>)</span><br><span class="line">    <span class="comment">// 同步定时器（go1.23开始默认启用），初始化sendLock、isChan</span></span><br><span class="line">    <span class="keyword">if</span> c != <span class="literal">nil</span> &#123;</span><br><span class="line">        lockInit(&amp;t.sendLock, lockRankTimerSend)</span><br><span class="line">        t.isChan = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 双向绑定</span></span><br><span class="line">        c.timer = &amp;t.timer</span><br><span class="line">        <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;invalid timer channel: no capacity&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> gr := getg().syncGroup; gr != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.isFake = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line">    t.modify(when, period, f, arg, <span class="number">0</span>)</span><br><span class="line">    t.init = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取定时器触发时刻</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">when</span><span class="params">(d Duration)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 时长不能为负</span></span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> runtimeNano()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    t := runtimeNano() + <span class="type">int64</span>(d)</span><br><span class="line">    <span class="comment">// 溢出时，设置为最大值math.MaxInt64</span></span><br><span class="line">    <span class="keyword">if</span> t &lt; <span class="number">0</span> &#123;</span><br><span class="line">        t = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把目标触发时刻发送给channel，定时器过期时调用</span></span><br><span class="line"><span class="comment">// 目前有maybeRunAsync、unlockAndRun、maybeRunChan在使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendTime</span><span class="params">(c any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// delta =&gt; 实际触发时刻-目标触发时刻</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c.(<span class="keyword">chan</span> Time) &lt;- Now().Add(Duration(-delta)):</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取同步定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncTimer</span><span class="params">(c <span class="keyword">chan</span> Time)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// async，go1.22及之前版本</span></span><br><span class="line">    <span class="keyword">if</span> asynctimerchan.Value() == <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">        asynctimerchan.IncNonDefault()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sync，go1.23及以后，返回channel的指针</span></span><br><span class="line">    <span class="comment">// asynctimerchan=2作用同asynctimerchan=1，修复了旧版问题，用于debug</span></span><br><span class="line">    <span class="keyword">return</span> *(*unsafe.Pointer)(unsafe.Pointer(&amp;c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化timer的mu/f/arg字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> init(f <span class="function"><span class="keyword">func</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span>, arg any) &#123;</span><br><span class="line">    lockInit(&amp;t.mu, lockRankTimer)</span><br><span class="line">    t.f = f</span><br><span class="line">    t.arg = arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line"><span class="comment">// 一般是netpoll、time.Ticker.Reset、time.Timer.Reset调用。该方法修改的是timer的when/period/f/arg/seq字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> modify(when, period <span class="type">int64</span>, f <span class="function"><span class="keyword">func</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span>, arg any, seq <span class="type">uintptr</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line">    <span class="keyword">if</span> when &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;timer when must be positive&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> period &lt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;timer period must be non-negative&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是异步还是同步定时器（go1.23开始默认是同步定时器）</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 防止重复发送数据到channel</span></span><br><span class="line">        lock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 异步定时器</span></span><br><span class="line">    <span class="keyword">if</span> async &#123;</span><br><span class="line">        <span class="comment">// 判断定时器是否需要触发执行函数f</span></span><br><span class="line">        t.maybeRunAsync()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;modify&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新timer字段</span></span><br><span class="line"></span><br><span class="line">    oldPeriod := t.period</span><br><span class="line">    t.period = period</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.f = f</span><br><span class="line">        t.arg = arg</span><br><span class="line">        t.seq = seq</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wake := <span class="literal">false</span></span><br><span class="line">    pending := t.when &gt; <span class="number">0</span></span><br><span class="line">    t.when = when</span><br><span class="line">    <span class="comment">// timer已经在最小堆中</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        t.state |= timerModified <span class="comment">// 已修改</span></span><br><span class="line">        <span class="comment">// timer已标记删除</span></span><br><span class="line">        <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">            t.ts.zombies.Add(<span class="number">-1</span>)    <span class="comment">// 计数器更新</span></span><br><span class="line">            t.state &amp;^= timerZombie <span class="comment">// 移除标志位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// minWhen更新</span></span><br><span class="line">        <span class="comment">// 最小堆为空 or when比minWhen小</span></span><br><span class="line">        <span class="keyword">if</span> min := t.ts.minWhenModified.Load(); min == <span class="number">0</span> || when &lt; min &#123;</span><br><span class="line">            <span class="comment">// 需要中断网络轮询</span></span><br><span class="line">            wake = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 纪录state</span></span><br><span class="line">            t.astate.Store(t.state)</span><br><span class="line">            <span class="comment">// 是否要用when替换minWhenModified</span></span><br><span class="line">            t.ts.updateMinWhenModified(when)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 判断是否需要把timer添加到最小堆、中断网络轮询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要把定时器放到timers.heap</span></span><br><span class="line">    add := t.needsAdd()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 版本计数器更新</span></span><br><span class="line">        t.seq++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正在发送数据到channel</span></span><br><span class="line">        <span class="keyword">if</span> oldPeriod == <span class="number">0</span> &amp;&amp; t.isSending.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 清空channel（t.arg）的buf缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> timerchandrain(t.hchan()) &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要把定时器放到timers.heap</span></span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line">        t.maybeAdd()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> wake &#123;</span><br><span class="line">        <span class="comment">// 如果正在轮询netpoll且有更早过期的事件，中断netpoll轮询。如果没有轮询netpoll，则从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        wakeNetPoller(when)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pending</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断定时器是否需要更新timer状态，执行函数f（异步定时器执行）</span></span><br><span class="line"><span class="comment">// timer为异步定时器调用（go1.23开始应该用不到了），目前只有modify和stop函数在使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeRunAsync() &#123;</span><br><span class="line">    <span class="comment">// mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// 1. timer不在最小堆</span></span><br><span class="line">    <span class="comment">// 2. 同步定时器（用来判断同步定时器？？？）</span></span><br><span class="line">    <span class="comment">// 3. 过期时刻大于0</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped == <span class="number">0</span> &amp;&amp; t.isChan &amp;&amp; t.when &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时刻，如果已过期</span></span><br><span class="line">        <span class="keyword">if</span> now := nanotime(); t.when &lt;= now &#123;</span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">                t.unlockAndRun(now)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 重新上锁</span></span><br><span class="line">            t.lock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line"><span class="comment">// 该函数不管是异步定时器还是同步定时器都会使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> unlockAndRun(now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;unlockAndRun&quot;</span>)</span><br><span class="line">    <span class="comment">// mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// 如果timer已经放到了ts最小堆上，ts也要加锁</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        assertLockHeld(&amp;t.ts.mu)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer已经被修改或被停止，异常</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;(timerModified|timerZombie) != <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新timer状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备被调用的函数数据</span></span><br><span class="line">    f := t.f</span><br><span class="line">    arg := t.arg</span><br><span class="line">    seq := t.seq</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> next <span class="type">int64</span></span><br><span class="line">    <span class="comment">// 超过过期时刻的纳秒数</span></span><br><span class="line">    delay := now - t.when</span><br><span class="line">    <span class="comment">// 周期性定时器</span></span><br><span class="line">    <span class="keyword">if</span> t.period &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 计算下一个过期时刻，这公式没明白原理</span></span><br><span class="line">        next = t.when + t.period*(<span class="number">1</span>+delay/t.period)</span><br><span class="line">        <span class="comment">// 溢出了，设置为最大值2^63-1</span></span><br><span class="line">        <span class="keyword">if</span> next &lt; <span class="number">0</span> &#123;</span><br><span class="line">            next = maxWhen</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一次性定时器</span></span><br><span class="line">        next = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ts := t.ts</span><br><span class="line">    t.when = next</span><br><span class="line">    <span class="comment">// timer已经在最小堆中</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 设置timerModified标志位</span></span><br><span class="line">        t.state |= timerModified</span><br><span class="line">        <span class="comment">// 如果是一次性定时器，标记删除</span></span><br><span class="line">        <span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 标记为删除</span></span><br><span class="line">            t.state |= timerZombie</span><br><span class="line">            <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">            t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line">        t.updateHeap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行函数f</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是异步还是同步定时器（go1.23开始默认是同步定时器）</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 同步定时器 and 一次性</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &amp;&amp; t.period == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 发送中，计数器加1（用于并发检测，后面会执行减1操作）</span></span><br><span class="line">        <span class="keyword">if</span> t.isSending.Add(<span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;too many concurrent timer firings&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前定时器已经放到了最小堆</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 计算heap元素数量并更新len字段，最后解锁</span></span><br><span class="line">        ts.unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &amp;&amp; ts.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Temporarily use the timer&#x27;s synctest group for the G running this timer.</span></span><br><span class="line">        gp := getg()</span><br><span class="line">        <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;unexpected syncgroup set&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        gp.syncGroup = ts.syncGroup</span><br><span class="line">        ts.syncGroup.changegstatus(gp, _Gdead, _Grunning)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        lock(&amp;t.sendLock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次性定时器</span></span><br><span class="line">        <span class="keyword">if</span> t.period == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 发送完毕，计数器减1</span></span><br><span class="line">            <span class="keyword">if</span> t.isSending.Add(<span class="number">-1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;mismatched isSending updates&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 版本不一样，不执行。加锁后double-check </span></span><br><span class="line">        <span class="keyword">if</span> t.seq != seq &#123;</span><br><span class="line">            f = <span class="function"><span class="keyword">func</span><span class="params">(any, <span class="type">uintptr</span>, <span class="type">int64</span>)</span></span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数f</span></span><br><span class="line">    f(arg, seq, delay)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        unlock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &amp;&amp; ts.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        gp := getg()</span><br><span class="line">        ts.syncGroup.changegstatus(gp, _Grunning, _Gdead)</span><br><span class="line">        gp.syncGroup = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前定时器已经放到了最小堆</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        ts.lock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否要用when替换minWhenModified</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> updateMinWhenModified(when <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// old == 0 =&gt; 第一次访问，替换</span></span><br><span class="line">    <span class="comment">// old &lt; when =&gt; 忽略 </span></span><br><span class="line">    <span class="comment">// old &gt; when =&gt; 替换</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := ts.minWhenModified.Load()</span><br><span class="line">        <span class="keyword">if</span> old != <span class="number">0</span> &amp;&amp; old &lt; when &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ts.minWhenModified.CompareAndSwap(old, when) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要把定时器放到timers.heap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> needsAdd() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// t.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// 1. timer不在最小堆</span></span><br><span class="line">    <span class="comment">// 2. 过期时刻大于0</span></span><br><span class="line">    <span class="comment">// 3. 异步定时器 or 在测试 or 有G阻塞在channel中</span></span><br><span class="line">    need := t.state&amp;timerHeaped == <span class="number">0</span> &amp;&amp; t.when &gt; <span class="number">0</span> &amp;&amp; (!t.isChan || t.isFake || t.blocked &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个trace都是debug用的，忽略</span></span><br><span class="line">    <span class="keyword">if</span> need &#123;</span><br><span class="line">        t.trace(<span class="string">&quot;needsAdd+&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.trace(<span class="string">&quot;needsAdd-&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> need</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空channel（t.arg）的buf缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerchandrain</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// channel数据为0</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    any := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// buf有数据？清空</span></span><br><span class="line">    <span class="keyword">for</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        any = <span class="literal">true</span></span><br><span class="line">        typedmemclr(c.elemtype, chanbuf(c, c.recvx))</span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount--</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeAdd() &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前P的timers最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保拿的是当前P</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="keyword">var</span> ts *timers</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        sg := getg().syncGroup</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;invalid timer: fake time but no syncgroup&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ts = &amp;sg.timers</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况</span></span><br><span class="line">        ts = &amp;mp.p.ptr().timers</span><br><span class="line">    &#125;</span><br><span class="line">    ts.lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 清理最小堆</span></span><br><span class="line">    <span class="comment">// 确保最小堆首尾都没有过期的timer</span></span><br><span class="line">    ts.cleanHead()</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;maybeAdd&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更新当前timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line"></span><br><span class="line">    when := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    wake := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="keyword">if</span> t.needsAdd() &#123;</span><br><span class="line">        <span class="comment">// 设置timerHeaped标志位</span></span><br><span class="line">        t.state |= timerHeaped</span><br><span class="line">        when = t.when</span><br><span class="line">        <span class="comment">// 获取最小堆的最小when，用于判断是否需要唤醒netpoller</span></span><br><span class="line">        wakeTime := ts.wakeTime()</span><br><span class="line">        <span class="comment">// 最小堆为空 or 当前timer过期时刻比最小堆的还小</span></span><br><span class="line">        wake = wakeTime == <span class="number">0</span> || when &lt; wakeTime</span><br><span class="line">        <span class="comment">// 把timer定时器加入到timers.heap最小堆中</span></span><br><span class="line">        ts.addHeap(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="comment">// 计算heap元素数量并更新len字段，最后解锁</span></span><br><span class="line">    ts.unlock()</span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断netpoll轮询</span></span><br><span class="line">    <span class="keyword">if</span> wake &#123;</span><br><span class="line">        <span class="comment">// 如果正在轮询netpoll且有更早过期的事件，中断netpoll轮询。如果没有轮询netpoll，则从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        wakeNetPoller(when)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保最小堆首尾都没有过期的timer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> cleanHead() &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;cleanHead&quot;</span>)</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 当前goroutine</span></span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小堆的最后一个元素开始向前扫描，如果timer已过期，则移除出最小堆</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 1. guard</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最小堆数据为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for循环会运行一段时间，因为持有锁，不会被抢占</span></span><br><span class="line">        <span class="comment">// 如果其他G要抢占，返回，稍后再清理</span></span><br><span class="line">        <span class="keyword">if</span> gp.preemptStop &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n := <span class="built_in">len</span>(ts.heap)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2. 尾部处理</span></span><br><span class="line">        <span class="comment">// 从最小堆的最后一个元素开始向前扫描，如果timer已过期，则移除出最小堆</span></span><br><span class="line">        <span class="keyword">if</span> t := ts.heap[n<span class="number">-1</span>].timer; t.astate.Load()&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">            t.lock()</span><br><span class="line">            <span class="comment">// double-check</span></span><br><span class="line">            <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 移除出heap前把状态清空</span></span><br><span class="line">                t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">                <span class="comment">// 表示从heap上移除</span></span><br><span class="line">                t.ts = <span class="literal">nil</span></span><br><span class="line">                <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">                ts.zombies.Add(<span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// 先用空的结构替换</span></span><br><span class="line">                ts.heap[n<span class="number">-1</span>] = timerWhen&#123;&#125;</span><br><span class="line">                <span class="comment">// 移除最后一个数据</span></span><br><span class="line">                ts.heap = ts.heap[:n<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">            t.unlock()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 头部处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最小堆中的最小timer</span></span><br><span class="line">        t := ts.heap[<span class="number">0</span>].timer</span><br><span class="line">        <span class="comment">// 不在同一个P上</span></span><br><span class="line">        <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad ts&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有被修改也没有标记删除，无须调整</span></span><br><span class="line">        <span class="keyword">if</span> t.astate.Load()&amp;(timerModified|timerZombie) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line">        updated := t.updateHeap()</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">if</span> !updated &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line"><span class="comment">// minWhenHeap = heap[0].when</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> updateMinWhenHeap() &#123;</span><br><span class="line">    <span class="comment">// mu加锁、STW</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// heap为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) == <span class="number">0</span> &#123;</span><br><span class="line">        ts.minWhenHeap.Store(<span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 最小堆中的最小when纪录到minWhenHeap字段</span></span><br><span class="line">        ts.minWhenHeap.Store(ts.heap[<span class="number">0</span>].when)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小堆的最小when，用于判断是否需要唤醒netpoller</span></span><br><span class="line"><span class="comment">// =&gt; min(minWhenHeap, minWhenModified)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> wakeTime() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 字段读取的顺序很关键，跟adjust函数存在并发竞态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了timerModified位的最小when</span></span><br><span class="line">    nextWhen := ts.minWhenModified.Load()</span><br><span class="line">    <span class="comment">// 最小when</span></span><br><span class="line">    when := ts.minWhenHeap.Load()</span><br><span class="line">    <span class="comment">// 最小堆为空 or nextWhen比最小when还要小</span></span><br><span class="line">    <span class="keyword">if</span> when == <span class="number">0</span> || (nextWhen != <span class="number">0</span> &amp;&amp; nextWhen &lt; when) &#123;</span><br><span class="line">        when = nextWhen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> when</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果正在轮询netpoll且有更早过期的事件，中断netpoll轮询。如果没有轮询netpoll，则从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakeNetPoller</span><span class="params">(when <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 正在轮询netpoll中</span></span><br><span class="line">    <span class="keyword">if</span> sched.lastpoll.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        pollerPollUntil := sched.pollUntil.Load()</span><br><span class="line">        <span class="comment">// 轮询完毕 or 有更早过期的事件</span></span><br><span class="line">        <span class="keyword">if</span> pollerPollUntil == <span class="number">0</span> || pollerPollUntil &gt; when &#123;</span><br><span class="line">            <span class="comment">// 中断</span></span><br><span class="line">            netpollBreak()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非plan9</span></span><br><span class="line">        <span class="keyword">if</span> GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">            wakep()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AfterFunc"><a href="#AfterFunc" class="headerlink" title="AfterFunc"></a>AfterFunc</h3><p>创建&#x2F;获取一次性定时器，与NewTimer的区别是使用了用户自定义函数，此外，该定时器是异步的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span></span>) *Timer &#123;</span><br><span class="line">    <span class="comment">// 异步定时器</span></span><br><span class="line">    <span class="keyword">return</span> (*Timer)(newTimer(when(d), <span class="number">0</span>, goFunc, f, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goFunc</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> arg.(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h3><p>创建定时器或重用当前G的定时器，把当前goroutine挂起休眠至少ns纳秒时间</p>
<ol>
<li>初始化g.timer或重用当前G的timer</li>
<li>计算过期时刻when，纪录到g.sleepWhen</li>
<li>调用modify更新定时器，将当前goroutine挂起等待唤醒</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeSleep</span><span class="params">(ns <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 时长不能为负</span></span><br><span class="line">    <span class="keyword">if</span> ns &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. g.timer设置</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    t := gp.timer</span><br><span class="line">    <span class="comment">// 确保当前goroutine的timer定时器不为nil</span></span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        t = <span class="built_in">new</span>(timer)</span><br><span class="line">        <span class="comment">// 纪录f/arg</span></span><br><span class="line">        t.init(goroutineReady, gp)</span><br><span class="line">        <span class="comment">// 测试，忽略</span></span><br><span class="line">        <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.isFake = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绑定</span></span><br><span class="line">        gp.timer = t</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. g.sleepWhen设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻-单调时钟</span></span><br><span class="line">    <span class="keyword">var</span> now <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> sg := gp.syncGroup; sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        now = sg.now</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标过期时刻</span></span><br><span class="line">    when := now + ns</span><br><span class="line">    <span class="keyword">if</span> when &lt; <span class="number">0</span> &#123;         <span class="comment">// 溢出</span></span><br><span class="line">        when = maxWhen     <span class="comment">// 设置为最大值2^63-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp.sleepWhen = when</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 挂起goroutine</span></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        resetForSleep(gp, <span class="literal">nil</span>)</span><br><span class="line">        <span class="comment">// 挂起休眠</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonSleep, traceBlockSleep, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 挂起休眠，挂起前调用resetForSleep</span></span><br><span class="line">        gopark(resetForSleep, <span class="literal">nil</span>, waitReasonSleep, traceBlockSleep, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能直接在timeSleep内部调用reset，G挂起前会有一个小的时间间隔，有竟态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetForSleep</span><span class="params">(gp *g, _ unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 调用modify函数更新when和period</span></span><br><span class="line">    gp.timer.reset(gp.sleepWhen, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="After-Tick"><a href="#After-Tick" class="headerlink" title="After &amp; Tick"></a>After &amp; Tick</h3><p>创建定时器，返回定时器的channel，属于NewTimer&#x2F;NewTicker函数的封装。go1.22及之前的版本中，如果在for循环使用After会申请大量内存，加剧GC压力</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time &#123;</span><br><span class="line">    <span class="keyword">return</span> NewTimer(d).C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tick</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time &#123;</span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NewTicker(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器相关"><a href="#定时器相关" class="headerlink" title="定时器相关"></a>定时器相关</h2><h3 id="停止定时器"><a href="#停止定时器" class="headerlink" title="停止定时器"></a>停止定时器</h3><p>停止定时器，因为定时器可能被其他P持有，只修改状态。具体逻辑如下</p>
<ol>
<li>如果是异步定时器，判断定时器是否需要触发执行函数f</li>
<li>定时器字段更新<ul>
<li>更新定时器状态state的timerZombie位</li>
<li>重置when</li>
<li>更新版本计数器</li>
<li>将状态state复制到astate上（到这里就解锁了）</li>
<li>如果是同步定时器，清空channel（t.arg）的buf缓冲区</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span></span> Stop() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="keyword">if</span> !t.initTimer &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: Stop called on uninitialized Timer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stopTimer(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span></span> Stop() &#123;</span><br><span class="line">    <span class="keyword">if</span> !t.initTicker &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    stopTimer((*Timer)(unsafe.Pointer(t)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTimer</span><span class="params">(t *timeTimer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;stop of synctest timer from outside bubble&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> stop() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是异步还是同步定时器（go1.23开始默认是同步定时器）</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        lock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;stop&quot;</span>)</span><br><span class="line">    <span class="comment">// 如果是异步定时器（go1.22及以前）</span></span><br><span class="line">    <span class="keyword">if</span> async &#123;</span><br><span class="line">        <span class="comment">// 判断定时器是否需要更新timer状态，执行函数f</span></span><br><span class="line">        t.maybeRunAsync()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// timer已经在最小堆中</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 设置timerModified标志位</span></span><br><span class="line">        t.state |= timerModified</span><br><span class="line">        <span class="comment">// timer无删除标记</span></span><br><span class="line">        <span class="keyword">if</span> t.state&amp;timerZombie == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 标记为删除</span></span><br><span class="line">            t.state |= timerZombie</span><br><span class="line">            <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">            t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pending := t.when &gt; <span class="number">0</span></span><br><span class="line">    <span class="comment">// 重置when</span></span><br><span class="line">    t.when = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 版本计数器更新</span></span><br><span class="line">        t.seq++</span><br><span class="line">        <span class="comment">// 一次性定时器 and 已经在调用函数f了</span></span><br><span class="line">        <span class="keyword">if</span> t.period == <span class="number">0</span> &amp;&amp; t.isSending.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        unlock(&amp;t.sendLock)</span><br><span class="line">        <span class="comment">// 清空channel（t.arg）的buf缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> timerchandrain(t.hchan()) &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pending</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重置定时器"><a href="#重置定时器" class="headerlink" title="重置定时器"></a>重置定时器</h3><p>重置定时器，本质是modify函数调用，更新timer状态、添加到最小堆、中断网络轮询。需要先调用Stop才能确保安全调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span></span> Reset(d Duration) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !t.initTimer &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: Reset called on uninitialized Timer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    w := when(d)</span><br><span class="line">    <span class="keyword">return</span> resetTimer(t, w, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span></span> Reset(d Duration) &#123;</span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;non-positive interval for Ticker.Reset&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !t.initTicker &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: Reset called on uninitialized Ticker&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resetTimer((*Timer)(unsafe.Pointer(t)), when(d), <span class="type">int64</span>(d))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetTimer</span><span class="params">(t *timeTimer, when, period <span class="type">int64</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;reset of synctest timer from outside bubble&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.reset(when, period)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> reset(when, period <span class="type">int64</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line">    <span class="keyword">return</span> t.modify(when, period, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小堆相关"><a href="#最小堆相关" class="headerlink" title="最小堆相关"></a>最小堆相关</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> updateHeap() (updated <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// mu加锁、STW</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;updateHeap&quot;</span>)</span><br><span class="line">    <span class="comment">// 最小堆</span></span><br><span class="line">    ts := t.ts</span><br><span class="line">    <span class="comment">// 最小堆为nil（没有初始化） or 当前定时器不是最小堆中最小的，异常</span></span><br><span class="line">    <span class="keyword">if</span> ts == <span class="literal">nil</span> || t != ts.heap[<span class="number">0</span>].timer &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// timer已标记删除</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 移除标志位</span></span><br><span class="line">        t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">        <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">        ts.zombies.Add(<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// 移除最小的timer</span></span><br><span class="line">        ts.deleteMin()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前定时器已被修改</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerModified != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 移除标志位</span></span><br><span class="line">        t.state &amp;^= timerModified</span><br><span class="line">        <span class="comment">// 更新when</span></span><br><span class="line">        ts.heap[<span class="number">0</span>].when = t.when</span><br><span class="line">        <span class="comment">// 调整最小堆，从根节点开始，一直向下交换最小的子节点</span></span><br><span class="line">        ts.siftDown(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">        ts.updateMinWhenHeap()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆重新排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> initHeap() &#123;</span><br><span class="line">    <span class="comment">// 0或1个元素，不用排序</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父节点idx =&gt; (len(heap)-1-1)/4</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">int</span>(<span class="type">uint</span>(<span class="built_in">len</span>(ts.heap)<span class="number">-1</span><span class="number">-1</span>) / timerHeapN); i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        ts.siftDown(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把timer定时器加入到timers.heap最小堆中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> addHeap(t *timer) &#123;</span><br><span class="line">    <span class="comment">// mu加锁、STW</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 确保netpoll已初始化（依赖）</span></span><br><span class="line">    <span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        netpollGenericInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer已经放到了P的timers上</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;ts set in timer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 纪录P的timers指针</span></span><br><span class="line">    t.ts = ts</span><br><span class="line">    <span class="comment">// 放到最小堆末尾</span></span><br><span class="line">    ts.heap = <span class="built_in">append</span>(ts.heap, timerWhen&#123;t, t.when&#125;)</span><br><span class="line">    <span class="comment">// 重新调整最小堆，写入timer时触发</span></span><br><span class="line">    ts.siftUp(<span class="built_in">len</span>(ts.heap) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 是同一个定时器</span></span><br><span class="line">    <span class="keyword">if</span> t == ts.heap[<span class="number">0</span>].timer &#123;</span><br><span class="line">        <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">        ts.updateMinWhenHeap()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新调整最小堆，写入timer时触发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> siftUp(i <span class="type">int</span>) &#123;</span><br><span class="line">    heap := ts.heap</span><br><span class="line">    <span class="comment">// 指针超过数组长度，异常</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(heap) &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂存当前节点</span></span><br><span class="line">    tw := heap[i]</span><br><span class="line">    when := tw.when</span><br><span class="line">    <span class="comment">// 异常值</span></span><br><span class="line">    <span class="keyword">if</span> when &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果父节点的值比当前节点的值要大，交换两者</span></span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 找父节点idx =&gt; p = (i-1) / 4</span></span><br><span class="line">        p := <span class="type">int</span>(<span class="type">uint</span>(i<span class="number">-1</span>) / timerHeapN)</span><br><span class="line">        <span class="comment">// 如果父节点的when大于等于当前节点的when，调整完毕，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> when &gt;= heap[p].when &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换父节点和当前节点</span></span><br><span class="line">        heap[i] = heap[p]</span><br><span class="line">        i = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> heap[i].timer != tw.timer &#123;</span><br><span class="line">        <span class="comment">// 一般排序完都要执行这步才对</span></span><br><span class="line">        heap[i] = tw</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新调整最小堆，移除timer时触发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> siftDown(i <span class="type">int</span>) &#123;</span><br><span class="line">    heap := ts.heap</span><br><span class="line">    <span class="comment">// 指针超过数组长度，异常</span></span><br><span class="line">    n := <span class="built_in">len</span>(heap)</span><br><span class="line">    <span class="keyword">if</span> i &gt;= n &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点idx超过数组长度</span></span><br><span class="line">    <span class="comment">// i*4+1 &gt;= n</span></span><br><span class="line">    <span class="keyword">if</span> i*timerHeapN+<span class="number">1</span> &gt;= n &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂存当前节点</span></span><br><span class="line">    tw := heap[i]</span><br><span class="line">    when := tw.when</span><br><span class="line">    <span class="comment">// 异常值</span></span><br><span class="line">    <span class="keyword">if</span> when &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果子节点的值比当前节点的值要小，交换两者</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 子节点left_idx =&gt; i*4+1</span></span><br><span class="line">        leftChild := i*timerHeapN + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> leftChild &gt;= n &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        w := when     <span class="comment">// 当前节点when</span></span><br><span class="line">        c := <span class="number">-1</span>        <span class="comment">// 节点索引</span></span><br><span class="line">        <span class="comment">// 找到子节点中最小的when</span></span><br><span class="line">        <span class="comment">// 每个节点存储最多4个数据</span></span><br><span class="line">        <span class="keyword">for</span> j, tw := <span class="keyword">range</span> heap[leftChild:min(leftChild+timerHeapN, n)] &#123;</span><br><span class="line">            <span class="keyword">if</span> tw.when &lt; w &#123;</span><br><span class="line">                w = tw.when</span><br><span class="line">                c = leftChild + j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到更小的when，退出</span></span><br><span class="line">        <span class="keyword">if</span> c &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了，交换父子节点</span></span><br><span class="line">        heap[i] = heap[c]</span><br><span class="line">        i = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> heap[i].timer != tw.timer &#123;</span><br><span class="line">        <span class="comment">// 一般排序完都要执行这步</span></span><br><span class="line">        heap[i] = tw</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除最小的timer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> deleteMin() &#123;</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 最小堆第一个</span></span><br><span class="line">    t := ts.heap[<span class="number">0</span>].timer</span><br><span class="line">    <span class="comment">// 不在同一个P上</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">        throw(<span class="string">&quot;wrong timers&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解除绑定</span></span><br><span class="line">    t.ts = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 跟最小堆最后一个元素交换</span></span><br><span class="line">    last := <span class="built_in">len</span>(ts.heap) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ts.heap[<span class="number">0</span>] = ts.heap[last]</span><br><span class="line">    &#125;</span><br><span class="line">    ts.heap[last] = timerWhen&#123;&#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    ts.heap = ts.heap[:last]</span><br><span class="line">    <span class="comment">// 重新调整最小堆</span></span><br><span class="line">    <span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ts.siftDown(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">    ts.updateMinWhenHeap()</span><br><span class="line">    <span class="comment">// 最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> last == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 将minWhen设置为0</span></span><br><span class="line">        ts.minWhenModified.Store(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="goroutine调度相关"><a href="#goroutine调度相关" class="headerlink" title="goroutine调度相关"></a>goroutine调度相关</h2><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>销毁P时，把最小堆里的timer全部迁移走</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把一个timers最小堆的timer搬到当前timers最小堆中。P销毁时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> take(src *timers) &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;take&quot;</span>)</span><br><span class="line">    <span class="comment">// STW</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line">    <span class="comment">// src最小堆不为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(src.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// STW 忽略顺序</span></span><br><span class="line">        <span class="keyword">for</span> _, tw := <span class="keyword">range</span> src.heap &#123;</span><br><span class="line">            t := tw.timer</span><br><span class="line">            <span class="comment">// 解除P绑定</span></span><br><span class="line">            t.ts = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">// timer已标记删除</span></span><br><span class="line">            <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 清理状态位（为什么要去修改它？？？）</span></span><br><span class="line">                t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 清理timerModified位</span></span><br><span class="line">                t.state &amp;^= timerModified</span><br><span class="line">                <span class="comment">// 把timer定时器加入到timers.heap最小堆中</span></span><br><span class="line">                ts.addHeap(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把整个最小堆清空了</span></span><br><span class="line">        src.heap = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 下面的统计数据也全部重置</span></span><br><span class="line">        src.zombies.Store(<span class="number">0</span>)</span><br><span class="line">        src.minWhenHeap.Store(<span class="number">0</span>)</span><br><span class="line">        src.minWhenModified.Store(<span class="number">0</span>)</span><br><span class="line">        src.<span class="built_in">len</span>.Store(<span class="number">0</span>)</span><br><span class="line">        ts.<span class="built_in">len</span>.Store(<span class="type">uint32</span>(<span class="built_in">len</span>(ts.heap)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行。调度时，寻找可运行的G时调用（findRunnable或stealWork）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> check(now <span class="type">int64</span>) (rnow, pollUntil <span class="type">int64</span>, ran <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;check&quot;</span>)</span><br><span class="line">    <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">    next := ts.wakeTime()</span><br><span class="line">    <span class="comment">// 最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> now, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记删除的timer数量</span></span><br><span class="line">    zombies := ts.zombies.Load()</span><br><span class="line">    <span class="keyword">if</span> zombies &lt; <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前P and 标记删除的timer数量超过总量的1/4</span></span><br><span class="line">    force := ts == &amp;getg().m.p.ptr().timers &amp;&amp; <span class="type">int</span>(zombies) &gt; <span class="type">int</span>(ts.<span class="built_in">len</span>.Load())/<span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// now小于最小when（下一个定时器还没准备好运行） and 非强制</span></span><br><span class="line">    <span class="keyword">if</span> now &lt; next &amp;&amp; !force &#123;</span><br><span class="line">        <span class="keyword">return</span> now, next, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的场景是：now大于等于最小when or 强制</span></span><br><span class="line"></span><br><span class="line">    ts.lock()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 清理最小堆，并重新排序（非强制）</span></span><br><span class="line">        <span class="comment">// 那么这里需要处理的场景就是now大于等于最小when（看了adjust代码感觉跟强制也没什么区别）</span></span><br><span class="line">        ts.adjust(now, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 清理后，heap不为空</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(ts.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 运行最小的timer，如果还没到时间就不执行</span></span><br><span class="line">            <span class="keyword">if</span> tw := ts.run(now); tw != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// -1或0表示最小堆为空，其他表示最小timer的运行时刻</span></span><br><span class="line">                <span class="keyword">if</span> tw &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    pollUntil = tw</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ran = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新检测</span></span><br><span class="line">        force = ts == &amp;getg().m.p.ptr().timers &amp;&amp; <span class="type">int</span>(ts.zombies.Load()) &gt; <span class="type">int</span>(ts.<span class="built_in">len</span>.Load())/<span class="number">4</span></span><br><span class="line">        <span class="keyword">if</span> force &#123;</span><br><span class="line">            <span class="comment">// 清理最小堆，并重新排序（强制）</span></span><br><span class="line">            ts.adjust(now, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ts.unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> now, pollUntil, ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清理最小堆，并重新排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> adjust(now <span class="type">int64</span>, force <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;adjust&quot;</span>)</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 非强制</span></span><br><span class="line">    <span class="keyword">if</span> !force &#123;</span><br><span class="line">        <span class="comment">// 设置了timerModified位的最小when</span></span><br><span class="line">        first := ts.minWhenModified.Load()</span><br><span class="line">        <span class="comment">// 最小堆为空 or now小于最小when（下一个定时器还没准备好运行）</span></span><br><span class="line">        <span class="keyword">if</span> first == <span class="number">0</span> || first &gt; now &#123;</span><br><span class="line">            <span class="comment">// debug用，忽略</span></span><br><span class="line">            <span class="keyword">if</span> verifyTimers &#123;</span><br><span class="line">                ts.verify()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">    <span class="comment">// minWhenHeap = min(minWhenHeap, minWhenModified)</span></span><br><span class="line">    ts.minWhenHeap.Store(ts.wakeTime())</span><br><span class="line">    <span class="comment">// minWhenModified = 0</span></span><br><span class="line">    ts.minWhenModified.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描整个最小堆</span></span><br><span class="line">    changed := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ts.heap); i++ &#123;</span><br><span class="line">        tw := &amp;ts.heap[i]</span><br><span class="line">        t := tw.timer</span><br><span class="line">        <span class="comment">// 不在同一个P上</span></span><br><span class="line">        <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad ts&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有被修改也没有标记删除，无须调整</span></span><br><span class="line">        <span class="keyword">if</span> t.astate.Load()&amp;(timerModified|timerZombie) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 加锁</span></span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> t.state&amp;timerHeaped == <span class="number">0</span>:         <span class="comment">// 异常状态</span></span><br><span class="line">            badTimer()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> t.state&amp;timerZombie != <span class="number">0</span>:         <span class="comment">// timer已标记删除</span></span><br><span class="line">            <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">            ts.zombies.Add(<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">// 移除标志位</span></span><br><span class="line">            t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">            <span class="comment">// 总数量</span></span><br><span class="line">            n := <span class="built_in">len</span>(ts.heap)</span><br><span class="line">            <span class="comment">// 当前timer跟最小堆的最后一个交换</span></span><br><span class="line">            ts.heap[i] = ts.heap[n<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// 先用空的结构替换</span></span><br><span class="line">            ts.heap[n<span class="number">-1</span>] = timerWhen&#123;&#125;</span><br><span class="line">            <span class="comment">// 移除最后一个数据</span></span><br><span class="line">            ts.heap = ts.heap[:n<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// 表示从heap上移除</span></span><br><span class="line">            t.ts = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">// 重新扫描当前位置的timer</span></span><br><span class="line">            i--</span><br><span class="line">            changed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> t.state&amp;timerModified != <span class="number">0</span>:    <span class="comment">// 已修改</span></span><br><span class="line">            <span class="comment">// 更新when</span></span><br><span class="line">            tw.when = t.when</span><br><span class="line">            <span class="comment">// 移除标志位</span></span><br><span class="line">            t.state &amp;^= timerModified</span><br><span class="line">            changed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        t.unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有调整过最小堆</span></span><br><span class="line">    <span class="keyword">if</span> changed &#123;</span><br><span class="line">        <span class="comment">// 最小堆重新排序</span></span><br><span class="line">        ts.initHeap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">    <span class="comment">// minWhenHeap = heap[0].when</span></span><br><span class="line">    ts.updateMinWhenHeap()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    <span class="keyword">if</span> verifyTimers &#123;</span><br><span class="line">        ts.verify()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证timers是最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> verify() &#123;</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 扫描最小堆</span></span><br><span class="line">    <span class="keyword">for</span> i, tw := <span class="keyword">range</span> ts.heap &#123;</span><br><span class="line">        <span class="comment">// 第一个timer，没有父节点</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点，p=(i-1)/4</span></span><br><span class="line">        p := <span class="type">int</span>(<span class="type">uint</span>(i<span class="number">-1</span>) / timerHeapN)</span><br><span class="line">        <span class="comment">// 子节点比父节点的值小，异常</span></span><br><span class="line">        <span class="keyword">if</span> tw.when &lt; ts.heap[p].when &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;bad timer heap at &quot;</span>, i, <span class="string">&quot;: &quot;</span>, p, <span class="string">&quot;: &quot;</span>, ts.heap[p].when, <span class="string">&quot;, &quot;</span>, i, <span class="string">&quot;: &quot;</span>, tw.when, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;bad timer heap&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// len字段验证</span></span><br><span class="line">    <span class="keyword">if</span> n := <span class="type">int</span>(ts.<span class="built_in">len</span>.Load()); <span class="built_in">len</span>(ts.heap) != n &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;timer heap len&quot;</span>, <span class="built_in">len</span>(ts.heap), <span class="string">&quot;!= atomic len&quot;</span>, n)</span><br><span class="line">        throw(<span class="string">&quot;bad timer heap len&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行最小的timer，如果还没到时间就不执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> run(now <span class="type">int64</span>) <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">Redo:</span><br><span class="line">    <span class="comment">// 最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个/最小timer</span></span><br><span class="line">    tw := ts.heap[<span class="number">0</span>]</span><br><span class="line">    t := tw.timer</span><br><span class="line">    <span class="comment">// 不在同一个P上，异常</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad ts&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer没有修改/标记删除 and when大于now（还没准备运行）</span></span><br><span class="line">    <span class="keyword">if</span> t.astate.Load()&amp;(timerModified|timerZombie) == <span class="number">0</span> &amp;&amp; tw.when &gt; now &#123;</span><br><span class="line">        <span class="keyword">return</span> tw.when</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line">    <span class="keyword">if</span> t.updateHeap() &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">goto</span> Redo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer不在最小堆 or 当前定时器已被修改</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped == <span class="number">0</span> || t.state&amp;timerModified != <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when大于now（还没准备运行）</span></span><br><span class="line">    <span class="keyword">if</span> t.when &gt; now &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">return</span> t.when</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">    t.unlockAndRun(now)</span><br><span class="line">    <span class="comment">// ts重新加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timeSleepUntil"><a href="#timeSleepUntil" class="headerlink" title="timeSleepUntil"></a>timeSleepUntil</h3><p>遍历所有P，找到全局最小的when。由sysmon、checkdead函数调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历所有P，找到全局最小的when</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeSleepUntil</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 最大值2^63-1</span></span><br><span class="line">    next := <span class="type">int64</span>(maxWhen)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保allp切片不会被更改</span></span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="comment">// 遍历所有P，获取在所有P中最小的when</span></span><br><span class="line">    <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 可能在扩容，还没有创建好新的P</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">        <span class="keyword">if</span> w := pp.timers.wakeTime(); w != <span class="number">0</span> &#123;</span><br><span class="line">            next = min(next, w)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="channel相关"><a href="#channel相关" class="headerlink" title="channel相关"></a>channel相关</h2><p>虽说是跟channel相关，实际上，在执行<code>&lt;-t.C</code>等待超时时，就会使用到下面的方法</p>
<h3 id="maybeRunChan"><a href="#maybeRunChan" class="headerlink" title="maybeRunChan"></a>maybeRunChan</h3><p>判断是否需要更新timer状态、执行函数f。具体逻辑如下</p>
<ol>
<li>不满足条件则返回<ul>
<li>timer已经放在最小堆上，那么过期后自动发送到channel</li>
<li>timer从未执行过</li>
<li>timer还未到触发时刻</li>
</ul>
</li>
<li>满足条件则更新timer状态、执行函数f</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line"><span class="comment">// 目前只有channel、select相关的代码在使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeRunChan() &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="keyword">var</span> timerGroup *synctestGroup</span><br><span class="line">        <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">            timerGroup = t.ts.syncGroup</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        sg := getg().syncGroup</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;synctest timer accessed from outside bubble&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> timerGroup != <span class="literal">nil</span> &amp;&amp; sg != timerGroup &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;timer moved between synctest bubbles&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果timer已经在最小堆中，过期后自动发送到channel</span></span><br><span class="line">    <span class="keyword">if</span> t.astate.Load()&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 当前时刻，单调时钟</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 加锁后double-check</span></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer从未执行过</span></span><br><span class="line">    <span class="comment">// 3. timer还未到触发时刻</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> || t.when == <span class="number">0</span> || t.when &gt; now &#123;</span><br><span class="line">        <span class="comment">// debug用，忽略</span></span><br><span class="line">        t.trace(<span class="string">&quot;maybeRunChan-&quot;</span>)</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;maybeRunChan+&quot;</span>)</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">        t.unlockAndRun(now)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="blockTimerChan-unblockTimerChan"><a href="#blockTimerChan-unblockTimerChan" class="headerlink" title="blockTimerChan &amp; unblockTimerChan"></a>blockTimerChan &amp; unblockTimerChan</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个10ms过期的定时器</span></span><br><span class="line">t := time.NewTimer(<span class="number">10</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待定时器过期信号</span></span><br><span class="line">&lt;-t.C</span><br></pre></td></tr></table></figure>

<p>上述示例代码，如果这个channel是属于一个定时器的，那么在G挂起前、唤醒后，需要修改定时器的state-状态、blocked-标记等。函数详细注释如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// G挂起休眠之前，将定时器标记为阻塞并加入最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;blockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer已标记删除</span></span><br><span class="line">    <span class="comment">// 3. 过期时刻大于0</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie != <span class="number">0</span> &amp;&amp; t.when &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t.state &amp;^= timerZombie    <span class="comment">// 移除标志位</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">-1</span>)    <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要把定时器放到最小堆</span></span><br><span class="line">    add := t.needsAdd()</span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line">        t.maybeAdd()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G唤醒后，将定时器标记为非阻塞、删除状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unblockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;unblockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器 or 计数器为0，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan || t.blocked == <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器为0 and timer已经在最小堆中 and timer无删除标记</span></span><br><span class="line">    <span class="keyword">if</span> t.blocked == <span class="number">0</span> &amp;&amp; t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 标记为删除</span></span><br><span class="line">        t.state |= timerZombie</span><br><span class="line">        <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器示例解析"><a href="#定时器示例解析" class="headerlink" title="定时器示例解析"></a>定时器示例解析</h2><ol>
<li>创建定时器</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.NewTimer(<span class="number">2</span> * time.Second) <span class="comment">// 调用NewTimer(2 * time.Second)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次创建timer，执行newTimer，此时不会触发任何其他函数操作，包括添加到最小堆等。</span></span><br><span class="line"><span class="comment">// timer数据初始化后，各字段数值如下</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//     |---------------------------------|</span></span><br><span class="line"><span class="comment">//     v                                 |</span></span><br><span class="line"><span class="comment">// timer.mu                         channel.timer</span></span><br><span class="line"><span class="comment">//      .f          =&gt; sendTime          ^</span></span><br><span class="line"><span class="comment">//      .arg        =&gt; *channel     -----|</span></span><br><span class="line"><span class="comment">//      .seq        =&gt; 1</span></span><br><span class="line"><span class="comment">//      .sendLock</span></span><br><span class="line"><span class="comment">//      .isChan     =&gt; true</span></span><br><span class="line"><span class="comment">//      .period     =&gt; 0</span></span><br><span class="line"><span class="comment">//      .when       =&gt; xyz</span></span><br><span class="line"><span class="comment">//      .state      =&gt; 0</span></span><br><span class="line"><span class="comment">//      .astate     =&gt; 0</span></span><br><span class="line"><span class="comment">//      .init       =&gt; true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当前G挂起等待</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;-t.C    <span class="comment">// 调用chanrecv函数，内部调用blockTimerChan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将timer放到最小堆</span></span><br><span class="line"><span class="comment">// timers.heap                        |---------------------------------|</span></span><br><span class="line"><span class="comment">//          |                         v                                 |</span></span><br><span class="line"><span class="comment">//  | timer0 | ... | timerx |  &lt;-- timer.mu                         channel.timer</span></span><br><span class="line"><span class="comment">//                                      .f          =&gt; sendTime          ^</span></span><br><span class="line"><span class="comment">//                                      .arg        =&gt; *channel     -----|</span></span><br><span class="line"><span class="comment">//                                      .seq        =&gt; 1</span></span><br><span class="line"><span class="comment">//                                      .sendLock</span></span><br><span class="line"><span class="comment">//                                      .isChan     =&gt; true</span></span><br><span class="line"><span class="comment">//                                      .period     =&gt; 0</span></span><br><span class="line"><span class="comment">//                                      .when       =&gt; xyz</span></span><br><span class="line"><span class="comment">//                                      .state      =&gt; 1</span></span><br><span class="line"><span class="comment">//                                      .astate     =&gt; 1(timerHeaped)</span></span><br><span class="line"><span class="comment">//                                      .init       =&gt; true</span></span><br><span class="line"><span class="comment">//                                      .blocked    =&gt; 1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定时器到期通知</li>
</ol>
<p>GMP调度执行findRunnable或stealWork，发现定时器过期，发送信号给channel，唤醒goroutine，流程如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sched -&gt; findRunnable -&gt; check -&gt; unlockAndRun -&gt; sendTime</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>当前G唤醒继续执行</li>
</ol>
<p>当前G唤醒后，调用unblockTimerChan</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行unblockTimerChan后，timer的数据状态大概如下</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//     |---------------------------------|</span></span><br><span class="line"><span class="comment">//     v                                 |</span></span><br><span class="line"><span class="comment">// timer.mu                         channel.timer</span></span><br><span class="line"><span class="comment">//      .f          =&gt; sendTime          ^</span></span><br><span class="line"><span class="comment">//      .arg        =&gt; *channel     -----|</span></span><br><span class="line"><span class="comment">//      .seq        =&gt; 1</span></span><br><span class="line"><span class="comment">//      .sendLock</span></span><br><span class="line"><span class="comment">//      .isChan     =&gt; true</span></span><br><span class="line"><span class="comment">//      .period     =&gt; 0</span></span><br><span class="line"><span class="comment">//      .when       =&gt; xyz(&lt;=now)</span></span><br><span class="line"><span class="comment">//      .state      =&gt; 0</span></span><br><span class="line"><span class="comment">//      .astate     =&gt; 5(timerHeaped|timerZombie)</span></span><br><span class="line"><span class="comment">//      .init       =&gt; true</span></span><br><span class="line"><span class="comment">//      .blocked    =&gt; 0</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://antonz.org/timer-reset/">Resetting timers in Go</a><br><a href="https://ggaaooppeenngg.github.io/zh-CN/2016/02/09/timer%E5%9C%A8go%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E7%B2%BE%E7%A1%AE/">timer 在 Golang 中可以有多精确？</a><br><a href="https://tonybai.com/2016/12/21/how-to-use-timer-reset-in-golang-correctly/">论golang Timer Reset方法使用的正确姿势</a><br><a href="https://www.youtube.com/watch?v=XJx0eTP-y9I">#74 time.Timer 源码分析 (Go 1.14) 【 Go 夜读 】</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>swift模板移除头部注释</title>
    <url>/swift-file-template-remove-header-comment/</url>
    <content><![CDATA[<p>记录下如何移除swift文件的头部注释</p>
<p><strong>注意，zsh要在空格处添加反斜杠 \，否则无法生成正确的文件路径</strong></p>
<h2 id="清空模板注释内容（可选）"><a href="#清空模板注释内容（可选）" class="headerlink" title="清空模板注释内容（可选）"></a>清空模板注释内容（可选）</h2><p><strong>以下操作可以先备份文件</strong></p>
<p>修改<code>IDETemplateMacros.plist</code>文件，移除注释内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/Library/Developer/Xcode/UserData/IDETemplateMacros.plist</span><br></pre></td></tr></table></figure>

<p>找到<code>FILEHEADER</code>，将string的内容清空</p>
<h2 id="Swift-File"><a href="#Swift-File" class="headerlink" title="Swift File"></a>Swift File</h2><p>进入Xcode目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Library/Developer/Xcode/</span><br></pre></td></tr></table></figure>

<p>添加模板<code>No Comment Swift File.xctemplate</code>，该模板会展示在Xcode的文件目录列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p Templates/File Templates/MultiPlatform/Source/No Comment Swift File.xctemplate</span><br></pre></td></tr></table></figure>

<p>进入模板目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Templates/File Templates/MultiPlatform/Source/No Comment Swift File.xctemplate</span><br></pre></td></tr></table></figure>

<p>复制原swift file模板数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/MultiPlatform/Source/Swift File.xctemplate/* ./</span><br></pre></td></tr></table></figure>

<p>修改<code>___FILEBASENAME___.swift</code>，将第一行头部注释部分移除</p>
<span id="more"></span>

<h2 id="SwiftUI-View"><a href="#SwiftUI-View" class="headerlink" title="SwiftUI View"></a>SwiftUI View</h2><p>同上，进入Xcode目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Library/Developer/Xcode</span><br></pre></td></tr></table></figure>

<p>添加模板<code>No Comment SwiftUI View.xctemplate</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p Templates/File Templates/MultiPlatform/User Interface/No Comment SwiftUI View.xctemplate</span><br></pre></td></tr></table></figure>

<p>进入模板目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Templates/File Templates/MultiPlatform/User Interface/No Comment SwiftUI View.xctemplate</span><br></pre></td></tr></table></figure>

<p>复制原swiftui view模板数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/MultiPlatform/User Interface/SwiftUI View.xctemplate/* ./</span><br></pre></td></tr></table></figure>

<p>修改<code>___FILEBASENAME___.swift</code>，将第一行头部注释部分移除</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>重启Xcode（不是关闭打开xcode窗口，而是重启），cmd+N查看模板列表，完成！</p>
]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql安装配置</title>
    <url>/postgres-setup-example/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h3><p>系统是ubuntu 24.04 LTS，开机启动使用了systemd，所以先安装相关依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install libsystemd-dev</span><br></pre></td></tr></table></figure>

<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>官网推荐使用pre-packaged方式，稳定可靠，适合生产环境。不过我想用最新版，就直接用源码编译安装了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入源代码目录</span></span><br><span class="line"><span class="built_in">cd</span> postgresql-16.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定安装目录、设置支持systemd</span></span><br><span class="line">./configure --prefix=/usr/local/postgresql-16.4 --with-systemd --with-ssl=openssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 软连接，方便升级用</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/local/postgresql-16.4 /usr/local/pgsql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="built_in">sudo</span> adduser postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库数据存储目录，与app目录分离</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/lib/pgsql/data</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R postgres /var/lib/pgsql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到postgres用户</span></span><br><span class="line">su - postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库目录、启动实例</span></span><br><span class="line">/usr/local/pgsql/bin/initdb -D /var/lib/pgsql/data</span><br><span class="line">/usr/local/pgsql/bin/pg_ctl -D /var/lib/pgsql/data -l logfile start</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">/usr/local/pgsql/bin/psql</span><br><span class="line"><span class="comment"># 关闭实例</span></span><br><span class="line"><span class="comment"># /usr/local/pgsql/bin/pg_ctl -D /var/lib/pgsql/data/ -l logfile stop</span></span><br></pre></td></tr></table></figure>

<p>到这里，postgresql完成安装、初始化</p>
<span id="more"></span>

<h3 id="systemd配置"><a href="#systemd配置" class="headerlink" title="systemd配置"></a>systemd配置</h3><p>开机启动配置systemd，添加配置文件<code>/etc/systemd/system/postgresql.service</code>，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=PostgreSQL database server</span><br><span class="line">Documentation=man:postgres(1)</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">User=postgres</span><br><span class="line">ExecStart=/usr/local/pgsql/bin/postgres -D /var/lib/pgsql/data</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=mixed</span><br><span class="line">KillSignal=SIGINT</span><br><span class="line">TimeoutSec=infinity</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>使用systemd启动postgresql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl start postgresql</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> postgresql</span><br></pre></td></tr></table></figure>

<h2 id="pgsql配置"><a href="#pgsql配置" class="headerlink" title="pgsql配置"></a>pgsql配置</h2><p>以上完成pg安装，本地可以直接访问使用。接下来是配置数据库提供对外访问能力，如配置tcp监听地址、添加用户、配置权限等</p>
<p>进入pg的data数据存储目录，修改相关配置文件</p>
<h3 id="tcp配置"><a href="#tcp配置" class="headerlink" title="tcp配置"></a>tcp配置</h3><p>修改<code>postgresql.conf</code>文件，配置监听地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认localhost，改为&#x27;*&#x27;</span><br><span class="line">listen_addresses = &#x27;*&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="auth配置"><a href="#auth配置" class="headerlink" title="auth配置"></a>auth配置</h3><p>PS: pg的授权配置没有像mysql一样开箱即用，先简单配置下吧</p>
<p>修改<code>pg_hba.conf</code>文件，开放数据库&#x2F;用户对外访问权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class="line">host    blogdb          all             0.0.0.0/0               scram-sha-256</span><br><span class="line">host    blogdb          all             ::0/0                   scram-sha-256</span><br></pre></td></tr></table></figure>

<p>重启postgresql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start postgresql</span><br></pre></td></tr></table></figure>

<p>修改超级用户密码或者创建新角色并授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 修改postgres密码</span></span><br><span class="line"><span class="comment">-- alter user postgres password &#x27;your_password&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建新角色并授权</span></span><br><span class="line">\c blogdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> ROLE blog_read_only <span class="keyword">WITH</span> LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ROLE blog_read_write <span class="keyword">WITH</span> LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ROLE blog_admin <span class="keyword">WITH</span> LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> blog_read_only;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> blog_read_write;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> blog_admin;</span><br></pre></td></tr></table></figure>

<h2 id="curd-example"><a href="#curd-example" class="headerlink" title="curd example"></a>curd example</h2><p>完成了pg的安装配置，接下来就是写一个demo测试了，首先，找一个数据表导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取countries.csv数据</span></span><br><span class="line">curl <span class="string">&#x27;https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv&#x27;</span> \</span><br><span class="line">    --output ./countries.csv</span><br></pre></td></tr></table></figure>

<p>创建数据库blogdb，并导入countries.csv</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database blogdb;</span><br><span class="line">\c blogdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> countries (</span><br><span class="line">  id <span class="type">integer</span> <span class="keyword">primary</span> key generated always <span class="keyword">as</span> <span class="keyword">identity</span>,</span><br><span class="line">  name text <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">  alpha_2 <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  alpha_3 <span class="type">char</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  numeric_3 <span class="type">char</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  iso_3166_2 text <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  region text,</span><br><span class="line">  sub_region text,</span><br><span class="line">  intermediate_region text,</span><br><span class="line">  region_code <span class="type">char</span>(<span class="number">3</span>),</span><br><span class="line">  sub_region_code <span class="type">char</span>(<span class="number">3</span>),</span><br><span class="line">  intermediate_region_code <span class="type">char</span>(<span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">copy</span> countries (</span><br><span class="line">  name,</span><br><span class="line">  alpha_2,</span><br><span class="line">  alpha_3,</span><br><span class="line">  numeric_3,</span><br><span class="line">  iso_3166_2,</span><br><span class="line">  region,</span><br><span class="line">  sub_region,</span><br><span class="line">  intermediate_region,</span><br><span class="line">  region_code,</span><br><span class="line">  sub_region_code,</span><br><span class="line">  intermediate_region_code</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> <span class="string">&#x27;/var/lib/pgsql/data/countries.csv&#x27;</span></span><br><span class="line">delimiter <span class="string">&#x27;,&#x27;</span> csv header;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check that the data got loaded into the table ok.</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> countries limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Should say 249.</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> countries;</span><br></pre></td></tr></table></figure>

<p>使用golang写一个简单的app，查询countries数据，到这里完成!</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/jackc/pgx/v5&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line"></span><br><span class="line">    conn, err := pgx.Connect(ctx, <span class="string">&quot;postgres://postgres:your_password@192.168.33.10:5432/blogdb?sslmode=disable&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close(ctx)</span><br><span class="line"></span><br><span class="line">    rows, err := conn.Query(ctx, <span class="string">&quot;SELECT id, name FROM countries LIMIT 10&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> id <span class="type">int</span></span><br><span class="line">        <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">        err = rows.Scan(&amp;id, &amp;name)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(id, <span class="string">&quot;-&quot;</span>, name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="开启ssl"><a href="#开启ssl" class="headerlink" title="开启ssl"></a>开启ssl</h3><p>如果想要在本地提前体验ssl加密配置的过程，那么按照下面的流程，先生成self-signed证书、私钥，最后修改配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入数据存储目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/pgsql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成self-signed ssl相关证书、私钥</span></span><br><span class="line">openssl req -new -x509 -days 365 -nodes -text -out server.crt \</span><br><span class="line">  -keyout server.key -subj <span class="string">&quot;/CN=dbhost.yourdomain.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除other、group的访问权限</span></span><br><span class="line"><span class="built_in">chmod</span> og-rwx server.key</span><br></pre></td></tr></table></figure>

<p>修改<code>postgresql.conf</code>文件，取消下面三行注释，需要保证证书放置在data目录，生产环境如果使用授权ca证书，修改的命令就不是ssl_cert_file以及ssl_key_file，按官网描述修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssl = on</span><br><span class="line">ssl_cert_file = &#x27;server.crt&#x27;</span><br><span class="line">ssl_key_file = &#x27;server.key&#x27;</span><br></pre></td></tr></table></figure>

<p>最后，demo里dsn移除<code>sslmode=disable</code>，然后重新运行验证</p>
]]></content>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL与PostgreSQL的使用区别</title>
    <url>/the-difference-between-mysql-and-postgresql-for-web-developer/</url>
    <content><![CDATA[<p>以<code>MySQL 9</code>以及<code>PostgreSQL 17</code>为例，从Web开发者的角度出发，列举两个数据库在使用方面的差异，仅介绍与CRUD依赖的操作，存储过程&#x2F;主从复制暂不介绍</p>
<h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h3 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h3><p><code>MySQL</code>创建管理员账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建mydb_admin管理员账户</span></span><br><span class="line"><span class="comment">-- 格式：`CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED WITH authentication_plugin BY &#x27;password&#x27;;`</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;mydb_admin&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> caching_sha2_password <span class="keyword">BY</span> <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 授权数据库/表访问权限</span></span><br><span class="line"><span class="comment">-- 格式：`GRANT PRIVILEGE ON database.table TO &#x27;username&#x27;@&#x27;host&#x27;;`</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;mydb_admin&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 如果不清楚有哪些权限，执行</span></span><br><span class="line"><span class="comment">-- SHOW PRIVILEGES;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 立即生效</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 查看账户列表核对</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.user;</span><br><span class="line"><span class="comment">-- SELECT * FROM mysql.user WHERE User=&#x27;mydb_admin&#x27; AND Host=&#x27;%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.查看账户授权</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;mydb_admin&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>创建管理员账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建mydb_admin管理员账户</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE mydb_admin LOGIN PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 授权数据库/表访问权限（需要多条语句）</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="comment">-- 如果不想让账号访问其他db</span></span><br><span class="line"><span class="comment">-- REVOKE CONNECT ON DATABASE otherdb1 FROM PUBLIC;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 所有跟public相关的授权都需要先切换到指定数据库</span></span><br><span class="line">\c mydb</span><br><span class="line"><span class="comment">-- 授权public</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="comment">-- 后续所有变更自动授权（由super admin执行）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> SEQUENCES <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> FUNCTIONS <span class="keyword">TO</span> mydb_admin;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 删除角色</span></span><br><span class="line"><span class="comment">-- DROP OWNED BY mydb_admin;</span></span><br><span class="line"><span class="comment">-- DROP ROLE mydb_admin;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>注意</strong></p>
<p><code>MySQL</code>通过上面配置即可对外提供访问，<code>PostgreSQL</code>还需要配置<code>pg_hba.conf</code>，此外，如果删除后重建mydb，需要重新授权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class="line"># host  all             all             0.0.0.0/32              scram-sha-256</span><br><span class="line">host    mydb mydb_admin 0.0.0.0/32 scram-sha-256</span><br><span class="line"># hostssl mydb mydb_admin 0.0.0.0/32 scram-sha-256</span><br></pre></td></tr></table></figure>

<h3 id="Web读写"><a href="#Web读写" class="headerlink" title="Web读写"></a>Web读写</h3><p><code>MySQL</code>创建CRUD账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建读写账户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;mydb_write&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> caching_sha2_password <span class="keyword">BY</span> <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;mydb_write&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建只读账户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;mydb_read&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> caching_sha2_password <span class="keyword">BY</span> <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;mydb_read&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>创建CRUD账户操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建读写账户</span></span><br><span class="line"><span class="comment">-- 创建角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE mydb_write_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色授权，只能连接mydb</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CONNECT</span> <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"><span class="comment">-- 所有跟public相关的授权都需要先切换到指定数据库</span></span><br><span class="line">\c mydb;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"><span class="comment">-- 后续所有变更自动授权（由super admin以及mydb_admin执行）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> mydb_write_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户并关联角色</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> mydb_write_user <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> mydb_write_role <span class="keyword">TO</span> mydb_write_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建只读账户</span></span><br><span class="line"><span class="comment">-- 创建角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE mydb_read_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CONNECT</span> <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"><span class="comment">-- 所有跟public相关的授权都需要先切换到指定数据库</span></span><br><span class="line">\c mydb;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"><span class="comment">-- 后续所有变更自动授权（由super admin以及mydb_admin执行）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES <span class="keyword">IN</span> SCHEMA public <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> TABLES <span class="keyword">TO</span> mydb_read_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户并关联角色</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> mydb_read_user <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> mydb_read_role <span class="keyword">TO</span> mydb_read_user;</span><br></pre></td></tr></table></figure>

<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h3><p><code>MySQL</code>建库操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 列出所有数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建mydb数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mydb;</span><br><span class="line"><span class="comment">-- 创建并设置charset</span></span><br><span class="line"><span class="comment">-- CREATE DATABASE mydb CHARACTER SET utf8mb4;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看建库sql</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 查看数据库列表核对</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.SCHEMATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 切换到mydb</span></span><br><span class="line">USE mydb;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>建库操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 列出所有数据库</span></span><br><span class="line">\l<span class="operator">+</span></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> datname <span class="keyword">FROM</span> pg_database;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建mydb数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 切换到mydb</span></span><br><span class="line">\c mydb</span><br></pre></td></tr></table></figure>

<h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p><code>MySQL</code>建表操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建数据表</span></span><br><span class="line"><span class="comment">-- 指定innodb、纪录备注、创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main(</span><br><span class="line">  `id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY COMMENT &quot;ID&quot;,</span><br><span class="line">  `order_number` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;order number&quot;,</span><br><span class="line">  `user_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;user id&quot;,</span><br><span class="line">  `product_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;product id&quot;,</span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(`order_number`),</span><br><span class="line">  INDEX `idx_user_id` (`user_id`)</span><br><span class="line">) ENGINE InnoDB <span class="keyword">DEFAULT</span> CHARSET utf8mb4 COMMENT &quot;order main&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单独创建索引示例如下</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX `idx_product_id` <span class="keyword">ON</span> `order_main`(`product_id`);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查看数据表列表核对</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="comment">-- SHOW TABLES LIKE &#x27;%order_main%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看建表语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>建表操作如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建数据表</span></span><br><span class="line"><span class="comment">-- 与关键字相同的字段需要使用双引号，不支持备注</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main(</span><br><span class="line">  &quot;id&quot; <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  &quot;order_number&quot; <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &quot;user_id&quot; <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &quot;product_id&quot; <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line">  <span class="keyword">UNIQUE</span>(&quot;order_number&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 非pk以及unique索引需要单独创建，名称需要区分数据表</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX &quot;order_main_idx_product_id&quot; <span class="keyword">ON</span> &quot;order_main&quot;(&quot;product_id&quot;);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查看数据表列表核对</span></span><br><span class="line">\dt<span class="operator">+</span></span><br><span class="line"><span class="comment">-- 列出所有数据库表</span></span><br><span class="line"><span class="comment">-- \dt *</span></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_catalog.pg_tables <span class="keyword">WHERE</span> schemaname <span class="operator">!=</span> <span class="string">&#x27;pg_catalog&#x27;</span> <span class="keyword">AND</span> schemaname <span class="operator">!=</span> <span class="string">&#x27;information_schema&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看数据表结构，不支持查看建表sql</span></span><br><span class="line">\d order_main</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="命令行显示优化"><a href="#命令行显示优化" class="headerlink" title="命令行显示优化"></a>命令行显示优化</h3><p><code>MySQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将;改为\G，以扩展模式输出</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_main\G</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mysql 所有输出自带命令执行耗时时长，单位：秒</span></span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 当内容长度超过一行自动切换为扩展模式输出</span></span><br><span class="line">\x auto</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出sql命令执行使用的时间，单位：毫秒</span></span><br><span class="line">\timing <span class="keyword">on</span></span><br></pre></td></tr></table></figure>

<h3 id="导入-导出sql"><a href="#导入-导出sql" class="headerlink" title="导入&#x2F;导出sql"></a>导入&#x2F;导出sql</h3><p><code>MySQL</code>如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入</span></span><br><span class="line">mysql -h localhost -u mydb_admin -P 3306 -p mydb &lt; mydb.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出</span></span><br><span class="line">mysqldump -h localhost -u mydb_admin -P 3306 -p mydb album &gt; mydb.album.sql</span><br></pre></td></tr></table></figure>

<p>或者使用sql导入文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 文件需要放在指定目录</span></span><br><span class="line">SOURCE <span class="operator">/</span>tmp<span class="operator">/</span>mydb.album.sql</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入，非if not exists，有数据会报错</span></span><br><span class="line">psql -d mydb -f mydb.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出</span></span><br><span class="line">pg_dump -t public.album mydb &gt; mydb.album.sql</span><br></pre></td></tr></table></figure>

<h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p><code>MySQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看服务器相关配置</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看服务器与buffer_pool相关的配置</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%buffer_pool%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改max_connections</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_connections<span class="operator">=</span><span class="number">1024</span>;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看服务器相关配置</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ALL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看max_connections</span></span><br><span class="line"><span class="keyword">SHOW</span> max_connections;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看服务器以max开头的配置</span></span><br><span class="line"><span class="keyword">SELECT</span> name, setting <span class="keyword">FROM</span> pg_settings <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;max_%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改timezone</span></span><br><span class="line"><span class="keyword">SET</span> timezone<span class="operator">=</span><span class="string">&#x27;Asia/Hong_kong&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p><code>MySQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前活动过进程</span></span><br><span class="line"><span class="keyword">SHOW</span> PROCESSLIST;</span><br><span class="line"><span class="comment">-- SHOW FULL PROCESSLIST;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结束进程</span></span><br><span class="line">KILL _pid_;</span><br></pre></td></tr></table></figure>

<p><code>PostgreSQL</code>如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前活动过进程</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_stat_activity;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结束进程</span></span><br><span class="line"><span class="keyword">SELECT</span> pg_cancel_backend(_pid_);</span><br><span class="line"><span class="keyword">SELECT</span> pg_terminate_backend(_pid_);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重新加载配置</span></span><br><span class="line"><span class="keyword">SELECT</span> pg_reload_conf();</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>postgresql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用colima作为docker desktop的替代</title>
    <url>/use-colima-as-an-alternative-to-docker-mac/</url>
    <content><![CDATA[<p>简单介绍下macOS当前docker运行环境的最新选择：colima，一个开源产品，使用体验与vagrant类似，感觉非常不错</p>
<h2 id="colima"><a href="#colima" class="headerlink" title="colima"></a>colima</h2><p>根据<a href="https://github.com/abiosoft/colima">colima</a>官方仓库指导安装colima</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install colima</span><br></pre></td></tr></table></figure>

<p>colima默认的runtime是docker，因为k8s已经剥离了docker，只保留containerd，所以为了跟k8s保持一致，另外也不想再多安装一个软件，就选择了只用containerd</p>
<p>但如果你使用了docker compose，那么最好还是根据教程安装docker以及docker-compose</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像并创建vm</span></span><br><span class="line">colima start --cpu 1 --memory 2 --disk 50 --runtime containerd</span><br><span class="line"><span class="comment"># 这里还可以开启kubernetes支持</span></span><br><span class="line"><span class="comment"># colima start --cpu 4 --memory 8 --disk 100 --runtime containerd --kubernetes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看vm列表</span></span><br><span class="line">colima list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接vm</span></span><br><span class="line">colima ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装nerdctl用于支持containerd</span></span><br><span class="line">colima nerdctl install</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="nerdctl"><a href="#nerdctl" class="headerlink" title="nerdctl"></a>nerdctl</h2><p>nerdctl是containerd的非核心命令行管理工具，与docker命令完全兼容，<code>containerd + nerdctl = docker</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看docker镜像列表，相当于docker image ls</span></span><br><span class="line">nerdctl image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">nerdctl pull mysql:9.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建container</span></span><br><span class="line">nerdctl run --name mysql9 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=a123456 -d mysql:9.2 --character-set-server=utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看container列表</span></span><br><span class="line">nerdctl ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接container</span></span><br><span class="line">nerdctl <span class="built_in">exec</span> -it mysql9 bash</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/abiosoft/colima">colima</a><br><a href="https://github.com/containerd/nerdctl">nerdctl</a><br><a href="https://smallsharpsoftwaretools.com/tutorials/use-colima-to-run-docker-containers-on-macos/">Use Colima to Run Docker Containers on macOS</a></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>kubernetes</tag>
        <tag>containerd</tag>
        <tag>nerdctl</tag>
        <tag>macOS</tag>
        <tag>colima</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次xdebug异常</title>
    <url>/vagrant-xdebug-not-working/</url>
    <content><![CDATA[<p>工欲善其事必先利其器，xdebug是php开发的一个杀手级利器，vagrant是一款非常便捷的虚拟机管理工具，两者搭配有时会出现一些奇怪的问题，近期在重新配置开发环境时，出现xdebug连不上的异常情况，花了些时间才找到问题并解决，记录下解决问题的过程，希望能帮助到一些小伙伴</p>
<h2 id="问题及解决过程"><a href="#问题及解决过程" class="headerlink" title="问题及解决过程"></a>问题及解决过程</h2><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>xdebug配置后，客户端多次请求，vscode均无任何反应。检查服务端、客户端配置，确认没有差错；监测网络数据，只有初次请求数据，无结果返回</p>
<h3 id="客户端-服务器配置信息"><a href="#客户端-服务器配置信息" class="headerlink" title="客户端&#x2F;服务器配置信息"></a>客户端&#x2F;服务器配置信息</h3><p>服务器是vagrant + ubuntu 18.04 + PHP 7.4，客户端是Windows 10，编辑器是vscode</p>
<p>初始xdebug配置如下</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[xdebug]</span></span><br><span class="line"><span class="attr">xdebug.remote_enable</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.remote_autostart</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.remote_port</span> = <span class="number">9001</span></span><br><span class="line"><span class="attr">xdebug.remote_handler</span> = <span class="string">&quot;dbgp&quot;</span></span><br><span class="line"><span class="attr">xdebug.remote_mode</span> = req</span><br><span class="line"><span class="attr">xdebug.remote_connect_back</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.overload_var_dump</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>vscode配置launch.json如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Listen for XDebug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;php&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">9001</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pathMappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;/data/example&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\data\\example&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="开启xdebug日志监测"><a href="#开启xdebug日志监测" class="headerlink" title="开启xdebug日志监测"></a>开启xdebug日志监测</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">xdebug.remote_log</span>=/tmp/xdebug.log</span><br></pre></td></tr></table></figure>

<p>再次请求，获取日志数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[140114918627520] Log opened at 2019-09-04 11:49:00</span><br><span class="line">[140114918627520] I: Checking remote connect back address.</span><br><span class="line">[140114918627520] I: Checking header &#x27;HTTP_X_FORWARDED_FOR&#x27;.</span><br><span class="line">[140114918627520] I: Checking header &#x27;REMOTE_ADDR&#x27;.</span><br><span class="line">[140114918627520] I: Remote address found, connecting to 192.168.33.1:9001.</span><br><span class="line">[140114918627520] E: Time-out connecting to client (Waited: 200 ms). :-(</span><br><span class="line">[140114918627520] Log closed at 2019-09-04 11:49:00</span><br></pre></td></tr></table></figure>

<p>日志显示服务端有正常向客户端9001端口发起连接，但客户端无响应导致超时，检查客户端防火墙无异常</p>
<p>最后，在谷歌上找到一个类似的问题，发现问题与vagrant有关，具体问题描述见参考文档链接</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 移除 xdebug.remote_connect_back = 1</span></span><br><span class="line"><span class="comment">; 添加</span></span><br><span class="line"><span class="attr">xdebug.remote_host</span>=<span class="number">10.0</span>.<span class="number">2.2</span></span><br></pre></td></tr></table></figure>

<p>重启php-fpm，再次测试，vscode可连接xdebug，问题解决</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://danemacmillan.com/how-to-configure-xdebug-in-phpstorm-through-vagrant/">How to configure Xdebug in PhpStorm through Vagrant</a><br><a href="https://stackoverflow.com/questions/24831707/xdebug-time-out-connecting-to-client-using-phpstorm-7-1-3-vagrant-virtualbo">xdebug Time-out connecting to client</a></p>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>vagrant</tag>
        <tag>xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kubeadm部署k8s集群</title>
    <url>/use-kubeadm-to-deploy-k8s-cluster/</url>
    <content><![CDATA[<p>部署计划：先创建一台虚拟机vm1，安装docker以及k8s组件，然后克隆两台新的vm2&#x2F;vm3，组合成一个小型的k8s集群</p>
<h2 id="虚拟机准备"><a href="#虚拟机准备" class="headerlink" title="虚拟机准备"></a>虚拟机准备</h2><h3 id="创建vm1"><a href="#创建vm1" class="headerlink" title="创建vm1"></a>创建vm1</h3><p>创建虚拟机vm1，以下就不展示繁琐的系统安装过程了</p>
<p><img src="/images/kvm_create_vm1.png" alt="kvm create vm1"></p>
<h3 id="配置vm1"><a href="#配置vm1" class="headerlink" title="配置vm1"></a>配置vm1</h3><p>根据教程：<a href="/deploy-docker-and-registry-service/">安装docker并部署registry服务</a>安装好containerd，再执行下面的配置</p>
<h4 id="系统配置修改"><a href="#系统配置修改" class="headerlink" title="系统配置修改"></a>系统配置修改</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux 模块</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> modprobe overlay</span><br><span class="line"><span class="built_in">sudo</span> modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># lsmod | grep overlay</span></span><br><span class="line"><span class="comment"># lsmod | grep br_netfilter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络配置</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> sysctl --system</span><br><span class="line"></span><br><span class="line"><span class="comment"># sudo sysctl -a | grep net.ipv4.ip_forward</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h4><p>关闭swap并移除文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看swap文件位置</span></span><br><span class="line"><span class="built_in">sudo</span> swapon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭swap</span></span><br><span class="line"><span class="built_in">sudo</span> swapoff /swap.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除swap文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /swap.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动项注释</span></span><br><span class="line"><span class="built_in">sudo</span> vi /etc/fstab</span><br><span class="line"><span class="comment"># 删除或注释下面行</span></span><br><span class="line"><span class="comment">#/swap.img      none    swap    sw      0       0</span></span><br></pre></td></tr></table></figure>

<h4 id="registry证书导入"><a href="#registry证书导入" class="headerlink" title="registry证书导入"></a>registry证书导入</h4><p>私有registry使用self-signed证书，kubeadm拉取时会报错，故将证书添加到vm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 物理机拷贝证书到vm1</span></span><br><span class="line">scp noname.io.crt noname@192.168.122.11:/home/noname/</span><br><span class="line"></span><br><span class="line"><span class="comment"># vm1 复制到系统目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> noname.io.crt /usr/local/share/ca-certificates/</span><br><span class="line"><span class="built_in">sudo</span> update-ca-certificates</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker <span class="comment"># 可选</span></span><br></pre></td></tr></table></figure>

<h4 id="containerd设置"><a href="#containerd设置" class="headerlink" title="containerd设置"></a>containerd设置</h4><p>修改<code>/etc/containerd/config.toml</code>，设置cgroup driver为systemd，同时可以修改pause版本，version是必须的，否则不生效，缩进非必要，可以删除</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="section">[plugins]</span></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span></span><br><span class="line">    <span class="attr">runtime_type</span> = <span class="string">&quot;io.containerd.runc.v2&quot;</span></span><br><span class="line">    <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span></span><br><span class="line">      <span class="attr">SystemdCgroup</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span></span><br><span class="line">    <span class="attr">sandbox_image</span> = <span class="string">&quot;registry.noname.io:5000/pause:3.10&quot;</span> <span class="comment"># 默认是3.8，这里可以不修改</span></span><br></pre></td></tr></table></figure>

<p>重启containerd服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>

<p>执行命令输出生效中的配置，验证配置是否跟预期一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd config dump | grep SystemdCgroup</span><br></pre></td></tr></table></figure>

<h4 id="docker配置（可选）"><a href="#docker配置（可选）" class="headerlink" title="docker配置（可选）"></a>docker配置（可选）</h4><p>k8s与docker分手后，vm只需要一个containerd就够了，但如果你同时也安装了docker，也可以修改<code>/etc/docker/daemon.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;exec-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;native.cgroupdriver=systemd&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;registry.noname.io:5000&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启docker服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="镜像准备（可选）"><a href="#镜像准备（可选）" class="headerlink" title="镜像准备（可选）"></a>镜像准备（可选）</h4><p>为了避免kubeadm init长时间卡在镜像拉取上，可以先在物理机上通过proxy拉取到本地，再推送到私有registry，最后配置从私有registry拉取image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># k8s需要的镜像，可以通过kubeadm config images list打印</span></span><br><span class="line">docker pull registry.k8s.io/kube-apiserver:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/kube-controller-manager:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/kube-scheduler:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/kube-proxy:v1.31.0</span><br><span class="line">docker pull registry.k8s.io/coredns/coredns:v1.11.1</span><br><span class="line">docker pull registry.k8s.io/pause:3.10</span><br><span class="line">docker pull registry.k8s.io/etcd:3.5.15-0</span><br><span class="line"><span class="comment"># cilium依赖的镜像</span></span><br><span class="line">docker pull quay.io/cilium/cilium:v1.15.6</span><br><span class="line">docker pull quay.io/cilium/operator-generic:v1.15.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新打tag</span></span><br><span class="line">docker tag registry.k8s.io/kube-apiserver:v1.31.0 registry.noname.io:5000/kube-apiserver:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/kube-controller-manager:v1.31.0 registry.noname.io:5000/kube-controller-manager:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/kube-scheduler:v1.31.0 registry.noname.io:5000/kube-scheduler:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/kube-proxy:v1.31.0 registry.noname.io:5000/kube-proxy:v1.31.0</span><br><span class="line">docker tag registry.k8s.io/coredns/coredns:v1.11.1 registry.noname.io:5000/coredns:v1.11.1</span><br><span class="line">docker tag registry.k8s.io/pause:3.10 registry.noname.io:5000/pause:3.10</span><br><span class="line">docker tag registry.k8s.io/etcd:3.5.15-0 registry.noname.io:5000/etcd:3.5.15-0</span><br><span class="line">docker tag quay.io/cilium/cilium:v1.15.6 registry.noname.io:5000/cilium/cilium:v1.15.6</span><br><span class="line">docker tag quay.io/cilium/operator-generic:v1.15.6 registry.noname.io:5000/cilium/operator-generic:v1.15.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送至私有registry</span></span><br><span class="line">docker push registry.noname.io:5000/kube-apiserver:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/kube-controller-manager:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/kube-scheduler:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/kube-proxy:v1.31.0</span><br><span class="line">docker push registry.noname.io:5000/coredns:v1.11.1</span><br><span class="line">docker push registry.noname.io:5000/pause:3.10</span><br><span class="line">docker push registry.noname.io:5000/etcd:3.5.15-0</span><br><span class="line">docker push registry.noname.io:5000/cilium/cilium:v1.15.6</span><br><span class="line">docker push registry.noname.io:5000/cilium/operator-generic:v1.15.6</span><br></pre></td></tr></table></figure>

<p>在虚拟机vm1中使用critool导入镜像，示例如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看containerd镜像</span></span><br><span class="line"><span class="built_in">sudo</span> crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像到containerd</span></span><br><span class="line"><span class="built_in">sudo</span> crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock pull registry.noname.io:5000/quay.io/cilium/operator-generic:v1.15.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新打tag</span></span><br><span class="line"><span class="built_in">sudo</span> ctr --namespace=k8s.io image tag registry.noname.io:5000/quay.io/cilium/operator-generic:v1.15.6 quay.io/cilium/operator-generic:v1.15.6</span><br></pre></td></tr></table></figure>

<h2 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h2><h3 id="apt方式安装（推荐）"><a href="#apt方式安装（推荐）" class="headerlink" title="apt方式安装（推荐）"></a>apt方式安装（推荐）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">sudo</span> apt update -y &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y apt-transport-https ca-certificates curl gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先创建好目录，如果没有的话</span></span><br><span class="line"><span class="comment"># sudo mkdir -p -m 755 /etc/apt/keyrings</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># curl这里需要使用http_proxy/https_proxy</span></span><br><span class="line">curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.31/deb/Release.key | <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认会覆盖已存在的/etc/apt/sources.list.d/kubernetes.list</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.31/deb/ /&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一 安装最新版，同时会安装ebtables cri-tools kubernetes-cni组件</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二 指定版本</span></span><br><span class="line"><span class="comment"># sudo apt install -y kubelet=1.31.0* kubeadm=1.31.0* kubectl=1.31.0*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时检查下xzip ethtool socat conntrack net-tools这几个组件是否安装</span></span><br><span class="line"><span class="comment"># sudo apt install -y xzip ethtool socat conntrack net-tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定版本</span></span><br><span class="line"><span class="built_in">sudo</span> apt-mark hold kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure>

<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p><strong>重点</strong>：<code>/usr/local/bin</code>以及<code>/opt/cni/bin</code>这两个目录树以及所有文件要确保所有者是root，否则会导致部署失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制软件到vm</span></span><br><span class="line"><span class="comment"># cd Downloads/</span></span><br><span class="line">scp kube* kubelet.service 10-kubeadm.conf noname@192.168.122.11:/home/noname/   <span class="comment"># kubernetes相关</span></span><br><span class="line">scp crictl-v1.30.1-linux-amd64.tar.gz noname@192.168.122.11:/home/noname/       <span class="comment"># cri-tools</span></span><br><span class="line">scp cni-plugins-linux-amd64-v1.5.1.tgz noname@192.168.122.11:/home/noname/      <span class="comment"># kubernetes-cni</span></span><br><span class="line">scp cilium-linux-v0.16.13.tar.gz noname@192.168.122.11:/home/noname/            <span class="comment"># cilium</span></span><br><span class="line">scp helm-v3.15.3-linux-amd64.tar.gz noname@192.168.122.11:/home/noname/         <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubernetes-cni</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /opt/cni/bin</span><br><span class="line"><span class="built_in">sudo</span> tar -C /opt/cni/bin -xzf cni-plugins-linux-amd64-v1.5.1.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># cri-tools</span></span><br><span class="line"><span class="built_in">sudo</span> tar -C /usr/local/bin -xzf crictl-v1.31.1-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># cilium</span></span><br><span class="line"><span class="built_in">sudo</span> tar -C /usr/local/bin -xzf cilium-linux-v0.16.13.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># helm</span></span><br><span class="line">tar zxf helm-v3.15.3-linux-amd64.tar.gz &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">mv</span> linux-amd64/helm /usr/local/bin/ &amp;&amp; <span class="built_in">rm</span> -rf linux-amd64/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将kubeadm等组件放置到指定目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> kube* /usr/local/bin/ &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/kube*</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/lib/kubelet</span><br><span class="line"><span class="comment"># 修改配置文件中的bin目录并放置到指定位置</span></span><br><span class="line"><span class="built_in">cat</span> kubelet.service | sed <span class="string">&quot;s:/usr/bin:/usr/local/bin:g&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /usr/lib/systemd/system/kubelet.service</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line"><span class="comment"># 同上</span></span><br><span class="line"><span class="built_in">cat</span> 10-kubeadm.conf | sed <span class="string">&quot;s:/usr/bin:/usr/local/bin:g&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保所有者是root</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R root:root /opt/cni</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R root:root /usr/local/bin</span><br></pre></td></tr></table></figure>

<h2 id="克隆vm1"><a href="#克隆vm1" class="headerlink" title="克隆vm1"></a>克隆vm1</h2><p>以上初步准备安装好了k8s，现在还不能执行初始化部署，复制两个新的vm，避免每台机器都重复执行上面的操作，偷懒</p>
<p>新的vm需要确保跟旧的vm1不能有相同的MAC地址、hostname、product_uuid</p>
<h3 id="hostname重命名"><a href="#hostname重命名" class="headerlink" title="hostname重命名"></a>hostname重命名</h3><p>修改hostname</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> hostnamectl hostname vm1</span><br><span class="line"><span class="comment"># sudo hostnamectl hostname vm2</span></span><br><span class="line"><span class="comment"># sudo hostnamectl hostname vm3</span></span><br></pre></td></tr></table></figure>

<h3 id="重新生成machine-id"><a href="#重新生成machine-id" class="headerlink" title="重新生成machine-id"></a>重新生成machine-id</h3><p>dhcp获取IP时，依赖的是machine-id，如果三台机器的machine-id都一样，你会发现所有vm的IP地址都是一样的，会出现冲突，比如ssh突然断线</p>
<p>先关闭其他机器如vm1，使用同样ssh命令如<code>ssh noname@192.168.122.11</code>连接到新的vm2&#x2F;vm3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要确保/etc/machine-id与/var/lib/dbus/machine-id一致，软连接来的，只要改一个</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/machine-id</span><br><span class="line"><span class="built_in">sudo</span> dbus-uuidgen --ensure=/etc/machine-id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次确认下，确定三台机器的product_uuid都不一样</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/class/dmi/id/product_uuid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启机器</span></span><br><span class="line"><span class="built_in">sudo</span> reboot now</span><br></pre></td></tr></table></figure>

<h3 id="cockpit绑定MAC以及IP"><a href="#cockpit绑定MAC以及IP" class="headerlink" title="cockpit绑定MAC以及IP"></a>cockpit绑定MAC以及IP</h3><p>点击添加【静态主机条目】，绑定mac地址与ip地址，避免重启一次机器就变一次IP</p>
<p><img src="/images/bind_ip_and_mac.png" alt="bind ip and mac"></p>
<h3 id="hosts修改"><a href="#hosts修改" class="headerlink" title="hosts修改"></a>hosts修改</h3><p>往hosts添加三台vm的host映射，移除<code>127.0.0.1 vm1</code>字样的的记录</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">192.168.0.105 registry.noname.io</span><br><span class="line"></span><br><span class="line">192.168.122.11 vm1</span><br><span class="line">192.168.122.126 vm2</span><br><span class="line">192.168.122.235 vm3</span><br></pre></td></tr></table></figure>

<h2 id="部署k8s"><a href="#部署k8s" class="headerlink" title="部署k8s"></a>部署k8s</h2><p>好了，到这里就可以开始使用kubeadm初始化部署k8s集群了</p>
<h3 id="执行kubeadm-init"><a href="#执行kubeadm-init" class="headerlink" title="执行kubeadm init"></a>执行kubeadm init</h3><p>方法一，直接运行下面命令，比较适合简单的集群配置，不涉及太多配置修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm init --skip-phases addon/kube-proxy --apiserver-advertise-address 192.168.122.11 --node-name vm1 --image-repository registry.noname.io:5000</span><br></pre></td></tr></table></figure>

<p>方法二，通过命令导出默认配置内容，修改相关配置，最后指定config文件运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导出默认配置</span></span><br><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm_config.yaml</span><br></pre></td></tr></table></figure>

<p>把advertiseAddress、name、skipPhases、imageRepository等需要修改的地方全改了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">bootstrapTokens:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">system:bootstrappers:kubeadm:default-node-token</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">abcdef.0123456789abcdef</span></span><br><span class="line">  <span class="attr">ttl:</span> <span class="string">24h0m0s</span></span><br><span class="line">  <span class="attr">usages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">signing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">authentication</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line">  <span class="attr">advertiseAddress:</span> <span class="number">192.168</span><span class="number">.122</span><span class="number">.11</span></span><br><span class="line">  <span class="attr">bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line">  <span class="attr">criSocket:</span> <span class="string">unix:///var/run/containerd/containerd.sock</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vm1</span></span><br><span class="line">  <span class="attr">taints:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">skipPhases:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">addon/kube-proxy</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">timeoutForControlPlane:</span> <span class="string">4m0s</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">clusterName:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">controllerManager:</span> &#123;&#125;</span><br><span class="line"><span class="attr">dns:</span> &#123;&#125;</span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.noname.io:5000</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="number">1.31</span><span class="number">.0</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">dnsDomain:</span> <span class="string">cluster.local</span></span><br><span class="line">  <span class="attr">serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span></span><br><span class="line"><span class="attr">scheduler:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>dry-run验证kubeadm_config.yaml文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm init --config kubeadm_config.yaml --dry-run</span><br></pre></td></tr></table></figure>

<p>执行初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm init --config kubeadm_config.yaml</span><br></pre></td></tr></table></figure>

<p>正常情况下，只要没有中途退出报错，走到这里就是安装成功的第一步了。如果出现异常可以在初始化命令后面加<code>-v 5</code>打印更具体的报错信息，我也把遇到过的报错情况放到了最后的bug处理，接下来就是验证集群是否在正常工作了</p>
<p>PS：kubeadm提示可以在执行init命令前可以先拉取image，我试了一下<code>kubeadm config images pull</code>，发现init还是会去拉取image，上面就不在记录这个步骤</p>
<h3 id="集群状态验证"><a href="#集群状态验证" class="headerlink" title="集群状态验证"></a>集群状态验证</h3><p>配置bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<p>执行命令，验证集群的工作状态。<strong>注意</strong>：安装过程中如果有使用proxy会导致kubectl连接不上api server，导致超时，需要删除环境变量<code>unset http_proxy</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看6443端口的监听情况</span></span><br><span class="line"><span class="built_in">sudo</span> netstat -tnlp | grep 6443</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出集群状态</span></span><br><span class="line">kubectl cluster-info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有节点信息</span></span><br><span class="line">kubectl get nodes -o wide</span><br><span class="line">kubectl describe nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于现在还没有安装cilium cni，此时coredns应处于pending状态</span></span><br><span class="line">kubectl get pods -A -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有pod反复崩溃重启，查看相关日志</span></span><br><span class="line">kubectl logs &lt;pod名称&gt; -n &lt;namespace&gt; -p</span><br><span class="line">kubectl describe &lt;pod名称&gt; -n &lt;namespace&gt; -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过crictl查看container，操作类似docker</span></span><br><span class="line"><span class="built_in">sudo</span> crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock ps -a</span><br></pre></td></tr></table></figure>

<h3 id="安装cilium"><a href="#安装cilium" class="headerlink" title="安装cilium"></a>安装cilium</h3><p>下载cilium，安装到&#x2F;usr&#x2F;local&#x2F;bin&#x2F;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可能需要proxy</span></span><br><span class="line">curl -L --fail --remote-name-all https://github.com/cilium/cilium-cli/releases/download/v0.16.15/cilium-linux-amd64.tar.gz&#123;,.<span class="built_in">sha256sum</span>&#125;</span><br><span class="line"><span class="built_in">sha256sum</span> --check cilium-linux-amd64.tar.gz.sha256sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略目录操作了</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> cilium /usr/local/bin/</span><br></pre></td></tr></table></figure>

<p>cilium查看组件安装情况以及报错信息，这里可以根据输出拉取相关image推送到私有registry，cni目录需要保证所有者是root</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看cilium状态、错误</span></span><br><span class="line">cilium status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保/opt/cni目录的所有者是root</span></span><br><span class="line"><span class="comment"># sudo chown -R root:root /opt/cni</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群安装cilium</span></span><br><span class="line">cilium install</span><br><span class="line"><span class="comment"># 指定版本安装</span></span><br><span class="line"><span class="comment"># cilium install v1.15.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod是否准备就绪-running</span></span><br><span class="line">kubectl get pods -A -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点状态应变为-Ready</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<p>到这里集群的初始化就完成了，congratulations</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="单节点k8s"><a href="#单节点k8s" class="headerlink" title="单节点k8s"></a>单节点k8s</h4><p>如果你不想要组集群了，想使用单个节点，那么移除taint即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/control-plane-</span><br><span class="line"><span class="comment"># 这个taint未必存在</span></span><br><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>

<h4 id="配置proxy拉取镜像"><a href="#配置proxy拉取镜像" class="headerlink" title="配置proxy拉取镜像"></a>配置proxy拉取镜像</h4><p>如果你不想使用私有的registry，那么可以使用proxy，containerd的配置如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl set-environment HTTP_PROXY=192.168.0.105:8118</span><br><span class="line"><span class="built_in">sudo</span> systemctl set-environment HTTPS_PROXY=192.168.0.105:8118</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>

<p>然后，不论是直接执行<code>kubeadm init</code>还是<code>kubeadm config images pull</code>，拉取镜像都会通过proxy拉取</p>
<h4 id="Dashboard-UI"><a href="#Dashboard-UI" class="headerlink" title="Dashboard UI"></a>Dashboard UI</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>方法一：使用helm安装（官方推荐）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 kubernetes-dashboard 仓库</span></span><br><span class="line">helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/</span><br><span class="line"><span class="comment"># 使用 kubernetes-dashboard Chart 部署名为 `kubernetes-dashboard` 的 Helm Release</span></span><br><span class="line">helm upgrade --install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard --create-namespace --namespace kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>方法二：下载配置文件导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以下载后传送到vm</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>

<p>执行<code>kubectl get pods -A</code>，你会在kubernetes-dashboard命名空间下看到两个pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS      AGE     IP                NODE   NOMINATED NODE   READINESS GATES</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper-6b96ff7878-ct999   1/1     Running   0             6m57s   10.0.1.215        vm2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard-8696f5f494-8cx4d        1/1     Running   0             6m57s   10.0.1.62         vm2    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>如果无法拉取image，可以在物理机下载后推送到私有registry</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull kubernetesui/dashboard:v2.7.0</span><br><span class="line">docker pull kubernetesui/metrics-scraper:v1.0.8</span><br></pre></td></tr></table></figure>

<h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>新建文件<code>dashboard-user.yaml</code>，创建用户、绑定角色，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: dashboard-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: dashboard-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: dashboard-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f dashboard-user.yaml</span><br></pre></td></tr></table></figure>

<h5 id="访问dashboard"><a href="#访问dashboard" class="headerlink" title="访问dashboard"></a>访问dashboard</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br><span class="line"><span class="comment"># 新版本限制死了只能在执行了kubectl proxy的机器上打开，没什么意义</span></span><br><span class="line"><span class="comment"># kubectl proxy --address 0.0.0.0 --accept-hosts &#x27;.*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取登陆的token</span></span><br><span class="line">kubectl -n kubernetes-dashboard create token dashboard-user</span><br><span class="line"></span><br><span class="line"><span class="comment"># 物理机建立ssh port forwarding</span></span><br><span class="line">ssh -L 8001:127.0.0.1:8001 noname@192.168.122.11</span><br></pre></td></tr></table></figure>

<p>在物理机浏览器打开dashboard页面：<a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a> ，输入token即可进入dashboard界面</p>
<h3 id="部署vm2-vm3"><a href="#部署vm2-vm3" class="headerlink" title="部署vm2&#x2F;vm3"></a>部署vm2&#x2F;vm3</h3><p>打印vm1的k8s token信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>

<p>在vm2&#x2F;vm3执行命令，加入集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> kubeadm <span class="built_in">join</span> 192.168.122.11:6443 --token 1kf3mx.6omg1ycbi6xul19q \</span><br><span class="line">  --discovery-token-ca-cert-hash sha256:9a412686425ed09f8156ec63cb52e798a61cf8de85069be0e36ec023f806ea4f</span><br></pre></td></tr></table></figure>

<p>在vm1验证集群状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>

<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>以下列出几个简单的app部署教程，从简单到复杂</p>
<ol>
<li><a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">nginx-deployment</a></li>
</ol>
<p>该教程是最简单的deployment使用教程，提供的功能是一个简单的http服务器，对外输出静态html页面，pod只有一个nginx的container，不涉及多container交互、存储等，该教程是一个很好的入门切入点</p>
<ol start="2">
<li><a href="https://kubernetes.io/docs/tutorials/stateless-application/guestbook/">guestbook</a></li>
</ol>
<p>该教程会教你如何部署一个redis主从服务、php服务，最后创建一个可对外的service，简单的说，是教你多个container如何交互并提供对外访问能力（集群内），这里不涉及存储、ingress等。应用提供的功能可以理解为动态http服务器，php从redis读取数据输出html页面、写入数据到redis</p>
<ol start="3">
<li><a href="https://kubernetes.io/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/">wordpress</a></li>
</ol>
<p>该教程会教你如何创建持久卷保存数据，涉及mysql部署、wordpress部署、创建secret，到这里基本涵盖到平时大多数的使用场景了</p>
<p><strong>注意</strong>：由于该教程是基于minikube的，直接部署到自建的k8s集群会有很多问题，比如</p>
<ul>
<li>不支持LoadBalancer，我们需要删除掉wordpress-deployment.yaml文件service声明配置里的<code>type: LoadBalancer</code></li>
<li>缺少默认的storageclass，不支持动态制备，只能手动建立pv，然后在pvc关联pv，具体如下</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把下面这部分配置插入到wordpress-deployment.yaml的pvc声明前面</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/k8s/pv/mysql-pv</span></span><br><span class="line"><span class="comment"># 同时往pvc的spec部分添加下面这句话</span></span><br><span class="line"><span class="comment"># volumeName: mysql-pv</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 把下面这部分配置插入到mysql-deployment.yaml的pvc声明前面</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wp-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/k8s/pv/wp-pv</span></span><br><span class="line"><span class="comment"># 同时往pvc的spec部分添加下面这句话</span></span><br><span class="line"><span class="comment"># volumeName: wp-pv</span></span><br></pre></td></tr></table></figure>

<p>最后，在vm1节点执行命令创建端口转发</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 映射到vm1</span></span><br><span class="line">kubectl port-forward svc/wordpress 8888:80</span><br><span class="line"><span class="comment"># 映射到物理机</span></span><br><span class="line">ssh -L 8888:127.0.0.1:8888 noname@192.168.122.11</span><br></pre></td></tr></table></figure>

<p>done!</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>注意，按照以上教程安装的集群属于裸集群（bare-metal），默认不支持以下几个功能</p>
<ul>
<li>Load Balancer Service</li>
<li>Persistent Volume</li>
<li>Ingress&#x2F;Gateway</li>
</ul>
<p>如果你的角色是开发者，还是老老实实使用Minikube，避免耗费太多时间精力在集群运维上</p>
<p>另外，一个完整的运维系统不仅仅只是k8s，应当包含以下组件</p>
<ul>
<li>k8s，负责管理pod资源（cpu&#x2F;内存）、node资源</li>
<li>分布式文件系统，负责持久存储</li>
<li>gateway，负责控制外部流量对集群内服务的访问</li>
<li>elk，负责日志收集、分析、告警</li>
<li>jaeger&#x2F;prometheus，负责收集指标、链路分析、告警</li>
<li>ci&#x2F;cd系统，如gitlab，负责开发-发布系统流程</li>
<li>管理后台，负责应用管理、发布审核、记录审计信息等</li>
</ul>
<h3 id="bug处理"><a href="#bug处理" class="headerlink" title="bug处理"></a>bug处理</h3><ol>
<li><code>kubeadm init</code>执行后集群组件反复崩溃重启<code>CrashLoopBackOff</code>或者是卡在<code>kubelet-check</code>检查步骤</li>
</ol>
<p>该问题原因与下面的cilium报错原因一致，软件权限导致的。在最开始时我使用的是手动安装方式，软件都是解压缩复制到bin目录，没有注意到所有组件的owner不是root，这才导致了上面这个问题。虽然是一个很容易忽视的问题，但却让我花了很长时间去debug，太亏了</p>
<ol start="2">
<li>cilium安装报错<code>cp: cannot create regular file &#39;/hostbin/cilium-mount&#39;: Permission denied</code></li>
</ol>
<p>这是因为这个目录是我手动创建的，在执行apt安装前就存在，目录的owner不是root，需要确保虚拟机&#x2F;opt&#x2F;cni目录的所有者是root，执行<code>sudo chown -R root:root /opt/cni</code>解决，详细看：<a href="https://github.com/cilium/cilium/issues/23838">https://github.com/cilium/cilium/issues/23838</a></p>
<ol start="3">
<li>kubeadm join报错<code>&#39;/run/systemd/resolve/resolv.conf&#39;: No such file or directory</code></li>
</ol>
<p>从服务器我换了一个debian，毕竟线上服务器通常都不是同一类系统，而这次报错的服务器bookworm就没有安装<code>systemd-resolved</code>，下载安装即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install systemd-resolved</span><br></pre></td></tr></table></figure>

<p>上面debian的修改会引入另一个问题，就是vm无法连通外网了，发现是dhcp有异常，进而导致<code>ImagePullBackOff</code>，也不知道为什么不能直接读取本地的image，需要使用<code>systemd-networkd</code>才行，详细看问题描述<a href="https://garajau.com.br/2022/01/configure-networkd-debian">Configuring systemd-networkd on Debian</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line"><span class="built_in">mv</span> /etc/network/interfaces /etc/network/interfaces.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增systemd-dhcp配置</span></span><br><span class="line"><span class="built_in">sudo</span> vi /etc/systemd/network/dhcp.network</span><br></pre></td></tr></table></figure>

<p>dhcp.network文件内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">[Match]</span><br><span class="line">Name=en*</span><br><span class="line">   </span><br><span class="line">[Network]</span><br><span class="line">DHCP=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>设置开机启动并重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> systemd-networkd</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart systemd-networkd</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>nginx-deployment报错<code>ImagePullBackOff</code></li>
</ol>
<p>这个问题很奇怪，除了前面提到的网络问题，还可能是hash值不匹配</p>
<p>当时我改了<a href="https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/controllers/nginx-deployment.yaml">nginx-deployment.yaml</a>里的镜像，而且确认本地已经拉取过来了，但部署时就一直报错，最后我在物理机重新拉取镜像时发现hash值居然对不上，最后重新打tag推送才解决</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">安装 kubeadm</a><br><a href="https://blog.radwell.codes/2022/07/single-node-kubernetes-cluster-via-kubeadm-on-ubuntu-22-04/">Simple Single-node Kubernetes Cluster via kubeadm on Ubuntu 22.04</a><br><a href="https://www.linuxtechi.com/install-kubernetes-cluster-on-debian/">How to Install Kubernetes Cluster on Debian 12 | 11</a><br><a href="https://izsk.me/2023/06/03/cilium-on-kubernetes-install/">cilium在kubernetes中的生产实践二(cilium部署)</a><br><a href="https://www.tutorialworks.com/difference-docker-containerd-runc-crio-oci/#:~:text=runc%20provides%20all%20of%20the,create%20and%20run%20container%20processes.">The differences between Docker, containerd, CRI-O and runc</a><br><a href="https://spacelift.io/blog/kubernetes-dashboard">Kubernetes Dashboard: Tutorial, Best Practices &amp; Alternatives</a><br><a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md">Creating sample user</a><br><a href="https://unix.stackexchange.com/questions/402999/is-it-ok-to-change-etc-machine-id">Is it OK to change &#x2F;etc&#x2F;machine-id?</a><br><a href="https://developer-friendly.blog/blog/2024/03/03/kubernetes-the-hard-way/">Kubernetes The Hard Way</a></p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
        <tag>kubeadm</tag>
      </tags>
  </entry>
  <entry>
    <title>golang系列之-内存分配</title>
    <url>/golang-series-memory-allocation/</url>
    <content><![CDATA[<p>golang的内存分配机制最初是基于TCMalloc，演化至今已经有了很大差异。其原理是：slab + tiling algorithm + 层级内存分配。本文仅介绍如何通过mallocgc分配内存，不涉及栈内存分配管理、手动内存管理等内容。当前go版本：1.24</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="slab-tiling"><a href="#slab-tiling" class="headerlink" title="slab + tiling"></a>slab + tiling</h3><p>内存分配基本单位-mspan（即slab），内部再划分更小的块（即tiling）</p>
<p>小对象（&lt;&#x3D;32KB）按预定义的sizeclass分成不同的mspan，每个mspan最低有8KB，切割成指定大小的块。而大对象（&gt;32KB）的sizeclass&#x3D;0，不限制大小，mspan不分块。如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mspann -&gt; sizeclass=0  -&gt; nKB  -&gt; | &lt;-----   nKB   -----&gt; |</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// mspanx -&gt; sizeclass=1  -&gt; 8KB  -&gt; | 8B  | 8B  | ... | 8B  |</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// mspany -&gt; sizeclass=5  -&gt; 8KB  -&gt; | 48B | 48B | ... | 48B |</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// mspanz -&gt; sizeclass=65 -&gt; 80KB</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>如<code>make([]int, 5)</code>，创建一块40B大小的内存区域，经过计算这个内存块会从sizeclass&#x3D;5的mspan分配（该mspan的每个元素大小为48B）</p>
<h3 id="层级内存分配"><a href="#层级内存分配" class="headerlink" title="层级内存分配"></a>层级内存分配</h3><p>参考TCMalloc，内存分配时主要分为3级：mcache、mcentral、mheap</p>
<ol>
<li>mcache为线程缓存，每个p都有一个，所有的内存分配&#x2F;回收都是先通过mcache，访问不需要加锁</li>
<li>mcentral负责向mheap申请分配内存、管理mspan，按spanclass分组，嵌入到mheap结构体，全局唯一</li>
<li>mheap负责从系统申请内存进行分配管理，一般情况下访问都要加锁，全局唯一</li>
</ol>
<p>执行mallocgc分配内存时，mheap、mcentral、mcache的关系如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  mallocgc</span></span><br><span class="line"><span class="comment">//     |</span></span><br><span class="line"><span class="comment">//     |    (&lt;=32KB)</span></span><br><span class="line"><span class="comment">//     |--&gt; p.mcache.alloc[spanclass] --&gt; mheap.central[spanclass] --&gt; mheap</span></span><br><span class="line"><span class="comment">//     |</span></span><br><span class="line"><span class="comment">//     |    (&gt;32KB)</span></span><br><span class="line"><span class="comment">//     |--&gt; mheap</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果对象&lt;&#x3D;32KB<ul>
<li>从p的mcache找一个空闲的mspan分配一段内存&#x2F;地址空间</li>
<li>如果mspan没有空闲空间，从mcentral申请一个新的&#x2F;重用一个已清扫的mspan</li>
<li>如果mcentral也没有可用mspan，通过mheap跟OS申请一段内存，初始化一个mspan返回</li>
</ul>
</li>
<li>如果对象&gt;32KB<ul>
<li>通过mheap跟OS申请一段内存，初始化一个mspan返回</li>
</ul>
</li>
</ul>
<h3 id="系统内存状态"><a href="#系统内存状态" class="headerlink" title="系统内存状态"></a>系统内存状态</h3><p>这里需要了解系统内存的几个状态，以及go内部是如何从系统分配、释放内存的</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>None</strong></td>
<td>默认状态，未映射，地址空间未被保留或使用</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>已保留，但未提交，即地址空间已经被申请，但尚未向操作系统请求实际物理内存</td>
</tr>
<tr>
<td><strong>Prepared</strong></td>
<td>已提交但未使用，已经向操作系统申请了物理内存，但可能未完全初始化</td>
</tr>
<tr>
<td><strong>Ready</strong></td>
<td>可用状态，内存已初始化，可用于分配</td>
</tr>
</tbody></table>
<p>状态转换函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">主要作用</th>
<th align="left">是否分配物理内存</th>
<th align="left">是否映射虚拟内存</th>
<th align="left">内存状态转换</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>sysAlloc</code></td>
<td align="left"><strong>直接申请内存</strong></td>
<td align="left">✅ 是</td>
<td align="left">✅ 是</td>
<td align="left">None -&gt; Ready</td>
<td align="left">可能会触发 <code>mmap</code></td>
</tr>
<tr>
<td align="left"><code>sysReserve</code></td>
<td align="left"><strong>保留虚拟地址空间，但不映射</strong></td>
<td align="left">❌ 否</td>
<td align="left">✅ 是</td>
<td align="left">None -&gt; Reserved</td>
<td align="left">预留地址，后续 <code>sysMap</code></td>
</tr>
<tr>
<td align="left"><code>sysMap</code></td>
<td align="left"><strong>将预留的虚拟地址映射为实际物理内存</strong></td>
<td align="left">✅ 是</td>
<td align="left">✅ 是</td>
<td align="left">Reserved -&gt; Prepared</td>
<td align="left">只有 <code>sysReserve</code> 过的地址能 <code>sysMap</code></td>
</tr>
<tr>
<td align="left"><code>sysUsed</code></td>
<td align="left"><strong>标记某段地址正在使用</strong></td>
<td align="left">✅ 是</td>
<td align="left">✅ 是</td>
<td align="left">Prepared -&gt; Ready</td>
<td align="left">可能会触发 <code>madvise</code> 让物理页生效</td>
</tr>
<tr>
<td align="left"><code>sysUnused</code></td>
<td align="left"><strong>标记某段地址未使用</strong>，可以回收物理内存</td>
<td align="left">⚠️ 可能</td>
<td align="left">❌ 否</td>
<td align="left">Ready -&gt; Prepared</td>
<td align="left"><code>MADV_DONTNEED</code>，内存仍属于进程</td>
</tr>
<tr>
<td align="left"><code>sysFault</code></td>
<td align="left"><strong>让一段地址变成不可访问</strong></td>
<td align="left">❌ 否</td>
<td align="left">✅ 是</td>
<td align="left">Ready -&gt; Reserved</td>
<td align="left"><code>mprotect(PROT_NONE)</code>，用于调试</td>
</tr>
<tr>
<td align="left"><code>sysFree</code></td>
<td align="left"><strong>释放虚拟内存，归还给 OS</strong></td>
<td align="left">✅ 是</td>
<td align="left">✅ 是</td>
<td align="left">-&gt; None</td>
<td align="left"><code>munmap</code>，这段内存不能再用</td>
</tr>
</tbody></table>
<p><strong>我对Go内存分配的理解</strong></p>
<ol>
<li>内存管理的本质是地址空间的组织和维护</li>
<li>Go的内存策略：尽量保留虚拟地址，按需释放物理页</li>
<li>Go会一次性申请64MB内存（Reserved-虚拟地址空间），但并不是立即分配物理页，而是在需要分配时使用sysMap + sysUsed使一小部份内存可用（Reserved-&gt;Prepared-&gt;Ready）</li>
</ol>
<h3 id="GC助攻"><a href="#GC助攻" class="headerlink" title="GC助攻"></a>GC助攻</h3><p>为了防止内存分配速度过快，导致GC跟不上，分配时会判断是否需要协助GC标记&#x2F;清扫。每次都要判断是否需要协助标记，而清扫只发生在获取新的mspan和大对象分配场景下</p>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h3><p>mspan负责纪录一片连续内存区域的起始&#x2F;终止地址、组织信息等，实际可用内存地址需要通过页分配器获得。一个mspan最少可管理8KB的内存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    _                     sys.NotInHeap</span><br><span class="line">    next                  *mspan        <span class="comment">// 链表用</span></span><br><span class="line">    prev                  *mspan        <span class="comment">// 链表用</span></span><br><span class="line">    list                  *mSpanList    <span class="comment">// debug，忽略</span></span><br><span class="line"></span><br><span class="line">    startAddr             <span class="type">uintptr</span>       <span class="comment">// 连续内存区域起始地址，同base</span></span><br><span class="line">    npages                <span class="type">uintptr</span>       <span class="comment">// 页数量，每个页8KB，每个mspan最少有1个页</span></span><br><span class="line"></span><br><span class="line">    manualFreeList        gclinkptr     <span class="comment">// 空闲对象链表，状态为mSpanManual时用</span></span><br><span class="line"></span><br><span class="line">    freeindex             <span class="type">uint16</span>        <span class="comment">// 下一个可用对象索引，范围[0,nelems)，GC后重置为0</span></span><br><span class="line">    nelems                <span class="type">uint16</span>        <span class="comment">// 可存储对象总量，=n*8192/elemsize</span></span><br><span class="line">    freeIndexForScan      <span class="type">uint16</span>        <span class="comment">// 同freeindex，用于GC</span></span><br><span class="line"></span><br><span class="line">    allocCache            <span class="type">uint64</span>        <span class="comment">// 64位bitmap，用于快速分配，从allocBits获取填充</span></span><br><span class="line"></span><br><span class="line">    allocBits             *gcBits       <span class="comment">// bitmap，用于标记mspan内哪些对象已被使用</span></span><br><span class="line">    gcmarkBits            *gcBits       <span class="comment">// bitmap，用于GC时将对象置为黑色</span></span><br><span class="line">    pinnerBits            *gcBits       <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果sweepgen == h-&gt;sweepgen - 2，mspan需要被清扫</span></span><br><span class="line">    <span class="comment">// 如果sweepgen == h-&gt;sweepgen - 1，mspan正在被清扫</span></span><br><span class="line">    <span class="comment">// 如果sweepgen == h-&gt;sweepgen，mspan已被清扫，可以随时被使用</span></span><br><span class="line">    <span class="comment">// 如果sweepgen == h-&gt;sweepgen + 1，mspan在sweep启动前被mcache使用，当然仍被使用，需要清扫</span></span><br><span class="line">    <span class="comment">// 如果sweepgen == h-&gt;sweepgen + 3，mspan已被清扫并被mcache使用</span></span><br><span class="line">    sweepgen              <span class="type">uint32</span>        <span class="comment">// 版本计数器，使用时/GC时同步mheap.sweepgen</span></span><br><span class="line">    divMul                <span class="type">uint32</span>        <span class="comment">// 用于优化除法运算</span></span><br><span class="line">    allocCount            <span class="type">uint16</span>        <span class="comment">// 已分配对象数，范围[0,nelems]</span></span><br><span class="line">    spanclass             spanClass     <span class="comment">// 类别，由7位sizeclass和1位noscan组成</span></span><br><span class="line">    state                 mSpanStateBox <span class="comment">// 状态，0-默认 1-使用中(heap) 2-使用中(手动)</span></span><br><span class="line">    needzero              <span class="type">uint8</span>         <span class="comment">// 分配前是否需要清0</span></span><br><span class="line">    isUserArenaChunk      <span class="type">bool</span>          <span class="comment">// 归属于arena包，用户手动管理</span></span><br><span class="line">    allocCountBeforeCache <span class="type">uint16</span>        <span class="comment">// allocCount快照，统计用</span></span><br><span class="line">    elemsize              <span class="type">uintptr</span>       <span class="comment">// 对象大小</span></span><br><span class="line">    limit                 <span class="type">uintptr</span>       <span class="comment">// 终止地址，与startAddr搭配使用</span></span><br><span class="line">    speciallock           mutex         <span class="comment">//</span></span><br><span class="line">    specials              *special      <span class="comment">//</span></span><br><span class="line">    userArenaChunkFree    addrRange     <span class="comment">//</span></span><br><span class="line">    largeType             *_type        <span class="comment">// 数据类型，大对象（&gt;32KB）分配时纪录，为nil表示noscan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>scan&#x2F;noscan</strong></p>
<p>noscan：如果对象是nil或者对象不包含指针（scalar）<br>scan：对象包含指针，如一个结构体有字段类型是指针类型</p>
<p><strong>状态</strong></p>
<p>mspan状态列表如下</p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mSpanDead</td>
<td align="left">0</td>
<td align="left">默认状态，未使用&#x2F;回收</td>
</tr>
<tr>
<td align="left">mSpanInUse</td>
<td align="left">1</td>
<td align="left">使用中，由go自己管理</td>
</tr>
<tr>
<td align="left">mSpanManual</td>
<td align="left">2</td>
<td align="left">使用中，手动管理，一般用于栈分配</td>
</tr>
</tbody></table>
<p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">spanAllocHeap</td>
<td align="left">0</td>
<td align="left">默认，heap类型，其他均为手动分配</td>
</tr>
<tr>
<td align="left">spanAllocStack</td>
<td align="left">1</td>
<td align="left">stack类型</td>
</tr>
<tr>
<td align="left">spanAllocPtrScalarBits</td>
<td align="left">2</td>
<td align="left">GC bitmap</td>
</tr>
<tr>
<td align="left">spanAllocWorkBuf</td>
<td align="left">3</td>
<td align="left">写屏障缓冲</td>
</tr>
</tbody></table>
<p><strong>小对象mspan示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有1个page的小对象（&lt;=32KB）mspan示例如下</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// noscan: startAddr</span></span><br><span class="line"><span class="comment">//            |</span></span><br><span class="line"><span class="comment">//            v</span></span><br><span class="line"><span class="comment">//            | &lt;---------- 8192 bytes ----------&gt;  |</span></span><br><span class="line"><span class="comment">//            | free                                |</span></span><br><span class="line"><span class="comment">//            | 8192 bytes                          |</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// scan &amp;&amp; size&lt;=512B</span></span><br><span class="line"><span class="comment">//            |</span></span><br><span class="line"><span class="comment">//            v</span></span><br><span class="line"><span class="comment">//            | &lt;---------- 8192 bytes ----------&gt;  |</span></span><br><span class="line"><span class="comment">//            | free                    | heapBits  |</span></span><br><span class="line"><span class="comment">//            | 8064 bytes              | 128 bytes | -&gt; 用于标记对象的可达性</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// scan类型时，elem大小超过512B需要存储类型，如下</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         &lt;= 512B =&gt; elem no header   =&gt; |    elemsize | ... |     elemsize |</span></span><br><span class="line"><span class="comment">//          &gt; 512B =&gt; elem with header =&gt; |8 + elemsize | ... | 8 + elemsize |</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 大对象的类型存储在mspan的largeType字段</span></span><br></pre></td></tr></table></figure>

<h3 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h3><p>每个p都有一个mcache，负责当前线程的内存分配，超小对象（scalar）通过tiny分配器分配（优化，本质还是访问的是mspan），小对象则通过找到alloc数组里相应的mspan进行分配，不负责大对象的分配</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    _           sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面三个每次malloc都会访问</span></span><br><span class="line">    nextSample  <span class="type">int64</span>                          <span class="comment">// 分配nextSample字节内存后触发采样</span></span><br><span class="line">    memProfRate <span class="type">int</span>                            <span class="comment">// 内存采样频率（缓存）</span></span><br><span class="line">    scanAlloc   <span class="type">uintptr</span>                        <span class="comment">// 需要被GC扫描的字节数（跟分配的内存大小也差不了多少）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// tiny分配器（spanclass=5 =&gt; sizeclass=2 + noscan）</span></span><br><span class="line">    tiny        <span class="type">uintptr</span>                        <span class="comment">// 16字节内存区域</span></span><br><span class="line">    tinyoffset  <span class="type">uintptr</span>                        <span class="comment">// 偏移量/下一个可分配地址</span></span><br><span class="line">    tinyAllocs  <span class="type">uintptr</span>                        <span class="comment">// 通过tiny区域分配的对象数量</span></span><br><span class="line"></span><br><span class="line">    alloc       [numSpanClasses]*mspan         <span class="comment">// 分配&lt;=32KB时使用，共136个mspan指针</span></span><br><span class="line">    stackcache  [_NumStackOrders]stackfreelist <span class="comment">// 栈分配使用，linux下共4个栈缓存链表</span></span><br><span class="line">    <span class="comment">// 只有当flushGen==sweepgen-2时清扫mcache</span></span><br><span class="line">    flushGen    atomic.Uint32                  <span class="comment">// sweepgen快照，创建mcache以及gcStart时同步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>alloc是一个固定长度的数组，包含136个mspan指针。如果其中的mspan空间分配完&#x2F;不足以容纳新对象，则向mcentral申请一个新的&#x2F;清扫过的mspan替换原mspan后重试</p>
<h3 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h3><p>新的mspan会立即替换mcache的纪录，而mcentral负责纪录空间已满&#x2F;不足的mspan、清扫重用mspan&#x2F;向mheap申请分配新的mspan。按spanclass进行分组，每个组都是一个二维数组，嵌入到mheap结构体，全局唯一</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    _         sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    spanclass spanClass     <span class="comment">// 类别，由7位的sizeclass和1位的noscan组成</span></span><br><span class="line"></span><br><span class="line">    partial   [<span class="number">2</span>]spanSet    <span class="comment">// mspan空间还有剩余（但不足以申请新的对象）</span></span><br><span class="line">    full      [<span class="number">2</span>]spanSet    <span class="comment">// mspan空间完全用完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组第一维</span></span><br><span class="line"><span class="keyword">type</span> spanSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    spineLock mutex                     <span class="comment">// 锁</span></span><br><span class="line">    spine     atomicSpanSetSpinePointer <span class="comment">// spanSetBlock切片指针，指向*[N]atomic.Pointer[spanSetBlock]，最少有256个指针</span></span><br><span class="line">    spineLen  atomic.Uintptr            <span class="comment">// spine数组长度</span></span><br><span class="line">    spineCap  <span class="type">uintptr</span>                   <span class="comment">// spine数组容量，访问需要加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个mspan的内存最小为1个页即8KB，2^32个索引最少能代表32TB</span></span><br><span class="line">    index     atomicHeadTailIndex       <span class="comment">// 索引，分为高32位-head，低32位-tail</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组第二维</span></span><br><span class="line"><span class="keyword">type</span> spanSetBlock <span class="keyword">struct</span> &#123;</span><br><span class="line">    lfnode                                         <span class="comment">// 无锁栈</span></span><br><span class="line">    popped atomic.Uint32                           <span class="comment">// 计数器，计算pop次数</span></span><br><span class="line">    spans  [spanSetBlockEntries]atomicMSpanPointer <span class="comment">// mspan指针数组，共512个指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无锁栈</span></span><br><span class="line"><span class="keyword">type</span> lfnode <span class="keyword">struct</span> &#123;</span><br><span class="line">    next    <span class="type">uint64</span>  <span class="comment">// 元素指针</span></span><br><span class="line">    pushcnt <span class="type">uintptr</span> <span class="comment">// 总量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mcentral示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mcentral[0].spanclass = 0</span></span><br><span class="line"><span class="comment">//            .partial[0] -&gt; *spanSet.spine[0]   -&gt; *spanSetBlock.spans[0]</span></span><br><span class="line"><span class="comment">//                                   ...            ...</span></span><br><span class="line"><span class="comment">//                                   ...            *spanSetBlock.spans[511]     </span></span><br><span class="line"><span class="comment">//                                   .spine[255]</span></span><br><span class="line"><span class="comment">//                                   ...</span></span><br><span class="line"><span class="comment">//                                   .spine[N]</span></span><br><span class="line"><span class="comment">//            .partial[1]</span></span><br><span class="line"><span class="comment">//            .full[0]</span></span><br><span class="line"><span class="comment">//            .full[1]</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// mcentral[67]</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// mcentral[135]</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>由于<code>spanclass = sizeclass &lt;&lt; 1 + noscan</code>，所以，奇数索引纪录scalar类型，偶数纪录索引类型</p>
<h3 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h3><p>负责向操作系统申请内存进行分配&#x2F;管理、纪录内存分配信息等。全局唯一，访问需要加锁或者STW。其中</p>
<ol>
<li>页通过pages-页分配器分配、管理</li>
<li>mspan通过spanalloc分配器创建&#x2F;回收，关联页后纪录到allspans，mspan空间用完&#x2F;不足会放到mcentral管理</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    _                  sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    lock               mutex          <span class="comment">// 锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页分配器，用于查找连续n页的起始地址</span></span><br><span class="line">    pages              pageAlloc</span><br><span class="line"></span><br><span class="line">    sweepgen           <span class="type">uint32</span>         <span class="comment">// 版本计数器，初始为0，GC后+=2，用于跟mspan对比判断</span></span><br><span class="line"></span><br><span class="line">    allspans           []*mspan       <span class="comment">// 通过spanalloc分配的mspan都纪录到这里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC清扫时使用</span></span><br><span class="line">    pagesInUse         atomic.Uintptr <span class="comment">// heap内存页使用量（mSpanInUse）</span></span><br><span class="line">    pagesSwept         atomic.Uint64  <span class="comment">// 已完成清扫的页数量</span></span><br><span class="line">    pagesSweptBasis    atomic.Uint64  <span class="comment">// pagesSwept快照</span></span><br><span class="line">    sweepHeapLiveBasis <span class="type">uint64</span>         <span class="comment">// heapLive快照（标记终止阶段纪录用于清扫阶段）</span></span><br><span class="line">    <span class="comment">// =剩余待清扫页数量/距离GC触发的剩余堆大小</span></span><br><span class="line">    <span class="comment">// 如果sweepPagesPerByte=0.01，那么每分配100字节，就需要清扫1个页</span></span><br><span class="line">    <span class="comment">// 分配对象时同步清扫，以确保GC触发前清扫任务能完成</span></span><br><span class="line">    sweepPagesPerByte  <span class="type">float64</span>        <span class="comment">// GC触发前，每分配1字节需要清扫的页数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存回收时用。先扣额度，额度用完则扫描heapArena</span></span><br><span class="line">    <span class="comment">// 额度用完时使用，索引从0开始，扫描完所有heapArena设置为1 &lt;&lt; 63</span></span><br><span class="line">    reclaimIndex       atomic.Uint64  <span class="comment">// heapArena索引</span></span><br><span class="line">    <span class="comment">// 释放完整的mspan或释放过多页时才会累计，避免scavenger过度回收</span></span><br><span class="line">    reclaimCredit      atomic.Uintptr <span class="comment">// 回收额度/回收积分</span></span><br><span class="line"></span><br><span class="line">    _                  cpu.CacheLinePad</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bitmap，二维数组，linux下结构为[1]*[4194304]*heapArena，其中</span></span><br><span class="line">    <span class="comment">// 1维只有一个元素，二维有4M个指针，每个heapArena负责管理64MB内存，共管理256TB内存</span></span><br><span class="line">    <span class="comment">// 因为基地址是0xffff800000000000，实际管理内存为128TB</span></span><br><span class="line">    arenas             [<span class="number">1</span> &lt;&lt; arenaL1Bits]*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class="line"></span><br><span class="line">    arenasHugePages    <span class="type">bool</span>           <span class="comment">// 是否启用huge page，linux下可用</span></span><br><span class="line">    heapArenaAlloc     linearAlloc    <span class="comment">// 线性分配器，32位平台用</span></span><br><span class="line">    arenaHints         *arenaHint     <span class="comment">// 链表，每个hint纪录一段heapArena占用的地址</span></span><br><span class="line">    arena              linearAlloc    <span class="comment">// 线性分配器，32位平台用</span></span><br><span class="line">    allArenas          []arenaIdx     <span class="comment">// 纪录arenaIdx</span></span><br><span class="line">    sweepArenas        []arenaIdx     <span class="comment">// allArenas快照，GC清扫时用</span></span><br><span class="line">    markArenas         []arenaIdx     <span class="comment">// allArenas快照，GC标记时用</span></span><br><span class="line">    curArena           <span class="keyword">struct</span> &#123;       <span class="comment">// 当前heapArena的基地址和下一个可分配的内存地址</span></span><br><span class="line">        base, end <span class="type">uintptr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配&lt;32KB内存时会先尝试清扫重用mcentral的mspan</span></span><br><span class="line">    central [numSpanClasses]<span class="keyword">struct</span> &#123;  <span class="comment">// 共136个mcentral</span></span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad      [(cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize) % cpu.CacheLinePadSize]<span class="type">byte</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面都是fixalloc类型的内存分配器，用于创建各类header，固定16KB，用完后重新从系统申请</span></span><br><span class="line">    spanalloc              fixalloc   <span class="comment">// span*</span></span><br><span class="line">    cachealloc             fixalloc   <span class="comment">// mcache*</span></span><br><span class="line">    specialfinalizeralloc  fixalloc   <span class="comment">// specialfinalizer*</span></span><br><span class="line">    specialCleanupAlloc    fixalloc   <span class="comment">// specialcleanup*</span></span><br><span class="line">    specialprofilealloc    fixalloc   <span class="comment">// specialprofile*</span></span><br><span class="line">    specialReachableAlloc  fixalloc   <span class="comment">// specialReachable</span></span><br><span class="line">    specialPinCounterAlloc fixalloc   <span class="comment">// specialPinCounter</span></span><br><span class="line">    specialWeakHandleAlloc fixalloc   <span class="comment">// specialWeakHandle</span></span><br><span class="line">    speciallock            mutex      <span class="comment">//</span></span><br><span class="line">    arenaHintAlloc         fixalloc   <span class="comment">// arenaHints</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// arena包用，用于手动分配内存</span></span><br><span class="line">    userArena              <span class="keyword">struct</span> &#123;</span><br><span class="line">        arenaHints     *arenaHint     <span class="comment">// 链表，初始化时创建128个arenaHint</span></span><br><span class="line">        quarantineList mSpanList      <span class="comment">//</span></span><br><span class="line">        readyList      mSpanList      <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cleanupID <span class="type">uint64</span>                  <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">    unused    *specialfinalizer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预规划地址，目的是尽量让地址连续</span></span><br><span class="line"><span class="keyword">type</span> arenaHint <span class="keyword">struct</span> &#123;</span><br><span class="line">    _    sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的addr是预设的，跟系统申请内存时尝试用sysMap直接映射，失败则回退到sysAlloc申请</span></span><br><span class="line">    addr <span class="type">uintptr</span>                      <span class="comment">// arena的开始虚拟地址</span></span><br><span class="line">    down <span class="type">bool</span>                         <span class="comment">// 分配内存时地址增长的方向，一般为false，即向上扩展</span></span><br><span class="line">    next *arenaHint                   <span class="comment">// 指针，指向下一个arenaHint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap，管理8K个页，每个页8192B，共64MB内存</span></span><br><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line">    _            sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 精确纪录</span></span><br><span class="line">    <span class="comment">// bitmap，共8192个mspan指针，每一个元素表示该页被哪个mspan使用，如</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// | 0       | 1       | ... | 8191     | -&gt; 通过地址addr找到页的索引idx</span></span><br><span class="line">    <span class="comment">// | page7   | page8   | ... | page8198 |</span></span><br><span class="line">    <span class="comment">// | *mspan3 | *mspan3 | ... | *mspan9  | -&gt; 页7、页8被mspan3使用</span></span><br><span class="line">    spans        [pagesPerArena]*mspan</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 粗略纪录，pageInUse纪录的颗粒度比较大，如果有n个页，只会纪录起始页</span></span><br><span class="line">    pageInUse    [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span> <span class="comment">// 用于标记mSpanInUse状态的mspan，共1KB</span></span><br><span class="line">    pageMarks    [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span> <span class="comment">// 同上，GC用</span></span><br><span class="line">    pageSpecials [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span> <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    checkmarks   *checkmarksMap           <span class="comment">// debug.gccheckmark不为0时使用（一般用不到）</span></span><br><span class="line">    zeroedBase   <span class="type">uintptr</span>                  <span class="comment">// 类似base，指向已经清0的区域，如果内存重用，分配的地址会比zeroedBase小，表示需要清0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>hint作用</strong></p>
<p>hint-预规划地址，它的作用是通过sysMap直接向操作系统申请在指定地址处映射内存，因为使用sysAlloc让操作系统选择地址空间会导致地址不连续、碎片化等。如果失败最后会回退到sysAlloc</p>
<p><strong>mheap示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mheap.arenas[0] -&gt; *heapArena[0](64MB)</span></span><br><span class="line"><span class="comment">//                    ...</span></span><br><span class="line"><span class="comment">//                    *heapArena[4194303]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      .central   -&gt; mcentral[0]</span></span><br><span class="line"><span class="comment">//                    ...</span></span><br><span class="line"><span class="comment">//                    mcentral[135]</span></span><br></pre></td></tr></table></figure>

<p><strong>可用内存空间</strong></p>
<ol>
<li>从arenas结构看，在linux系统下，mheap可以管理1<em>4194304</em>64MB&#x3D;256TB内存，但实际上，go选择内存地址的中间-<code>0xffff800000000000</code>作为基地址，计算最大地址<code>0x007ffffffff000</code>减去基地址，得出实际可管理内存为128TB</li>
<li>arena包用于手动管理内存，从预分配地址看，实际可管理内存也为128TB，当然，它选择的是另一个地址空间，不跟heap共用</li>
</ol>
<h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><h4 id="fixalloc"><a href="#fixalloc" class="headerlink" title="fixalloc"></a>fixalloc</h4><p>mheap大多数分配器是fixalloc类型，比如mspan就使用了fixalloc，每次用完就从系统申请16KB内存。分配内存优先从空闲对象链表list获取，没有才从chunk分配内存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> fixalloc <span class="keyword">struct</span> &#123;</span><br><span class="line">    size   <span class="type">uintptr</span>                     <span class="comment">// 元素大小，如mspan数据类型的大小为160B</span></span><br><span class="line">    first  <span class="function"><span class="keyword">func</span><span class="params">(arg, p unsafe.Pointer)</span></span> <span class="comment">// 一般为nil，除了mspan需要纪录每个页对应的mspan</span></span><br><span class="line">    arg    unsafe.Pointer              <span class="comment">// 函数参数，比如mspan指针</span></span><br><span class="line">    list   *mlink                      <span class="comment">// 空闲对象列表，比如mspan释放时会放到这里，后续重用</span></span><br><span class="line">    chunk  <span class="type">uintptr</span>                     <span class="comment">// 内存指针，指向未使用的内存的起始位置，也可以认为是offset</span></span><br><span class="line">    nchunk <span class="type">uint32</span>                      <span class="comment">// 剩余字节数，初始值为nalloc</span></span><br><span class="line">    nalloc <span class="type">uint32</span>                      <span class="comment">// 一般是16KB，但会优化移除尾部不用的部份，按8的倍数对齐</span></span><br><span class="line">    inuse  <span class="type">uintptr</span>                     <span class="comment">// 已使用字节数</span></span><br><span class="line">    stat   *sysMemStat                 <span class="comment">// 内存统计用</span></span><br><span class="line">    zero   <span class="type">bool</span>                        <span class="comment">// 默认都需要清0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pageAlloc"><a href="#pageAlloc" class="headerlink" title="pageAlloc"></a>pageAlloc</h4><p>页分配器，本身属于bitmap，用于快速查找连续n页的起始地址。实现比较复杂，是非常重要的数据结构。其中</p>
<ol>
<li>chunks为二维数组，总数据量与arena相同，一次性可管理512个页，即4MB内存</li>
<li>summary是chunks的索引，分5层，最后一层数量与chunks总数相同，每上一层数量缩减8倍，管理的页数增长8倍，可快速寻找连续n页内存的起始地址</li>
</ol>
<p><strong>注意</strong></p>
<p>pageAlloc对bitmap的处理与其他分配器正相反，1为已使用，0为未使用，刚开始看代码很容易混淆</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pageAlloc <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// summary =&gt; [0][2^14]pallocSum =&gt; 第1层每8个sum汇总成1个sum =&gt; 每个sum管理  2M个页共4GB内存</span></span><br><span class="line">    <span class="comment">//            [1][2^17]pallocSum =&gt; 第2层每8个sum汇总成1个sum =&gt; 每个sum管理256K个页共2GB内存</span></span><br><span class="line">    <span class="comment">//            [2][2^20]pallocSum =&gt; 第3层每8个sum汇总成1个sum =&gt; 每个sum管理 32K个页共256MB内存</span></span><br><span class="line">    <span class="comment">//            [3][2^23]pallocSum =&gt; 第4层每8个sum汇总成1个sum =&gt; 每个sum管理  4K个页共32MB内存</span></span><br><span class="line">    <span class="comment">//            [4][2^26]pallocSum =&gt; 代表8192*8192个chunk    =&gt; 每个sum管理 512个页共4MB内存</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// pallocSum =&gt; | 1bit   | 21bit | 21bit | 21bit |</span></span><br><span class="line">    <span class="comment">//              | allmax | end   | max   | start |</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    summary    [summaryLevels][]pallocSum</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chunks -&gt; [0]</span></span><br><span class="line">    <span class="comment">//           ...</span></span><br><span class="line">    <span class="comment">//           [8191] -&gt; [0]    -&gt; pallocBits(512 bit) + scavenged(512 bit)</span></span><br><span class="line">    <span class="comment">//            |        ...</span></span><br><span class="line">    <span class="comment">//            v        [8191] -&gt; 一个单元代表512*8KB=4MB内存</span></span><br><span class="line">    <span class="comment">//           一个单元代表8192*4MB=32GB</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// scavenged初始化时设置为全1，pallocBits初始化时设置为全0的bitmap</span></span><br><span class="line">    <span class="comment">// 可标记n=8192*8192*64*8个page指针，共n*8192=256TB内存，与mheap管理的arena的内存管理量相同</span></span><br><span class="line">    chunks     [<span class="number">1</span> &lt;&lt; pallocChunksL1Bits]*[<span class="number">1</span> &lt;&lt; pallocChunksL2Bits]pallocData</span><br><span class="line"></span><br><span class="line">    searchAddr offAddr               <span class="comment">// 搜索地址，避免每次从基地址开始搜索</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的索引计算刚开始看会很困惑，因为它是把2维数组当1维数组用了，索引范围是[0,8192*8192-1]</span></span><br><span class="line">    <span class="comment">// start会纪录全局最小的索引，而end则纪录全局最大的索引</span></span><br><span class="line">    start, end chunkIdx              <span class="comment">// 起始、终止索引</span></span><br><span class="line"></span><br><span class="line">    inUse      addrRanges            <span class="comment">// 扩容时纪录内存使用情况</span></span><br><span class="line"></span><br><span class="line">    scav       <span class="keyword">struct</span> &#123;</span><br><span class="line">        index         scavengeIndex  <span class="comment">// 回收索引</span></span><br><span class="line">        releasedBg    atomic.Uintptr <span class="comment">// 累计释放字节数（后台scavenger回收）</span></span><br><span class="line">        releasedEager atomic.Uintptr <span class="comment">// 累计释放字节数（分配内存时协助回收）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mheapLock          *mutex        <span class="comment">// mheap.lock字段</span></span><br><span class="line">    sysStat            *sysMemStat   <span class="comment">//</span></span><br><span class="line">    summaryMappedReady <span class="type">uintptr</span>       <span class="comment">// 已映射且可用的内存量，测试用</span></span><br><span class="line">    chunkHugePages     <span class="type">bool</span>          <span class="comment">// 开启huge page时，设置为true</span></span><br><span class="line"></span><br><span class="line">    test               <span class="type">bool</span>          <span class="comment">// 测试，忽略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> addrRanges <span class="keyword">struct</span> &#123;</span><br><span class="line">    ranges     []addrRange           <span class="comment">// 已分配的地址段，每个元素纪录base、limit，插入时会进行合并</span></span><br><span class="line">    totalBytes <span class="type">uintptr</span>               <span class="comment">// 总分配字节数</span></span><br><span class="line">    sysStat    *sysMemStat           <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// | 1bit   | 21bit | 21bit | 21bit |</span></span><br><span class="line"><span class="comment">// | allmax | end   | max   | start |</span></span><br><span class="line"><span class="keyword">type</span> pallocSum <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap，负责管理64*8=512个页 =&gt; 4MB内存</span></span><br><span class="line"><span class="keyword">type</span> pallocData <span class="keyword">struct</span> &#123;</span><br><span class="line">    pallocBits         <span class="comment">// 分配标记，64字节</span></span><br><span class="line">    scavenged pageBits <span class="comment">// 回收标记，64字节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pageBits [pallocChunkPages / <span class="number">64</span>]<span class="type">uint64</span> <span class="comment">// 512字节，共8个uint64</span></span><br></pre></td></tr></table></figure>

<h2 id="mallocgc"><a href="#mallocgc" class="headerlink" title="mallocgc"></a>mallocgc</h2><p>slice、map、string申请内存时是通过mallocgc来分配的，其他如newobject、newarray、reflect.unsafe_New底层实际也是在调用mallocgc</p>
<p>mallocg内部对申请的内存大小size、对象的类型type判断，分别调用不同的内存分配器分配内存，具体如下</p>
<table>
<thead>
<tr>
<th align="left">条件1</th>
<th align="left">条件2</th>
<th align="left">条件3</th>
<th align="left">内存分配器</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt;&#x3D;32760B</td>
<td align="left">nil或对象不包含指针</td>
<td align="left">&lt;16B</td>
<td align="left">mallocgcTiny</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">&gt;&#x3D;16B</td>
<td align="left">mallocgcSmallNoscan</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">对象包含指针</td>
<td align="left">&lt;&#x3D;512B</td>
<td align="left">mallocgcSmallScanNoHeader</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">&gt;512B</td>
<td align="left">mallocgcSmallScanHeader</td>
</tr>
<tr>
<td align="left">&gt;32760B</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">mallocgcLarge</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据请求的内存大小分配内存、返回地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// size为0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 一个全局变量的指针</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数，忽略（staticlockranking默认为false）</span></span><br><span class="line">    lockRankMayQueueFinalizer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动（gcStart时为true）</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 降低g的Assist额度，如果额度用光了，则g需要协助GC标记（g会被挂起）</span></span><br><span class="line">        deductAssistCredit(size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新申请的内存区域起始地址</span></span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    <span class="comment">// 对象大小，以mspan的为准</span></span><br><span class="line">    <span class="keyword">var</span> elemsize <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总申请字节数 &lt;= 32KB（32768-8）</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize-mallocHeaderSize &#123;</span><br><span class="line">        <span class="comment">// 没有类型信息 or 该类型不包含指针</span></span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> || !typ.Pointers() &#123;</span><br><span class="line">            <span class="keyword">if</span> size &lt; maxTinySize &#123;</span><br><span class="line">                <span class="comment">// &lt; 16B</span></span><br><span class="line">                <span class="comment">// 从mcache.tiny分配</span></span><br><span class="line">                x, elemsize = mallocgcTiny(size, typ, needzero)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// &gt;= 16B</span></span><br><span class="line">                <span class="comment">// 计算spanclass获取span，分配size大小的内存返回</span></span><br><span class="line">                x, elemsize = mallocgcSmallNoscan(size, typ, needzero)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面的是有类型信息 and 包含指针的情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> heapBitsInSpan(size) &#123; </span><br><span class="line">            <span class="comment">// &lt;=512B</span></span><br><span class="line">            <span class="comment">// 直接存储对象、设置heapBits</span></span><br><span class="line">            x, elemsize = mallocgcSmallScanNoHeader(size, typ, needzero)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &gt;512B，&lt;=32KB</span></span><br><span class="line">            <span class="comment">// 对象大小增加8字节用于存储数据类型、设置heapBits</span></span><br><span class="line">            x, elemsize = mallocgcSmallScanHeader(size, typ, needzero)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// &gt; 32KB</span></span><br><span class="line">        <span class="comment">// 一个对象占用一个mspan</span></span><br><span class="line">        x, elemsize = mallocgcLarge(size, typ, needzero)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC已启动（gcStart时为true） and elemsize不为0</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; elemsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 重复，避免当前g是调度的g0</span></span><br><span class="line">        <span class="keyword">if</span> assistG := getg().m.curg; assistG != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 额度-=剩余量</span></span><br><span class="line">            <span class="comment">// 先前只是按传入的size减少额度，到这里，size已elemsize为准，需要把多余的量也减去</span></span><br><span class="line">            assistG.gcAssistBytes -= <span class="type">int64</span>(elemsize - size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mallocgcTiny"><a href="#mallocgcTiny" class="headerlink" title="mallocgcTiny"></a>mallocgcTiny</h3><p>前提条件：size&lt;&#x3D;32KB，对象为nil或对象不包含指针，size&lt;16B。tiny区域只有16字节，用于合并多个微小对象的内存分配，大概逻辑如下</p>
<ol>
<li>访问mcache<ul>
<li>有p则获取p.mcache，没有p则获取mcache0</li>
</ul>
</li>
<li>tiny区域调整、计算<ul>
<li>tiny区域的offset偏移量跟内存分配量size对齐</li>
</ul>
</li>
<li>空间足够（offset+size&lt;&#x3D;61）<ul>
<li>更新偏移量、计数器，返回内存区域起始地址</li>
</ul>
</li>
<li>空间不足<ul>
<li>申请新的mspan<ul>
<li>从mcache.alloc[tinySpanClass]获取mspan</li>
</ul>
</li>
<li>快速分配<ul>
<li>通过64位的allocCache快速判断并分配对象</li>
</ul>
</li>
<li>慢速分配<ul>
<li>从allocBits获取64位数据，重新填充allocCache并重新判断分配对象</li>
<li>如果mspan已满&#x2F;空间不足，则从mcentral获取新的mspan替换原mspan后重试</li>
</ul>
</li>
</ul>
</li>
<li>收尾<ul>
<li>分配的16字节内存区域清0</li>
<li>如果size比offse小或tiny区域未初始化，替换tiny区域、更新信息</li>
<li>如果size比offset大，如offset&#x3D;8，size&#x3D;12，直接返回整个16字节内存块，不更新tiny区域</li>
<li>写屏障、profiling、GC处理</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从tiny区域分配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcTiny</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 防止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止被GC抢占</span></span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偏移量（指向下一个可用区域）</span></span><br><span class="line">    off := c.tinyoffset</span><br><span class="line">    <span class="comment">// 调整偏移量，按指定倍数向上取整</span></span><br><span class="line">    <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;        <span class="comment">// 低3位为0</span></span><br><span class="line">        <span class="comment">// 按8的倍数向上取整</span></span><br><span class="line">        off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> goarch.PtrSize == <span class="number">4</span> &amp;&amp; size == <span class="number">12</span> &#123; <span class="comment">// 32位系统 and 12B</span></span><br><span class="line">        <span class="comment">// 按8的倍数向上取整</span></span><br><span class="line">        off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123; <span class="comment">// 低2位为0</span></span><br><span class="line">        <span class="comment">// 按4的倍数向上取整</span></span><br><span class="line">        off = alignUp(off, <span class="number">4</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123; <span class="comment">// 低1位为0</span></span><br><span class="line">        <span class="comment">// 按2的倍数向上取整</span></span><br><span class="line">        off = alignUp(off, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有足够的空间容纳元素 and tiny区域已初始化</span></span><br><span class="line">    <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取内存地址</span></span><br><span class="line">        x := unsafe.Pointer(c.tiny + off)</span><br><span class="line">        <span class="comment">// 更新偏移量</span></span><br><span class="line">        c.tinyoffset = off + size</span><br><span class="line">        <span class="comment">// 计数器tinyAllocs+=1</span></span><br><span class="line">        c.tinyAllocs++</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        mp.mallocing = <span class="number">0</span></span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span> x, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空间不足（最大16字节） or tiny区域未初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要触发GC清扫（分配了新的mspan）</span></span><br><span class="line">    checkGCTrigger := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// mspan，索引tinySpanClass=5（sizeclass=2，noscan=true）</span></span><br><span class="line">    span := c.alloc[tinySpanClass]</span><br><span class="line">    <span class="comment">// 通过64位的allocCache快速判断并分配对象</span></span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="comment">// 64个对象已经被分配完了，进入slow path</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// mspan获取一个可用对象，如果mspan已满，则从mcentral获取新的mspan替换原mspan后重试</span></span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(tinySpanClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line">    <span class="comment">// 内存区域清0（共16个字节）</span></span><br><span class="line">    (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// raceenabled默认为false，因此固定为true and (size比已offset小 or tiny未初始化)</span></span><br><span class="line">    <span class="keyword">if</span> !raceenabled &amp;&amp; (size &lt; c.tinyoffset || c.tiny == <span class="number">0</span>) &#123;</span><br><span class="line">        c.tiny = <span class="type">uintptr</span>(x)</span><br><span class="line">        c.tinyoffset = size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果size比offset大，如offset=8，size=12，直接返回整个x内存块，不更新tiny区域</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步freeindex</span></span><br><span class="line">    span.freeIndexForScan = span.freeindex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障已开启</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        <span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextSample初始值为随机数：[0,MemProfileRate)</span></span><br><span class="line">    c.nextSample -= <span class="type">int64</span>(span.elemsize)</span><br><span class="line">    <span class="comment">// 负数立即采样 or MemProfileRate有改动</span></span><br><span class="line">    <span class="keyword">if</span> c.nextSample &lt; <span class="number">0</span> || MemProfileRate != c.memProfRate &#123;</span><br><span class="line">        <span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">        profilealloc(mp, x, span.elemsize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    mp.mallocing = <span class="number">0</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要触发GC清扫</span></span><br><span class="line">    <span class="keyword">if</span> checkGCTrigger &#123;</span><br><span class="line">        <span class="comment">// 内存达到阈值，执行GC</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">            gcStart(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x, span.elemsize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mallocgcSmallNoscan"><a href="#mallocgcSmallNoscan" class="headerlink" title="mallocgcSmallNoscan"></a>mallocgcSmallNoscan</h3><p>前提条件：size&lt;&#x3D;32KB，对象为nil或对象不包含指针，size&gt;&#x3D;16B。大概逻辑如下</p>
<ol>
<li>访问mcache<ul>
<li>有p则获取p.mcache，没有p则获取mcache0</li>
</ul>
</li>
<li>获取mspan<ul>
<li>通过组合sizeclass和noscan变量计算出spanclass<ul>
<li>如果size&lt;&#x3D;1016（1KB-8），sizeclass范围是[0,32]</li>
<li>如果size&gt;1016，sizeclass范围是[32,67]<br> 从mcache.alloc[sizeclass]获取mspan</li>
</ul>
</li>
</ul>
</li>
<li>分配内存<ul>
<li>快速分配<ul>
<li>通过64位的allocCache快速判断并分配对象</li>
</ul>
</li>
<li>慢速分配<ul>
<li>从allocBits获取64位数据，重新填充allocCache并重新判断分配对象</li>
<li>如果mspan已满&#x2F;空间不足，则从mcentral获取新的mspan替换原mspan后重试</li>
</ul>
</li>
</ul>
</li>
<li>收尾<ul>
<li>内存区域清0</li>
<li>写屏障、profiling、GC处理</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算spanclass获取span，分配size大小的内存返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcSmallNoscan</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止被GC抢占</span></span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要触发GC清扫（分配了新的mspan）</span></span><br><span class="line">    checkGCTrigger := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;=1016</span></span><br><span class="line">        <span class="comment">// =size_to_class8[ceil(size/8)]（sizeclass范围是[0,32]，闭区间）</span></span><br><span class="line">        sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// &gt;1016</span></span><br><span class="line">        <span class="comment">// =size_to_class128[ceil((size-1024)/128)]（sizeclass范围是[32,67]，闭区间）</span></span><br><span class="line">        sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上取整，如原size=20，经过计算sizeclass=3，新size=24</span></span><br><span class="line">    size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">    <span class="comment">// 组合sizeclass和noscan成spanclass</span></span><br><span class="line">    spc := makeSpanClass(sizeclass, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 找到mspan</span></span><br><span class="line">    span := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过64位的allocCache快速判断并分配对象</span></span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="comment">// 64个对象已经被分配完了，进入slow path</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// mspan获取一个可用对象，如果mspan已满，则从mcentral获取新的mspan替换原mspan后重试</span></span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(spc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要清0 and span分配前需要清0</span></span><br><span class="line">    <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 内存区域清0</span></span><br><span class="line">        memclrNoHeapPointers(x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步freeindex</span></span><br><span class="line">    span.freeIndexForScan = span.freeindex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障已开启</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        <span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextSample初始值为随机数：[0,MemProfileRate)</span></span><br><span class="line">    c.nextSample -= <span class="type">int64</span>(size)</span><br><span class="line">    <span class="comment">// 负数立即采样 or MemProfileRate有改动</span></span><br><span class="line">    <span class="keyword">if</span> c.nextSample &lt; <span class="number">0</span> || MemProfileRate != c.memProfRate &#123;</span><br><span class="line">        <span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">        profilealloc(mp, x, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    mp.mallocing = <span class="number">0</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要触发GC清扫</span></span><br><span class="line">    <span class="keyword">if</span> checkGCTrigger &#123;</span><br><span class="line">        <span class="comment">// 内存达到阈值，执行GC</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">            gcStart(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mallocgcSmallScanNoHeader"><a href="#mallocgcSmallScanNoHeader" class="headerlink" title="mallocgcSmallScanNoHeader"></a>mallocgcSmallScanNoHeader</h3><p>前提条件：size&lt;&#x3D;32KB，对象包含指针，size&lt;&#x3D;512B。大概逻辑如下</p>
<ol>
<li>访问mcache<ul>
<li>有p则获取p.mcache，没有p则获取mcache0</li>
</ul>
</li>
<li>获取mspan<ul>
<li>通过组合sizeclass和noscan变量计算出spanclass，最终sizeclass范围是[0,32]</li>
<li>从mcache.alloc[sizeclass]获取mspan</li>
</ul>
</li>
<li>分配内存<ul>
<li>快速分配<ul>
<li>通过64位的allocCache快速判断并分配对象</li>
</ul>
</li>
<li>慢速分配<ul>
<li>从allocBits获取64位数据，重新填充allocCache并重新判断分配对象</li>
<li>如果mspan已满&#x2F;空间不足，则从mcentral获取新的mspan替换原mspan后重试</li>
</ul>
</li>
</ul>
</li>
<li>收尾<ul>
<li>根据sizeclass调整scanAlloc、size</li>
<li>写屏障、profiling、GC处理</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcSmallScanNoHeader</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止被GC抢占</span></span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要触发GC清扫（分配了新的mspan）</span></span><br><span class="line">    checkGCTrigger := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =size_to_class8[ceil(size/8)]（sizeclass范围是[0,32]，闭区间）</span></span><br><span class="line">    sizeclass := size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">    <span class="comment">// 组合sizeclass和noscan成spanclass</span></span><br><span class="line">    spc := makeSpanClass(sizeclass, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// 找到mspan</span></span><br><span class="line">    span := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过64位的allocCache快速判断并分配对象</span></span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="comment">// 64个对象已经被分配完了，进入slow path</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// mspan获取一个可用对象，如果mspan已满，则从mcentral获取新的mspan替换原mspan后重试</span></span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(spc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要清0 and span分配前需要清0</span></span><br><span class="line">    <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 内存区域清0</span></span><br><span class="line">        memclrNoHeapPointers(x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64位操作系统 and sizeclass为1（&gt;8B)</span></span><br><span class="line">    <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &amp;&amp; sizeclass == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// mcentral在grow时已调用initHeapBits设置</span></span><br><span class="line">        c.scanAlloc += <span class="number">8</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 32位系统 or sizeclass不为1（&gt;8B)</span></span><br><span class="line">        <span class="comment">// bitmap纪录指针位置，返回需要扫描的字节数</span></span><br><span class="line">        c.scanAlloc += heapSetTypeNoHeader(<span class="type">uintptr</span>(x), size, typ, span)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上取整，如原size=20，经过计算sizeclass=3，新size=24</span></span><br><span class="line">    size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步freeindex</span></span><br><span class="line">    span.freeIndexForScan = span.freeindex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障已开启</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        <span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextSample初始值为随机数：[0,MemProfileRate)</span></span><br><span class="line">    c.nextSample -= <span class="type">int64</span>(size)</span><br><span class="line">    <span class="comment">// 负数立即采样 or MemProfileRate有改动</span></span><br><span class="line">    <span class="keyword">if</span> c.nextSample &lt; <span class="number">0</span> || MemProfileRate != c.memProfRate &#123;</span><br><span class="line">        <span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">        profilealloc(mp, x, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    mp.mallocing = <span class="number">0</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要触发GC清扫</span></span><br><span class="line">    <span class="keyword">if</span> checkGCTrigger &#123;</span><br><span class="line">        <span class="comment">// 内存达到阈值，执行GC</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">            gcStart(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mallocgcSmallScanHeader"><a href="#mallocgcSmallScanHeader" class="headerlink" title="mallocgcSmallScanHeader"></a>mallocgcSmallScanHeader</h3><p>前提条件：size&lt;&#x3D;32KB，对象包含指针，size&gt;512B。大概逻辑如下</p>
<ol>
<li>访问mcache<ul>
<li>有p则获取p.mcache，没有p则获取mcache0</li>
</ul>
</li>
<li>获取mspan<ul>
<li>size+&#x3D;8（多分配8字节存储type）</li>
<li>通过组合sizeclass和noscan变量计算出spanclass<ul>
<li>如果size&lt;&#x3D;1016（1KB-8），sizeclass范围是[0,32]</li>
<li>如果size&gt;1016，sizeclass范围是[32,67]</li>
</ul>
</li>
<li>从mcache.alloc[sizeclass]获取mspan</li>
</ul>
</li>
<li>分配内存<ul>
<li>快速分配<ul>
<li>通过64位的allocCache快速判断并分配对象</li>
</ul>
</li>
<li>慢速分配<ul>
<li>从allocBits获取64位数据，重新填充allocCache并重新判断分配对象</li>
<li>如果mspan已满&#x2F;空间不足，则从mcentral获取新的mspan替换原mspan后重试</li>
</ul>
</li>
</ul>
</li>
<li>收尾<ul>
<li>内存区域清0</li>
<li>存储type到内存区域头8个字节，调整内存区域指针、scanAlloc、size</li>
<li>写屏障、profiling、GC处理</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcSmallScanHeader</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止被GC抢占</span></span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要触发GC清扫（分配了新的mspan）</span></span><br><span class="line">    checkGCTrigger := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多申请8B用作header</span></span><br><span class="line">    size += mallocHeaderSize</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;=1016</span></span><br><span class="line">        <span class="comment">// =size_to_class8[ceil(size/8)]（sizeclass范围是[0,32]，闭区间）</span></span><br><span class="line">        sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// &gt;1016</span></span><br><span class="line">        <span class="comment">// =size_to_class128[ceil((size-1024)/128)]（sizeclass范围是[32,67]，闭区间）</span></span><br><span class="line">        sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上取整，如原size=20，经过计算sizeclass=3，新size=24</span></span><br><span class="line">    size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">    <span class="comment">// 组合sizeclass和noscan成spanclass</span></span><br><span class="line">    spc := makeSpanClass(sizeclass, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// 找到mspan</span></span><br><span class="line">    span := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过64位的allocCache快速判断并分配对象</span></span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="comment">// 64个对象已经被分配完了，进入slow path</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// mspan获取一个可用对象，如果mspan已满，则从mcentral获取新的mspan替换原mspan后重试</span></span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(spc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要清0 and span分配前需要清0</span></span><br><span class="line">    <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 内存区域清0</span></span><br><span class="line">        memclrNoHeapPointers(x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始的8B用作header</span></span><br><span class="line">    header := (**_type)(x)</span><br><span class="line">    <span class="comment">// 往后移动8B才是实际存储</span></span><br><span class="line">    x = add(x, mallocHeaderSize)</span><br><span class="line">    <span class="comment">// 把typ存储到header，返回span.elemsize</span></span><br><span class="line">    c.scanAlloc += heapSetTypeSmallHeader(<span class="type">uintptr</span>(x), size-mallocHeaderSize, typ, header, span)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步freeindex</span></span><br><span class="line">    span.freeIndexForScan = span.freeindex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障已开启</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        <span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextSample初始值为随机数：[0,MemProfileRate)</span></span><br><span class="line">    c.nextSample -= <span class="type">int64</span>(size)</span><br><span class="line">    <span class="comment">// 负数立即采样 or MemProfileRate有改动</span></span><br><span class="line">    <span class="keyword">if</span> c.nextSample &lt; <span class="number">0</span> || MemProfileRate != c.memProfRate &#123;</span><br><span class="line">        <span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">        profilealloc(mp, x, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    mp.mallocing = <span class="number">0</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要触发GC清扫</span></span><br><span class="line">    <span class="keyword">if</span> checkGCTrigger &#123;</span><br><span class="line">        <span class="comment">// 内存达到阈值，执行GC</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">            gcStart(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mallocgcLarge"><a href="#mallocgcLarge" class="headerlink" title="mallocgcLarge"></a>mallocgcLarge</h3><p>前提条件：size&gt;32KB。大概逻辑如下</p>
<ol>
<li>访问mcache<ul>
<li>有p则获取p.mcache，没有p则获取mcache0</li>
</ul>
</li>
<li>创建mspan<ul>
<li>通过mheap分配size大小的mspan（size会按一定的倍数向上取整），更新mspan信息</li>
<li>需要协助GC清扫</li>
</ul>
</li>
<li>收尾<ul>
<li>内存区域清0，如果是scan则纪录对象类型到largeType</li>
<li>写屏障、profiling、GC处理</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcLarge</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止被GC抢占</span></span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (c *mcache) allocLarge(size uintptr, noscan bool) *mspan</span></span><br><span class="line">    <span class="comment">// 协助sweeper清扫，从mheap分配内存、更新索引/gc等信息，mspan放到fullSwept</span></span><br><span class="line">    span := c.allocLarge(size, typ == <span class="literal">nil</span> || !typ.Pointers())</span><br><span class="line">    <span class="comment">// 下一个可用对象索引</span></span><br><span class="line">    span.freeindex = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 已分配对象数</span></span><br><span class="line">    span.allocCount = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 先设置为nil，避免GC扫描，特别是noscan类型</span></span><br><span class="line">    span.largeType = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 调整为mspan的对象大小，对齐后</span></span><br><span class="line">    size = span.elemsize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan的起始地址</span></span><br><span class="line">    x := unsafe.Pointer(span.base())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步freeindex</span></span><br><span class="line">    span.freeIndexForScan = span.freeindex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障已开启</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        <span class="comment">// 新分配对象标记为黑色，类似greyobject</span></span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextSample初始值为随机数：[0,MemProfileRate)</span></span><br><span class="line">    c.nextSample -= <span class="type">int64</span>(size)</span><br><span class="line">    <span class="comment">// 负数立即采样 or MemProfileRate有改动</span></span><br><span class="line">    <span class="keyword">if</span> c.nextSample &lt; <span class="number">0</span> || MemProfileRate != c.memProfRate &#123;</span><br><span class="line">        <span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">        profilealloc(mp, x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    mp.mallocing = <span class="number">0</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存达到阈值，执行GC</span></span><br><span class="line">    <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">        gcStart(t)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是scan类型 or (需要清0 and span分配前需要清0)</span></span><br><span class="line">    <span class="keyword">if</span> noscan := typ == <span class="literal">nil</span> || !typ.Pointers(); !noscan || (needzero &amp;&amp; span.needzero != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 内存区域批量清0，发生抢占则挂起</span></span><br><span class="line">        memclrNoHeapPointersChunked(size, x)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止被GC抢占</span></span><br><span class="line">        mp := acquirem()</span><br><span class="line">        <span class="comment">// 如果是scan类型</span></span><br><span class="line">        <span class="keyword">if</span> !noscan &#123;</span><br><span class="line">            <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">            <span class="comment">// 把typ存储到span.largeType，返回span.elemsize</span></span><br><span class="line">            getMCache(mp).scanAlloc += heapSetTypeLarge(<span class="type">uintptr</span>(x), size, typ, span)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">        publicationBarrier()</span><br><span class="line">        releasem(mp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关依赖函数"><a href="#相关依赖函数" class="headerlink" title="相关依赖函数"></a>相关依赖函数</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// malloc初始化，schedinit-调度器初始化时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. guard，各种检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// class_to_size[2] != 16</span></span><br><span class="line">    <span class="keyword">if</span> class_to_size[_TinySizeClass] != _TinySize &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad TinySizeClass&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heapArenaBitmapWords非2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> heapArenaBitmapWords&amp;(heapArenaBitmapWords<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;heapArenaBitmapWords not a power of 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// physPageSize没有初始化（该变量由osinit初始化）</span></span><br><span class="line">    <span class="keyword">if</span> physPageSize == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;failed to get system page size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// physPageSize大于524288</span></span><br><span class="line">    <span class="keyword">if</span> physPageSize &gt; maxPhysPageSize &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;system page size (&quot;</span>, physPageSize, <span class="string">&quot;) is larger than maximum page size (&quot;</span>, maxPhysPageSize, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad system page size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// physPageSize小于4096</span></span><br><span class="line">    <span class="keyword">if</span> physPageSize &lt; minPhysPageSize &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;system page size (&quot;</span>, physPageSize, <span class="string">&quot;) is smaller than minimum page size (&quot;</span>, minPhysPageSize, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad system page size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// physPageSize大小非2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> physPageSize&amp;(physPageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;system page size (&quot;</span>, physPageSize, <span class="string">&quot;) must be a power of 2\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad system page size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// physHugePageSize大小非2的倍数（由osinit初始化，只有linux才有）</span></span><br><span class="line">    <span class="keyword">if</span> physHugePageSize&amp;(physHugePageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;system huge page size (&quot;</span>, physHugePageSize, <span class="string">&quot;) must be a power of 2\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad system huge page size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大于4194304</span></span><br><span class="line">    <span class="keyword">if</span> physHugePageSize &gt; maxPhysHugePageSize &#123;</span><br><span class="line">        <span class="comment">// 改为不支持</span></span><br><span class="line">        physHugePageSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// physHugePageSize有正常数值</span></span><br><span class="line">    <span class="keyword">if</span> physHugePageSize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 计算physHugePageShift，使2^physHugePageShift==physHugePageSize</span></span><br><span class="line">        <span class="keyword">for</span> <span class="number">1</span>&lt;&lt;physHugePageShift != physHugePageSize &#123;</span><br><span class="line">            physHugePageShift++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8192%512</span></span><br><span class="line">    <span class="keyword">if</span> pagesPerArena%pagesPerSpanRoot != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;pagesPerArena (&quot;</span>, pagesPerArena, <span class="string">&quot;) is not divisible by pagesPerSpanRoot (&quot;</span>, pagesPerSpanRoot, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad pagesPerSpanRoot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8192%512</span></span><br><span class="line">    <span class="keyword">if</span> pagesPerArena%pagesPerReclaimerChunk != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;pagesPerArena (&quot;</span>, pagesPerArena, <span class="string">&quot;) is not divisible by pagesPerReclaimerChunk (&quot;</span>, pagesPerReclaimerChunk, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad pagesPerReclaimerChunk&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个最终的结果都为true</span></span><br><span class="line">    minSizeForMallocHeaderIsSizeClass := <span class="literal">false</span></span><br><span class="line">    sizeClassesUpToMinSizeForMallocHeaderAreOnePage := <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 68个元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(class_to_size); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> class_to_allocnpages[i] &gt; <span class="number">1</span> &#123;</span><br><span class="line">            sizeClassesUpToMinSizeForMallocHeaderAreOnePage = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 512 == class_to_size[i]</span></span><br><span class="line">        <span class="keyword">if</span> minSizeForMallocHeader == <span class="type">uintptr</span>(class_to_size[i]) &#123;</span><br><span class="line">            minSizeForMallocHeaderIsSizeClass = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !minSizeForMallocHeaderIsSizeClass &#123;</span><br><span class="line">        throw(<span class="string">&quot;min size of malloc header is not a size class boundary&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !sizeClassesUpToMinSizeForMallocHeaderAreOnePage &#123;</span><br><span class="line">        throw(<span class="string">&quot;expected all size classes up to min size for malloc header to fit in one-page spans&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 512/8 &gt; 8*8 =&gt; false</span></span><br><span class="line">    <span class="keyword">if</span> minSizeForMallocHeader/goarch.PtrSize &gt; <span class="number">8</span>*goarch.PtrSize &#123;</span><br><span class="line">        throw(<span class="string">&quot;max pointer/scan bitmap size for headerless objects is too large&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10 &gt; 19 =&gt; false</span></span><br><span class="line">    <span class="keyword">if</span> minTagBits &gt; taggedPointerBits &#123;</span><br><span class="line">        throw(<span class="string">&quot;taggedPointerBits too small&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行相关初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mheap初始化（感觉没什么好说的）</span></span><br><span class="line">    mheap_.init()</span><br><span class="line">    <span class="comment">// mcache0从cachealloc分配器申请内存初始化</span></span><br><span class="line">    mcache0 = allocmcache()</span><br><span class="line">    <span class="comment">// 锁初始化</span></span><br><span class="line">    lockInit(&amp;gcBitsArenas.lock, lockRankGcBitsArenas)</span><br><span class="line">    lockInit(&amp;profInsertLock, lockRankProfInsert)</span><br><span class="line">    lockInit(&amp;profBlockLock, lockRankProfBlock)</span><br><span class="line">    lockInit(&amp;profMemActiveLock, lockRankProfMemActive)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> profMemFutureLock &#123;</span><br><span class="line">        lockInit(&amp;profMemFutureLock[i], lockRankProfMemFuture)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局内存分配器</span></span><br><span class="line">    lockInit(&amp;globalAlloc.mutex, lockRankGlobalAlloc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是userArena的初始化，用以Arena包，让用户自己手动管理内存，可以先忽略</span></span><br><span class="line">    <span class="keyword">if</span> isSbrkPlatform &#123;</span><br><span class="line">        <span class="comment">// wasm（isSbrkPlatform默认为false）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">        <span class="comment">// 64位系统</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成hint-预规划地址，后期尽量调用sysMap直接映射，而不是sysAlloc让OS选择，减少碎片化</span></span><br><span class="line">        <span class="comment">// 为了防止冲突和区分用途，选择0x00c0作为该内存段的标记</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// i=127，共128个，每个arena间隔1&lt;&lt;40（即1TB），共128TB</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0x7f</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">            <span class="comment">// 第一步，计算p</span></span><br><span class="line">            <span class="keyword">var</span> p <span class="type">uintptr</span></span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> raceenabled: <span class="comment">// raceenabled默认为false，忽略</span></span><br><span class="line">                <span class="comment">// TSAN要求heap必须在[0x00c000000000, 0x00e000000000)范围内</span></span><br><span class="line">                p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">32</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">                <span class="keyword">if</span> p &gt;= uintptrMask&amp;<span class="number">0x00e000000000</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> GOARCH == <span class="string">&quot;arm64&quot;</span> &amp;&amp; GOOS == <span class="string">&quot;ios&quot;</span>: <span class="comment">// 忽略</span></span><br><span class="line">                p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">            <span class="keyword">case</span> GOARCH == <span class="string">&quot;arm64&quot;</span>: <span class="comment">// 忽略</span></span><br><span class="line">                p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0040</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">            <span class="keyword">case</span> GOOS == <span class="string">&quot;aix&quot;</span>: <span class="comment">// 忽略</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 防止跟mmap冲突（mmap使用0x0A00000000000000开始的地址）</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0xa0</span>&lt;&lt;<span class="number">52</span>)</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// 默认</span></span><br><span class="line">                <span class="comment">// p = (i*2^40)|(2^64-1)&amp;(0x00c0&lt;&lt;32)</span></span><br><span class="line">                <span class="comment">// i最大值为127，p总共占用47个位，&amp;优先级比|高</span></span><br><span class="line">                <span class="comment">// 如果i=127(0x7f)，p的结果是0x007FC00000000000（7f和c被保留）</span></span><br><span class="line">                p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二步，arenaHint链表</span></span><br><span class="line">            <span class="comment">// 下面判断中，127个hint中的前64个（即一半）hints由mheap直接管理，剩余的放入userArena</span></span><br><span class="line">            hintList := &amp;mheap_.arenaHints</span><br><span class="line">            <span class="comment">// raceenabled默认为false</span></span><br><span class="line">            <span class="keyword">if</span> (!raceenabled &amp;&amp; i &gt; <span class="number">0x3f</span>) || (raceenabled &amp;&amp; i &gt; <span class="number">0x5f</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果i &gt; 0x3f，走这里</span></span><br><span class="line">                hintList = &amp;mheap_.userArena.arenaHints</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从arenaHintAlloc里获取24字节作为arenaHint（内存不够用一次性申请16KB）</span></span><br><span class="line">            hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())</span><br><span class="line">            <span class="comment">// 纪录地址p</span></span><br><span class="line">            hint.addr = p</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 链成一个链表</span></span><br><span class="line">            <span class="comment">// hint0-&gt;hint1-&gt;...-&gt;hint127</span></span><br><span class="line">            <span class="comment">// curr.next = *prev; *prev = curr</span></span><br><span class="line">            hint.next, *hintList = *hintList, hint</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 32位系统，直接忽略</span></span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认2^64-1，可以通过GOMEMLIMIT环境变量修改</span></span><br><span class="line">    gcController.memoryLimit.Store(maxInt64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mheap-1"><a href="#mheap-1" class="headerlink" title="mheap"></a>mheap</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mheap初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> init() &#123;</span><br><span class="line">    <span class="comment">// 锁初始化</span></span><br><span class="line">    lockInit(&amp;h.lock, lockRankMheap)</span><br><span class="line">    lockInit(&amp;h.speciallock, lockRankMheapSpecial)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面全是初始化fixalloc结构体（allock时若数据量不足，则一次性申请16KB内存）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan，每个单元160字节</span></span><br><span class="line">    <span class="comment">// 每次alloc执行recordspan函数，其将分配的mspan纪录到allspans</span></span><br><span class="line">    h.spanalloc.init(unsafe.Sizeof(mspan&#123;&#125;), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)</span><br><span class="line">    <span class="comment">// mcache，每个单元1208字节</span></span><br><span class="line">    h.cachealloc.init(unsafe.Sizeof(mcache&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.mcache_sys)</span><br><span class="line">    <span class="comment">// specialfinalizer，每个单元56字节</span></span><br><span class="line">    h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    <span class="comment">// specialCleanup，每个单元40字节</span></span><br><span class="line">    h.specialCleanupAlloc.init(unsafe.Sizeof(specialCleanup&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    <span class="comment">// specialprofile，每个单元32字节</span></span><br><span class="line">    h.specialprofilealloc.init(unsafe.Sizeof(specialprofile&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    <span class="comment">// specialReachable，每个单元32字节</span></span><br><span class="line">    h.specialReachableAlloc.init(unsafe.Sizeof(specialReachable&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    <span class="comment">// specialPinCounter，每个单元32字节</span></span><br><span class="line">    h.specialPinCounterAlloc.init(unsafe.Sizeof(specialPinCounter&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">    <span class="comment">// specialWeakHandle，每个单元32字节</span></span><br><span class="line">    h.specialWeakHandleAlloc.init(unsafe.Sizeof(specialWeakHandle&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.gcMiscSys)</span><br><span class="line">    <span class="comment">// arenaHint，每个单元24字节</span></span><br><span class="line">    h.arenaHintAlloc.init(unsafe.Sizeof(arenaHint&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan在alloc时，单元的内存不执行清零操作</span></span><br><span class="line">    h.spanalloc.zero = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// h-&gt;mapcache不需要初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 136个mcentral</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> h.central &#123;</span><br><span class="line">        <span class="comment">// 纪录spanclass、初始化锁</span></span><br><span class="line">        h.central[i].mcentral.init(spanClass(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pageAlloc初始化</span></span><br><span class="line">    h.pages.init(&amp;h.lock, &amp;memstats.gcMiscSys, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先清扫并释放至少n个页，然后获取mspan、分配n个页面、更新元信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> alloc(npages <span class="type">uintptr</span>, spanclass spanClass) *mspan &#123;</span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 清扫并释放至少n个页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// sweeper数量不为0 =&gt; 还在清扫阶段</span></span><br><span class="line">        <span class="keyword">if</span> !isSweepDone() &#123;</span><br><span class="line">            <span class="comment">// func (h *mheap) reclaim(npage uintptr)</span></span><br><span class="line">            <span class="comment">// 有额度先扣额度，没有额度则按页索引地址找到mspan并清扫，完成至少n个页清扫后返回（分批次清扫，每批512个页）</span></span><br><span class="line">            h.reclaim(npages)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// func (h *mheap) allocSpan(npages uintptr, typ spanAllocType, spanclass spanClass) (s *mspan)</span></span><br><span class="line">        <span class="comment">// 获取mspan、分配n个页面、更新元信息</span></span><br><span class="line">        s = h.allocSpan(npages, spanAllocHeap, spanclass)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取mspan、分配n个页面、更新元信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocManual(npages <span class="type">uintptr</span>, typ spanAllocType) *mspan &#123;</span><br><span class="line">    <span class="comment">// 类型异常</span></span><br><span class="line">    <span class="keyword">if</span> !typ.manual() &#123;</span><br><span class="line">        throw(<span class="string">&quot;manual span allocation called with non-manually-managed type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sizeclass=0</span></span><br><span class="line">    <span class="comment">// 获取mspan、分配n个页面、更新元信息</span></span><br><span class="line">    <span class="keyword">return</span> h.allocSpan(npages, typ, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heap扩容至少npage，返回实际扩容量和是否成功</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> grow(npage <span class="type">uintptr</span>) (<span class="type">uintptr</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总字节数 = npage按512的倍数向上取整，再乘于每页字节数8192</span></span><br><span class="line">    ask := alignUp(npage, pallocChunkPages) * pageSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际扩容量</span></span><br><span class="line">    totalGrowth := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// end地址</span></span><br><span class="line">    end := h.curArena.base + ask</span><br><span class="line">    <span class="comment">// 按physPageSize的倍数向上取整</span></span><br><span class="line">    nBase := alignUp(end, physPageSize)</span><br><span class="line">    <span class="comment">// 不够用，不管有没有溢出</span></span><br><span class="line">    <span class="keyword">if</span> nBase &gt; h.curArena.end || end &lt; h.curArena.base &#123;</span><br><span class="line">        <span class="comment">// func (h *mheap) sysAlloc(n uintptr, hintList **arenaHint, register bool) (v unsafe.Pointer, size uintptr)</span></span><br><span class="line">        <span class="comment">// 向系统申请size大小内存（Reserved），最低64MB，创建arenaHint、heapArena</span></span><br><span class="line">        av, asize := h.sysAlloc(ask, &amp;h.arenaHints, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">if</span> av == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 打印，返回</span></span><br><span class="line">            inUse := gcController.heapFree.load() + gcController.heapReleased.load() + gcController.heapInUse.load()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: out of memory: cannot allocate &quot;</span>, ask, <span class="string">&quot;-byte block (&quot;</span>, inUse, <span class="string">&quot; in use)\n&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个arena</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">uintptr</span>(av) == h.curArena.end &#123;</span><br><span class="line">            <span class="comment">// 更新end</span></span><br><span class="line">            h.curArena.end = <span class="type">uintptr</span>(av) + asize</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 可能有多个arena</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前arena剩余空间</span></span><br><span class="line">            <span class="keyword">if</span> size := h.curArena.end - h.curArena.base; size != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 使用sysMap直接映射，内存状态从Reserved改为Prepared</span></span><br><span class="line">                sysMap(unsafe.Pointer(h.curArena.base), size, &amp;gcController.heapReleased)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">                <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">                stats := memstats.heapStats.acquire()</span><br><span class="line">                <span class="comment">// 剩余内存大小加到released</span></span><br><span class="line">                atomic.Xaddint64(&amp;stats.released, <span class="type">int64</span>(size))</span><br><span class="line">                <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">                memstats.heapStats.release()</span><br><span class="line">                <span class="comment">// func (p *pageAlloc) grow(base, size uintptr)</span></span><br><span class="line">                <span class="comment">// 分配物理内存，更新并重新统计chunks信息，最后更新summary（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">                h.pages.grow(h.curArena.base, size)</span><br><span class="line">                <span class="comment">// 累计到实际扩容量</span></span><br><span class="line">                totalGrowth += size</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 切换到最新的arena</span></span><br><span class="line">            h.curArena.base = <span class="type">uintptr</span>(av)</span><br><span class="line">            h.curArena.end = <span class="type">uintptr</span>(av) + asize</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再算一遍</span></span><br><span class="line">        nBase = alignUp(h.curArena.base+ask, physPageSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原base</span></span><br><span class="line">    v := h.curArena.base</span><br><span class="line">    <span class="comment">// 新base</span></span><br><span class="line">    h.curArena.base = nBase</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用sysMap直接映射，内存状态从Reserved改为Prepared</span></span><br><span class="line">    sysMap(unsafe.Pointer(v), nBase-v, &amp;gcController.heapReleased)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    <span class="comment">// 申请内存大小加到released</span></span><br><span class="line">    atomic.Xaddint64(&amp;stats.released, <span class="type">int64</span>(nBase-v))</span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (p *pageAlloc) grow(base, size uintptr)</span></span><br><span class="line">    <span class="comment">// 分配物理内存，更新并重新统计chunks信息，最后更新summary（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">    h.pages.grow(v, nBase-v)</span><br><span class="line">    <span class="comment">// 累计到实际扩容量</span></span><br><span class="line">    totalGrowth += nBase - v</span><br><span class="line">    <span class="keyword">return</span> totalGrowth, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从mspancache末尾拿一个mspan，不触发扩容操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> tryAllocMSpan() *mspan &#123;</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有p or mspancache为空</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> || pp.mspancache.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从mspancache末尾拿一个mspan</span></span><br><span class="line">    s := pp.mspancache.buf[pp.mspancache.<span class="built_in">len</span><span class="number">-1</span>]</span><br><span class="line">    pp.mspancache.<span class="built_in">len</span>--</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从mspancache末尾拿一个mspan（不足时扩容）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocMSpanLocked() *mspan &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// 没有p</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// spanalloc分配一个mspan header</span></span><br><span class="line">        <span class="keyword">return</span> (*mspan)(h.spanalloc.alloc())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspancache为空</span></span><br><span class="line">    <span class="keyword">if</span> pp.mspancache.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 生成buf长度一半数量的mspan header</span></span><br><span class="line">        <span class="keyword">const</span> refillCount = <span class="built_in">len</span>(pp.mspancache.buf) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; refillCount; i++ &#123;</span><br><span class="line">            pp.mspancache.buf[i] = (*mspan)(h.spanalloc.alloc())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新len</span></span><br><span class="line">        pp.mspancache.<span class="built_in">len</span> = refillCount</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从mspancache末尾拿一个mspan</span></span><br><span class="line">    s := pp.mspancache.buf[pp.mspancache.<span class="built_in">len</span><span class="number">-1</span>]</span><br><span class="line">    pp.mspancache.<span class="built_in">len</span>--</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取mspan、分配n个页面、更新元信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocSpan(npages <span class="type">uintptr</span>, typ spanAllocType, spanclass spanClass) (s *mspan) &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 起始地址，被清理的页数（一般为0）</span></span><br><span class="line">    base, scav := <span class="type">uintptr</span>(<span class="number">0</span>), <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    growth := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// needPhysPageAlign默认false，所以固定返回true</span></span><br><span class="line">    <span class="comment">// 有p and n &lt; 16(=64/4)</span></span><br><span class="line">    <span class="keyword">if</span> !needPhysPageAlign &amp;&amp; pp != <span class="literal">nil</span> &amp;&amp; npages &lt; pageCachePages/<span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">// p.pcache</span></span><br><span class="line">        c := &amp;pp.pcache</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pcache的64个页都用完了</span></span><br><span class="line">        <span class="keyword">if</span> c.empty() &#123;</span><br><span class="line">            lock(&amp;h.lock)</span><br><span class="line">            <span class="comment">// 通过summary查找，找到一个最少包含一个可用页的块（共64个页信息）</span></span><br><span class="line">            *c = h.pages.allocToCache()</span><br><span class="line">            unlock(&amp;h.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// func (c *pageCache) alloc(npages uintptr) (uintptr, uintptr)</span></span><br><span class="line">        <span class="comment">// 从pcache找到连续n个页的起始地址，并判断这几个页是否被清理过（重用）</span></span><br><span class="line">        base, scav = c.alloc(npages)</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        <span class="keyword">if</span> base != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试从mspancache末尾拿一个mspan，不触发扩容操作</span></span><br><span class="line">            s = h.tryAllocMSpan()</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">goto</span> HaveSpan</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从pcache分配页失败</span></span><br><span class="line">    <span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// func (p *pageAlloc) alloc(npages uintptr) (addr uintptr, scav uintptr)</span></span><br><span class="line">        <span class="comment">// pageAlloc通过summary扫描寻找足以容纳n个页的地址</span></span><br><span class="line">        base, scav = h.pages.alloc(npages)</span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">            <span class="comment">// func (h *mheap) grow(npage uintptr) (uintptr, bool)</span></span><br><span class="line">            <span class="comment">// heap扩容至少npage，返回实际扩容量和是否成功（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">            growth, ok = h.grow(npages)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩容失败</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                unlock(&amp;h.lock)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩容成功，重试</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// func (p *pageAlloc) alloc(npages uintptr) (addr uintptr, scav uintptr)</span></span><br><span class="line">            <span class="comment">// pageAlloc通过summary扫描寻找足以容纳n个页的地址</span></span><br><span class="line">            base, scav = h.pages.alloc(npages)</span><br><span class="line">            <span class="comment">// 还是失败，异常</span></span><br><span class="line">            <span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;grew heap, but no adequate free space found&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan为nil</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从mspancache末尾拿一个mspan（不足时扩容）</span></span><br><span class="line">        s = h.allocMSpanLocked()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，page和mspan都准备好了</span></span><br><span class="line">HaveSpan:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存超限溢出的数量</span></span><br><span class="line">    bytesToScavenge := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 是否强制回收</span></span><br><span class="line">    forceScavenge := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC不限速</span></span><br><span class="line">    <span class="keyword">if</span> limit := gcController.memoryLimit.Load(); !gcCPULimiter.limiting() &#123;</span><br><span class="line">        <span class="comment">// 已映射且可用的内存量（总内存）</span></span><br><span class="line">        inuse := gcController.mappedReady.Load()</span><br><span class="line">        <span class="comment">// 重用的内存量+已映射且可用的内存量（总内存）超过限制</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">uint64</span>(scav)+inuse &gt; <span class="type">uint64</span>(limit) &#123;</span><br><span class="line">            <span class="comment">// 溢出量</span></span><br><span class="line">            bytesToScavenge = <span class="type">uintptr</span>(<span class="type">uint64</span>(scav) + inuse - <span class="type">uint64</span>(limit))</span><br><span class="line">            <span class="comment">// 强制回收</span></span><br><span class="line">            forceScavenge = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC触发临界点有设置限制 and mheap扩容了</span></span><br><span class="line">    <span class="keyword">if</span> goal := scavenge.gcPercentGoal.Load(); goal != ^<span class="type">uint64</span>(<span class="number">0</span>) &amp;&amp; growth &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// retained=heapInUse+heapFree（gcController）</span></span><br><span class="line">        <span class="comment">// 如果heap内存+扩容量超过临界点</span></span><br><span class="line">        <span class="keyword">if</span> retained := heapRetained(); retained+<span class="type">uint64</span>(growth) &gt; goal &#123;</span><br><span class="line">            <span class="comment">// 溢出量，先按扩容量为准</span></span><br><span class="line">            todo := growth</span><br><span class="line">            <span class="comment">// 扩容量比溢出量大</span></span><br><span class="line">            <span class="keyword">if</span> overage := <span class="type">uintptr</span>(retained + <span class="type">uint64</span>(growth) - goal); todo &gt; overage &#123;</span><br><span class="line">                <span class="comment">// 实际溢出量（按道理，一般都会走这个流程）</span></span><br><span class="line">                todo = overage</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// =max(bytesToScavenge,todo) =&gt; 哪个大就已哪个为准</span></span><br><span class="line">            <span class="keyword">if</span> todo &gt; bytesToScavenge &#123;</span><br><span class="line">                bytesToScavenge = todo</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> now <span class="type">int64</span></span><br><span class="line">    <span class="comment">// 有p and 内存超限</span></span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &amp;&amp; bytesToScavenge &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时刻</span></span><br><span class="line">        start := nanotime()</span><br><span class="line">        <span class="comment">// stamp存储limiterEventScavengeAssist和start</span></span><br><span class="line">        track := pp.limiterEvent.start(limiterEventScavengeAssist, start)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// func (p *pageAlloc) scavenge(nbytes uintptr, shouldStop func() bool, force bool) uintptr</span></span><br><span class="line">        <span class="comment">// 回收指定字节数量的内存（扫描时是从高地址向低地址进行搜索）</span></span><br><span class="line">        released := h.pages.scavenge(bytesToScavenge, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="comment">// GC是否限速</span></span><br><span class="line">            <span class="keyword">return</span> gcCPULimiter.limiting()</span><br><span class="line">        &#125;, forceScavenge)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收索引将已回收字节数累计到releasedEager</span></span><br><span class="line">        mheap_.pages.scav.releasedEager.Add(released)</span><br><span class="line"></span><br><span class="line">        now = nanotime()</span><br><span class="line">        <span class="keyword">if</span> track &#123;</span><br><span class="line">            <span class="comment">// 重置stamp字段，纪录耗时</span></span><br><span class="line">            pp.limiterEvent.stop(limiterEventScavengeAssist, now)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 纪录耗时</span></span><br><span class="line">        scavenge.assistTime.Add(now - start)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新mspan、arena</span></span><br><span class="line">    h.initSpan(s, typ, spanclass, base, npages)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数=npages * 8192</span></span><br><span class="line">    nbytes := npages * pageSize</span><br><span class="line">    <span class="keyword">if</span> scav != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 内存状态从Prepared改为Ready</span></span><br><span class="line">        sysUsed(unsafe.Pointer(base), nbytes, scav)</span><br><span class="line">        <span class="comment">// heap内存释放量</span></span><br><span class="line">        gcController.heapReleased.add(-<span class="type">int64</span>(scav))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap内存可复用量（这里需要减去释放回OS的量）</span></span><br><span class="line">    gcController.heapFree.add(-<span class="type">int64</span>(nbytes - scav))</span><br><span class="line">    <span class="comment">// heap内存</span></span><br><span class="line">    <span class="keyword">if</span> typ == spanAllocHeap &#123;</span><br><span class="line">        <span class="comment">// 累计到heap内存使用量</span></span><br><span class="line">        gcController.heapInUse.add(<span class="type">int64</span>(nbytes))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    atomic.Xaddint64(&amp;stats.committed, <span class="type">int64</span>(scav))</span><br><span class="line">    atomic.Xaddint64(&amp;stats.released, -<span class="type">int64</span>(scav))</span><br><span class="line">    <span class="keyword">switch</span> typ &#123;</span><br><span class="line">    <span class="keyword">case</span> spanAllocHeap:          <span class="comment">// 0-heap内存</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inHeap, <span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocStack:         <span class="comment">// 1-stack内存</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inStacks, <span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocPtrScalarBits: <span class="comment">// 3-GC bitmap</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inPtrScalarBits, <span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocWorkBuf:       <span class="comment">// 4-GC wbuf</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inWorkBufs, <span class="type">int64</span>(nbytes))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新mspan、arena</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> initSpan(s *mspan, typ spanAllocType, spanclass spanClass, base, npages <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 简单初始化，数据记录到startAddr、npages</span></span><br><span class="line">    s.init(base, npages)</span><br><span class="line">    <span class="comment">// heapArena分配地址空间，如果开始地址重用则needZero为true</span></span><br><span class="line">    <span class="keyword">if</span> h.allocNeedsZero(base, npages) &#123;</span><br><span class="line">        s.needzero = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数=npages * 8192</span></span><br><span class="line">    nbytes := npages * pageSize</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下是mspan元信息初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动分配管理</span></span><br><span class="line">    <span class="keyword">if</span> typ.manual() &#123;</span><br><span class="line">        s.manualFreeList = <span class="number">0</span></span><br><span class="line">        s.nelems = <span class="number">0</span></span><br><span class="line">        s.limit = s.base() + s.npages*pageSize</span><br><span class="line">        s.state.set(mSpanManual)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// heap类型</span></span><br><span class="line"></span><br><span class="line">        s.spanclass = spanclass</span><br><span class="line">        <span class="comment">// &gt;32KB</span></span><br><span class="line">        <span class="keyword">if</span> sizeclass := spanclass.sizeclass(); sizeclass == <span class="number">0</span> &#123;</span><br><span class="line">            s.elemsize = nbytes</span><br><span class="line">            s.nelems = <span class="number">1</span></span><br><span class="line">            s.divMul = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &lt;=32KB</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向上取整，如原size=20，经过计算sizeclass=3，新size=24</span></span><br><span class="line">            s.elemsize = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">            <span class="comment">// scan and elemsize&lt;=512B</span></span><br><span class="line">            <span class="keyword">if</span> !s.spanclass.noscan() &amp;&amp; heapBitsInSpan(s.elemsize) &#123;</span><br><span class="line">                <span class="comment">// =(总字节数-bitmap字节数)/elemsize</span></span><br><span class="line">                s.nelems = <span class="type">uint16</span>((nbytes - (nbytes / goarch.PtrSize / <span class="number">8</span>)) / s.elemsize)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// noscan or elemsize&gt;512B</span></span><br><span class="line">                <span class="comment">// 不需要加8个字节的header</span></span><br><span class="line">                s.nelems = <span class="type">uint16</span>(nbytes / s.elemsize)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用于优化除法运算</span></span><br><span class="line">            s.divMul = class_to_divmagic[sizeclass]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为0</span></span><br><span class="line">        s.freeindex = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 默认为0</span></span><br><span class="line">        s.freeIndexForScan = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 默认64位全为1</span></span><br><span class="line">        s.allocCache = ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从gcBitsArenas分配足以容纳nelems个位的内存（64的倍数向上取整）</span></span><br><span class="line">        s.gcmarkBits = newMarkBits(<span class="type">uintptr</span>(s.nelems))</span><br><span class="line">        <span class="comment">// 从gcBitsArenas分配足以容纳nelems个位的内存（64的倍数向上取整）</span></span><br><span class="line">        s.allocBits = newAllocBits(<span class="type">uintptr</span>(s.nelems))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用mheap的sweepgen更新mspan的</span></span><br><span class="line">        atomic.Store(&amp;s.sweepgen, h.sweepgen)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态设置</span></span><br><span class="line">        s.state.set(mSpanInUse)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan初始化完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ha.spans纪录heapArena内每个页对应的mspan</span></span><br><span class="line">    h.setSpans(s.base(), npages, s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非手动分配管理</span></span><br><span class="line">    <span class="keyword">if</span> !typ.manual() &#123;</span><br><span class="line">        <span class="comment">// 通过地址计算出heapArena、页起始索引、页起始位</span></span><br><span class="line">        arena, pageIdx, pageMask := pageIndexOf(s.base())</span><br><span class="line">        <span class="comment">// 汇编，按位或，看起来只有第一个页有设置</span></span><br><span class="line">        atomic.Or8(&amp;arena.pageInUse[pageIdx], pageMask)</span><br><span class="line">        <span class="comment">// heap内存页使用量（mSpanInUse） =&gt; pagesInUse+=n</span></span><br><span class="line">        h.pagesInUse.Add(npages)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，linux+amd64下为空函数</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有额度先扣额度，没有额度则按页索引地址找到mspan并清扫，完成至少n个页清扫后返回（分批次清扫，每批512个页）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> reclaim(npage <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// scavenger-回收器已完成工作</span></span><br><span class="line">    <span class="keyword">if</span> h.reclaimIndex.Load() &gt;= <span class="number">1</span>&lt;&lt;<span class="number">63</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allArenas快照 =&gt; []arenaIdx</span></span><br><span class="line">    arenas := h.sweepArenas</span><br><span class="line">    <span class="comment">// 是否已加锁</span></span><br><span class="line">    locked := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清扫至少n个页面</span></span><br><span class="line">    <span class="keyword">for</span> npage &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 还有额度</span></span><br><span class="line">        <span class="keyword">if</span> credit := h.reclaimCredit.Load(); credit &gt; <span class="number">0</span> &#123;</span><br><span class="line">            take := credit</span><br><span class="line">            <span class="comment">// 额度足够</span></span><br><span class="line">            <span class="keyword">if</span> take &gt; npage &#123;</span><br><span class="line">                <span class="comment">// 以n为准</span></span><br><span class="line">                take = npage</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拿走take额度</span></span><br><span class="line">            <span class="keyword">if</span> h.reclaimCredit.CompareAndSwap(credit, credit-take) &#123;</span><br><span class="line">                <span class="comment">// 调整，结果&gt;=0</span></span><br><span class="line">                npage -= take</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有额度了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取reclaimIndex =&gt; idx=reclaimIndex; reclaimIndex+=512</span></span><br><span class="line">        idx := <span class="type">uintptr</span>(h.reclaimIndex.Add(pagesPerReclaimerChunk) - pagesPerReclaimerChunk)</span><br><span class="line">        <span class="comment">// 获取heapArena的索引并判断是否越界 =&gt; idx/8192 &gt;= len(arenas)</span></span><br><span class="line">        <span class="keyword">if</span> idx/pagesPerArena &gt;= <span class="type">uintptr</span>(<span class="built_in">len</span>(arenas)) &#123;</span><br><span class="line">            <span class="comment">// 越界了</span></span><br><span class="line">            <span class="comment">// 设置为1 &lt;&lt; 63</span></span><br><span class="line">            h.reclaimIndex.Store(<span class="number">1</span> &lt;&lt; <span class="number">63</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁，用于访问reclaimChunk</span></span><br><span class="line">        <span class="keyword">if</span> !locked &#123;</span><br><span class="line">            lock(&amp;h.lock)</span><br><span class="line">            locked = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按页索引地址找到mspan并清扫，完成至少512个页清扫后返回</span></span><br><span class="line">        nfound := h.reclaimChunk(arenas, idx, pagesPerReclaimerChunk)</span><br><span class="line">        <span class="keyword">if</span> nfound &lt;= npage &#123;</span><br><span class="line">            npage -= nfound</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 释放了过多的页，则多余的量累计到回收额度</span></span><br><span class="line">            h.reclaimCredit.Add(nfound - npage)</span><br><span class="line">            npage = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复原锁状态</span></span><br><span class="line">    <span class="keyword">if</span> locked &#123;</span><br><span class="line">        unlock(&amp;h.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按页索引地址找到mspan并清扫，完成至少n个页清扫后返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> reclaimChunk(arenas []arenaIdx, pageIdx, n <span class="type">uintptr</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    <span class="comment">// 防止访问到过期的mspan指针</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    n0 := n <span class="comment">// 512</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> nFreed <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// 计数器加1，返回mheap_.sweepgen及sweepDrainedMask标记是否已设置</span></span><br><span class="line">    sl := sweep.active.begin()</span><br><span class="line">    <span class="comment">// sweeper数量为0 =&gt; sweep阶段结束</span></span><br><span class="line">    <span class="keyword">if</span> !sl.valid &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// =arenas[reclaimIndex/8192]</span></span><br><span class="line">        ai := arenas[pageIdx/pagesPerArena]</span><br><span class="line">        <span class="comment">// heapArena</span></span><br><span class="line">        ha := h.arenas[ai.l1()][ai.l2()]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在heapArena内的页索引=reclaimIndex%8192</span></span><br><span class="line">        arenaPage := <span class="type">uint</span>(pageIdx % pagesPerArena)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面两个都是bitmap，每个都有8K个位，找到n个页的bitmap区域</span></span><br><span class="line">        inUse := ha.pageInUse[arenaPage/<span class="number">8</span>:]</span><br><span class="line">        marked := ha.pageMarks[arenaPage/<span class="number">8</span>:]</span><br><span class="line">        <span class="comment">// uint8类型，可管理8个页</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">uintptr</span>(<span class="built_in">len</span>(inUse)) &gt; n/<span class="number">8</span> &#123;</span><br><span class="line">            inUse = inUse[:n/<span class="number">8</span>]</span><br><span class="line">            marked = marked[:n/<span class="number">8</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个字节</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> inUse &#123;</span><br><span class="line">            <span class="comment">// 找出标记为已使用但没有被GC标记的页（白色对象，应该要清扫的页）</span></span><br><span class="line">            inUseUnmarked := atomic.Load8(&amp;inUse[i]) &amp;^ marked[i]</span><br><span class="line">            <span class="comment">// 没有，继续</span></span><br><span class="line">            <span class="keyword">if</span> inUseUnmarked == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有需要清扫的页，找到具体的页</span></span><br><span class="line">            <span class="keyword">for</span> j := <span class="type">uint</span>(<span class="number">0</span>); j &lt; <span class="number">8</span>; j++ &#123;</span><br><span class="line">                <span class="comment">// 找到了</span></span><br><span class="line">                <span class="keyword">if</span> inUseUnmarked&amp;(<span class="number">1</span>&lt;&lt;j) != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 根据页ID找到mspan</span></span><br><span class="line">                    s := ha.spans[arenaPage+<span class="type">uint</span>(i)*<span class="number">8</span>+j]</span><br><span class="line">                    <span class="comment">// 尝试获得mspan的所有权</span></span><br><span class="line">                    <span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">                        npages := s.npages</span><br><span class="line">                        <span class="comment">// 解锁</span></span><br><span class="line">                        unlock(&amp;h.lock)</span><br><span class="line">                        <span class="comment">// func (sl *sweepLocked) sweep(preserve bool) bool</span></span><br><span class="line">                        <span class="comment">// 清扫一个mspan（不保留，被heap回收）</span></span><br><span class="line">                        <span class="keyword">if</span> s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line">                            nFreed += npages</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 重新加锁</span></span><br><span class="line">                        lock(&amp;h.lock)</span><br><span class="line">                        <span class="comment">// double-check，防止过期mspan指针</span></span><br><span class="line">                        inUseUnmarked = atomic.Load8(&amp;inUse[i]) &amp;^ marked[i]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共扫描inUse*8个页</span></span><br><span class="line">        <span class="comment">// 移动索引</span></span><br><span class="line">        pageIdx += <span class="type">uintptr</span>(<span class="built_in">len</span>(inUse) * <span class="number">8</span>)</span><br><span class="line">        <span class="comment">// 计数器调整，看是否还需要继续清扫</span></span><br><span class="line">        n -= <span class="type">uintptr</span>(<span class="built_in">len</span>(inUse) * <span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清扫完毕</span></span><br><span class="line">    <span class="comment">// 计数器减1</span></span><br><span class="line">    sweep.active.end(sl)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line">    <span class="keyword">return</span> nFreed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放页和mspan，仅heap管理用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> freeSpan(s *mspan) &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lock(&amp;h.lock)</span><br><span class="line">        <span class="comment">// 释放页和mspan</span></span><br><span class="line">        h.freeSpanLocked(s, spanAllocHeap)</span><br><span class="line">        unlock(&amp;h.lock)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放页和mspan，仅手动分配用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> freeManual(s *mspan, typ spanAllocType) &#123;</span><br><span class="line">    <span class="comment">// 表示需要清0</span></span><br><span class="line">    s.needzero = <span class="number">1</span></span><br><span class="line">    lock(&amp;h.lock)</span><br><span class="line">    <span class="comment">// 释放页和mspan</span></span><br><span class="line">    h.freeSpanLocked(s, typ)</span><br><span class="line">    unlock(&amp;h.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放页和mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> freeSpanLocked(s *mspan, typ spanAllocType) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> s.state.get() &#123;</span><br><span class="line">    <span class="keyword">case</span> mSpanManual: <span class="comment">// 手动</span></span><br><span class="line">        <span class="keyword">if</span> s.allocCount != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;mheap.freeSpanLocked - invalid stack free&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> mSpanInUse: <span class="comment">// heap管理</span></span><br><span class="line">        <span class="keyword">if</span> s.isUserArenaChunk &#123;</span><br><span class="line">            throw(<span class="string">&quot;mheap.freeSpanLocked - invalid free of user arena chunk&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s.allocCount != <span class="number">0</span> || s.sweepgen != h.sweepgen &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;mheap.freeSpanLocked - span &quot;</span>, s, <span class="string">&quot; ptr &quot;</span>, hex(s.base()), <span class="string">&quot; allocCount &quot;</span>, s.allocCount, <span class="string">&quot; sweepgen &quot;</span>, s.sweepgen, <span class="string">&quot;/&quot;</span>, h.sweepgen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;mheap.freeSpanLocked - invalid free&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// heap内存页使用量（mSpanInUse） =&gt; pagesInUse-=n</span></span><br><span class="line">        h.pagesInUse.Add(-s.npages)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过地址计算出heapArena、页起始索引、页起始位</span></span><br><span class="line">        arena, pageIdx, pageMask := pageIndexOf(s.base())</span><br><span class="line">        <span class="comment">// 在pageInUse中将该页所在位设置为0</span></span><br><span class="line">        atomic.And8(&amp;arena.pageInUse[pageIdx], ^pageMask)</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 其他</span></span><br><span class="line">        throw(<span class="string">&quot;mheap.freeSpanLocked - invalid span state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新stat</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 总字节数</span></span><br><span class="line">    nbytes := s.npages * pageSize</span><br><span class="line">    <span class="comment">// heap内存可复用量（free时增加）</span></span><br><span class="line">    gcController.heapFree.add(<span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="comment">// heap内存</span></span><br><span class="line">    <span class="keyword">if</span> typ == spanAllocHeap &#123;</span><br><span class="line">        <span class="comment">// 累计到heap内存使用量</span></span><br><span class="line">        gcController.heapInUse.add(-<span class="type">int64</span>(nbytes))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    <span class="keyword">switch</span> typ &#123;</span><br><span class="line">    <span class="keyword">case</span> spanAllocHeap:          <span class="comment">// 0-heap内存</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inHeap, -<span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocStack:         <span class="comment">// 1-stack内存</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inStacks, -<span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocPtrScalarBits: <span class="comment">// 3-GC bitmap</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inPtrScalarBits, -<span class="type">int64</span>(nbytes))</span><br><span class="line">    <span class="keyword">case</span> spanAllocWorkBuf:       <span class="comment">// 4-GC wbuf</span></span><br><span class="line">        atomic.Xaddint64(&amp;stats.inWorkBufs, -<span class="type">int64</span>(nbytes))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新并重新统计chunks，最后更新summary（释放）</span></span><br><span class="line">    h.pages.free(s.base(), s.npages)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认状态</span></span><br><span class="line">    s.state.set(mSpanDead)</span><br><span class="line">    <span class="comment">// mspan放到mspancache末尾</span></span><br><span class="line">    h.freeMSpanLocked(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mspan放到mspancache末尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> freeMSpanLocked(s *mspan) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p不为空 and buf不满一半</span></span><br><span class="line">    <span class="keyword">if</span> pp != <span class="literal">nil</span> &amp;&amp; pp.mspancache.<span class="built_in">len</span> &lt; <span class="built_in">len</span>(pp.mspancache.buf) &#123;</span><br><span class="line">        <span class="comment">// 放到mspancache末尾</span></span><br><span class="line">        pp.mspancache.buf[pp.mspancache.<span class="built_in">len</span>] = s</span><br><span class="line">        pp.mspancache.<span class="built_in">len</span>++</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有p</span></span><br><span class="line">    h.spanalloc.free(unsafe.Pointer(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向系统申请size大小内存（Reserved），最低64MB，创建arenaHint、heapArena（这是mheap的方法）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> sysAlloc(n <span class="type">uintptr</span>, hintList **arenaHint, register <span class="type">bool</span>) (v unsafe.Pointer, size <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按64MB的倍数向上取整</span></span><br><span class="line">    n = alignUp(n, heapArenaBytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般情况下都是</span></span><br><span class="line">    <span class="keyword">if</span> hintList == &amp;h.arenaHints &#123;</span><br><span class="line">        <span class="comment">// 忽略，这一步会失败，因为arena压根没初始化</span></span><br><span class="line">        v = h.arena.alloc(n, heapArenaBytes, &amp;gcController.heapReleased)</span><br><span class="line">        <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">            size = n</span><br><span class="line">            <span class="keyword">goto</span> mapped</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> *hintList != <span class="literal">nil</span> &#123;</span><br><span class="line">        hint := *hintList</span><br><span class="line">        <span class="comment">// 初始地址</span></span><br><span class="line">        p := hint.addr</span><br><span class="line">        <span class="comment">// 向下扩展</span></span><br><span class="line">        <span class="keyword">if</span> hint.down &#123;</span><br><span class="line">            p -= n</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p+n &lt; p &#123;</span><br><span class="line">            <span class="comment">// 溢出</span></span><br><span class="line">            v = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+n<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">            <span class="comment">// 地址越界</span></span><br><span class="line">            v = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 向系统申请n大小的内存（64MB的倍数，Reserved）</span></span><br><span class="line">            v = sysReserve(unsafe.Pointer(p), n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 申请成功</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="type">uintptr</span>(v) &#123;</span><br><span class="line">            <span class="comment">// 向上扩展</span></span><br><span class="line">            <span class="keyword">if</span> !hint.down &#123;</span><br><span class="line">                p += n</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新addr</span></span><br><span class="line">            hint.addr = p</span><br><span class="line">            size = n</span><br><span class="line">            <span class="comment">// 退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是申请失败</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 释放未使用的内存回收给操作系统</span></span><br><span class="line">            sysFreeOS(v, n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一个hint</span></span><br><span class="line">        *hintList = hint.next</span><br><span class="line">        <span class="comment">// hint回收放到free链表</span></span><br><span class="line">        h.arenaHintAlloc.free(unsafe.Pointer(hint))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的hint都失败了，申请64MB内存，但生成两个hint</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 默认false，忽略</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            throw(<span class="string">&quot;too many address space collisions for -race mode&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向系统申请n大小的内存（Reserved），按64MB对齐，返回对齐后的内存地址和大小，对齐时剩余的量全部释放回系统</span></span><br><span class="line">        v, size = sysReserveAligned(<span class="literal">nil</span>, n, heapArenaBytes)</span><br><span class="line">        <span class="comment">// 还是失败</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个新hint</span></span><br><span class="line">        hint := (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">        hint.addr, hint.down = <span class="type">uintptr</span>(v), <span class="literal">true</span></span><br><span class="line">        hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个新hint</span></span><br><span class="line">        hint = (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">        hint.addr = <span class="type">uintptr</span>(v) + size</span><br><span class="line">        hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> bad <span class="type">string</span></span><br><span class="line">        p := <span class="type">uintptr</span>(v)</span><br><span class="line">        <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">if</span> p+size &lt; p &#123;</span><br><span class="line">            bad = <span class="string">&quot;region exceeds uintptr range&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">            <span class="comment">// 地址越界</span></span><br><span class="line">            bad = <span class="string">&quot;base outside usable address space&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+size<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">            <span class="comment">// 地址越界</span></span><br><span class="line">            bad = <span class="string">&quot;end outside usable address space&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bad != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: memory allocated by OS [&quot;</span>, hex(p), <span class="string">&quot;, &quot;</span>, hex(p+size), <span class="string">&quot;) not in usable address space: &quot;</span>, bad, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;memory reservation exceeds address space limit&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 低26位不为0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(v)&amp;(heapArenaBytes<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;misrounded allocation in sysAlloc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存申请成功</span></span><br><span class="line"></span><br><span class="line">mapped:</span><br><span class="line">    <span class="comment">// 创建heapArena</span></span><br><span class="line">    <span class="keyword">for</span> ri := arenaIndex(<span class="type">uintptr</span>(v)); ri &lt;= arenaIndex(<span class="type">uintptr</span>(v)+size<span class="number">-1</span>); ri++ &#123;</span><br><span class="line">        <span class="comment">// l2数组，4M个heapArena指针</span></span><br><span class="line">        l2 := h.arenas[ri.l1()]</span><br><span class="line">        <span class="comment">// l2为nil</span></span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 直接向系统申请4M*8B=32MB内存（Ready）</span></span><br><span class="line">            l2 = (*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena)(sysAllocOS(unsafe.Sizeof(*l2)))</span><br><span class="line">            <span class="comment">// 申请失败</span></span><br><span class="line">            <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;out of memory allocating heap arena map&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> h.arenasHugePages &#123;</span><br><span class="line">                <span class="comment">// 按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line">                sysHugePage(unsafe.Pointer(l2), unsafe.Sizeof(*l2))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不使用huge page</span></span><br><span class="line">                sysNoHugePage(unsafe.Pointer(l2), unsafe.Sizeof(*l2))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// h.arenas[ri.l1()]=l2</span></span><br><span class="line">            atomic.StorepNoWB(unsafe.Pointer(&amp;h.arenas[ri.l1()]), unsafe.Pointer(l2))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已初始化</span></span><br><span class="line">        <span class="keyword">if</span> l2[ri.l2()] != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;arena already initialized&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> r *heapArena</span><br><span class="line">        <span class="comment">// 这一步会失败，因为压根没初始化</span></span><br><span class="line">        r = (*heapArena)(h.heapArenaAlloc.alloc(unsafe.Sizeof(*r), goarch.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">        <span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 调用sysAlloc向系统申请64KB大小的内存（Ready），按8倍数向上取整，统计</span></span><br><span class="line">            <span class="comment">// 超过64KB直接向系统申请，未超过64KB则一次性申请256KB内存后再分配</span></span><br><span class="line">            r = (*heapArena)(persistentalloc(unsafe.Sizeof(*r), goarch.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">            <span class="comment">// 失败，异常</span></span><br><span class="line">            <span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;out of memory allocating heap arena metadata&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要注册到allArenas</span></span><br><span class="line">        <span class="keyword">if</span> register &#123;</span><br><span class="line">            <span class="comment">// 容量不足</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(h.allArenas) == <span class="built_in">cap</span>(h.allArenas) &#123;</span><br><span class="line">                <span class="comment">// 总字节数（双倍容量）</span></span><br><span class="line">                size := <span class="number">2</span> * <span class="type">uintptr</span>(<span class="built_in">cap</span>(h.allArenas)) * goarch.PtrSize</span><br><span class="line">                <span class="comment">// 最小为一个页大小</span></span><br><span class="line">                <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">                    size = physPageSize</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 调用sysAlloc向系统申请64KB大小的内存（Ready），按align倍数向上取整，统计</span></span><br><span class="line">                <span class="comment">// 超过64KB直接向系统申请，未超过64KB则一次性申请256KB内存后再分配</span></span><br><span class="line">                newArray := (*notInHeap)(persistentalloc(size, goarch.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">                <span class="comment">// 申请失败</span></span><br><span class="line">                <span class="keyword">if</span> newArray == <span class="literal">nil</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;out of memory allocating allArenas&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 旧数组</span></span><br><span class="line">                oldSlice := h.allArenas</span><br><span class="line">                <span class="comment">// 替换为新数组</span></span><br><span class="line">                *(*notInHeapSlice)(unsafe.Pointer(&amp;h.allArenas)) = notInHeapSlice&#123;newArray, <span class="built_in">len</span>(h.allArenas), <span class="type">int</span>(size / goarch.PtrSize)&#125;</span><br><span class="line">                <span class="comment">// 复制旧数组内容</span></span><br><span class="line">                <span class="built_in">copy</span>(h.allArenas, oldSlice)</span><br><span class="line">                <span class="comment">// 不释放旧数组，可能存在并发读</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 放到数组末尾</span></span><br><span class="line">            h.allArenas = h.allArenas[:<span class="built_in">len</span>(h.allArenas)+<span class="number">1</span>]</span><br><span class="line">            h.allArenas[<span class="built_in">len</span>(h.allArenas)<span class="number">-1</span>] = ri</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// l2[ri.l2()] = r</span></span><br><span class="line">        atomic.StorepNoWB(unsafe.Pointer(&amp;l2[ri.l2()]), unsafe.Pointer(r))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ha.spans纪录heapArena内每个页对应的mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> setSpans(base, npage <span class="type">uintptr</span>, s *mspan) &#123;</span><br><span class="line">    <span class="comment">// = base/8192</span></span><br><span class="line">    p := base / pageSize</span><br><span class="line">    <span class="comment">// heapArena索引</span></span><br><span class="line">    ai := arenaIndex(base)</span><br><span class="line">    <span class="comment">// heapArena</span></span><br><span class="line">    ha := h.arenas[ai.l1()][ai.l2()]</span><br><span class="line">    <span class="comment">// 这几个页全局都要纪录mspan指针</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="type">uintptr</span>(<span class="number">0</span>); n &lt; npage; n++ &#123;</span><br><span class="line">        <span class="comment">// 索引=(p+n)%8192</span></span><br><span class="line">        i := (p + n) % pagesPerArena</span><br><span class="line">        <span class="comment">// 末尾/到了一个新的heapArena</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 重新读</span></span><br><span class="line">            ai = arenaIndex(base + n*pageSize)</span><br><span class="line">            ha = h.arenas[ai.l1()][ai.l2()]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// heapArena纪录mspan</span></span><br><span class="line">        ha.spans[i] = s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spanalloc分配的mspan纪录到allspans</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recordspan</span><span class="params">(vh unsafe.Pointer, p unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// mheap</span></span><br><span class="line">    h := (*mheap)(vh)</span><br><span class="line">    <span class="comment">// mspan</span></span><br><span class="line">    s := (*mspan)(p)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(h.allspans) &gt;= <span class="built_in">cap</span>(h.allspans) &#123;</span><br><span class="line">        <span class="comment">// 8KB</span></span><br><span class="line">        n := <span class="number">64</span> * <span class="number">1024</span> / goarch.PtrSize</span><br><span class="line">        <span class="comment">// 1.5倍</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="built_in">cap</span>(h.allspans)*<span class="number">3</span>/<span class="number">2</span> &#123;</span><br><span class="line">            n = <span class="built_in">cap</span>(h.allspans) * <span class="number">3</span> / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">new</span> []*mspan</span><br><span class="line">        sp := (*slice)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">        <span class="comment">// 直接向系统申请8*n内存（Ready）</span></span><br><span class="line">        sp.array = sysAlloc(<span class="type">uintptr</span>(n)*goarch.PtrSize, &amp;memstats.other_sys)</span><br><span class="line">        <span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">if</span> sp.array == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: cannot allocate memory&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 旧len</span></span><br><span class="line">        sp.<span class="built_in">len</span> = <span class="built_in">len</span>(h.allspans)</span><br><span class="line">        <span class="comment">// 新cap</span></span><br><span class="line">        sp.<span class="built_in">cap</span> = n</span><br><span class="line">        <span class="comment">// 复制</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(h.allspans) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">copy</span>(<span class="built_in">new</span>, h.allspans)</span><br><span class="line">        &#125;</span><br><span class="line">        oldAllspans := h.allspans</span><br><span class="line">        <span class="comment">// 替换旧allspans</span></span><br><span class="line">        *(*notInHeapSlice)(unsafe.Pointer(&amp;h.allspans)) = *(*notInHeapSlice)(unsafe.Pointer(&amp;<span class="built_in">new</span>))</span><br><span class="line">        <span class="comment">// 释放内存回系统</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(oldAllspans) != <span class="number">0</span> &#123;</span><br><span class="line">            sysFree(unsafe.Pointer(&amp;oldAllspans[<span class="number">0</span>]), <span class="type">uintptr</span>(<span class="built_in">cap</span>(oldAllspans))*unsafe.Sizeof(oldAllspans[<span class="number">0</span>]), &amp;memstats.other_sys)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放到末尾</span></span><br><span class="line">    h.allspans = h.allspans[:<span class="built_in">len</span>(h.allspans)+<span class="number">1</span>]</span><br><span class="line">    h.allspans[<span class="built_in">len</span>(h.allspans)<span class="number">-1</span>] = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heapArena分配地址空间，如果开始地址重用则needZero为true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocNeedsZero(base, npage <span class="type">uintptr</span>) (needZero <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> npage &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 转换为anera索引</span></span><br><span class="line">        ai := arenaIndex(base)</span><br><span class="line">        <span class="comment">// 找到heapArena</span></span><br><span class="line">        ha := h.arenas[ai.l1()][ai.l2()]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已清0的索引</span></span><br><span class="line">        zeroedBase := atomic.Loaduintptr(&amp;ha.zeroedBase)</span><br><span class="line">        <span class="comment">// 在heapArena内部的地址=base%64MB</span></span><br><span class="line">        arenaBase := base % heapArenaBytes</span><br><span class="line">        <span class="comment">// 重用，需要清0（zeroedBase后面的区域都为0）</span></span><br><span class="line">        <span class="keyword">if</span> arenaBase &lt; zeroedBase &#123;</span><br><span class="line">            needZero = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止地址=arenaBase+npage*8192</span></span><br><span class="line">        arenaLimit := arenaBase + npage*pageSize</span><br><span class="line">        <span class="comment">// 最大64MB</span></span><br><span class="line">        <span class="keyword">if</span> arenaLimit &gt; heapArenaBytes &#123;</span><br><span class="line">            arenaLimit = heapArenaBytes</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果limit超过zerobase，则替换掉zeroedBase</span></span><br><span class="line">        <span class="keyword">for</span> arenaLimit &gt; zeroedBase &#123;</span><br><span class="line">            <span class="comment">// ha.zeroedBase设置为arenaLimit</span></span><br><span class="line">            <span class="keyword">if</span> atomic.Casuintptr(&amp;ha.zeroedBase, zeroedBase, arenaLimit) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新读一遍</span></span><br><span class="line">            zeroedBase = atomic.Loaduintptr(&amp;ha.zeroedBase)</span><br><span class="line">            <span class="comment">// double-check</span></span><br><span class="line">            <span class="keyword">if</span> zeroedBase &lt;= arenaLimit &amp;&amp; zeroedBase &gt; arenaBase &#123;</span><br><span class="line">                <span class="comment">// 有交叉</span></span><br><span class="line">                throw(<span class="string">&quot;potentially overlapping in-use allocations detected&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base调整</span></span><br><span class="line">        base += arenaLimit - arenaBase</span><br><span class="line">        <span class="comment">// 这n个页可能分为两个heapArena，第一个计算完了，计算下一个</span></span><br><span class="line">        npage -= (arenaLimit - arenaBase) / pageSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/debug.freeOSMemory，手动管理</span></span><br><span class="line"><span class="comment">// 回收指定字节数量的内存，期间禁止malloc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> scavengeAll() &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 禁止malloc</span></span><br><span class="line">    gp.m.mallocing++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (p *pageAlloc) scavenge(nbytes uintptr, shouldStop func() bool, force bool) uintptr</span></span><br><span class="line">    <span class="comment">// 回收指定字节数量的内存（扫描时是从高地址向低地址进行搜索）</span></span><br><span class="line">    released := h.pages.scavenge(^<span class="type">uintptr</span>(<span class="number">0</span>), <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置，允许malloc</span></span><br><span class="line">    gp.m.mallocing--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debug.scavtrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">        printScavTrace(<span class="number">0</span>, released, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关内存如heapArena、chunk元素重新按huge_page的大小对齐（linux才有，不一定成功）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> enableMetadataHugePages() &#123;</span><br><span class="line">    <span class="comment">// chunk元素按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line">    h.pages.enableChunkHugePages()</span><br><span class="line"></span><br><span class="line">    lock(&amp;h.lock)</span><br><span class="line">    <span class="comment">// 已设置</span></span><br><span class="line">    <span class="keyword">if</span> h.arenasHugePages &#123;</span><br><span class="line">        unlock(&amp;h.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置</span></span><br><span class="line">    h.arenasHugePages = <span class="literal">true</span></span><br><span class="line">    unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历arenas</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> h.arenas &#123;</span><br><span class="line">        <span class="comment">// l2数组，4MB个数据</span></span><br><span class="line">        l2 := (*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena)(atomic.Loadp(unsafe.Pointer(&amp;h.arenas[i])))</span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line">        sysHugePage(unsafe.Pointer(l2), unsafe.Sizeof(*l2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mcentral-1"><a href="#mcentral-1" class="headerlink" title="mcentral"></a>mcentral</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mcentral初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> init(spc spanClass) &#123;</span><br><span class="line">    <span class="comment">// 纪录spanclass</span></span><br><span class="line">    c.spanclass = spc</span><br><span class="line">    <span class="comment">// 锁初始化</span></span><br><span class="line">    lockInit(&amp;c.partial[<span class="number">0</span>].spineLock, lockRankSpanSetSpine)</span><br><span class="line">    lockInit(&amp;c.partial[<span class="number">1</span>].spineLock, lockRankSpanSetSpine)</span><br><span class="line">    lockInit(&amp;c.full[<span class="number">0</span>].spineLock, lockRankSpanSetSpine)</span><br><span class="line">    lockInit(&amp;c.full[<span class="number">1</span>].spineLock, lockRankSpanSetSpine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从mcentral获取一个mspan，没有则从mheap获取，更新mspan状态并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> cacheSpan() *mspan &#123;</span><br><span class="line">    <span class="comment">// 计算mspan大小（字节）= 页数 * 8KB</span></span><br><span class="line">    spanBytes := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配内存时，如果sweeper还在清扫中且分配速度比清扫速度快，则协助sweeper清扫</span></span><br><span class="line">    deductSweepCredit(spanBytes, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环总预算</span></span><br><span class="line">    spanBudget := <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">    <span class="keyword">var</span> sl sweepLocker</span><br><span class="line"></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// =partial[sweepgen/2%2]</span></span><br><span class="line">    <span class="comment">// 尝试从已清扫有空对象的spanSet里获取一个mspan =&gt; partial[sweepgen/2%2]</span></span><br><span class="line">    <span class="keyword">if</span> s = c.partialSwept(sg).pop(); s != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 找到了</span></span><br><span class="line">        <span class="keyword">goto</span> havespan</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器加1，返回mheap_.sweepgen及sweepDrainedMask标记是否已设置</span></span><br><span class="line">    sl = sweep.active.begin()</span><br><span class="line">    <span class="comment">// sweeper数量不为0 =&gt; 还在清扫阶段</span></span><br><span class="line">    <span class="keyword">if</span> sl.valid &#123;</span><br><span class="line">        <span class="comment">// 100次</span></span><br><span class="line">        <span class="keyword">for</span> ; spanBudget &gt;= <span class="number">0</span>; spanBudget-- &#123;</span><br><span class="line">            <span class="comment">// =partial[1-sweepgen/2%2]</span></span><br><span class="line">            <span class="comment">// 尝试从未清扫有空对象的spanSet里获取一个mspan</span></span><br><span class="line">            s = c.partialUnswept(sg).pop()</span><br><span class="line">            <span class="comment">// partial为空</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// partial不为空</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试获得mspan的所有权</span></span><br><span class="line">            <span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">                <span class="comment">// 清扫一个mspan（保留）</span></span><br><span class="line">                s.sweep(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 计数器减1</span></span><br><span class="line">                sweep.active.end(sl)</span><br><span class="line">                <span class="comment">// 找到了</span></span><br><span class="line">                <span class="keyword">goto</span> havespan</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取mspan所有权失败，被其他工作线程清扫中，尝试别的mspan</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从partial获取mspan失败</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 100次</span></span><br><span class="line">        <span class="keyword">for</span> ; spanBudget &gt;= <span class="number">0</span>; spanBudget-- &#123;</span><br><span class="line">            <span class="comment">// 尝试从未清扫无空对象的spanSet里获取一个mspan</span></span><br><span class="line">            s = c.fullUnswept(sg).pop()</span><br><span class="line">            <span class="comment">// full为空</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试获得mspan的所有权</span></span><br><span class="line">            <span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">                <span class="comment">// 清扫一个mspan（保留）</span></span><br><span class="line">                s.sweep(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 获取freeindex</span></span><br><span class="line">                freeIndex := s.nextFreeIndex()</span><br><span class="line">                <span class="comment">// 有空余空间</span></span><br><span class="line">                <span class="keyword">if</span> freeIndex != s.nelems &#123;</span><br><span class="line">                    <span class="comment">// 更新freeindex</span></span><br><span class="line">                    s.freeindex = freeIndex</span><br><span class="line">                    <span class="comment">// 计数器减1</span></span><br><span class="line">                    sweep.active.end(sl)</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">goto</span> havespan</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 清扫后，mspan放到full[sweepgen/2%2]</span></span><br><span class="line">                c.fullSwept(sg).push(s.mspan)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从full获取mspan失败</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器减1</span></span><br><span class="line">        sweep.active.end(sl)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有从partial、full找到一个mspan</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (c *mcentral) grow() *mspan</span></span><br><span class="line">    <span class="comment">// 从mheap分配内存创建一个mspan（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">    s = c.grow()</span><br><span class="line">    <span class="comment">// 分配失败</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，mspan准备就绪</span></span><br><span class="line"></span><br><span class="line">havespan:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算剩余空间</span></span><br><span class="line">    n := <span class="type">int</span>(s.nelems) - <span class="type">int</span>(s.allocCount)</span><br><span class="line">    <span class="comment">// mspan没有剩余空间</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || s.freeindex == s.nelems || s.allocCount == s.nelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;span has no free objects&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按64倍数对齐</span></span><br><span class="line">    freeByteBase := s.freeindex &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 计算bitmap字节数</span></span><br><span class="line">    whichByte := freeByteBase / <span class="number">8</span></span><br><span class="line">    <span class="comment">// 从s.allocBits分配8个字节替换为新的s.allocCache</span></span><br><span class="line">    s.refillAllocCache(whichByte)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据freeindex调整，丢弃已用位</span></span><br><span class="line">    s.allocCache &gt;&gt;= s.freeindex % <span class="number">64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mspan已过期则清扫，未过期则根据是否mspan释放有剩余放到partial或full链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> uncacheSpan(s *mspan) &#123;</span><br><span class="line">    <span class="comment">// 异常，已分配对象数为0</span></span><br><span class="line">    <span class="keyword">if</span> s.allocCount == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;uncaching span but s.allocCount == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// 已过期 =&gt; mspan.sweepgen &lt; mheap_.sweepgen</span></span><br><span class="line">    stale := s.sweepgen == sg+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> stale &#123;</span><br><span class="line">        <span class="comment">// 已过期</span></span><br><span class="line">        <span class="comment">// 从 sg+1 改为 sg-1 =&gt; 正在被并发清扫</span></span><br><span class="line">        atomic.Store(&amp;s.sweepgen, sg<span class="number">-1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未过期</span></span><br><span class="line">        <span class="comment">// 改为sg =&gt; 已经被清扫完成，无需再清扫</span></span><br><span class="line">        atomic.Store(&amp;s.sweepgen, sg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已过期</span></span><br><span class="line">    <span class="keyword">if</span> stale &#123;</span><br><span class="line">        <span class="comment">// 封装mspan，获得所有权</span></span><br><span class="line">        ss := sweepLocked&#123;s&#125;</span><br><span class="line">        <span class="comment">// 清扫一个mspan（不保留，被heap回收）</span></span><br><span class="line">        ss.sweep(<span class="literal">false</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未过期</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mspan还有剩余</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">int</span>(s.nelems)-<span class="type">int</span>(s.allocCount) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 把mspan放入已清扫有空对象的spanSet =&gt; partial[sweepgen/2%2]</span></span><br><span class="line">            c.partialSwept(sg).push(s)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// mspan无剩余</span></span><br><span class="line">            <span class="comment">// full[sweepgen/2%2]</span></span><br><span class="line">            c.fullSwept(sg).push(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从mheap分配内存创建一个mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> grow() *mspan &#123;</span><br><span class="line">    <span class="comment">// 根据spanclass获取该mspan指定的页数</span></span><br><span class="line">    npages := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">    <span class="comment">// 根据spanclass获取该mspan的对象大小</span></span><br><span class="line">    size := <span class="type">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先清扫并释放至少n个页，然后获取mspan、分配n个页面、更新元信息</span></span><br><span class="line">    s := mheap_.alloc(npages, c.spanclass)</span><br><span class="line">    <span class="comment">// 分配失败</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算对象总数 = npages*8KB/size = (npages &lt;&lt; _PageShift) / size</span></span><br><span class="line">    n := s.divideByElemSize(npages &lt;&lt; _PageShift)</span><br><span class="line">    <span class="comment">// 终止地址</span></span><br><span class="line">    s.limit = s.base() + size*n</span><br><span class="line">    <span class="comment">// 初始化bitmap区域</span></span><br><span class="line">    s.initHeapBits()</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mcache-1"><a href="#mcache-1" class="headerlink" title="mcache"></a>mcache</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建mcache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocmcache</span><span class="params">()</span></span> *mcache &#123;</span><br><span class="line">    <span class="keyword">var</span> c *mcache</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// mheap加锁</span></span><br><span class="line">        lock(&amp;mheap_.lock)</span><br><span class="line">        <span class="comment">// 从cachealloc申请160字节作为mcache（内存不够用一次性申请16KB）</span></span><br><span class="line">        c = (*mcache)(mheap_.cachealloc.alloc())</span><br><span class="line">        <span class="comment">// sweepgen快照</span></span><br><span class="line">        c.flushGen.Store(mheap_.sweepgen)</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历136个mspan</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c.alloc &#123;</span><br><span class="line">        <span class="comment">// 全部指向emptymspan全局变量</span></span><br><span class="line">        c.alloc[i] = &amp;emptymspan</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存分配采样比例（memprof用）</span></span><br><span class="line">    <span class="comment">// 返回堆分析的下一个采样点（随机数：[0,MemProfileRate)）</span></span><br><span class="line">    c.nextSample = nextSample()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mcache重置放回free链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freemcache</span><span class="params">(c *mcache)</span></span> &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// tiny、alloc重置并释放mspan，更新内存统计信息</span></span><br><span class="line">        c.releaseAll()</span><br><span class="line">        <span class="comment">// 清空stackcache</span></span><br><span class="line">        stackcache_clear(c)</span><br><span class="line"></span><br><span class="line">        lock(&amp;mheap_.lock)</span><br><span class="line">        <span class="comment">// 放回free链表</span></span><br><span class="line">        mheap_.cachealloc.free(unsafe.Pointer(c))</span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tiny、alloc重置并释放mspan，更新内存统计信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> releaseAll() &#123;</span><br><span class="line">    <span class="comment">// 快照，需要被GC扫描的字节数</span></span><br><span class="line">    scanAlloc := <span class="type">int64</span>(c.scanAlloc)</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    c.scanAlloc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// 累计存活字节数</span></span><br><span class="line">    dHeapLive := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 所有mpsan清空</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c.alloc &#123;</span><br><span class="line">        <span class="comment">// mspan</span></span><br><span class="line">        s := c.alloc[i]</span><br><span class="line">        <span class="comment">// 不为空</span></span><br><span class="line">        <span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">            <span class="comment">// 已分配对象数</span></span><br><span class="line">            slotsUsed := <span class="type">int64</span>(s.allocCount) - <span class="type">int64</span>(s.allocCountBeforeCache)</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            s.allocCountBeforeCache = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">            <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">            stats := memstats.heapStats.acquire()</span><br><span class="line">            <span class="comment">// 累计到全局计数器</span></span><br><span class="line">            atomic.Xadd64(&amp;stats.smallAllocCount[spanClass(i).sizeclass()], slotsUsed)</span><br><span class="line">            <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">            memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 累计已分配字节数</span></span><br><span class="line">            gcController.totalAlloc.Add(slotsUsed * <span class="type">int64</span>(s.elemsize))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未过期</span></span><br><span class="line">            <span class="keyword">if</span> s.sweepgen != sg+<span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// -=剩余可用字节数</span></span><br><span class="line">                dHeapLive -= <span class="type">int64</span>(s.nelems-s.allocCount) * <span class="type">int64</span>(s.elemsize)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// mspan已过期则清扫，未过期则根据是否mspan释放有剩余放到partial或full链表</span></span><br><span class="line">            mheap_.central[i].mcentral.uncacheSpan(s)</span><br><span class="line">            <span class="comment">// 设置为空的mspan</span></span><br><span class="line">            c.alloc[i] = &amp;emptymspan</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tiny区域清扫</span></span><br><span class="line">    c.tiny = <span class="number">0</span></span><br><span class="line">    c.tinyoffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    <span class="comment">// 累计到全局tiny计数器</span></span><br><span class="line">    atomic.Xadd64(&amp;stats.tinyAllocCount, <span class="type">int64</span>(c.tinyAllocs))</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    c.tinyAllocs = <span class="number">0</span></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计heap存活字节数，如果GC未启动则累计heap扫描字节数，否则重新计算辅助GC的工作量转换参数</span></span><br><span class="line">    gcController.update(dHeapLive, scanAlloc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协助sweeper清扫，从mheap分配内存、更新索引/gc等信息，mspan放到fullSwept</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> allocLarge(size <span class="type">uintptr</span>, noscan <span class="type">bool</span>) *mspan &#123;</span><br><span class="line">    <span class="comment">// 溢出</span></span><br><span class="line">    <span class="keyword">if</span> size+_PageSize &lt; size &#123;</span><br><span class="line">        throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页数（右移13位，即除于8KB）</span></span><br><span class="line">    npages := size &gt;&gt; _PageShift</span><br><span class="line">    <span class="comment">// 除后还有余量，n+=1</span></span><br><span class="line">    <span class="keyword">if</span> size&amp;_PageMask != <span class="number">0</span> &#123;</span><br><span class="line">        npages++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存时，如果sweeper还在清扫中且分配速度比清扫速度快，则协助sweeper清扫</span></span><br><span class="line">    deductSweepCredit(npages*_PageSize, npages)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合sizeclass和noscan成spanclass</span></span><br><span class="line">    spc := makeSpanClass(<span class="number">0</span>, noscan)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (h *mheap) alloc(npages uintptr, spanclass spanClass) *mspan</span></span><br><span class="line">    <span class="comment">// 先清扫并释放至少n个页，然后获取mspan、分配n个页面、更新元信息</span></span><br><span class="line">    s := mheap_.alloc(npages, spc)</span><br><span class="line">    <span class="comment">// 分配失败</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    <span class="comment">// 累计分配字节数</span></span><br><span class="line">    atomic.Xadd64(&amp;stats.largeAlloc, <span class="type">int64</span>(npages*pageSize))</span><br><span class="line">    <span class="comment">// 累计分配对象数</span></span><br><span class="line">    atomic.Xadd64(&amp;stats.largeAllocCount, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计已分配字节数</span></span><br><span class="line">    gcController.totalAlloc.Add(<span class="type">int64</span>(npages * pageSize))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计heap存活字节数，如果GC未启动则累计heap扫描字节数，否则重新计算辅助GC的工作量转换参数</span></span><br><span class="line">    gcController.update(<span class="type">int64</span>(s.npages*pageSize), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把mspan放到full[sweepgen/2%2]</span></span><br><span class="line">    mheap_.central[spc].mcentral.fullSwept(mheap_.sweepgen).push(s)</span><br><span class="line">    <span class="comment">// 终止地址</span></span><br><span class="line">    s.limit = s.base() + size</span><br><span class="line">    <span class="comment">// 初始化bitmap区域（实际上为大对象时不需要执行）</span></span><br><span class="line">    s.initHeapBits()</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过64位的allocCache快速判断并分配对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span></span> gclinkptr &#123;</span><br><span class="line">    <span class="comment">// 64位二进制数的尾部的0的个数</span></span><br><span class="line">    theBit := sys.TrailingZeros64(s.allocCache)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocCache&gt;0（初始化时64位全为1）</span></span><br><span class="line">    <span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">        <span class="comment">// 下一个可用对象索引（二进制中为0的位置需要跳过）</span></span><br><span class="line">        result := s.freeindex + <span class="type">uint16</span>(theBit)</span><br><span class="line">        <span class="comment">// mspan空间没有用完</span></span><br><span class="line">        <span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">            <span class="comment">// 更新freeidx，指向下一个可分配对象</span></span><br><span class="line">            freeidx := result + <span class="number">1</span></span><br><span class="line">            <span class="comment">// 64个对象已经分配完（实际上是63个，这里的判断会跳过最后1个可用对象）</span></span><br><span class="line">            <span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 丢弃低x+1位（因为这几位已经被分配了）</span></span><br><span class="line">            s.allocCache &gt;&gt;= <span class="type">uint</span>(theBit + <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 更新freeidx</span></span><br><span class="line">            s.freeindex = freeidx</span><br><span class="line">            <span class="comment">// 计数器allocCount+=1</span></span><br><span class="line">            s.allocCount++</span><br><span class="line">            <span class="comment">// 返回对象的地址</span></span><br><span class="line">            <span class="keyword">return</span> gclinkptr(<span class="type">uintptr</span>(result)*s.elemsize + s.base())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allocCache=0，没有可分配对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mspan获取一个可用对象，如果mspan已满，则从mcentral获取新的mspan替换原mspan后重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> nextFree(spc spanClass) (v gclinkptr, s *mspan, checkGCTrigger <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据spanclass从mcache获取mspan</span></span><br><span class="line">    s = c.alloc[spc]</span><br><span class="line">    <span class="comment">// 是否需要触发GC清扫（分配了新的mspan）</span></span><br><span class="line">    checkGCTrigger = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 获取可用对象索引，如果allocCache用完则重新填充再计算索引（可能多次）</span></span><br><span class="line">    freeIndex := s.nextFreeIndex()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan已满</span></span><br><span class="line">    <span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> s.allocCount != s.nelems &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: s.allocCount=&quot;</span>, s.allocCount, <span class="string">&quot;s.nelems=&quot;</span>, s.nelems)</span><br><span class="line">            throw(<span class="string">&quot;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从mcentral分配新的mspan替换原mspan</span></span><br><span class="line">        c.refill(spc)</span><br><span class="line">        <span class="comment">// 需要触发GC清扫</span></span><br><span class="line">        checkGCTrigger = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 重新读一遍</span></span><br><span class="line">        s = c.alloc[spc]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取可用对象索引，如果allocCache用完则重新填充再计算索引（可能多次）</span></span><br><span class="line">        freeIndex = s.nextFreeIndex()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> freeIndex &gt;= s.nelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;freeIndex is not valid&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象地址</span></span><br><span class="line">    v = gclinkptr(<span class="type">uintptr</span>(freeIndex)*s.elemsize + s.base())</span><br><span class="line">    <span class="comment">// 计数器allocCount+=1</span></span><br><span class="line">    s.allocCount++</span><br><span class="line">    <span class="comment">// 异常，超过总量</span></span><br><span class="line">    <span class="keyword">if</span> s.allocCount &gt; s.nelems &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;s.allocCount=&quot;</span>, s.allocCount, <span class="string">&quot;s.nelems=&quot;</span>, s.nelems)</span><br><span class="line">        throw(<span class="string">&quot;s.allocCount &gt; s.nelems&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从mcentral分配新的mspan替换原mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> refill(spc spanClass) &#123;</span><br><span class="line">    <span class="comment">// 根据spanclass从mcache获取mspan</span></span><br><span class="line">    s := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常，还有可用对象</span></span><br><span class="line">    <span class="keyword">if</span> s.allocCount != s.nelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;refill of span with free space remaining&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">        <span class="comment">// 期望状态：已清扫并被mcache使用</span></span><br><span class="line">        <span class="keyword">if</span> s.sweepgen != mheap_.sweepgen+<span class="number">3</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad sweepgen in refill&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原mspan已过期则清扫，未过期则根据是否mspan释放有剩余放到partial或full链表</span></span><br><span class="line">        mheap_.central[spc].mcentral.uncacheSpan(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新heapStats</span></span><br><span class="line">        <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">        <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">        stats := memstats.heapStats.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已分配对象数</span></span><br><span class="line">        slotsUsed := <span class="type">int64</span>(s.allocCount) - <span class="type">int64</span>(s.allocCountBeforeCache)</span><br><span class="line">        <span class="comment">// 累计到小对象分配数</span></span><br><span class="line">        atomic.Xadd64(&amp;stats.smallAllocCount[spc.sizeclass()], slotsUsed)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是tiny分配</span></span><br><span class="line">        <span class="keyword">if</span> spc == tinySpanClass &#123;</span><br><span class="line">            <span class="comment">// 累计到微小对象数</span></span><br><span class="line">            atomic.Xadd64(&amp;stats.tinyAllocCount, <span class="type">int64</span>(c.tinyAllocs))</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            c.tinyAllocs = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">        memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已分配字节数</span></span><br><span class="line">        bytesAllocated := slotsUsed * <span class="type">int64</span>(s.elemsize)</span><br><span class="line">        <span class="comment">// 累计已分配字节数</span></span><br><span class="line">        gcController.totalAlloc.Add(bytesAllocated)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        s.allocCountBeforeCache = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新mspan</span></span><br><span class="line">    <span class="comment">// 从mcentral获取一个mspan</span></span><br><span class="line">    s = mheap_.central[spc].mcentral.cacheSpan()</span><br><span class="line">    <span class="comment">// 分配失败</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常，mspan空间用光了</span></span><br><span class="line">    <span class="keyword">if</span> s.allocCount == s.nelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;span has no free space&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已清扫并被mcache使用</span></span><br><span class="line">    s.sweepgen = mheap_.sweepgen + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到mcache前，纪录allocCount快照</span></span><br><span class="line">    s.allocCountBeforeCache = s.allocCount</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新heapLive</span></span><br><span class="line">    <span class="comment">// mspan已使用字节数</span></span><br><span class="line">    usedBytes := <span class="type">uintptr</span>(s.allocCount) * s.elemsize</span><br><span class="line">    <span class="comment">// 累计heap存活字节数，如果GC未启动则累计heap扫描字节数，否则重新计算辅助GC的工作量转换参数</span></span><br><span class="line">    gcController.update(<span class="type">int64</span>(s.npages*pageSize)-<span class="type">int64</span>(usedBytes), <span class="type">int64</span>(c.scanAlloc))</span><br><span class="line">    <span class="comment">// 清空scanAlloc</span></span><br><span class="line">    c.scanAlloc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    c.alloc[spc] = s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mspan-1"><a href="#mspan-1" class="headerlink" title="mspan"></a>mspan</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取可用对象索引，如果allocCache用完则重新填充再计算索引（可能多次）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span></span> nextFreeIndex() <span class="type">uint16</span> &#123;</span><br><span class="line">    <span class="comment">// 可用对象索引</span></span><br><span class="line">    sfreeindex := s.freeindex</span><br><span class="line">    <span class="comment">// mspan可存储对象数量</span></span><br><span class="line">    snelems := s.nelems</span><br><span class="line">    <span class="comment">// mspan已满</span></span><br><span class="line">    <span class="keyword">if</span> sfreeindex == snelems &#123;</span><br><span class="line">        <span class="keyword">return</span> sfreeindex</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">if</span> sfreeindex &gt; snelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;s.freeindex &gt; s.nelems&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64位bitmap</span></span><br><span class="line">    aCache := s.allocCache</span><br><span class="line">    <span class="comment">// allocCache尾部的0的个数（这个时候可能还剩余1个可分配对象）</span></span><br><span class="line">    bitIndex := sys.TrailingZeros64(aCache)</span><br><span class="line">    <span class="comment">// allocCache为0，全部已分配完</span></span><br><span class="line">    <span class="keyword">for</span> bitIndex == <span class="number">64</span> &#123;</span><br><span class="line">        <span class="comment">// 按64的倍数向上取整</span></span><br><span class="line">        sfreeindex = (sfreeindex + <span class="number">64</span>) &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// mspan已满</span></span><br><span class="line">        <span class="keyword">if</span> sfreeindex &gt;= snelems &#123;</span><br><span class="line">            s.freeindex = snelems</span><br><span class="line">            <span class="keyword">return</span> snelems</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mspan未满</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 字节数</span></span><br><span class="line">        whichByte := sfreeindex / <span class="number">8</span></span><br><span class="line">        <span class="comment">// 从s.allocBits分配8个字节替换为新的s.allocCache</span></span><br><span class="line">        s.refillAllocCache(whichByte)</span><br><span class="line">        <span class="comment">// 重新读一遍新的allocCache</span></span><br><span class="line">        aCache = s.allocCache</span><br><span class="line">        <span class="comment">// 顺利的话，这里的bitIndex应该为0</span></span><br><span class="line">        bitIndex = sys.TrailingZeros64(aCache)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还是用完了，继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可用对象的索引（二进制中为0的位置需要跳过）</span></span><br><span class="line">    result := sfreeindex + <span class="type">uint16</span>(bitIndex)</span><br><span class="line">    <span class="comment">// mspan已满</span></span><br><span class="line">    <span class="keyword">if</span> result &gt;= snelems &#123;</span><br><span class="line">        s.freeindex = snelems</span><br><span class="line">        <span class="keyword">return</span> snelems</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan未满</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 丢弃低x+1位（因为这几位已经被分配了）</span></span><br><span class="line">    s.allocCache &gt;&gt;= <span class="type">uint</span>(bitIndex + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 更新freeidx，指向下一个可分配对象</span></span><br><span class="line">    sfreeindex = result + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64个对象已经分配完（实际上是63个，这里的判断会跳过最后1个可用对象）</span></span><br><span class="line">    <span class="keyword">if</span> sfreeindex%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; sfreeindex != snelems &#123;</span><br><span class="line">        <span class="comment">// 字节数</span></span><br><span class="line">        whichByte := sfreeindex / <span class="number">8</span></span><br><span class="line">        <span class="comment">// 从s.allocBits分配8个字节替换为新的s.allocCache</span></span><br><span class="line">        s.refillAllocCache(whichByte)</span><br><span class="line">    &#125;</span><br><span class="line">    s.freeindex = sfreeindex</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回封装bitmap区域的slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> heapBits() []<span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 只有一个页</span></span><br><span class="line">    <span class="keyword">if</span> span.npages == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heapBitsSlice(span.base(), pageSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多个页</span></span><br><span class="line">    <span class="keyword">return</span> heapBitsSlice(span.base(), span.npages*pageSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装bitmap区域成slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapBitsSlice</span><span class="params">(spanBase, spanSize <span class="type">uintptr</span>)</span></span> []<span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// bitmap需要的字节数</span></span><br><span class="line">    bitmapSize := spanSize / goarch.PtrSize / <span class="number">8</span></span><br><span class="line">    <span class="comment">// 有多少个int</span></span><br><span class="line">    elems := <span class="type">int</span>(bitmapSize / goarch.PtrSize)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sl notInHeapSlice</span><br><span class="line">    <span class="comment">// 纪录bitmap区域的起始地址、所需int数</span></span><br><span class="line">    sl = notInHeapSlice&#123;(*notInHeap)(unsafe.Pointer(spanBase + spanSize - bitmapSize)), elems, elems&#125;</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="type">uintptr</span>)(unsafe.Pointer(&amp;sl))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化bitmap区域</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span></span> initHeapBits() &#123;</span><br><span class="line">    <span class="comment">// scan and sizeclass==1</span></span><br><span class="line">    <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &amp;&amp; !s.spanclass.noscan() &amp;&amp; s.spanclass.sizeclass() == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 返回封装bitmap区域的slice</span></span><br><span class="line">        b := s.heapBits()</span><br><span class="line">        <span class="comment">// 全部位设为1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">            b[i] = ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!s.spanclass.noscan() &amp;&amp; heapBitsInSpan(s.elemsize)) || s.isUserArenaChunk &#123;</span><br><span class="line">        <span class="comment">// (scan &amp;&amp; size&lt;=512B) or 手动管理内存</span></span><br><span class="line">        <span class="comment">// 返回封装bitmap区域的slice</span></span><br><span class="line">        b := s.heapBits()</span><br><span class="line">        <span class="comment">// 清0</span></span><br><span class="line">        clear(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap纪录指针位置，返回需要扫描的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSetTypeNoHeader</span><span class="params">(x, dataSize <span class="type">uintptr</span>, typ *_type, span *mspan)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// bitmap纪录指针位置，返回需要扫描的字节数</span></span><br><span class="line">    scanSize := span.writeHeapBitsSmall(x, dataSize, typ)</span><br><span class="line">    <span class="keyword">return</span> scanSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap纪录指针位置，返回需要扫描的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> writeHeapBitsSmall(x, dataSize <span class="type">uintptr</span>, typ *_type) (scanSize <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// type Example struct &#123;</span></span><br><span class="line">    <span class="comment">//     a *int8   // 8B (指针)</span></span><br><span class="line">    <span class="comment">//     b int16   // 2B (非指针，编译器会对齐b为8字节)</span></span><br><span class="line">    <span class="comment">//     c *int32  // 8B (指针)</span></span><br><span class="line">    <span class="comment">//     d float64 // 8B (非指针)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据类型的GCMask，如上为0b0101</span></span><br><span class="line">    src0 := readUintptr(getGCMask(typ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要扫描的总字节数，一般只会比Size_小一点</span></span><br><span class="line">    <span class="comment">// 从第一个字段开始到最后一个指针类型字段，如上为24字节</span></span><br><span class="line">    scanSize = typ.PtrBytes</span><br><span class="line"></span><br><span class="line">    src := src0</span><br><span class="line">    <span class="keyword">if</span> typ.Size_ == goarch.PtrSize &#123;</span><br><span class="line">        <span class="comment">// 8字节大小，单个指针</span></span><br><span class="line">        <span class="comment">// 掩码：(1&lt;&lt;x)-1 =&gt; 低位全为1</span></span><br><span class="line">        src = (<span class="number">1</span> &lt;&lt; (dataSize / goarch.PtrSize)) - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非8字节大小</span></span><br><span class="line">        <span class="comment">// 遍历所有对象</span></span><br><span class="line">        <span class="keyword">for</span> i := typ.Size_; i &lt; dataSize; i += typ.Size_ &#123;</span><br><span class="line">            <span class="comment">// 掩码累加（如上，2个Example，结果为 0b01010101)</span></span><br><span class="line">            src |= src0 &lt;&lt; (i / goarch.PtrSize)</span><br><span class="line">            <span class="comment">// 扩展指针扫描范围（如上，2个Example，结果为24+32=56）</span></span><br><span class="line">            scanSize += typ.Size_</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bitmap内存区域起始地址 =&gt; base+8192-128</span></span><br><span class="line">    dst := unsafe.Pointer(span.base() + pageSize - pageSize/goarch.PtrSize/<span class="number">8</span>)</span><br><span class="line">    <span class="comment">// 指针位置 =&gt; sizeclass范围是[0,32]，闭区间，分配的页数为1</span></span><br><span class="line">    o := (x - span.base()) / goarch.PtrSize</span><br><span class="line">    <span class="comment">// 第几个uint64</span></span><br><span class="line">    i := o / ptrBits</span><br><span class="line">    <span class="comment">// 具体bit位置</span></span><br><span class="line">    j := o % ptrBits</span><br><span class="line">    <span class="comment">// 指针数量</span></span><br><span class="line">    bits := span.elemsize / goarch.PtrSize</span><br><span class="line">    <span class="comment">// 超过64位，分成两个uint64处理</span></span><br><span class="line">    <span class="keyword">if</span> j+bits &gt; ptrBits &#123;</span><br><span class="line">        <span class="comment">// 第1个uint64要设置的位数量</span></span><br><span class="line">        bits0 := ptrBits - j</span><br><span class="line">        <span class="comment">// 第2个uint64要设置的位数量</span></span><br><span class="line">        bits1 := bits - bits0</span><br><span class="line">        dst0 := (*<span class="type">uintptr</span>)(add(dst, (i+<span class="number">0</span>)*goarch.PtrSize))</span><br><span class="line">        dst1 := (*<span class="type">uintptr</span>)(add(dst, (i+<span class="number">1</span>)*goarch.PtrSize))</span><br><span class="line">        <span class="comment">// src地bits0位纪录到dst0</span></span><br><span class="line">        *dst0 = (*dst0)&amp;(^<span class="type">uintptr</span>(<span class="number">0</span>)&gt;&gt;bits0) | (src &lt;&lt; j)</span><br><span class="line">        <span class="comment">// src高bits1位纪录到dst1</span></span><br><span class="line">        *dst1 = (*dst1)&amp;^((<span class="number">1</span>&lt;&lt;bits1)<span class="number">-1</span>) | (src &gt;&gt; bits0)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不超过64位，只写一个uint64</span></span><br><span class="line">        dst := (*<span class="type">uintptr</span>)(add(dst, i*goarch.PtrSize))</span><br><span class="line">        <span class="comment">// src纪录到dst</span></span><br><span class="line">        *dst = (*dst)&amp;^(((<span class="number">1</span>&lt;&lt;bits)<span class="number">-1</span>)&lt;&lt;j) | (src &lt;&lt; j)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pageCache"><a href="#pageCache" class="headerlink" title="pageCache"></a>pageCache</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从pcache找到连续n个页的起始地址，并判断这几个页是否被清理过（重用）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pageCache)</span></span> alloc(npages <span class="type">uintptr</span>) (<span class="type">uintptr</span>, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// bitmap为0，64个页全部用完</span></span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 64个页未用完</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配1个页</span></span><br><span class="line">    <span class="keyword">if</span> npages == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// cache尾部0个数，定位可用页的位置</span></span><br><span class="line">        i := <span class="type">uintptr</span>(sys.TrailingZeros64(c.cache))</span><br><span class="line">        <span class="comment">// 丢弃低i位后取最低位</span></span><br><span class="line">        scav := (c.scav &gt;&gt; i) &amp; <span class="number">1</span></span><br><span class="line">        <span class="comment">// 低i位清0，标记该页已使用</span></span><br><span class="line">        c.cache &amp;^= <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        <span class="comment">// 低i位清0，标记该页未清理</span></span><br><span class="line">        c.scav &amp;^= <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        <span class="comment">// 起始地址，被清理的页数</span></span><br><span class="line">        <span class="keyword">return</span> c.base + i*pageSize, <span class="type">uintptr</span>(scav) * pageSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找出连续n个1的起始位置（64个位），找不到返回64</span></span><br><span class="line">    <span class="keyword">return</span> c.allocN(npages)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出连续n个1的起始位置（64个位），找不到返回64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pageCache)</span></span> allocN(npages <span class="type">uintptr</span>) (<span class="type">uintptr</span>, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 找出连续n个1的起始位置（64个位），找不到返回64</span></span><br><span class="line">    i := findBitRange64(c.cache, <span class="type">uint</span>(npages))</span><br><span class="line">    <span class="comment">// 64代表没找到</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 低n个1向左移动i位</span></span><br><span class="line">    mask := ((<span class="type">uint64</span>(<span class="number">1</span>) &lt;&lt; npages) - <span class="number">1</span>) &lt;&lt; i</span><br><span class="line">    <span class="comment">// 计算1的数量</span></span><br><span class="line">    scav := sys.OnesCount64(c.scav &amp; mask)</span><br><span class="line">    <span class="comment">// 这连续n个位清0，标记已使用</span></span><br><span class="line">    c.cache &amp;^= mask</span><br><span class="line">    <span class="comment">// 这连续n个位清0，重置</span></span><br><span class="line">    c.scav &amp;^= mask</span><br><span class="line">    <span class="comment">// 起始地址，被清理的页数</span></span><br><span class="line">    <span class="keyword">return</span> c.base + <span class="type">uintptr</span>(i*pageSize), <span class="type">uintptr</span>(scav) * pageSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空pageCache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pageCache)</span></span> flush(p *pageAlloc) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为空不处理</span></span><br><span class="line">    <span class="keyword">if</span> c.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    ci := chunkIndex(c.base)</span><br><span class="line">    <span class="comment">// offset</span></span><br><span class="line">    pi := chunkPageIndex(c.base)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历bitmap，比对64个页</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint</span>(<span class="number">0</span>); i &lt; <span class="number">64</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 被使用</span></span><br><span class="line">        <span class="keyword">if</span> c.cache&amp;(<span class="number">1</span>&lt;&lt;i) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 该位置为0</span></span><br><span class="line">            p.chunkOf(ci).free1(pi + i)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">            p.scav.index.free(ci, pi+i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被标记为已清理</span></span><br><span class="line">        <span class="keyword">if</span> c.scav&amp;(<span class="number">1</span>&lt;&lt;i) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// pallocData.scavenged更新，指定位置为1</span></span><br><span class="line">            p.chunkOf(ci).scavenged.setRange(pi+i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果释放的页地址比searchAddr小</span></span><br><span class="line">    <span class="keyword">if</span> b := (offAddr&#123;c.base&#125;); b.lessThan(p.searchAddr) &#123;</span><br><span class="line">        p.searchAddr = b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">    p.update(c.base, pageCachePages, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">    *c = pageCache&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pageAlloc-1"><a href="#pageAlloc-1" class="headerlink" title="pageAlloc"></a>pageAlloc</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> init(mheapLock *mutex, sysStat *sysMemStat, test <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个元素!=21</span></span><br><span class="line">    <span class="keyword">if</span> levelLogPages[<span class="number">0</span>] &gt; logMaxPackedValue &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: root level max pages = &quot;</span>, <span class="number">1</span>&lt;&lt;levelLogPages[<span class="number">0</span>], <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: summary max pages = &quot;</span>, maxPackedValue, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;root level max pages doesn&#x27;t fit in summary&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    p.sysStat = sysStat</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p.inUse初始化（ranges切片容量为256B）</span></span><br><span class="line">    p.inUse.init(sysStat)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从系统申请内存（Reserved）初始化p.summary数组（16KB~64MB）</span></span><br><span class="line">    p.sysInit(test)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大地址 = (2^48-1) + 0xffff800000000000</span></span><br><span class="line">    p.searchAddr = maxSearchAddr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mheap.lock</span></span><br><span class="line">    p.mheapLock = mheapLock</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收索引初始化，但固定返回0</span></span><br><span class="line">    p.summaryMappedReady += p.scav.index.init(test, sysStat)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是测试调用</span></span><br><span class="line">    p.test = test</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pageAlloc通过summary扫描寻找足以容纳n个页的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> alloc(npages <span class="type">uintptr</span>) (addr <span class="type">uintptr</span>, scav <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索地址searchAddr越界</span></span><br><span class="line">    <span class="keyword">if</span> chunkIndex(p.searchAddr.addr()) &gt;= p.end &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =0xffff800000000000</span></span><br><span class="line">    searchAddr := minOffAddr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (512-(p.searchAddr%4194304/8192)) &gt;= n =&gt; 当前chunk的剩余量足够容纳n个页</span></span><br><span class="line">    <span class="keyword">if</span> pallocChunkPages-chunkPageIndex(p.searchAddr.addr()) &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从地址到索引，i = (p.searchAddr-0xffff800000000000)/4194304</span></span><br><span class="line">        i := chunkIndex(p.searchAddr.addr())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 第4层取第i个chunk的pallocSum的max段</span></span><br><span class="line">        <span class="comment">// 2. max &gt;= n =&gt; 当前chunk足够容纳n个页</span></span><br><span class="line">        <span class="keyword">if</span> max := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][i].max(); max &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">            <span class="comment">// func (b *pallocBits) find(npages uintptr, searchIdx uint) (uint, uint)</span></span><br><span class="line">            <span class="comment">// 在一个chunk中寻找可用的连续n个页的起始索引（最多512个页，从searchAddr开始搜索）</span></span><br><span class="line">            j, searchIdx := p.chunkOf(i).find(npages, chunkPageIndex(p.searchAddr.addr()))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 固定数值，表示寻找失败，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> j == ^<span class="type">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;runtime: max = &quot;</span>, max, <span class="string">&quot;, npages = &quot;</span>, npages, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;runtime: searchIdx = &quot;</span>, chunkPageIndex(p.searchAddr.addr()), <span class="string">&quot;, p.searchAddr = &quot;</span>, hex(p.searchAddr.addr()), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                throw(<span class="string">&quot;bad summary data&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连续n页内存的起始地址 = i*4194304+0xffff800000000000 + j*8192</span></span><br><span class="line">            addr = chunkBase(i) + <span class="type">uintptr</span>(j)*pageSize</span><br><span class="line">            <span class="comment">// chunk第一个可用页的位置 = i*4194304+0xffff800000000000 + searchIdx*8192</span></span><br><span class="line">            searchAddr = offAddr&#123;chunkBase(i) + <span class="type">uintptr</span>(searchIdx)*pageSize&#125;</span><br><span class="line">            <span class="keyword">goto</span> Found</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前组内存空间不足以容纳n个页（可能超过4MB）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (p *pageAlloc) find(npages uintptr) (uintptr, offAddr)</span></span><br><span class="line">    <span class="comment">// 从summary最顶层开始扫描，寻找足以容纳n个页的内存地址和不小于addr的最近可用地址</span></span><br><span class="line">    addr, searchAddr = p.find(npages)</span><br><span class="line">    <span class="comment">// 失败了</span></span><br><span class="line">    <span class="keyword">if</span> addr == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个页也失败了，可能达到了最大内存边界</span></span><br><span class="line">        <span class="keyword">if</span> npages == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 设置为最大内存边界 = (2^48-1) + 0xffff800000000000</span></span><br><span class="line">            p.searchAddr = maxSearchAddr()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Found:</span><br><span class="line">    <span class="comment">// 更新并重新统计chunks，最后更新summary（分配）</span></span><br><span class="line">    scav = p.allocRange(addr, npages)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最近可用地址比searchAddr大</span></span><br><span class="line">    <span class="keyword">if</span> p.searchAddr.lessThan(searchAddr) &#123;</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        p.searchAddr = searchAddr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr, scav</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新并重新统计chunks，最后更新summary（释放）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> free(base, npages <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果释放的页地址比searchAddr小</span></span><br><span class="line">    <span class="keyword">if</span> b := (offAddr&#123;base&#125;); b.lessThan(p.searchAddr) &#123;</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        p.searchAddr = b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个字节的地址</span></span><br><span class="line">    limit := base + npages*pageSize - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只释放一个页</span></span><br><span class="line">    <span class="keyword">if</span> npages == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// chunk索引</span></span><br><span class="line">        i := chunkIndex(base)</span><br><span class="line">        <span class="comment">// 位于512位bitmap的位置</span></span><br><span class="line">        pi := chunkPageIndex(base)</span><br><span class="line">        <span class="comment">// 该位置为0</span></span><br><span class="line">        p.chunkOf(i).free1(pi)</span><br><span class="line">        <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">        p.scav.index.free(i, pi, <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 释放多个页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 起始索引、终止索引</span></span><br><span class="line">        sc, ec := chunkIndex(base), chunkIndex(limit)</span><br><span class="line">        <span class="comment">// 位于512位bitmap的位置</span></span><br><span class="line">        si, ei := chunkPageIndex(base), chunkPageIndex(limit)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个chunk</span></span><br><span class="line">        <span class="keyword">if</span> sc == ec &#123;</span><br><span class="line">            <span class="comment">// 将这个范围的bitmap清0</span></span><br><span class="line">            p.chunkOf(sc).free(si, ei+<span class="number">1</span>-si)</span><br><span class="line">            <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">            p.scav.index.free(sc, si, ei+<span class="number">1</span>-si)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不同chunk</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个chunk</span></span><br><span class="line">            <span class="comment">// 将这个范围的bitmap清0</span></span><br><span class="line">            p.chunkOf(sc).free(si, pallocChunkPages-si)</span><br><span class="line">            <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">            p.scav.index.free(sc, si, pallocChunkPages-si)</span><br><span class="line">            <span class="comment">// 中间chunk</span></span><br><span class="line">            <span class="keyword">for</span> c := sc + <span class="number">1</span>; c &lt; ec; c++ &#123;</span><br><span class="line">                <span class="comment">// pallocBits清除所有位</span></span><br><span class="line">                p.chunkOf(c).freeAll()</span><br><span class="line">                <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">                p.scav.index.free(c, <span class="number">0</span>, pallocChunkPages)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后一个chunk</span></span><br><span class="line">            <span class="comment">// 将这个范围的bitmap清0</span></span><br><span class="line">            p.chunkOf(ec).free(<span class="number">0</span>, ei+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">            p.scav.index.free(ec, <span class="number">0</span>, ei+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">    p.update(base, npages, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配物理内存，更新并重新统计chunks信息，最后更新summary</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> grow(base, size <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base+size按4MB的倍数向上取整</span></span><br><span class="line">    limit := alignUp(base+size, pallocChunkBytes)</span><br><span class="line">    <span class="comment">// base按4MB的倍数向下取整</span></span><br><span class="line">    base = alignDown(base, pallocChunkBytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (p *pageAlloc) sysGrow(base, limit uintptr)</span></span><br><span class="line">    <span class="comment">// 在指定的虚拟地址范围内分配/映射物理内存，让该地址变为可用（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">    p.sysGrow(base, limit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (s *scavengeIndex) grow(base, limit uintptr, sysStat *sysMemStat) uintptr</span></span><br><span class="line">    <span class="comment">// 回收索引更新minHeapIdx，分配/映射物理内存使地址变为可用（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">    p.summaryMappedReady += p.scav.index.grow(base, limit, p.sysStat)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次走到这里</span></span><br><span class="line">    firstGrowth := p.start == <span class="number">0</span></span><br><span class="line">    <span class="comment">// 地址转索引</span></span><br><span class="line">    start, end := chunkIndex(base), chunkIndex(limit)</span><br><span class="line">    <span class="comment">// 如果是第一次走到这里，直接纪录，否则取最小值</span></span><br><span class="line">    <span class="comment">// p.start = min(p.start, start)</span></span><br><span class="line">    <span class="keyword">if</span> firstGrowth || start &lt; p.start &#123;</span><br><span class="line">        p.start = start</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// end会一直更新取最大值</span></span><br><span class="line">    <span class="keyword">if</span> end &gt; p.end &#123;</span><br><span class="line">        p.end = end</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base、limit索引纪录到inuse</span></span><br><span class="line">    p.inUse.add(makeAddrRange(base, limit))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果base比searchAddr小</span></span><br><span class="line">    <span class="keyword">if</span> b := (offAddr&#123;base&#125;); b.lessThan(p.searchAddr) &#123;</span><br><span class="line">        p.searchAddr = b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历这部份chunk</span></span><br><span class="line">    <span class="keyword">for</span> c := chunkIndex(base); c &lt; chunkIndex(limit); c++ &#123;</span><br><span class="line">        <span class="comment">// 如果chunk为nil，创建chunk</span></span><br><span class="line">        <span class="keyword">if</span> p.chunks[c.l1()] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 第二维有8192个指针</span></span><br><span class="line">            <span class="keyword">const</span> l2Size = unsafe.Sizeof(*p.chunks[<span class="number">0</span>])</span><br><span class="line">            <span class="comment">// 直接向系统申请8192*8B=64KB大小内存（Ready）</span></span><br><span class="line">            r := sysAlloc(l2Size, p.sysStat)</span><br><span class="line">            <span class="comment">// 申请失败</span></span><br><span class="line">            <span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;pageAlloc: out of memory&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非测试</span></span><br><span class="line">            <span class="keyword">if</span> !p.test &#123;</span><br><span class="line">                <span class="keyword">if</span> p.chunkHugePages &#123;</span><br><span class="line">                    <span class="comment">// 按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line">                    sysHugePage(r, l2Size)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不使用huge page</span></span><br><span class="line">                    sysNoHugePage(r, l2Size)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 纪录指针</span></span><br><span class="line">            *(*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;p.chunks[c.l1()])) = <span class="type">uintptr</span>(r)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pallocData.scavenged更新，指定位置为1（0,512）</span></span><br><span class="line">        p.chunkOf(c).scavenged.setRange(<span class="number">0</span>, pallocChunkPages)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">    p.update(base, size/pageSize, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新并重新统计chunks，最后更新summary（分配）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> allocRange(base, npages <span class="type">uintptr</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个字节的地址</span></span><br><span class="line">    limit := base + npages*pageSize - <span class="number">1</span></span><br><span class="line">    <span class="comment">// chunk索引</span></span><br><span class="line">    sc, ec := chunkIndex(base), chunkIndex(limit)</span><br><span class="line">    <span class="comment">// 位于512位bitmap的位置</span></span><br><span class="line">    si, ei := chunkPageIndex(base), chunkPageIndex(limit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存重用后，scavenged还设置为1，需要统计这部份内存</span></span><br><span class="line">    scav := <span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 同一个chunk</span></span><br><span class="line">    <span class="keyword">if</span> sc == ec &#123;</span><br><span class="line">        chunk := p.chunkOf(sc)</span><br><span class="line">        <span class="comment">// 计算区间内1的数量</span></span><br><span class="line">        scav += chunk.scavenged.popcntRange(si, ei+<span class="number">1</span>-si)</span><br><span class="line">        <span class="comment">// 区间内的pallocBits设置为1、scavenged重置为0</span></span><br><span class="line">        chunk.allocRange(si, ei+<span class="number">1</span>-si)</span><br><span class="line">        <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">        p.scav.index.alloc(sc, ei+<span class="number">1</span>-si)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 多个chunk</span></span><br><span class="line">        <span class="comment">// 第一个chunk</span></span><br><span class="line">        chunk := p.chunkOf(sc)</span><br><span class="line">        <span class="comment">// 计算区间内1的数量</span></span><br><span class="line">        scav += chunk.scavenged.popcntRange(si, pallocChunkPages-si)</span><br><span class="line">        <span class="comment">// 区间内的pallocBits设置为1、scavenged重置为0</span></span><br><span class="line">        chunk.allocRange(si, pallocChunkPages-si)</span><br><span class="line">        <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">        p.scav.index.alloc(sc, pallocChunkPages-si)</span><br><span class="line">        <span class="comment">// 中间chunk</span></span><br><span class="line">        <span class="keyword">for</span> c := sc + <span class="number">1</span>; c &lt; ec; c++ &#123;</span><br><span class="line">            chunk := p.chunkOf(c)</span><br><span class="line">            <span class="comment">// 计算区间内1的数量</span></span><br><span class="line">            scav += chunk.scavenged.popcntRange(<span class="number">0</span>, pallocChunkPages)</span><br><span class="line">            <span class="comment">// 64位全设置为1</span></span><br><span class="line">            chunk.allocAll()</span><br><span class="line">            <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">            p.scav.index.alloc(c, pallocChunkPages)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个chunk</span></span><br><span class="line">        chunk = p.chunkOf(ec)</span><br><span class="line">        <span class="comment">// 计算区间内1的数量</span></span><br><span class="line">        scav += chunk.scavenged.popcntRange(<span class="number">0</span>, ei+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 区间内的pallocBits设置为1、scavenged重置为0</span></span><br><span class="line">        chunk.allocRange(<span class="number">0</span>, ei+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">        p.scav.index.alloc(ec, ei+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">    p.update(base, npages, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uintptr</span>(scav) * pageSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> update(base, npages <span class="type">uintptr</span>, contig, alloc <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向最后一个字节</span></span><br><span class="line">    limit := base + npages*pageSize - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 起始idx、终止idx（指针转idx）</span></span><br><span class="line">    sc, ec := chunkIndex(base), chunkIndex(limit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计chunks信息并更新到summary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一个chunk，4MB内存内</span></span><br><span class="line">    <span class="keyword">if</span> sc == ec &#123;</span><br><span class="line">        <span class="comment">// x = p.summary[4][sc] =&gt; pallocSum</span></span><br><span class="line">        x := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][sc]</span><br><span class="line">        <span class="comment">// 统计前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line">        <span class="comment">// chunk =&gt; p.chunks[sc&gt;&gt;13][sc&amp;(2^13-1)] =&gt; pallocData</span></span><br><span class="line">        y := p.chunkOf(sc).summarize()</span><br><span class="line">        <span class="comment">// 不需要更新</span></span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以实际统计为准</span></span><br><span class="line">        p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][sc] = y</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> contig &#123;</span><br><span class="line">        <span class="comment">// 不同一个chunk、连续</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// = p.summary[4]</span></span><br><span class="line">        summary := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新第一个chunk：统计前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line">        <span class="comment">// chunk =&gt; p.chunks[sc&gt;&gt;13][sc&amp;(2^13-1)] =&gt; pallocData</span></span><br><span class="line">        summary[sc] = p.chunkOf(sc).summarize()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中间chunk，不包含sc和ec</span></span><br><span class="line">        whole := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][sc+<span class="number">1</span> : ec]</span><br><span class="line">        <span class="keyword">if</span> alloc &#123;</span><br><span class="line">            <span class="comment">// 分配内存，整个chunk都被使用</span></span><br><span class="line">            <span class="comment">// 清0</span></span><br><span class="line">            clear(whole)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 刚从系统申请的内存或被GC清扫后的内存，重置为默认值</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">range</span> whole &#123;</span><br><span class="line">                <span class="comment">// = |0|512|512|512|</span></span><br><span class="line">                whole[i] = freeChunkSum</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最后一个chunk：统计前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line">        summary[ec] = p.chunkOf(ec).summarize()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不同一个chunk、不连续</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// = p.summary[4]</span></span><br><span class="line">        summary := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">// 遍历所有chunk</span></span><br><span class="line">        <span class="keyword">for</span> c := sc; c &lt;= ec; c++ &#123;</span><br><span class="line">            <span class="comment">// 更新summary：统计前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line">            summary[c] = p.chunkOf(c).summarize()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里已经算出每个chunk的sum信息，也就是summary最后一层已经计算完，需要往前更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示第l层需要更新</span></span><br><span class="line">    changed := <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 从后向前遍历剩下的summary</span></span><br><span class="line">    <span class="comment">// p.summary[3] ... p.summary[0]</span></span><br><span class="line">    <span class="keyword">for</span> l := <span class="built_in">len</span>(p.summary) - <span class="number">2</span>; l &gt;= <span class="number">0</span> &amp;&amp; changed; l-- &#123;</span><br><span class="line">        <span class="comment">// 合并后的sum没有变化，则提前退出循环</span></span><br><span class="line">        changed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般是3个bit，也就是除以8</span></span><br><span class="line">        logEntriesPerBlock := levelBits[l+<span class="number">1</span>]</span><br><span class="line">        <span class="comment">// 一个sum代表的页数量，第4层一个sum代表512页，每上一层数量*=8，这里取对数值</span></span><br><span class="line">        logMaxPages := levelLogPages[l+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// |16|14| 3| 3| 3| 3|22|</span></span><br><span class="line">        <span class="comment">// |  |l0|l1|l2|l3|l4|  |</span></span><br><span class="line">        <span class="comment">// 地址丢弃低22位，然后每上一层，丢弃3位</span></span><br><span class="line">        lo, hi := addrsToSummaryRange(l, base, limit+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一层的每8个sum汇总成一个sum</span></span><br><span class="line">        <span class="keyword">for</span> i := lo; i &lt; hi; i++ &#123;</span><br><span class="line">            <span class="comment">// 第i个block，每个block有logEntriesPerBlock个entry</span></span><br><span class="line">            children := p.summary[l+<span class="number">1</span>][i&lt;&lt;logEntriesPerBlock : (i+<span class="number">1</span>)&lt;&lt;logEntriesPerBlock]</span><br><span class="line">            <span class="comment">// 每8个sum汇总成一个sum</span></span><br><span class="line">            sum := mergeSummaries(children, logMaxPages)</span><br><span class="line">            old := p.summary[l][i]</span><br><span class="line">            <span class="comment">// 相同则不更新</span></span><br><span class="line">            <span class="keyword">if</span> old != sum &#123;</span><br><span class="line">                <span class="comment">// 不同，还要继续往上一层合并</span></span><br><span class="line">                changed = <span class="literal">true</span></span><br><span class="line">                p.summary[l][i] = sum</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每8个sum汇总成一个sum</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSummaries</span><span class="params">(sums []pallocSum, logMaxPagesPerSum <span class="type">uint</span>)</span></span> pallocSum &#123;</span><br><span class="line">    <span class="comment">// 解析第1个sum</span></span><br><span class="line">    start, most, end := sums[<span class="number">0</span>].unpack()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历剩下的sum</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(sums); i++ &#123;</span><br><span class="line">        <span class="comment">// 解析第i个sum</span></span><br><span class="line">        si, mi, ei := sums[i].unpack()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前导连续空闲页数</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="type">uint</span>(i)&lt;&lt;logMaxPagesPerSum &#123;</span><br><span class="line">            <span class="comment">// 如果start是512（更高层*8），代表前一个chunk没有被使用</span></span><br><span class="line">            start += si</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大连续空闲页数</span></span><br><span class="line">        most = max(most, end+si, mi)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 末尾连续空闲页数</span></span><br><span class="line">        <span class="keyword">if</span> ei == <span class="number">1</span>&lt;&lt;logMaxPagesPerSum &#123;</span><br><span class="line">            <span class="comment">// 如果end是512（更高层*8），代表当前chunk没有被使用</span></span><br><span class="line">            end += <span class="number">1</span> &lt;&lt; logMaxPagesPerSum</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = ei</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> packPallocSum(start, most, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出不小于addr的最近可用地址（一般情况下返回传入的参数）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> findMappedAddr(addr offAddr) offAddr &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为anera索引</span></span><br><span class="line">    ai := arenaIndex(addr.addr())</span><br><span class="line">    <span class="comment">// 测试中 or heapArena尚未分配或被释放</span></span><br><span class="line">    <span class="keyword">if</span> p.test || mheap_.arenas[ai.l1()] == <span class="literal">nil</span> || mheap_.arenas[ai.l1()][ai.l2()] == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 在inUse.ranges内找到不小于addr的地址</span></span><br><span class="line">        vAddr, ok := p.inUse.findAddrGreaterEqual(addr.addr())</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="comment">// 找到了</span></span><br><span class="line">            <span class="keyword">return</span> offAddr&#123;vAddr&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没找到</span></span><br><span class="line">            <span class="keyword">return</span> maxOffAddr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般情况下返回传入的参数</span></span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从summary最顶层开始扫描，寻找足以容纳n个页的内存地址和不小于addr的最近可用地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> find(npages <span class="type">uintptr</span>) (<span class="type">uintptr</span>, offAddr) &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以认为是基地址的索引</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// base和bound基本覆盖了整个48位地址空间</span></span><br><span class="line">    firstFree := <span class="keyword">struct</span> &#123;</span><br><span class="line">        base, bound offAddr</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        base:  minOffAddr, <span class="comment">// 基地址 =&gt; 0xffff800000000000</span></span><br><span class="line">        bound: maxOffAddr, <span class="comment">// 终止地址 =&gt; (2^48-1) + 0xffff800000000000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该函数用于检查地址是否合法，合法则更新到firstFree变量，不合法则抛出异常</span></span><br><span class="line">    foundFree := <span class="function"><span class="keyword">func</span><span class="params">(addr offAddr, size <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 边界检测</span></span><br><span class="line">        <span class="keyword">if</span> firstFree.base.lessEqual(addr) &amp;&amp; addr.add(size<span class="number">-1</span>).lessEqual(firstFree.bound) &#123;</span><br><span class="line">            <span class="comment">// 合法，纪录</span></span><br><span class="line">            firstFree.base = addr</span><br><span class="line">            firstFree.bound = addr.add(size - <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> !(addr.add(size<span class="number">-1</span>).lessThan(firstFree.base) || firstFree.bound.lessThan(addr)) &#123;</span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: addr = &quot;</span>, hex(addr.addr()), <span class="string">&quot;, size = &quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: base = &quot;</span>, hex(firstFree.base.addr()), <span class="string">&quot;, bound = &quot;</span>, hex(firstFree.bound.addr()), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;range partially overlaps&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个参数debug用</span></span><br><span class="line">    <span class="comment">// 上一个sum-初始值表示全部已使用</span></span><br><span class="line">    lastSum := packPallocSum(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 上一个sum索引</span></span><br><span class="line">    lastSumIdx := <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">nextLevel:</span><br><span class="line">    <span class="comment">// 遍历summary，从最顶层到最底层</span></span><br><span class="line">    <span class="keyword">for</span> l := <span class="number">0</span>; l &lt; <span class="built_in">len</span>(p.summary); l++ &#123;</span><br><span class="line">        <span class="comment">// 每层需要扫描的的entry数量</span></span><br><span class="line">        <span class="comment">// 第0层全部16K个块都要扫描，每下一层只需要扫描8个块</span></span><br><span class="line">        entriesPerBlock := <span class="number">1</span> &lt;&lt; levelBits[l]</span><br><span class="line">        <span class="comment">// 一个sum代表的页数量，第4层一个sum代表512页（4MB），每上一层数量*=8，第0层代表2M个页（4GB）</span></span><br><span class="line">        logMaxPages := levelLogPages[l]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 地址索引，第0层乘于16K，但因为初始为0，所以结果还是0，而后每下一层，乘于8</span></span><br><span class="line">        <span class="comment">// i在后面还会累加偏移量j</span></span><br><span class="line">        i &lt;&lt;= levelBits[l]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从i位置开始扫描</span></span><br><span class="line">        <span class="comment">// 第0层全部16K个块都要扫描，每下一层只需要扫描8个块</span></span><br><span class="line">        entries := p.summary[l][i : i+entriesPerBlock]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偏移量</span></span><br><span class="line">        j0 := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 先将searchAddr转换为相对地址，再除于每层entry数量，获得数组索引</span></span><br><span class="line">        <span class="comment">// 2. searchIdx丢弃低位 =&gt; 块的起始地址，判断searchIdx是不是在i指向的块内</span></span><br><span class="line">        <span class="keyword">if</span> searchIdx := offAddrToLevelIndex(l, p.searchAddr); searchIdx&amp;^(entriesPerBlock<span class="number">-1</span>) == i &#123;</span><br><span class="line">            <span class="comment">// 取searchIdx低位 =&gt; 第i块内的偏移量</span></span><br><span class="line">            j0 = searchIdx &amp; (entriesPerBlock - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可用页的起始位置，累计总页数</span></span><br><span class="line">        <span class="keyword">var</span> base, size <span class="type">uint</span></span><br><span class="line">        <span class="comment">// 从0或j0的位置开始扫描整个entries数组</span></span><br><span class="line">        <span class="keyword">for</span> j := j0; j &lt; <span class="built_in">len</span>(entries); j++ &#123;</span><br><span class="line">            <span class="comment">// sum</span></span><br><span class="line">            sum := entries[j]</span><br><span class="line">            <span class="comment">// 全部已使用</span></span><br><span class="line">            <span class="keyword">if</span> sum == <span class="number">0</span> &#123;</span><br><span class="line">                size = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 部份已使用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 索引转绝对地址</span></span><br><span class="line">            <span class="comment">// 2. 检查地址是否合法，合法则更新到firstFree，不合法则抛出异常</span></span><br><span class="line">            foundFree(levelIndexToOffAddr(l, i+j), (<span class="type">uintptr</span>(<span class="number">1</span>)&lt;&lt;logMaxPages)*pageSize)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// start部份-前导连续空闲页数</span></span><br><span class="line">            s := sum.start()</span><br><span class="line">            <span class="comment">// 空间足够</span></span><br><span class="line">            <span class="keyword">if</span> size+s &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">                <span class="comment">// 调整起始位置</span></span><br><span class="line">                <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">                    base = <span class="type">uint</span>(j) &lt;&lt; logMaxPages</span><br><span class="line">                &#125;</span><br><span class="line">                size += s</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 空间不足</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// max部份-最大连续空闲页数，可以容纳n个页</span></span><br><span class="line">            <span class="keyword">if</span> sum.max() &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">                <span class="comment">// 进入块内部扫描</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 偏移量</span></span><br><span class="line">                i += j</span><br><span class="line">                <span class="comment">// 下面两个参数debug用</span></span><br><span class="line">                <span class="comment">// 上一层的偏移量</span></span><br><span class="line">                lastSumIdx = i</span><br><span class="line">                <span class="comment">// 上一层的sum</span></span><br><span class="line">                lastSum = sum</span><br><span class="line">                <span class="comment">// 向下一层寻找</span></span><br><span class="line">                <span class="keyword">continue</span> nextLevel</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果最大连续空闲页数不足以容纳n个页</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未开始累计 or 当前块部份使用</span></span><br><span class="line">            <span class="keyword">if</span> size == <span class="number">0</span> || s &lt; <span class="number">1</span>&lt;&lt;logMaxPages &#123;</span><br><span class="line">                <span class="comment">// end-末尾连续空闲页数</span></span><br><span class="line">                size = sum.end()</span><br><span class="line">                <span class="comment">// 更新base到正确的起始位置</span></span><br><span class="line">                base = <span class="type">uint</span>(j+<span class="number">1</span>)&lt;&lt;logMaxPages - size</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 已开始累计 and 当前块全部可用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接累加</span></span><br><span class="line">            size += <span class="number">1</span> &lt;&lt; logMaxPages</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，已经找到足够的n个页，或当前层的x个块已经扫描完了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 足以容纳n个页</span></span><br><span class="line">        <span class="keyword">if</span> size &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">            <span class="comment">// 1. 索引转绝对地址</span></span><br><span class="line">            <span class="comment">// 2. 检查地址是否合法，合法则更新到firstFree，不合法则抛出异常</span></span><br><span class="line">            addr := levelIndexToOffAddr(l, i).add(<span class="type">uintptr</span>(base) * pageSize).addr()</span><br><span class="line">            <span class="comment">// addr, 找出不小于addr的最近可用地址（一般情况下返回传入的参数）</span></span><br><span class="line">            <span class="keyword">return</span> addr, p.findMappedAddr(firstFree.base)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不足以容纳n个页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第0层，说明整个地址空间都扫描过了，内存不够用</span></span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, maxSearchAddr()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他层不应该出现这种情况，异常，打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: summary[&quot;</span>, l<span class="number">-1</span>, <span class="string">&quot;][&quot;</span>, lastSumIdx, <span class="string">&quot;] = &quot;</span>, lastSum.start(), <span class="string">&quot;, &quot;</span>, lastSum.max(), <span class="string">&quot;, &quot;</span>, lastSum.end(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: level = &quot;</span>, l, <span class="string">&quot;, npages = &quot;</span>, npages, <span class="string">&quot;, j0 = &quot;</span>, j0, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: p.searchAddr = &quot;</span>, hex(p.searchAddr.addr()), <span class="string">&quot;, i = &quot;</span>, i, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: levelShift[level] = &quot;</span>, levelShift[l], <span class="string">&quot;, levelBits[level] = &quot;</span>, levelBits[l], <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(entries); j++ &#123;</span><br><span class="line">            sum := entries[j]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: summary[&quot;</span>, l, <span class="string">&quot;][&quot;</span>, i+j, <span class="string">&quot;] = (&quot;</span>, sum.start(), <span class="string">&quot;, &quot;</span>, sum.max(), <span class="string">&quot;, &quot;</span>, sum.end(), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        throw(<span class="string">&quot;bad summary data&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兜底代码？按道理怎么也不会走到这里才对！！！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// chunk索引</span></span><br><span class="line">    ci := chunkIdx(i)</span><br><span class="line">    <span class="comment">// 在一个chunk中寻找可用的连续n个页的起始索引（最多512个页，从基地址开始搜索）</span></span><br><span class="line">    j, searchIdx := p.chunkOf(ci).find(npages, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定数值，表示寻找失败，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> j == ^<span class="type">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        sum := p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: summary[&quot;</span>, <span class="built_in">len</span>(p.summary)<span class="number">-1</span>, <span class="string">&quot;][&quot;</span>, i, <span class="string">&quot;] = (&quot;</span>, sum.start(), <span class="string">&quot;, &quot;</span>, sum.max(), <span class="string">&quot;, &quot;</span>, sum.end(), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: npages = &quot;</span>, npages, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad summary data&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引转地址</span></span><br><span class="line">    addr := chunkBase(ci) + <span class="type">uintptr</span>(j)*pageSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引转地址</span></span><br><span class="line">    searchAddr := chunkBase(ci) + <span class="type">uintptr</span>(searchIdx)*pageSize</span><br><span class="line">    <span class="comment">// 检查地址是否合法，合法则更新到firstFree，不合法则抛出异常</span></span><br><span class="line">    foundFree(offAddr&#123;searchAddr&#125;, chunkBase(ci+<span class="number">1</span>)-searchAddr)</span><br><span class="line">    <span class="comment">// addr, 找出不小于addr的最近可用地址（一般情况下返回传入的参数）</span></span><br><span class="line">    <span class="keyword">return</span> addr, p.findMappedAddr(firstFree.base)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过summary查找，找到一个最少包含一个可用页的块（共64个页信息）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> allocToCache() pageCache &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址转索引，越界</span></span><br><span class="line">    <span class="keyword">if</span> chunkIndex(p.searchAddr.addr()) &gt;= p.end &#123;</span><br><span class="line">        <span class="keyword">return</span> pageCache&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未越界</span></span><br><span class="line">    c := pageCache&#123;&#125;</span><br><span class="line">    <span class="comment">// 起始索引</span></span><br><span class="line">    ci := chunkIndex(p.searchAddr.addr())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> chunk *pallocData</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][ci] != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 最底层的chunk的pallocSum有剩余的页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// chunk</span></span><br><span class="line">        chunk = p.chunkOf(ci)</span><br><span class="line">        <span class="comment">// func (b *pallocBits) find(npages uintptr, searchIdx uint) (uint, uint)</span></span><br><span class="line">        <span class="comment">// 在一个chunk中寻找可用的连续n个页的起始索引（最多512个页，从searchAddr开始搜索）</span></span><br><span class="line">        j, _ := chunk.find(<span class="number">1</span>, chunkPageIndex(p.searchAddr.addr()))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 固定数值，表示寻找失败，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> j == ^<span class="type">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad summary data&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了</span></span><br><span class="line">        c = pageCache&#123;</span><br><span class="line">            <span class="comment">// 对象地址 = 基地址 + [0,512)*8192</span></span><br><span class="line">            base:  chunkBase(ci) + alignDown(<span class="type">uintptr</span>(j), <span class="number">64</span>)*pageSize,</span><br><span class="line">            <span class="comment">// 64位取反，这里1表示页是可用的</span></span><br><span class="line">            cache: ^chunk.pages64(j),</span><br><span class="line">            <span class="comment">// 直接使用64位</span></span><br><span class="line">            scav:  chunk.scavenged.block64(j),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 最底层的chunk的pallocSum没有剩余的页 =&gt; 为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// func (p *pageAlloc) find(npages uintptr) (uintptr, offAddr)</span></span><br><span class="line">        <span class="comment">// 从summary最顶层开始扫描，寻找足以容纳1个页的内存地址和最近可用地址</span></span><br><span class="line">        addr, _ := p.find(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 失败了</span></span><br><span class="line">        <span class="keyword">if</span> addr == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 内存不足</span></span><br><span class="line">            p.searchAddr = maxSearchAddr()</span><br><span class="line">            <span class="keyword">return</span> pageCache&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        ci = chunkIndex(addr)</span><br><span class="line">        chunk = p.chunkOf(ci)</span><br><span class="line">        c = pageCache&#123;</span><br><span class="line">            <span class="comment">// 对象地址</span></span><br><span class="line">            base:  alignDown(addr, <span class="number">64</span>*pageSize),</span><br><span class="line">            <span class="comment">// 64位取反，这里1表示页是可用的</span></span><br><span class="line">            cache: ^chunk.pages64(chunkPageIndex(addr)),</span><br><span class="line">            <span class="comment">// 直接使用64位</span></span><br><span class="line">            scav:  chunk.scavenged.block64(chunkPageIndex(addr)),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这部份数据被缓存，原来的chunk需要更新为已使用</span></span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    cpi := chunkPageIndex(c.base)</span><br><span class="line">    <span class="comment">// 用cache的bitmap合并原chunk数据，这样原64位全为1</span></span><br><span class="line">    chunk.allocPages64(cpi, c.cache)</span><br><span class="line">    <span class="comment">// 如果一个页被使用，后被回收，scavenged的状态需要重置为0</span></span><br><span class="line">    chunk.scavenged.clearBlock64(cpi, c.cache&amp;c.scav)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">    p.update(c.base, pageCachePages, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (s *scavengeIndex) alloc(ci chunkIdx, npages uint)</span></span><br><span class="line">    <span class="comment">// 回收索引更新指定chunk元信息，如inUse、gen、scavChunkFlags等。防止scavenger错误回收已分配的页</span></span><br><span class="line">    p.scav.index.alloc(ci, <span class="type">uint</span>(sys.OnesCount64(c.cache)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索地址往后移动63个页 =&gt; 8192*63</span></span><br><span class="line">    p.searchAddr = offAddr&#123;c.base + pageSize*(pageCachePages<span class="number">-1</span>)&#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定的虚拟地址范围内分配/映射物理内存，让该地址变为可用（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> sysGrow(base, limit <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 非4MB的倍数，异常</span></span><br><span class="line">    <span class="keyword">if</span> base%pallocChunkBytes != <span class="number">0</span> || limit%pallocChunkBytes != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: base = &quot;</span>, hex(base), <span class="string">&quot;, limit = &quot;</span>, hex(limit), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;sysGrow bounds not aligned to pallocChunkBytes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据地址找到sum的索引边界</span></span><br><span class="line">    addrRangeToSummaryRange := <span class="function"><span class="keyword">func</span><span class="params">(level <span class="type">int</span>, r addrRange)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="comment">// |16|14| 3| 3| 3| 3|22|</span></span><br><span class="line">        <span class="comment">// |  |l0|l1|l2|l3|l4|  |</span></span><br><span class="line">        <span class="comment">// 地址丢弃低22位，然后每上一层，丢弃3位，l0时是一个14位的数，l4时是一个26位数</span></span><br><span class="line">        sumIdxBase, sumIdxLimit := addrsToSummaryRange(level, r.base.addr(), r.limit.addr())</span><br><span class="line">        <span class="comment">// 按指定倍数，base向下取整，limit向上取整，l0时倍数为2^14</span></span><br><span class="line">        <span class="keyword">return</span> blockAlignSummaryRange(level, sumIdxBase, sumIdxLimit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出当前层的summary的起始、终止索引</span></span><br><span class="line">    summaryRangeToSumAddrRange := <span class="function"><span class="keyword">func</span><span class="params">(level, sumIdxBase, sumIdxLimit <span class="type">int</span>)</span></span> addrRange &#123;</span><br><span class="line">        <span class="comment">// base*8，按physPageSize向下取整</span></span><br><span class="line">        baseOffset := alignDown(<span class="type">uintptr</span>(sumIdxBase)*pallocSumBytes, physPageSize)</span><br><span class="line">        <span class="comment">// limit*8，按physPageSize向上取整</span></span><br><span class="line">        limitOffset := alignUp(<span class="type">uintptr</span>(sumIdxLimit)*pallocSumBytes, physPageSize)</span><br><span class="line">        <span class="comment">// 当前层的第一个sum</span></span><br><span class="line">        base := unsafe.Pointer(&amp;p.summary[level][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> addrRange&#123;</span><br><span class="line">            offAddr&#123;<span class="type">uintptr</span>(add(base, baseOffset))&#125;,  <span class="comment">// 当前层的base索引</span></span><br><span class="line">            offAddr&#123;<span class="type">uintptr</span>(add(base, limitOffset))&#125;, <span class="comment">// 当前层的limit索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据地址计算出其在summary的起始、终止索引</span></span><br><span class="line">    addrRangeToSumAddrRange := <span class="function"><span class="keyword">func</span><span class="params">(level <span class="type">int</span>, r addrRange)</span></span> addrRange &#123;</span><br><span class="line">        <span class="comment">// 根据地址找到sum的索引边界</span></span><br><span class="line">        sumIdxBase, sumIdxLimit := addrRangeToSummaryRange(level, r)</span><br><span class="line">        <span class="comment">// 计算出当前层的summary的起始、终止索引</span></span><br><span class="line">        <span class="keyword">return</span> summaryRangeToSumAddrRange(level, sumIdxBase, sumIdxLimit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用二分法在inUse.ranges中寻找范围包含base的addrRange的索引</span></span><br><span class="line">    inUseIndex := p.inUse.findSucc(base)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历summary</span></span><br><span class="line">    <span class="keyword">for</span> l := <span class="keyword">range</span> p.summary &#123;</span><br><span class="line">        <span class="comment">// 根据地址找到sum的索引边界</span></span><br><span class="line">        needIdxBase, needIdxLimit := addrRangeToSummaryRange(l, makeAddrRange(base, limit))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止越界</span></span><br><span class="line">        <span class="keyword">if</span> needIdxLimit &gt; <span class="built_in">len</span>(p.summary[l]) &#123;</span><br><span class="line">            p.summary[l] = p.summary[l][:needIdxLimit]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出当前层的summary的起始、终止索引</span></span><br><span class="line">        need := summaryRangeToSumAddrRange(l, needIdxBase, needIdxLimit)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于是二分法，这个索引可能越界</span></span><br><span class="line">        <span class="keyword">if</span> inUseIndex &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 根据地址计算出其在summary的起始、终止索引</span></span><br><span class="line">            <span class="comment">// 2. need根据range的地址范围调整base和limit</span></span><br><span class="line">            <span class="comment">// 注意：inUseIndex索引下的地址范围可能会包含addr</span></span><br><span class="line">            need = need.subtract(addrRangeToSumAddrRange(l, p.inUse.ranges[inUseIndex<span class="number">-1</span>]))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> inUseIndex &lt; <span class="built_in">len</span>(p.inUse.ranges) &#123;</span><br><span class="line">            <span class="comment">// 1. 根据地址计算出其在summary的起始、终止索引</span></span><br><span class="line">            <span class="comment">// 2. need根据range的地址范围调整base和limit</span></span><br><span class="line">            <span class="comment">// 注意：inUseIndex索引下的地址范围不可能会包含addr</span></span><br><span class="line">            need = need.subtract(addrRangeToSumAddrRange(l, p.inUse.ranges[inUseIndex]))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.base &lt; a.base &lt; a.limit &lt; b.limit</span></span><br><span class="line">        <span class="comment">// 如果need的地址范围被包含在range的地址范围内时，base和limit设置为0</span></span><br><span class="line">        <span class="keyword">if</span> need.size() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 前往下一层</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 走到这里，need和range的地址范围有交叉，需要更新base或者limit</span></span><br><span class="line">        <span class="comment">// a.base &lt; b.limit &lt; a.limit =&gt; a.base=b.limit（此时b.base的位置随意）</span></span><br><span class="line">        <span class="comment">// a.base &lt; b.base  &lt; a.limit =&gt; a.limit=b.base（此时b.limit的位置随意）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用sysMap直接映射，内存状态从Reserved改为Prepared</span></span><br><span class="line">        sysMap(unsafe.Pointer(need.base.addr()), need.size(), p.sysStat)</span><br><span class="line">        <span class="comment">// 内存状态从Prepared改为Ready</span></span><br><span class="line">        sysUsed(unsafe.Pointer(need.base.addr()), need.size(), need.size())</span><br><span class="line">        <span class="comment">// 这部份内存是Ready状态，累计到summaryMappedReady</span></span><br><span class="line">        p.summaryMappedReady += need.size()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (s *scavengeIndex) sysGrow(base, limit uintptr, sysStat *sysMemStat) uintptr</span></span><br><span class="line">    <span class="comment">// 回收索引在指定的虚拟地址范围内分配/映射物理内存，让该地址变为可用（Reserved-&gt;Prepared-&gt;Ready）</span></span><br><span class="line">    p.summaryMappedReady += p.scav.index.sysGrow(base, limit, p.sysStat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// chunk元素按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> enableChunkHugePages() &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;mheap_.lock)</span><br><span class="line">    <span class="comment">// 已修改</span></span><br><span class="line">    <span class="keyword">if</span> p.chunkHugePages &#123;</span><br><span class="line">        <span class="comment">// 解锁返回</span></span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置标志</span></span><br><span class="line">    p.chunkHugePages = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inUse addrRanges</span><br><span class="line">    inUse.sysStat = p.sysStat</span><br><span class="line">    <span class="comment">// 复制p.inUse到inUse变量（如果inUse容量较小，还会进行扩容）</span></span><br><span class="line">    p.inUse.cloneInto(&amp;inUse)</span><br><span class="line">    unlock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有地址</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> p.inUse.ranges &#123;</span><br><span class="line">        <span class="keyword">for</span> i := chunkIndex(r.base.addr()).l1(); i &lt; chunkIndex(r.limit.addr()<span class="number">-1</span>).l1(); i++ &#123;</span><br><span class="line">            <span class="comment">// 按physHugePageSize大小对齐，并尝试转成huge page（只有linux有）</span></span><br><span class="line">            sysHugePage(unsafe.Pointer(p.chunks[i]), unsafe.Sizeof(*p.chunks[<span class="number">0</span>]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pallocBits"><a href="#pallocBits" class="headerlink" title="pallocBits"></a>pallocBits</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在一个chunk中寻找可用的连续n个页的起始索引（最多512个页）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *pallocBits)</span></span> find(npages <span class="type">uintptr</span>, searchIdx <span class="type">uint</span>) (<span class="type">uint</span>, <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> npages == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 1个page</span></span><br><span class="line">        <span class="comment">// 寻找可用的1个页的起始索引（最多1个页）</span></span><br><span class="line">        addr := b.find1(searchIdx)</span><br><span class="line">        <span class="keyword">return</span> addr, addr</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> npages &lt;= <span class="number">64</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;=64个page</span></span><br><span class="line">        <span class="comment">// 寻找可用的连续n个页的起始索引（最多64个页）</span></span><br><span class="line">        <span class="keyword">return</span> b.findSmallN(npages, searchIdx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;64个page</span></span><br><span class="line">    <span class="comment">// 寻找可用的连续n个页的起始索引（最多512个页）</span></span><br><span class="line">    <span class="keyword">return</span> b.findLargeN(npages, searchIdx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找可用的1个页的起始索引（最多1个页）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *pallocBits)</span></span> find1(searchIdx <span class="type">uint</span>) <span class="type">uint</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否为nil</span></span><br><span class="line">    _ = b[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// i = chunk二级索引/64 =&gt; 定位是第几个uint64</span></span><br><span class="line">    <span class="keyword">for</span> i := searchIdx / <span class="number">64</span>; i &lt; <span class="type">uint</span>(<span class="built_in">len</span>(b)); i++ &#123;</span><br><span class="line">        <span class="comment">// 64个位</span></span><br><span class="line">        x := b[i]</span><br><span class="line">        <span class="comment">// 取反，如0000 0111 -&gt; 1111 1000</span></span><br><span class="line">        <span class="keyword">if</span> ^x == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果x的64个位全为1，全部已分配，跳过</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位页起始索引 =&gt; i-&gt;基索引，64位二进制数的尾部的0的个数 -&gt; 空闲位</span></span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">64</span> + <span class="type">uint</span>(sys.TrailingZeros64(^x))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部已分配</span></span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找可用的连续n个页的起始索引（最多64个页）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *pallocBits)</span></span> findSmallN(npages <span class="type">uintptr</span>, searchIdx <span class="type">uint</span>) (<span class="type">uint</span>, <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// 高位连续0个数，chunk第一个可用页的位置</span></span><br><span class="line">    end, newSearchIdx := <span class="type">uint</span>(<span class="number">0</span>), ^<span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// i = chunk二级索引/64 =&gt; 范围：[0,8)，定位是第几个uint64</span></span><br><span class="line">    <span class="keyword">for</span> i := searchIdx / <span class="number">64</span>; i &lt; <span class="type">uint</span>(<span class="built_in">len</span>(b)); i++ &#123;</span><br><span class="line">        <span class="comment">// 64个位</span></span><br><span class="line">        bi := b[i]</span><br><span class="line">        <span class="comment">// 取反，如0000 0111 -&gt; 1111 1000</span></span><br><span class="line">        <span class="keyword">if</span> ^bi == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 说明bi的64个位全为1，全部已分配，跳过</span></span><br><span class="line">            end = <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有至少一个页可用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次走到这里</span></span><br><span class="line">        <span class="keyword">if</span> newSearchIdx == ^<span class="type">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// chunk第一个可用页的位置（后面判断可能发现不连续/不够用）</span></span><br><span class="line">            newSearchIdx = i*<span class="number">64</span> + <span class="type">uint</span>(sys.TrailingZeros64(^bi))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 低位连续0个数</span></span><br><span class="line">        start := <span class="type">uint</span>(sys.TrailingZeros64(bi))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断连续空闲页数是否满足需求，举例</span></span><br><span class="line">        <span class="comment">// 上一个64位bitmap =&gt; 0001 1111 ... =&gt;   end = 3</span></span><br><span class="line">        <span class="comment">// 当前的64位bitmap =&gt; 1111 0000 ... =&gt; start = 60</span></span><br><span class="line">        <span class="keyword">if</span> end+start &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">            <span class="comment">// 连续可用n页的起始位置，chunk第一个可用页的位置</span></span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">64</span> - end, newSearchIdx</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出连续n个1的起始位置（64个位），找不到返回64</span></span><br><span class="line">        j := findBitRange64(^bi, <span class="type">uint</span>(npages))</span><br><span class="line">        <span class="comment">// 有足够空间容纳连续npages</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">64</span> &#123;</span><br><span class="line">            <span class="comment">// 连续可用n页的起始位置，chunk第一个可用页的位置</span></span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">64</span> + j, newSearchIdx</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有足够空间容纳连续npages</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 高位连续0个数</span></span><br><span class="line">        end = <span class="type">uint</span>(sys.LeadingZeros64(bi))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">uint</span>(<span class="number">0</span>), newSearchIdx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找可用的连续n个页的起始索引（最多512个页）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *pallocBits)</span></span> findLargeN(npages <span class="type">uintptr</span>, searchIdx <span class="type">uint</span>) (<span class="type">uint</span>, <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// 连续可用n页的起始位置，连续1的数量，chunk第一个可用页的位置</span></span><br><span class="line">    start, size, newSearchIdx := ^<span class="type">uint</span>(<span class="number">0</span>), <span class="type">uint</span>(<span class="number">0</span>), ^<span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// i = chunk二级索引/64 =&gt; 定位是第几个uint64</span></span><br><span class="line">    <span class="keyword">for</span> i := searchIdx / <span class="number">64</span>; i &lt; <span class="type">uint</span>(<span class="built_in">len</span>(b)); i++ &#123;</span><br><span class="line">        <span class="comment">// 64个位</span></span><br><span class="line">        x := b[i]</span><br><span class="line">        <span class="comment">// 取反，如0000 0111 -&gt; 1111 1000</span></span><br><span class="line">        <span class="keyword">if</span> x == ^<span class="type">uint64</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果x的64个位全为1，全部已分配，跳过</span></span><br><span class="line">            size = <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有至少一个页可用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次走到这里</span></span><br><span class="line">        <span class="keyword">if</span> newSearchIdx == ^<span class="type">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// chunk第一个可用页的位置（后面判断可能发现不连续/不够用）</span></span><br><span class="line">            newSearchIdx = i*<span class="number">64</span> + <span class="type">uint</span>(sys.TrailingZeros64(^x))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未改动/被重置</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 高位连续0个数</span></span><br><span class="line">            size = <span class="type">uint</span>(sys.LeadingZeros64(x))</span><br><span class="line">            <span class="comment">// 连续可用n页的起始位置</span></span><br><span class="line">            start = i*<span class="number">64</span> + <span class="number">64</span> - size</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，起始位置已经确定，看能否找到足够的空间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 低位连续0个数</span></span><br><span class="line">        s := <span class="type">uint</span>(sys.TrailingZeros64(x))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断连续空闲页数是否满足需求，举例</span></span><br><span class="line">        <span class="comment">// 上一个64位bitmap =&gt; 0001 1111 ... =&gt;   end = 3</span></span><br><span class="line">        <span class="comment">// 当前的64位bitmap =&gt; 1111 0000 ... =&gt; start = 60</span></span><br><span class="line">        <span class="keyword">if</span> s+size &gt;= <span class="type">uint</span>(npages) &#123;</span><br><span class="line">            <span class="comment">// 连续可用n页的起始位置，chunk第一个可用页的位置</span></span><br><span class="line">            <span class="keyword">return</span> start, newSearchIdx</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，64位扫描完了，还是不够用，继续扫描下一个64位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s!=64，64位中只有一部分可用，重置</span></span><br><span class="line">        <span class="keyword">if</span> s &lt; <span class="number">64</span> &#123;</span><br><span class="line">            <span class="comment">// 高位连续0个数</span></span><br><span class="line">            size = <span class="type">uint</span>(sys.LeadingZeros64(x))</span><br><span class="line">            <span class="comment">// 连续可用n页的起始位置</span></span><br><span class="line">            start = i*<span class="number">64</span> + <span class="number">64</span> - size</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 64位全部可用，直接累加</span></span><br><span class="line">        size += <span class="number">64</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不够</span></span><br><span class="line">    <span class="keyword">if</span> size &lt; <span class="type">uint</span>(npages) &#123;</span><br><span class="line">        <span class="keyword">return</span> ^<span class="type">uint</span>(<span class="number">0</span>), newSearchIdx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 够了</span></span><br><span class="line">    <span class="keyword">return</span> start, newSearchIdx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出连续n个1的起始位置（64个位），找不到返回64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBitRange64</span><span class="params">(c <span class="type">uint64</span>, n <span class="type">uint</span>)</span></span> <span class="type">uint</span> &#123;</span><br><span class="line">    <span class="comment">// 这个方法的神奇之处就是能够快速找出连续n个1的起始位置（64个位）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余位，每次循环后减k，k的范围：1,2,4,8,...</span></span><br><span class="line">    p := n - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 丢弃位的数量，每次循环后翻倍，取值范围：1,2,4,8...</span></span><br><span class="line">    k := <span class="type">uint</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一共会丢弃n-1个位</span></span><br><span class="line">    <span class="keyword">for</span> p &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 要保证k&lt;p</span></span><br><span class="line">        <span class="keyword">if</span> p &lt;= k &#123;</span><br><span class="line">            c &amp;= c &gt;&gt; (p &amp; <span class="number">63</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 丢弃k个位，如果有x个连续的1，经过这个操作，x-=k</span></span><br><span class="line">        c &amp;= c &gt;&gt; (k &amp; <span class="number">63</span>)</span><br><span class="line">        <span class="comment">// 还没操作完，但c已经为0了，表示连续的1数量不足以容纳n</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">64</span></span><br><span class="line">        &#125;</span><br><span class="line">        p -= k</span><br><span class="line">        <span class="comment">// 丢弃位的数量翻倍</span></span><br><span class="line">        k *= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时c内第一个1就是连续n个页的起始位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint</span>(sys.TrailingZeros64(c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *pallocBits)</span></span> summarize() pallocSum &#123;</span><br><span class="line">    <span class="comment">// 前导连续空闲页数，最大连续空闲页数，末尾连续空闲页数</span></span><br><span class="line">    <span class="keyword">var</span> start, most, cur <span class="type">uint</span></span><br><span class="line">    <span class="comment">// 特殊值</span></span><br><span class="line">    <span class="keyword">const</span> notSetYet = ^<span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">    start = notSetYet</span><br><span class="line">    <span class="comment">// 8个uint64，bitmap中1为已使用，0为未使用</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">        <span class="comment">// 第i个uint64</span></span><br><span class="line">        x := b[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 64个页均未使用</span></span><br><span class="line">            cur += <span class="number">64</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 64个页中有已使用的页</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二进制数x尾部0个数</span></span><br><span class="line">        t := <span class="type">uint</span>(sys.TrailingZeros64(x))</span><br><span class="line">        <span class="comment">// 二进制数x头部0个数</span></span><br><span class="line">        l := <span class="type">uint</span>(sys.LeadingZeros64(x))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累计cur+t个页（未使用）</span></span><br><span class="line">        cur += t</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start为初始值，需要更新</span></span><br><span class="line">        <span class="keyword">if</span> start == notSetYet &#123;</span><br><span class="line">            <span class="comment">// 出现已使用的页，纪录该页的索引</span></span><br><span class="line">            start = cur</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连续的未使用页数最大值</span></span><br><span class="line">        most = max(most, cur)</span><br><span class="line">        <span class="comment">// l累计到下一个uint64</span></span><br><span class="line">        cur = l</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 512个页都未被使用</span></span><br><span class="line">    <span class="keyword">if</span> start == notSetYet &#123;</span><br><span class="line">        <span class="comment">// n=512</span></span><br><span class="line">        <span class="keyword">const</span> n = <span class="type">uint</span>(<span class="number">64</span> * <span class="built_in">len</span>(b))</span><br><span class="line">        <span class="comment">// |0|512|512|512|</span></span><br><span class="line">        <span class="keyword">return</span> packPallocSum(n, n, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有使用的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得出最后的most</span></span><br><span class="line">    most = max(most, cur)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连续未分配页数量最大值超过62，就算 1xxxxx1 内部有0也不可能超过这个数</span></span><br><span class="line">    <span class="keyword">if</span> most &gt;= <span class="number">64</span><span class="number">-2</span> &#123;</span><br><span class="line">        <span class="comment">// |0|cur|most|start|</span></span><br><span class="line">        <span class="keyword">return</span> packPallocSum(start, most, cur)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，所有的uint64都不可能为0， 1xxxxx1 内部搜索连续0的数量，如果比most大，则更新most</span></span><br><span class="line"></span><br><span class="line">outer:</span><br><span class="line">    <span class="comment">// 重新扫描</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">        x := b[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 示例：000000 1xxxxx1 000000</span></span><br><span class="line">        <span class="comment">// 需要确保 1xxxxx1 内部没有连续0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 丢弃所有低位的0</span></span><br><span class="line">        x &gt;&gt;= sys.TrailingZeros64(x) &amp; <span class="number">63</span></span><br><span class="line">        <span class="keyword">if</span> x&amp;(x+<span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 内部没有0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部有0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩余量=连续0最大值</span></span><br><span class="line">        p := most</span><br><span class="line">        <span class="comment">// 1的数量</span></span><br><span class="line">        k := <span class="type">uint</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> p &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> p &lt;= k &#123;</span><br><span class="line">                    <span class="comment">// 用高位的p个1向右移位覆盖内部的0</span></span><br><span class="line">                    x |= x &gt;&gt; (p &amp; <span class="number">63</span>)</span><br><span class="line">                    <span class="keyword">if</span> x&amp;(x+<span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 内部0数量&lt;most，扫描下一组</span></span><br><span class="line">                        <span class="keyword">continue</span> outer</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 内部0数量超过most</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 用高位的k个1向右移位覆盖内部的0</span></span><br><span class="line">                x |= x &gt;&gt; (k &amp; <span class="number">63</span>)</span><br><span class="line">                <span class="keyword">if</span> x&amp;(x+<span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 内部0数量&lt;most，扫描下一组</span></span><br><span class="line">                    <span class="keyword">continue</span> outer</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 剩余量</span></span><br><span class="line">                p -= k</span><br><span class="line">                <span class="comment">// k翻倍</span></span><br><span class="line">                k *= <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内部0数量超过most</span></span><br><span class="line"></span><br><span class="line">            j := <span class="type">uint</span>(sys.TrailingZeros64(^x)) <span class="comment">// 尾部1的数量</span></span><br><span class="line">            x &gt;&gt;= j &amp; <span class="number">63</span>                       <span class="comment">// 丢弃尾部1</span></span><br><span class="line">            j = <span class="type">uint</span>(sys.TrailingZeros64(x))   <span class="comment">// 尾部0的数量</span></span><br><span class="line">            x &gt;&gt;= j &amp; <span class="number">63</span>                       <span class="comment">// 丢弃尾部0</span></span><br><span class="line">            most += j                          <span class="comment">// most+j就是 1xxxxx1 内部连续0的其中一个值</span></span><br><span class="line">            <span class="keyword">if</span> x&amp;(x+<span class="number">1</span>) == <span class="number">0</span> &#123;                  <span class="comment">// 没有其他0了，扫描下一组</span></span><br><span class="line">                <span class="keyword">continue</span> outer</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比如 1xxxxx1 内部连续0的数量有6、5两种情况，而most为4，只计算到了5，6没有计算到</span></span><br><span class="line">            p = j <span class="comment">// 剩余量从j开始</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// |0|cur|most|start|</span></span><br><span class="line">    <span class="keyword">return</span> packPallocSum(start, most, cur)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GC助攻-1"><a href="#GC助攻-1" class="headerlink" title="GC助攻"></a>GC助攻</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 降低g的Assist额度，如果额度用光了，则g需要协助GC标记（g会被挂起）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deductAssistCredit</span><span class="params">(size <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    assistG := getg()</span><br><span class="line">    <span class="comment">// 重复，避免当前g是调度的g0</span></span><br><span class="line">    <span class="keyword">if</span> assistG.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">        assistG = assistG.m.curg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 额度-=size</span></span><br><span class="line">    assistG.gcAssistBytes -= <span class="type">int64</span>(size)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 额度用光了</span></span><br><span class="line">    <span class="keyword">if</span> assistG.gcAssistBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 协助GC标记，全局额度bgScanCredit有数据则偷额度，没有则协助标记还债，还不清则挂起等待</span></span><br><span class="line">        gcAssistAlloc(assistG)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配内存时，如果sweeper还在清扫中且分配速度比清扫速度快，则协助sweeper清扫</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deductSweepCredit</span><span class="params">(spanBytes <span class="type">uintptr</span>, callerSweepPages <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 清扫完毕</span></span><br><span class="line">    <span class="keyword">if</span> mheap_.sweepPagesPerByte == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还在清扫中</span></span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// pagesSwept快照-已完成清扫的页数量（标记终止阶段时纪录）</span></span><br><span class="line">    sweptBasis := mheap_.pagesSweptBasis.Load()</span><br><span class="line">    <span class="comment">// heap存活字节数（标记终止阶段纪录或分配内存时调整）</span></span><br><span class="line">    live := gcController.heapLive.Load()</span><br><span class="line">    <span class="comment">// heapLive快照（标记终止阶段时纪录）</span></span><br><span class="line">    liveBasis := mheap_.sweepHeapLiveBasis</span><br><span class="line">    <span class="comment">// mspan字节数</span></span><br><span class="line">    newHeapLive := spanBytes</span><br><span class="line">    <span class="comment">// 一般情况下heapLive&gt;=sweepHeapLiveBasis</span></span><br><span class="line">    <span class="keyword">if</span> liveBasis &lt; live &#123;</span><br><span class="line">        <span class="comment">// 累加内存分配时增加的字节数</span></span><br><span class="line">        newHeapLive += <span class="type">uintptr</span>(live - liveBasis)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标页数=每分配1字节需要清扫的页数*总字节数-n个页</span></span><br><span class="line">    pagesTarget := <span class="type">int64</span>(mheap_.sweepPagesPerByte*<span class="type">float64</span>(newHeapLive)) - <span class="type">int64</span>(callerSweepPages)</span><br><span class="line">    <span class="comment">// 目标页数 &gt; sweeper清扫的页总数 =&gt; 短时间内分配大量内存</span></span><br><span class="line">    <span class="keyword">for</span> pagesTarget &gt; <span class="type">int64</span>(mheap_.pagesSwept.Load()-sweptBasis) &#123;</span><br><span class="line">        <span class="comment">// 不断的逐个清扫mspan</span></span><br><span class="line">        <span class="keyword">if</span> sweepone() == ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// sweeper清扫完了</span></span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sweeper还没清扫完</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// GCPercent/MemoryLimit有变动</span></span><br><span class="line">        <span class="keyword">if</span> mheap_.pagesSweptBasis.Load() != sweptBasis &#123;</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">goto</span> retry</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协助GC标记，全局额度bgScanCredit有数据则偷额度，没有则协助标记还债，还不清则挂起等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcAssistAlloc</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="comment">// g0不可被抢占</span></span><br><span class="line">    <span class="keyword">if</span> getg() == gp.m.g0 &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被抢占</span></span><br><span class="line">    <span class="keyword">if</span> mp := getg().m; mp.locks &gt; <span class="number">0</span> || mp.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        sg := gp.syncGroup</span><br><span class="line">        gp.syncGroup = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            gp.syncGroup = sg</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要协助GC标记</span></span><br><span class="line">    enteredMarkAssistForTracing := <span class="literal">false</span></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// GC限速</span></span><br><span class="line">    <span class="keyword">if</span> gcCPULimiter.limiting() &#123;</span><br><span class="line">        <span class="comment">// 如果先前已经协助GC标记</span></span><br><span class="line">        <span class="keyword">if</span> enteredMarkAssistForTracing &#123;</span><br><span class="line">            <span class="comment">// 不协助GC标记，降低GC对CPU的使用（trace相关的代码我删了）</span></span><br><span class="line">            gp.inMarkAssist = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不限制</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换参数</span></span><br><span class="line">    assistWorkPerByte := gcController.assistWorkPerByte.Load()</span><br><span class="line">    assistBytesPerWork := gcController.assistBytesPerWork.Load()</span><br><span class="line">    <span class="comment">// 额度/欠债，此时gcAssistBytes为负数</span></span><br><span class="line">    debtBytes := -gp.gcAssistBytes</span><br><span class="line">    <span class="comment">// 任务量</span></span><br><span class="line">    scanWork := <span class="type">int64</span>(assistWorkPerByte * <span class="type">float64</span>(debtBytes))</span><br><span class="line">    <span class="comment">// 最低64K</span></span><br><span class="line">    <span class="keyword">if</span> scanWork &lt; gcOverAssistWork &#123;</span><br><span class="line">        <span class="comment">// 设置为64K</span></span><br><span class="line">        scanWork = gcOverAssistWork</span><br><span class="line">        <span class="comment">// 总欠债</span></span><br><span class="line">        debtBytes = <span class="type">int64</span>(assistBytesPerWork * <span class="type">float64</span>(scanWork))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局扫描额度</span></span><br><span class="line">    bgScanCredit := gcController.bgScanCredit.Load()</span><br><span class="line">    stolen := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 全局额度还有一定数量</span></span><br><span class="line">    <span class="keyword">if</span> bgScanCredit &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> bgScanCredit &lt; scanWork &#123;</span><br><span class="line">            <span class="comment">// 剩余额度不足</span></span><br><span class="line">            <span class="comment">// 剩余的全部拿走</span></span><br><span class="line">            stolen = bgScanCredit</span><br><span class="line">            <span class="comment">// 调整欠债</span></span><br><span class="line">            gp.gcAssistBytes += <span class="number">1</span> + <span class="type">int64</span>(assistBytesPerWork*<span class="type">float64</span>(stolen))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 剩余额度充足</span></span><br><span class="line">            <span class="comment">// 一次解决欠债</span></span><br><span class="line">            stolen = scanWork</span><br><span class="line">            gp.gcAssistBytes += debtBytes</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 经过上面的操作，gcAssistBytes可能为正</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局扫描额度更新，并发情况下，可能为负数</span></span><br><span class="line">        gcController.bgScanCredit.Add(-stolen)</span><br><span class="line"></span><br><span class="line">        scanWork -= stolen</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偷走的额度跟欠债一致</span></span><br><span class="line">        <span class="keyword">if</span> scanWork == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果先前已经协助GC标记</span></span><br><span class="line">            <span class="keyword">if</span> enteredMarkAssistForTracing &#123;</span><br><span class="line">                <span class="comment">// 不协助GC标记，降低GC对CPU的使用（trace相关的代码我删了）</span></span><br><span class="line">                gp.inMarkAssist = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还有欠债</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有额度 或 额度不足以偿还</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有欠债，且没有协助GC标记过（洗盘子还债去吧）</span></span><br><span class="line">    <span class="keyword">if</span> !enteredMarkAssistForTracing &#123;</span><br><span class="line">        <span class="comment">// 有欠债，需要协助GC标记（trace相关的代码我删了）</span></span><br><span class="line">        gp.inMarkAssist = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 设置为true，进入协助标记流程</span></span><br><span class="line">        enteredMarkAssistForTracing = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到g0运行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 协助GC标记</span></span><br><span class="line">        gcAssistAlloc1(gp, scanWork)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是最后一个mark worker，param为当前g的指针</span></span><br><span class="line">    completed := gp.param != <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// mark已结束</span></span><br><span class="line">    <span class="keyword">if</span> completed &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        gcMarkDone()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仍有欠债</span></span><br><span class="line">    <span class="keyword">if</span> gp.gcAssistBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 偷不到额度，也没有完成足够的任务偿还欠债</span></span><br><span class="line">        <span class="comment">// 被抢占</span></span><br><span class="line">        <span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">            <span class="comment">// 同协程yield关键字，当前g让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">            Gosched()</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">goto</span> retry</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局额度bgScanCredit大于0则直接返回，否则g加到assist队列挂起休眠（与gcFlushBgCredit成对使用）</span></span><br><span class="line">        <span class="keyword">if</span> !gcParkAssist() &#123;</span><br><span class="line">            <span class="comment">// 有额度，不挂起休眠</span></span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">goto</span> retry</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有新的额度，被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果先前已经协助GC标记 =&gt; return前把相关字段复原</span></span><br><span class="line">    <span class="keyword">if</span> enteredMarkAssistForTracing &#123;</span><br><span class="line">        <span class="comment">// 不协助GC标记，降低GC对CPU的使用（trace相关的代码我删了）</span></span><br><span class="line">        gp.inMarkAssist = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协助GC标记</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcAssistAlloc1</span><span class="params">(gp *g, scanWork <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 重置，需要利用param字段传递数据</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC未启动/停止</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;gcBlackenEnabled) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 欠债归0</span></span><br><span class="line">        gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始时刻</span></span><br><span class="line">    startTime := nanotime()</span><br><span class="line">    <span class="comment">// stamp存储limiterEventMarkAssist和startTime</span></span><br><span class="line">    trackLimiterEvent := gp.m.p.ptr().limiterEvent.start(limiterEventMarkAssist, startTime)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动worker，计数器减1</span></span><br><span class="line">    decnwait := atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 异常，nproc始终&gt;=nwait</span></span><br><span class="line">    <span class="keyword">if</span> decnwait == work.nproc &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: work.nwait =&quot;</span>, decnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">        throw(<span class="string">&quot;nwait &gt; work.nprocs&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">    casGToWaitingForGC(gp, _Grunning, waitReasonGCAssistMarking)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf</span></span><br><span class="line">    gcw := &amp;getg().m.p.ptr().gcw</span><br><span class="line">    <span class="comment">// 从本地队列获取并扫描灰色对象，或扫描根对象，直到达到指定额度</span></span><br><span class="line">    <span class="comment">// （workDone可能大于scanWork，也可能因为mark阶段结束而小于scanWork）</span></span><br><span class="line">    workDone := gcDrainN(gcw, scanWork)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从_Gwaiting状态改为_Grunning（非_Grunnable）</span></span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换参数</span></span><br><span class="line">    assistBytesPerWork := gcController.assistBytesPerWork.Load()</span><br><span class="line">    <span class="comment">// 额度调整，这里加1是向上取整</span></span><br><span class="line">    gp.gcAssistBytes += <span class="number">1</span> + <span class="type">int64</span>(assistBytesPerWork*<span class="type">float64</span>(workDone))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复原，worker计数器加1</span></span><br><span class="line">    incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 异常，nproc始终&gt;=nwait</span></span><br><span class="line">    <span class="keyword">if</span> incnwait &gt; work.nproc &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: work.nwait=&quot;</span>, incnwait,</span><br><span class="line">            <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">        throw(<span class="string">&quot;work.nwait &gt; work.nproc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列为空（最后一个mark worker） and 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）</span></span><br><span class="line">    <span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 已经标记完毕</span></span><br><span class="line">        <span class="comment">// param传递一个数值，被唤醒时就知道是标记完成了</span></span><br><span class="line">        gp.param = unsafe.Pointer(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 耗时</span></span><br><span class="line">    duration := now - startTime</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line">    <span class="comment">// 累计到gcAssistTime</span></span><br><span class="line">    pp.gcAssistTime += duration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> trackLimiterEvent &#123;</span><br><span class="line">        <span class="comment">// 重置stamp字段，纪录耗时</span></span><br><span class="line">        pp.limiterEvent.stop(limiterEventMarkAssist, now)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt; 5000ns =&gt; gcAssistTime每达到5000ns则刷新到全局计数器里</span></span><br><span class="line">    <span class="keyword">if</span> pp.gcAssistTime &gt; gcAssistTimeSlack &#123;</span><br><span class="line">        <span class="comment">// 累计到全局GC助攻耗时</span></span><br><span class="line">        gcController.assistTime.Add(pp.gcAssistTime)</span><br><span class="line">        <span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">        gcCPULimiter.update(now)</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        pp.gcAssistTime = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从本地队列获取并扫描灰色对象，或扫描根对象，直到达到指定额度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrainN</span><span class="params">(gcw *gcWork, scanWork <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 写屏障未开启</span></span><br><span class="line">    <span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcDrainN phase incorrect&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快照，额度变欠债</span></span><br><span class="line">    workFlushed := -gcw.heapScanWork</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    gp := getg().m.curg</span><br><span class="line">    <span class="comment">// 非抢占 and GC不限速 and GC工作量没有达到scanWork</span></span><br><span class="line">    <span class="keyword">for</span> !gp.preempt &amp;&amp; !gcCPULimiter.limiting() &amp;&amp; workFlushed+gcw.heapScanWork &lt; scanWork &#123;</span><br><span class="line">        <span class="comment">// full为空</span></span><br><span class="line">        <span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// wbuf2不为空则全部放入work.full，否则将wbuf1的一半放到work.full</span></span><br><span class="line">            gcw.balance()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从wbuf获取一个obj，未初始化或为空直接返回</span></span><br><span class="line">        b := gcw.tryGetFast()</span><br><span class="line">        <span class="comment">// 没有拿到</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 从wbuf获取一个obj</span></span><br><span class="line">            b = gcw.tryGet()</span><br><span class="line">            <span class="comment">// 还是没有</span></span><br><span class="line">            <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">                wbBufFlush()</span><br><span class="line">                <span class="comment">// 从wbuf获取一个obj</span></span><br><span class="line">                b = gcw.tryGet()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3次均失败</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 根对象还没扫描完</span></span><br><span class="line">            <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">                <span class="comment">// job=markrootNext; markrootNext+=1</span></span><br><span class="line">                job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">                <span class="comment">// 确定是合法的id</span></span><br><span class="line">                <span class="keyword">if</span> job &lt; work.markrootJobs &#123;</span><br><span class="line">                    <span class="comment">// 根据索引扫描指定的根对象，扫描的字节数除了返回还会累计到gcController</span></span><br><span class="line">                    workFlushed += markroot(gcw, job, <span class="literal">false</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根对象扫描完了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf有数据，b成功读取</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描一个对象（最多128KB，剩余放到任务缓冲区）内所有指针，设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">        scanobject(b, gcw)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;= 2000 =&gt; heapScanWork每达到2000则刷新到全局计数器里</span></span><br><span class="line">        <span class="keyword">if</span> gcw.heapScanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">            <span class="comment">// 累计到全局heapScanWork</span></span><br><span class="line">            gcController.heapScanWork.Add(gcw.heapScanWork)</span><br><span class="line">            <span class="comment">// 累计到快照</span></span><br><span class="line">            workFlushed += gcw.heapScanWork</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            gcw.heapScanWork = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与gcDrain不同，gcDrainN不刷新bgScanCredit，dispose方法负责把剩下的任务交给scanWork</span></span><br><span class="line">    <span class="comment">// 这里的求和结果&gt;=scanWork</span></span><br><span class="line">    <span class="keyword">return</span> workFlushed + gcw.heapScanWork</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局额度bgScanCredit大于0则直接返回，否则g加到assist队列挂起休眠（与gcFlushBgCredit成对使用）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcParkAssist</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    lock(&amp;work.assistQueue.lock)</span><br><span class="line">    <span class="comment">// GC未启动/停止</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;gcBlackenEnabled) == <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;work.assistQueue.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 快照</span></span><br><span class="line">    oldList := work.assistQueue.q</span><br><span class="line">    <span class="comment">// 当前g放到队列末尾</span></span><br><span class="line">    work.assistQueue.q.pushBack(gp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有额度</span></span><br><span class="line">    <span class="keyword">if</span> gcController.bgScanCredit.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 用快照恢复队列（是否会有并发问题？）</span></span><br><span class="line">        work.assistQueue.q = oldList</span><br><span class="line">        <span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> oldList.tail != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// next指针置为nil</span></span><br><span class="line">            oldList.tail.ptr().schedlink.set(<span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;work.assistQueue.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有额度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前g让出CPU，g0执行调度运行其他g（在内部g、m解除绑定后会解锁lock）</span></span><br><span class="line">    goparkunlock(&amp;work.assistQueue.lock, waitReasonGCAssistWait, traceBlockGCMarkAssist, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcmarknewobject</span><span class="params">(span *mspan, obj <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> useCheckmark &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcmarknewobject called while doing checkmark&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应该在mark阶段</span></span><br><span class="line">    <span class="keyword">if</span> gcphase == _GCmarktermination &#123;</span><br><span class="line">        throw(<span class="string">&quot;mallocgc called with gcphase == _GCmarktermination&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象在mspan内的位置</span></span><br><span class="line">    <span class="comment">// =(obj-s.base)/s.elemsize</span></span><br><span class="line">    objIndex := span.objIndex(obj)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获取该对象的bitmap（从gcmarkBits获取，第几个字节、字节内第几位）</span></span><br><span class="line">    <span class="comment">// 2. 将该位设置为1（只要用mask跟gcmarkBits按位或）</span></span><br><span class="line">    span.markBitsForIndex(objIndex).setMarked()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记mspan</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据mspan起始地址获取heapArena、页索引、页bitmap位置</span></span><br><span class="line">    arena, pageIdx, pageMask := pageIndexOf(span.base())</span><br><span class="line">    <span class="comment">// 将这个页的bitmap设置为1（粗略，只设置一页，不是所有页，此外，pageMarks在GC启动时清0）</span></span><br><span class="line">    <span class="keyword">if</span> arena.pageMarks[pageIdx]&amp;pageMask == <span class="number">0</span> &#123;</span><br><span class="line">        atomic.Or8(&amp;arena.pageMarks[pageIdx], pageMask)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象大小累计到bytesMarked-被标记的字节总数</span></span><br><span class="line">    gcw := &amp;getg().m.p.ptr().gcw</span><br><span class="line">    gcw.bytesMarked += <span class="type">uint64</span>(span.elemsize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OS内存申请"><a href="#OS内存申请" class="headerlink" title="OS内存申请"></a>OS内存申请</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向系统申请内存，返回对齐后的内存地址和大小，对齐后剩余的量全部释放回系统</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserveAligned</span><span class="params">(v unsafe.Pointer, size, align <span class="type">uintptr</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// wasm（isSbrkPlatform默认为false）</span></span><br><span class="line">    <span class="keyword">if</span> isSbrkPlatform &#123;</span><br><span class="line">        <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;unexpected heap arena hint on sbrk platform&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sysReserveAlignedSbrk(size, align)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// windows才有，忽略</span></span><br><span class="line">    retries := <span class="number">0</span></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 向系统申请内存（Reserved）</span></span><br><span class="line">    p := <span class="type">uintptr</span>(sysReserve(v, size+align))</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> p == <span class="number">0</span>: <span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> p&amp;(align<span class="number">-1</span>) == <span class="number">0</span>: <span class="comment">// 已对齐</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(p), size + align</span><br><span class="line">    <span class="keyword">case</span> GOOS == <span class="string">&quot;windows&quot;</span>: <span class="comment">// 忽略</span></span><br><span class="line">        sysFreeOS(unsafe.Pointer(p), size+align)</span><br><span class="line">        p = alignUp(p, align)</span><br><span class="line">        p2 := sysReserve(unsafe.Pointer(p), size)</span><br><span class="line">        <span class="keyword">if</span> p != <span class="type">uintptr</span>(p2) &#123;</span><br><span class="line">            sysFreeOS(p2, size)</span><br><span class="line">            <span class="keyword">if</span> retries++; retries == <span class="number">100</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;failed to allocate aligned heap memory; too many retries&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> retry</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2, size</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 其他情况</span></span><br><span class="line">        <span class="comment">// p按align的倍数向上取整</span></span><br><span class="line">        pAligned := alignUp(p, align)</span><br><span class="line">        <span class="comment">// p和pAligned的间隔部份释放回系统</span></span><br><span class="line">        sysFreeOS(unsafe.Pointer(p), pAligned-p)</span><br><span class="line">        <span class="comment">// end</span></span><br><span class="line">        end := pAligned + size</span><br><span class="line">        <span class="comment">// 申请内存的end跟实际end的间隔（align剩余部份）</span></span><br><span class="line">        endLen := (p + size + align) - end</span><br><span class="line">        <span class="keyword">if</span> endLen &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// align剩余部份也释放回系统</span></span><br><span class="line">            sysFreeOS(unsafe.Pointer(end), endLen)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(pAligned), size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用sysAlloc向系统申请size大小的内存（Ready），按align倍数向上取整，统计</span></span><br><span class="line"><span class="comment">// 超过64KB直接向系统申请，未超过64KB则一次性申请256KB内存后再分配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">persistentalloc</span><span class="params">(size, align <span class="type">uintptr</span>, sysStat *sysMemStat)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="keyword">var</span> p *notInHeap</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 申请size大小的内存，按align倍数向上取整，统计</span></span><br><span class="line">        p = persistentalloc1(size, align, sysStat)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用sysAlloc向系统申请size大小的内存（Ready），按align倍数向上取整，统计</span></span><br><span class="line"><span class="comment">// 超过64KB直接向系统申请，未超过64KB则一次性申请256KB内存后再分配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">persistentalloc1</span><span class="params">(size, align <span class="type">uintptr</span>, sysStat *sysMemStat)</span></span> *notInHeap &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        <span class="comment">// 64KB</span></span><br><span class="line">        maxBlock = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size不能为0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;persistentalloc: size == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> align != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 2的倍数</span></span><br><span class="line">        <span class="keyword">if</span> align&amp;(align<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;persistentalloc: align is not a power of 2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能大于8K</span></span><br><span class="line">        <span class="keyword">if</span> align &gt; _PageSize &#123;</span><br><span class="line">            throw(<span class="string">&quot;persistentalloc: align is too large&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 默认8字节对齐</span></span><br><span class="line">        align = <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过64KB</span></span><br><span class="line">    <span class="keyword">if</span> size &gt;= maxBlock &#123;</span><br><span class="line">        <span class="comment">// 直接向系统申请size大小内存（Ready）</span></span><br><span class="line">        <span class="keyword">return</span> (*notInHeap)(sysAlloc(size, sysStat))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未超过64KB</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="keyword">var</span> persistent *persistentAlloc</span><br><span class="line">    <span class="comment">// p不为空</span></span><br><span class="line">    <span class="keyword">if</span> mp != <span class="literal">nil</span> &amp;&amp; mp.p != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 使用p的palloc</span></span><br><span class="line">        persistent = &amp;mp.p.ptr().palloc</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用全局alloc</span></span><br><span class="line">        lock(&amp;globalAlloc.mutex)</span><br><span class="line">        persistent = &amp;globalAlloc.persistentAlloc</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// offset按align（默认8字节）的倍数向上取整</span></span><br><span class="line">    persistent.off = alignUp(persistent.off, align)</span><br><span class="line">    <span class="comment">// offset+size超过256KB or base为nil</span></span><br><span class="line">    <span class="keyword">if</span> persistent.off+size &gt; persistentChunkSize || persistent.base == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接向系统申请256KB大小的内存（Ready）</span></span><br><span class="line">        persistent.base = (*notInHeap)(sysAlloc(persistentChunkSize, &amp;memstats.other_sys))</span><br><span class="line">        <span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">if</span> persistent.base == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> persistent == &amp;globalAlloc.persistentAlloc &#123;</span><br><span class="line">                unlock(&amp;globalAlloc.mutex)</span><br><span class="line">            &#125;</span><br><span class="line">            throw(<span class="string">&quot;runtime: cannot allocate memory&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 申请成功</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 旧块：persistentAlloc全局变量指针</span></span><br><span class="line">            chunks := <span class="type">uintptr</span>(unsafe.Pointer(persistentChunks))</span><br><span class="line">            <span class="comment">// 新块的开头8字节存储旧块的指针</span></span><br><span class="line">            *(*<span class="type">uintptr</span>)(unsafe.Pointer(persistent.base)) = chunks</span><br><span class="line">            <span class="comment">// 更新persistentAlloc</span></span><br><span class="line">            <span class="keyword">if</span> atomic.Casuintptr((*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;persistentChunks)), chunks, <span class="type">uintptr</span>(unsafe.Pointer(persistent.base))) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// offset=8</span></span><br><span class="line">        persistent.off = alignUp(goarch.PtrSize, align)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动8个字节指向初始地址</span></span><br><span class="line">    p := persistent.base.add(persistent.off)</span><br><span class="line">    <span class="comment">// 分配size大小的内存</span></span><br><span class="line">    persistent.off += size</span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">if</span> persistent == &amp;globalAlloc.persistentAlloc &#123;</span><br><span class="line">        unlock(&amp;globalAlloc.mutex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计</span></span><br><span class="line">    <span class="keyword">if</span> sysStat != &amp;memstats.other_sys &#123;</span><br><span class="line">        sysStat.add(<span class="type">int64</span>(size))</span><br><span class="line">        memstats.other_sys.add(-<span class="type">int64</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断地址是否在persistentChunks</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inPersistentAlloc</span><span class="params">(p <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    chunk := atomic.Loaduintptr((*<span class="type">uintptr</span>)(unsafe.Pointer(&amp;persistentChunks)))</span><br><span class="line">    <span class="keyword">for</span> chunk != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 在chunk内存地址范围内（256KB）</span></span><br><span class="line">        <span class="keyword">if</span> p &gt;= chunk &amp;&amp; p &lt; chunk+persistentChunkSize &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找下一个chunk</span></span><br><span class="line">        chunk = *(*<span class="type">uintptr</span>)(unsafe.Pointer(chunk))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="profile相关"><a href="#profile相关" class="headerlink" title="profile相关"></a>profile相关</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回堆分析的下一个采样点（随机数：[0,MemProfileRate)）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextSample</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> MemProfileRate == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 永不采样</span></span><br><span class="line">        <span class="keyword">return</span> maxInt64</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> MemProfileRate == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 立刻采样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">if</span> GOOS == <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// plan9在note handler不支持浮点数</span></span><br><span class="line">        <span class="keyword">if</span> gp := getg(); gp == gp.m.gsignal &#123;</span><br><span class="line">            <span class="keyword">return</span> nextSampleNoFP()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(fastexprand(MemProfileRate))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置相关字段，记录内存分配事件，添加special防止GC回收</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">profilealloc</span><span class="params">(mp *m, x unsafe.Pointer, size <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取p.mcache，没有p则获取mcache0</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;profilealloc called without a P or outside bootstrapping&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置，默认512KB，可以通过GODEBUG修改</span></span><br><span class="line">    c.memProfRate = MemProfileRate</span><br><span class="line">    <span class="comment">// 返回堆分析的下一个采样点（随机数：[0,MemProfileRate)）</span></span><br><span class="line">    c.nextSample = nextSample()</span><br><span class="line">    <span class="comment">// 记录内存分配事件，添加special防止GC回收</span></span><br><span class="line">    mProf_Malloc(mp, x, size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存区域批量清0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memclrNoHeapPointersChunked</span><span class="params">(size <span class="type">uintptr</span>, x unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    v := <span class="type">uintptr</span>(x)</span><br><span class="line">    <span class="comment">// 按批次清0，每批256KB</span></span><br><span class="line">    <span class="keyword">const</span> chunkBytes = <span class="number">256</span> * <span class="number">1024</span></span><br><span class="line">    vsize := v + size</span><br><span class="line">    <span class="keyword">for</span> voff := v; voff &lt; vsize; voff = voff + chunkBytes &#123;</span><br><span class="line">        <span class="comment">// 被抢占</span></span><br><span class="line">        <span class="keyword">if</span> getg().preempt &#123;</span><br><span class="line">            <span class="comment">// 可能持有锁</span></span><br><span class="line">            goschedguarded()</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将min(avail, lump)个字节清0</span></span><br><span class="line">        n := vsize - voff</span><br><span class="line">        <span class="keyword">if</span> n &gt; chunkBytes &#123;</span><br><span class="line">            n = chunkBytes</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 内存区域清0（只有你知道该区域不存在指针才能调用）</span></span><br><span class="line">        memclrNoHeapPointers(unsafe.Pointer(voff), n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://medium.com/safetycultureengineering/an-overview-of-memory-management-in-go-9a72ec7c76a8">An overview of memory management in Go</a><br><a href="https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">A visual guide to Go Memory Allocator from scratch (Golang)</a><br><a href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">Go: Memory Management and Allocation</a><br><a href="https://andrestc.com/post/go-memory-allocation-pt1/">Go’s Memory Allocator - Overview</a><br><a href="https://deepu.tech/memory-management-in-golang/">Visualizing memory management in Golang</a><br><a href="https://about.sourcegraph.com/blog/go/gophercon-2018-allocator-wrestling">GopherCon 2018 - Allocator Wrestling</a><br><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">7.1 内存分配器</a><br><a href="https://agis.io/post/contiguous-stacks-golang/">Contiguous stacks in Go</a><br><a href="https://medium.com/@kai.chihkaiyu/golang-memory-management-based-on-1-12-5-51fcc97f3c92">Golang Memory Management (based on 1.12.5)</a><br><a href="https://mhh12121.github.io/2020/02/24/Go/memManage/">Golang Memory Allocator</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
