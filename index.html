<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"y2k38.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="个人笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="noname">
<meta property="og:url" content="https://y2k38.github.io/index.html">
<meta property="og:site_name" content="noname">
<meta property="og:description" content="个人笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="y2k38">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://y2k38.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>noname</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">noname</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">y2k38</p>
  <div class="site-description" itemprop="description">个人笔记</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-timer-and-ticker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-timer-and-ticker/" class="post-title-link" itemprop="url">golang系列之-定时器Timer和Ticker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-03-01 09:57:28 / 修改时间：09:58:47" itemprop="dateCreated datePublished" datetime="2025-03-01T09:57:28+08:00">2025-03-01</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>29 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Timer-一次性定时器，Ticker-周期性定时器。从1.23版本开始，将异步实现改为同步实现，但你仍然可以使用AfterFunc创建异步定时器，或者通过改变asynctimerchan变量启用异步实现</p>
<p>asynctimerchan变量可选项如下</p>
<table>
<thead>
<tr>
<th align="left">asynctimerchan</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">同步实现，从1.23版本开始启用</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">旧版异步实现</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">同1，异步实现，但修复了1的问题，debug用</td>
</tr>
</tbody></table>
<p>定时器的精确度因系统不同而不同，具体如下</p>
<table>
<thead>
<tr>
<th align="left">OS</th>
<th align="left">resolution</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Unix</td>
<td align="left">~1ms</td>
</tr>
<tr>
<td align="left">&gt;&#x3D; Windows 1803</td>
<td align="left">~0.5ms</td>
</tr>
<tr>
<td align="left">&lt; Windows 1803</td>
<td align="left">~16ms</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：golang团队声称1.23版本已解决Reset的问题，实际发现并没有彻底解决</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timeout = <span class="number">10</span> * time.Millisecond</span><br><span class="line">    <span class="comment">// 10ms超时</span></span><br><span class="line">    t := time.NewTimer(timeout)</span><br><span class="line">    <span class="comment">// 当前goroutine先挂起个20ms</span></span><br><span class="line">    time.Sleep(<span class="number">20</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这时t已经过期</span></span><br><span class="line">    start := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置timer，设置10ms的超时时间</span></span><br><span class="line">    t.Reset(timeout)</span><br><span class="line">    <span class="comment">// 理想：在这里阻塞，10ms后被唤醒</span></span><br><span class="line">    <span class="comment">// t.C =&gt; make(chan Time, 1)</span></span><br><span class="line">    &lt;-t.C </span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Time elapsed: %dms\n&quot;</span>, time.Since(start).Milliseconds())</span><br><span class="line">    <span class="comment">// 预期输出: Time elapsed: 10ms</span></span><br><span class="line">    <span class="comment">// 实际输出: Time elapsed:  0ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码，不管是1.22版本还是1.24版本，问题都没有解决。不过，在for循环使用timer时内存膨胀的问题已解决</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>深入了解源代码前，先了解其功能如何使用</p>
<h3 id="Timer-一次性定时器"><a href="#Timer-一次性定时器" class="headerlink" title="Timer-一次性定时器"></a>Timer-一次性定时器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定时器1</span></span><br><span class="line">    timer1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    &lt;-timer1.C</span><br><span class="line">    fmt.Println(<span class="string">&quot;Timer 1 fired&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器2</span></span><br><span class="line">    timer2 := time.NewTimer(time.Second)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-timer2.C</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer 2 fired&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    stop2 := timer2.Stop()</span><br><span class="line">    <span class="keyword">if</span> stop2 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer 2 stopped&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器3</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例代码运行效果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># Timer 1 fired</span></span><br><span class="line"><span class="comment"># Timer 2 stopped</span></span><br></pre></td></tr></table></figure>

<h3 id="Ticker-周期性定时器"><a href="#Ticker-周期性定时器" class="headerlink" title="Ticker-周期性定时器"></a>Ticker-周期性定时器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 每500ms执行一次</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Tick at&quot;</span>, t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起休眠1600ms</span></span><br><span class="line">    time.Sleep(<span class="number">1600</span> * time.Millisecond)</span><br><span class="line">    <span class="comment">// 停止定时器</span></span><br><span class="line">    ticker.Stop()</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Ticker stopped&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例代码运行效果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tick at 2025-02-27 10:41:07.875146141 +0800 CST m=+0.500099485</span></span><br><span class="line"><span class="comment"># Tick at 2025-02-27 10:41:08.37515345 +0800 CST m=+1.000100767</span></span><br><span class="line"><span class="comment"># Tick at 2025-02-27 10:41:08.875159521 +0800 CST m=+1.500100789</span></span><br><span class="line"><span class="comment"># Ticker stopped</span></span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>time.Timer以及time.Ticker数据结构同源，在实际运行时都会转换成runtime的timeTimer，数据结构的字段释义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/time/sleep.go</span></span><br><span class="line"><span class="comment">// time.Timer结构，可以忽略，实际使用会转换成runtime的timeTimer</span></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    C         &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    initTimer <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/time/tick.go</span></span><br><span class="line"><span class="comment">// time.Ticker，可以忽略，实际使用会转换成runtime的timeTimer</span></span><br><span class="line"><span class="keyword">type</span> Ticker <span class="keyword">struct</span> &#123;</span><br><span class="line">    C          &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    initTicker <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time.go</span></span><br><span class="line"><span class="comment">// 下面几个数据结构才是实际使用的</span></span><br><span class="line"><span class="keyword">type</span> timeTimer <span class="keyword">struct</span> &#123;</span><br><span class="line">    c     unsafe.Pointer            <span class="comment">// channel</span></span><br><span class="line">    init  <span class="type">bool</span>                      <span class="comment">// 是否已经初始化</span></span><br><span class="line">    timer                           <span class="comment">// 具体看下方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu        mutex                 <span class="comment">// 锁，保护以下所有字段</span></span><br><span class="line">    astate    atomic.Uint8          <span class="comment">// state字段的复制，modify以及unlock时复制</span></span><br><span class="line">    state     <span class="type">uint8</span>                 <span class="comment">// 状态位，具体见后面的列表</span></span><br><span class="line">    isChan    <span class="type">bool</span>                  <span class="comment">// 同步还是异步（go1.23开始设置为true，除非自己设置asynctimerchan）</span></span><br><span class="line">    isFake    <span class="type">bool</span>                  <span class="comment">// 测试用</span></span><br><span class="line">    blocked   <span class="type">uint32</span>                <span class="comment">// 阻塞在channel中的G数量</span></span><br><span class="line">    when      <span class="type">int64</span>                 <span class="comment">// 目标过期时刻</span></span><br><span class="line">    period    <span class="type">int64</span>                 <span class="comment">// 时长-周期性定时器使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数f内部不能出现阻塞，默认为sendTime，也可以是goroutineReady或用户自定义函数</span></span><br><span class="line">    f         <span class="function"><span class="keyword">func</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span></span><br><span class="line">    <span class="comment">// 当与netpoll一起使用时</span></span><br><span class="line">    <span class="comment">// arg是*pollDesc</span></span><br><span class="line">    <span class="comment">// seq是版本计数器，类似时间戳，确保过期的消息不会被处理，stop以及modify时自增</span></span><br><span class="line">    <span class="comment">// 当作为time包时</span></span><br><span class="line">    <span class="comment">// arg是一个channel（After/NewTicker）或一个函数（AfterFunc）</span></span><br><span class="line">    <span class="comment">// seq同上，但没有使用</span></span><br><span class="line">    arg       any                   <span class="comment">// 见上方解释</span></span><br><span class="line">    seq       <span class="type">uintptr</span>               <span class="comment">// 版本计数器</span></span><br><span class="line"></span><br><span class="line">    ts        *timers               <span class="comment">// 判断timer属于哪个P</span></span><br><span class="line">    </span><br><span class="line">    sendLock  mutex                 <span class="comment">// 用于channel加锁（go1.23开始启用）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于处理运行定时器和停止/重置定时器的冲突检测</span></span><br><span class="line">    <span class="comment">// 只用于同步定时器（isChan == true），周期性定时器不可用</span></span><br><span class="line">    <span class="comment">// 发送数据到channel时isSending++，发送后isSending--</span></span><br><span class="line">    <span class="comment">// t.mu加锁             =&gt; isSending可自增</span></span><br><span class="line">    <span class="comment">// t.sendLock加锁       =&gt; isSending可自减</span></span><br><span class="line">    <span class="comment">// t.mu、t.sendLock加锁 =&gt; 数据只读</span></span><br><span class="line">    isSending atomic.Int32          <span class="comment">// 见上方解释</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆及其元数据，每个P都有一个timers（见P的数据结构）</span></span><br><span class="line"><span class="keyword">type</span> timers <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu              mutex           <span class="comment">// 锁，保护下面字段，因为其他P的G可以访问当前P的timers</span></span><br><span class="line">    heap            []timerWhen     <span class="comment">// 最小堆，用于存储timer，按heap[i].when排序</span></span><br><span class="line">    <span class="built_in">len</span>             atomic.Uint32   <span class="comment">// 最小堆中的元素数量 =&gt; len(heap)</span></span><br><span class="line">    zombies         atomic.Int32    <span class="comment">// 最小堆中，timer.state设置了timerZombie位的定时器数量</span></span><br><span class="line">    raceCtx         <span class="type">uintptr</span>         <span class="comment">// 冲突检测用，忽略</span></span><br><span class="line">    minWhenHeap     atomic.Int64    <span class="comment">// 最小堆中的最小when（=heap[0].when），为0时表示heap为空</span></span><br><span class="line">    minWhenModified atomic.Int64    <span class="comment">// 最小堆中的最小when，但仅限timer.state设置了timerModified位的定时器</span></span><br><span class="line">    syncGroup       *synctestGroup  <span class="comment">// 测试用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器及其过期时刻</span></span><br><span class="line"><span class="keyword">type</span> timerWhen <span class="keyword">struct</span> &#123;</span><br><span class="line">    timer *timer                    <span class="comment">// 定时器指针</span></span><br><span class="line">    when  <span class="type">int64</span>                     <span class="comment">// 目标过期时刻</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>timer的state状态总共占用3个位，如下所示</p>
<table>
<thead>
<tr>
<th align="left">state_name</th>
<th align="left">state_value</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">timerHeaped</td>
<td align="left">1</td>
<td align="left">定时器已经放在某个P的timers最小堆中</td>
</tr>
<tr>
<td align="left">timerModified</td>
<td align="left">2</td>
<td align="left">t.when被修改但还没更新heap[i].when，如果定时器不在heap，忽略</td>
</tr>
<tr>
<td align="left">timerZombie</td>
<td align="left">4</td>
<td align="left">定时器被停止，但还放在heap里，可以跟timerModified位共存。定时器为zombie时可以发送数据到channel，因为数据不会被读取</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>timerModified和timerZombie的前提都是timerHeaped</li>
<li>无法直接把timer移除出timers.heap，因为别的P可能已经拿到了这个timer</li>
<li>timer有这几个状态位意味着最小堆还没有重新调整，timer还放在之前的位置上（不满足最小堆）</li>
</ol>
<h2 id="创建定时器"><a href="#创建定时器" class="headerlink" title="创建定时器"></a>创建定时器</h2><h3 id="NewTimer-NewTicker"><a href="#NewTimer-NewTicker" class="headerlink" title="NewTimer &amp; NewTicker"></a>NewTimer &amp; NewTicker</h3><p>创建&#x2F;获取定时器，过期时刻为当前时刻加目标时长</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span></span> *Timer &#123;</span><br><span class="line">    <span class="comment">// channel，有缓冲</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    t := (*Timer)(newTimer(when(d), <span class="number">0</span>, sendTime, c, syncTimer(c)))</span><br><span class="line">    <span class="comment">// 定时器绑定channel</span></span><br><span class="line">    t.C = c</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTicker</span><span class="params">(d Duration)</span></span> *Ticker &#123;</span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;non-positive interval for NewTicker&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// channel，有缓冲</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    t := (*Ticker)(unsafe.Pointer(newTimer(when(d), <span class="type">int64</span>(d), sendTime, c, syncTimer(c))))</span><br><span class="line">    <span class="comment">// 定时器绑定channel</span></span><br><span class="line">    t.C = c</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建定时器time.Timer或time.Ticker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTimer</span><span class="params">(when, period <span class="type">int64</span>, f <span class="keyword">func</span>(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span>, arg any, c *hchan) *timeTimer &#123;</span><br><span class="line">    t := <span class="built_in">new</span>(timeTimer)</span><br><span class="line">    <span class="comment">// mu/f/arg参数初始化，这里传nil，后面用t.modify修改</span></span><br><span class="line">    t.timer.init(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;new&quot;</span>)</span><br><span class="line">    <span class="comment">// 同步定时器（go1.23开始默认启用），初始化sendLock、isChan</span></span><br><span class="line">    <span class="keyword">if</span> c != <span class="literal">nil</span> &#123;</span><br><span class="line">        lockInit(&amp;t.sendLock, lockRankTimerSend)</span><br><span class="line">        t.isChan = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 双向绑定</span></span><br><span class="line">        c.timer = &amp;t.timer</span><br><span class="line">        <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;invalid timer channel: no capacity&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> gr := getg().syncGroup; gr != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.isFake = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line">    t.modify(when, period, f, arg, <span class="number">0</span>)</span><br><span class="line">    t.init = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取定时器触发时刻</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">when</span><span class="params">(d Duration)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 时长不能为负</span></span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> runtimeNano()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    t := runtimeNano() + <span class="type">int64</span>(d)</span><br><span class="line">    <span class="comment">// 溢出时，设置为最大值math.MaxInt64</span></span><br><span class="line">    <span class="keyword">if</span> t &lt; <span class="number">0</span> &#123;</span><br><span class="line">        t = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把目标触发时刻发送给channel，定时器过期时调用</span></span><br><span class="line"><span class="comment">// 目前有maybeRunAsync、unlockAndRun、maybeRunChan在使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendTime</span><span class="params">(c any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// delta =&gt; 实际触发时刻-目标触发时刻</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c.(<span class="keyword">chan</span> Time) &lt;- Now().Add(Duration(-delta)):</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取同步定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syncTimer</span><span class="params">(c <span class="keyword">chan</span> Time)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// async，go1.22及之前版本</span></span><br><span class="line">    <span class="keyword">if</span> asynctimerchan.Value() == <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">        asynctimerchan.IncNonDefault()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sync，go1.23及以后，返回channel的指针</span></span><br><span class="line">    <span class="comment">// asynctimerchan=2作用同asynctimerchan=1，修复了旧版问题，用于debug</span></span><br><span class="line">    <span class="keyword">return</span> *(*unsafe.Pointer)(unsafe.Pointer(&amp;c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化timer的mu/f/arg字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> init(f <span class="function"><span class="keyword">func</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span>, arg any) &#123;</span><br><span class="line">    lockInit(&amp;t.mu, lockRankTimer)</span><br><span class="line">    t.f = f</span><br><span class="line">    t.arg = arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line"><span class="comment">// 一般是netpoll、time.Ticker.Reset、time.Timer.Reset调用。该方法修改的是timer的when/period/f/arg/seq字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> modify(when, period <span class="type">int64</span>, f <span class="function"><span class="keyword">func</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delay <span class="type">int64</span>)</span></span>, arg any, seq <span class="type">uintptr</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line">    <span class="keyword">if</span> when &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;timer when must be positive&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> period &lt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;timer period must be non-negative&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是异步还是同步定时器（go1.23开始默认是同步定时器）</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 防止重复发送数据到channel</span></span><br><span class="line">        lock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 异步定时器</span></span><br><span class="line">    <span class="keyword">if</span> async &#123;</span><br><span class="line">        <span class="comment">// 判断定时器是否需要触发执行函数f</span></span><br><span class="line">        t.maybeRunAsync()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;modify&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新timer字段</span></span><br><span class="line"></span><br><span class="line">    oldPeriod := t.period</span><br><span class="line">    t.period = period</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.f = f</span><br><span class="line">        t.arg = arg</span><br><span class="line">        t.seq = seq</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wake := <span class="literal">false</span></span><br><span class="line">    pending := t.when &gt; <span class="number">0</span></span><br><span class="line">    t.when = when</span><br><span class="line">    <span class="comment">// timer已经在最小堆中</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        t.state |= timerModified <span class="comment">// 已修改</span></span><br><span class="line">        <span class="comment">// timer已标记删除</span></span><br><span class="line">        <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">            t.ts.zombies.Add(<span class="number">-1</span>)    <span class="comment">// 计数器更新</span></span><br><span class="line">            t.state &amp;^= timerZombie <span class="comment">// 移除标志位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// minWhen更新</span></span><br><span class="line">        <span class="comment">// 最小堆为空 or when比minWhen小</span></span><br><span class="line">        <span class="keyword">if</span> min := t.ts.minWhenModified.Load(); min == <span class="number">0</span> || when &lt; min &#123;</span><br><span class="line">            <span class="comment">// 需要中断网络轮询</span></span><br><span class="line">            wake = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 纪录state</span></span><br><span class="line">            t.astate.Store(t.state)</span><br><span class="line">            <span class="comment">// 是否要用when替换minWhenModified</span></span><br><span class="line">            t.ts.updateMinWhenModified(when)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 判断是否需要把timer添加到最小堆、中断网络轮询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要把定时器放到timers.heap</span></span><br><span class="line">    add := t.needsAdd()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 版本计数器更新</span></span><br><span class="line">        t.seq++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正在发送数据到channel</span></span><br><span class="line">        <span class="keyword">if</span> oldPeriod == <span class="number">0</span> &amp;&amp; t.isSending.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 清空channel（t.arg）的buf缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> timerchandrain(t.hchan()) &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要把定时器放到timers.heap</span></span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line">        t.maybeAdd()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断网络轮询任务</span></span><br><span class="line">    <span class="keyword">if</span> wake &#123;</span><br><span class="line">        wakeNetPoller(when)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pending</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断定时器是否需要更新timer状态，执行函数f（异步定时器执行）</span></span><br><span class="line"><span class="comment">// timer为异步定时器调用（go1.23开始应该用不到了），目前只有modify和stop函数在使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeRunAsync() &#123;</span><br><span class="line">    <span class="comment">// mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// 1. timer不在最小堆</span></span><br><span class="line">    <span class="comment">// 2. 同步定时器</span></span><br><span class="line">    <span class="comment">// 3. 过期时刻大于0</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped == <span class="number">0</span> &amp;&amp; t.isChan &amp;&amp; t.when &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时刻，如果已过期</span></span><br><span class="line">        <span class="keyword">if</span> now := nanotime(); t.when &lt;= now &#123;</span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">                t.unlockAndRun(now)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 重新上锁</span></span><br><span class="line">            t.lock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line"><span class="comment">// 该函数不管是异步定时器还是同步定时器都会使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> unlockAndRun(now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;unlockAndRun&quot;</span>)</span><br><span class="line">    <span class="comment">// mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// 如果timer已经放到了ts最小堆上，ts也要加锁</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        assertLockHeld(&amp;t.ts.mu)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer已经被修改或被停止，异常</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;(timerModified|timerZombie) != <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新timer状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备被调用的函数数据</span></span><br><span class="line">    f := t.f</span><br><span class="line">    arg := t.arg</span><br><span class="line">    seq := t.seq</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> next <span class="type">int64</span></span><br><span class="line">    <span class="comment">// 超过过期时刻的纳秒数</span></span><br><span class="line">    delay := now - t.when</span><br><span class="line">    <span class="comment">// 周期性定时器</span></span><br><span class="line">    <span class="keyword">if</span> t.period &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 计算下一个过期时刻，这公式没明白原理</span></span><br><span class="line">        next = t.when + t.period*(<span class="number">1</span>+delay/t.period)</span><br><span class="line">        <span class="comment">// 溢出了，设置为最大值2^63-1</span></span><br><span class="line">        <span class="keyword">if</span> next &lt; <span class="number">0</span> &#123;</span><br><span class="line">            next = maxWhen</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一次性定时器</span></span><br><span class="line">        next = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ts := t.ts</span><br><span class="line">    t.when = next</span><br><span class="line">    <span class="comment">// timer已经在最小堆中</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 设置timerModified标志位</span></span><br><span class="line">        t.state |= timerModified</span><br><span class="line">        <span class="comment">// 如果是一次性定时器，标记删除</span></span><br><span class="line">        <span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 标记为删除</span></span><br><span class="line">            t.state |= timerZombie</span><br><span class="line">            <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">            t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line">        t.updateHeap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行函数f</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是异步还是同步定时器（go1.23开始默认是同步定时器）</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 同步定时器 and 一次性</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &amp;&amp; t.period == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 发送中，计数器加1（用于并发检测，后面会执行减1操作）</span></span><br><span class="line">        <span class="keyword">if</span> t.isSending.Add(<span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;too many concurrent timer firings&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前定时器已经放到了最小堆</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 计算heap元素数量并更新len字段，最后解锁</span></span><br><span class="line">        ts.unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &amp;&amp; ts.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Temporarily use the timer&#x27;s synctest group for the G running this timer.</span></span><br><span class="line">        gp := getg()</span><br><span class="line">        <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;unexpected syncgroup set&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        gp.syncGroup = ts.syncGroup</span><br><span class="line">        ts.syncGroup.changegstatus(gp, _Gdead, _Grunning)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        lock(&amp;t.sendLock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次性定时器</span></span><br><span class="line">        <span class="keyword">if</span> t.period == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 发送完毕，计数器减1</span></span><br><span class="line">            <span class="keyword">if</span> t.isSending.Add(<span class="number">-1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;mismatched isSending updates&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 版本不一样，不执行。加锁后double-check </span></span><br><span class="line">        <span class="keyword">if</span> t.seq != seq &#123;</span><br><span class="line">            f = <span class="function"><span class="keyword">func</span><span class="params">(any, <span class="type">uintptr</span>, <span class="type">int64</span>)</span></span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数f</span></span><br><span class="line">    f(arg, seq, delay)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        unlock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &amp;&amp; ts.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        gp := getg()</span><br><span class="line">        ts.syncGroup.changegstatus(gp, _Grunning, _Gdead)</span><br><span class="line">        gp.syncGroup = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前定时器已经放到了最小堆</span></span><br><span class="line">    <span class="keyword">if</span> ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        ts.lock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否要用when替换minWhenModified</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> updateMinWhenModified(when <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// old == 0 =&gt; 第一次访问，替换</span></span><br><span class="line">    <span class="comment">// old &lt; when =&gt; 忽略 </span></span><br><span class="line">    <span class="comment">// old &gt; when =&gt; 替换</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := ts.minWhenModified.Load()</span><br><span class="line">        <span class="keyword">if</span> old != <span class="number">0</span> &amp;&amp; old &lt; when &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ts.minWhenModified.CompareAndSwap(old, when) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要把定时器放到timers.heap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> needsAdd() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// t.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// 1. timer不在最小堆</span></span><br><span class="line">    <span class="comment">// 2. 过期时刻大于0</span></span><br><span class="line">    <span class="comment">// 3. 异步定时器 or 在测试 or 有G阻塞在channel中</span></span><br><span class="line">    need := t.state&amp;timerHeaped == <span class="number">0</span> &amp;&amp; t.when &gt; <span class="number">0</span> &amp;&amp; (!t.isChan || t.isFake || t.blocked &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个trace都是debug用的，忽略</span></span><br><span class="line">    <span class="keyword">if</span> need &#123;</span><br><span class="line">        t.trace(<span class="string">&quot;needsAdd+&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.trace(<span class="string">&quot;needsAdd-&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> need</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空channel（t.arg）的buf缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerchandrain</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// channel数据为0</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    any := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// buf有数据？清空</span></span><br><span class="line">    <span class="keyword">for</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        any = <span class="literal">true</span></span><br><span class="line">        typedmemclr(c.elemtype, chanbuf(c, c.recvx))</span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount--</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeAdd() &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前P的timers最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保拿的是当前P</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="keyword">var</span> ts *timers</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        sg := getg().syncGroup</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;invalid timer: fake time but no syncgroup&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ts = &amp;sg.timers</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况</span></span><br><span class="line">        ts = &amp;mp.p.ptr().timers</span><br><span class="line">    &#125;</span><br><span class="line">    ts.lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 清理最小堆</span></span><br><span class="line">    <span class="comment">// 确保最小堆首尾都没有过期的timer</span></span><br><span class="line">    ts.cleanHead()</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;maybeAdd&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更新当前timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line"></span><br><span class="line">    when := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    wake := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="keyword">if</span> t.needsAdd() &#123;</span><br><span class="line">        <span class="comment">// 设置timerHeaped标志位</span></span><br><span class="line">        t.state |= timerHeaped</span><br><span class="line">        when = t.when</span><br><span class="line">        <span class="comment">// 获取最小堆的最小when，用于判断是否需要唤醒netpoller</span></span><br><span class="line">        wakeTime := ts.wakeTime()</span><br><span class="line">        <span class="comment">// 最小堆为空 or 当前timer过期时刻比最小堆的还小</span></span><br><span class="line">        wake = wakeTime == <span class="number">0</span> || when &lt; wakeTime</span><br><span class="line">        <span class="comment">// 把timer定时器加入到timers.heap最小堆中</span></span><br><span class="line">        ts.addHeap(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="comment">// 计算heap元素数量并更新len字段，最后解锁</span></span><br><span class="line">    ts.unlock()</span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中断网络轮询任务</span></span><br><span class="line">    <span class="keyword">if</span> wake &#123;</span><br><span class="line">        wakeNetPoller(when)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保最小堆首尾都没有过期的timer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> cleanHead() &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;cleanHead&quot;</span>)</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 当前goroutine</span></span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小堆的最后一个元素开始向前扫描，如果timer已过期，则移除出最小堆</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 1. guard</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最小堆数据为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for循环会运行一段时间，因为持有锁，不会被抢占</span></span><br><span class="line">        <span class="comment">// 如果其他G要抢占，返回，稍后再清理</span></span><br><span class="line">        <span class="keyword">if</span> gp.preemptStop &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n := <span class="built_in">len</span>(ts.heap)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2. 尾部处理</span></span><br><span class="line">        <span class="comment">// 从最小堆的最后一个元素开始向前扫描，如果timer已过期，则移除出最小堆</span></span><br><span class="line">        <span class="keyword">if</span> t := ts.heap[n<span class="number">-1</span>].timer; t.astate.Load()&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">            t.lock()</span><br><span class="line">            <span class="comment">// double-check</span></span><br><span class="line">            <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 移除出heap前把状态清空</span></span><br><span class="line">                t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">                <span class="comment">// 表示从heap上移除</span></span><br><span class="line">                t.ts = <span class="literal">nil</span></span><br><span class="line">                <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">                ts.zombies.Add(<span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// 先用空的结构替换</span></span><br><span class="line">                ts.heap[n<span class="number">-1</span>] = timerWhen&#123;&#125;</span><br><span class="line">                <span class="comment">// 移除最后一个数据</span></span><br><span class="line">                ts.heap = ts.heap[:n<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">            t.unlock()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 头部处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最小堆中的最小timer</span></span><br><span class="line">        t := ts.heap[<span class="number">0</span>].timer</span><br><span class="line">        <span class="comment">// 不在同一个P上</span></span><br><span class="line">        <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad ts&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有被修改也没有标记删除，无须调整</span></span><br><span class="line">        <span class="keyword">if</span> t.astate.Load()&amp;(timerModified|timerZombie) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line">        updated := t.updateHeap()</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">if</span> !updated &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line"><span class="comment">// minWhenHeap = heap[0].when</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> updateMinWhenHeap() &#123;</span><br><span class="line">    <span class="comment">// mu加锁、STW</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// heap为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) == <span class="number">0</span> &#123;</span><br><span class="line">        ts.minWhenHeap.Store(<span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 最小堆中的最小when纪录到minWhenHeap字段</span></span><br><span class="line">        ts.minWhenHeap.Store(ts.heap[<span class="number">0</span>].when)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小堆的最小when，用于判断是否需要唤醒netpoller</span></span><br><span class="line"><span class="comment">// =&gt; min(minWhenHeap, minWhenModified)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> wakeTime() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 字段读取的顺序很关键，跟adjust函数存在并发竞态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了timerModified位的最小when</span></span><br><span class="line">    nextWhen := ts.minWhenModified.Load()</span><br><span class="line">    <span class="comment">// 最小when</span></span><br><span class="line">    when := ts.minWhenHeap.Load()</span><br><span class="line">    <span class="comment">// 最小堆为空 or nextWhen比最小when还要小</span></span><br><span class="line">    <span class="keyword">if</span> when == <span class="number">0</span> || (nextWhen != <span class="number">0</span> &amp;&amp; nextWhen &lt; when) &#123;</span><br><span class="line">        when = nextWhen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> when</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakeNetPoller</span><span class="params">(when <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 按道理，除非是第一次运行，不然这个时刻不应该为0，还没深入了解GMP调度，暂停分析</span></span><br><span class="line">    <span class="keyword">if</span> sched.lastpoll.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 预定结束时间</span></span><br><span class="line">        pollerPollUntil := sched.pollUntil.Load()</span><br><span class="line">        <span class="comment">// 当前没有网络轮询任务 or 当前的网络轮询还没有完成，可以中断当前轮询</span></span><br><span class="line">        <span class="keyword">if</span> pollerPollUntil == <span class="number">0</span> || pollerPollUntil &gt; when &#123;</span><br><span class="line">            <span class="comment">// 中断</span></span><br><span class="line">            netpollBreak()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">            wakep()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AfterFunc"><a href="#AfterFunc" class="headerlink" title="AfterFunc"></a>AfterFunc</h3><p>创建&#x2F;获取一次性定时器，与NewTimer的区别是使用了用户自定义函数，此外，该定时器是异步的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span></span>) *Timer &#123;</span><br><span class="line">    <span class="comment">// 异步定时器</span></span><br><span class="line">    <span class="keyword">return</span> (*Timer)(newTimer(when(d), <span class="number">0</span>, goFunc, f, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goFunc</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> arg.(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h3><p>创建定时器或重用当前G的定时器，把当前goroutine挂起休眠至少ns纳秒时间</p>
<ol>
<li>初始化g.timer或重用当前G的timer</li>
<li>计算过期时刻when，纪录到g.sleepWhen</li>
<li>调用modify更新定时器，将当前goroutine挂起等待唤醒</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeSleep</span><span class="params">(ns <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 时长不能为负</span></span><br><span class="line">    <span class="keyword">if</span> ns &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. g.timer设置</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    t := gp.timer</span><br><span class="line">    <span class="comment">// 确保当前goroutine的timer定时器不为nil</span></span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        t = <span class="built_in">new</span>(timer)</span><br><span class="line">        <span class="comment">// 纪录f/arg</span></span><br><span class="line">        t.init(goroutineReady, gp)</span><br><span class="line">        <span class="comment">// 测试，忽略</span></span><br><span class="line">        <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.isFake = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绑定</span></span><br><span class="line">        gp.timer = t</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. g.sleepWhen设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻-单调时钟</span></span><br><span class="line">    <span class="keyword">var</span> now <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> sg := gp.syncGroup; sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        now = sg.now</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标过期时刻</span></span><br><span class="line">    when := now + ns</span><br><span class="line">    <span class="keyword">if</span> when &lt; <span class="number">0</span> &#123;         <span class="comment">// 溢出</span></span><br><span class="line">        when = maxWhen     <span class="comment">// 设置为最大值2^63-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp.sleepWhen = when</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 挂起goroutine</span></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        resetForSleep(gp, <span class="literal">nil</span>)</span><br><span class="line">        <span class="comment">// 挂起休眠</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonSleep, traceBlockSleep, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 挂起休眠，挂起前调用resetForSleep</span></span><br><span class="line">        gopark(resetForSleep, <span class="literal">nil</span>, waitReasonSleep, traceBlockSleep, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能直接在timeSleep内部调用reset，G挂起前会有一个小的时间间隔，有竟态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetForSleep</span><span class="params">(gp *g, _ unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 调用modify函数更新when和period</span></span><br><span class="line">    gp.timer.reset(gp.sleepWhen, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="After-Tick"><a href="#After-Tick" class="headerlink" title="After &amp; Tick"></a>After &amp; Tick</h3><p>创建定时器，返回定时器的channel，属于NewTimer&#x2F;NewTicker函数的封装。go1.22及之前的版本中，如果在for循环使用After会申请大量内存，加剧GC压力</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time &#123;</span><br><span class="line">    <span class="keyword">return</span> NewTimer(d).C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tick</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time &#123;</span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NewTicker(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器相关"><a href="#定时器相关" class="headerlink" title="定时器相关"></a>定时器相关</h2><h3 id="停止定时器"><a href="#停止定时器" class="headerlink" title="停止定时器"></a>停止定时器</h3><p>停止定时器，因为定时器可能被其他P持有，只修改状态。具体逻辑如下</p>
<ol>
<li>如果是异步定时器，判断定时器是否需要触发执行函数f</li>
<li>定时器字段更新<ul>
<li>更新定时器状态state的timerZombie位</li>
<li>重置when</li>
<li>更新版本计数器</li>
<li>将状态state复制到astate上（到这里就解锁了）</li>
<li>如果是同步定时器，清空channel（t.arg）的buf缓冲区</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span></span> Stop() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="keyword">if</span> !t.initTimer &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: Stop called on uninitialized Timer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stopTimer(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span></span> Stop() &#123;</span><br><span class="line">    <span class="keyword">if</span> !t.initTicker &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    stopTimer((*Timer)(unsafe.Pointer(t)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTimer</span><span class="params">(t *timeTimer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;stop of synctest timer from outside bubble&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> stop() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是异步还是同步定时器（go1.23开始默认是同步定时器）</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        lock(&amp;t.sendLock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;stop&quot;</span>)</span><br><span class="line">    <span class="comment">// 如果是异步定时器（go1.22及以前）</span></span><br><span class="line">    <span class="keyword">if</span> async &#123;</span><br><span class="line">        <span class="comment">// 判断定时器是否需要更新timer状态，执行函数f</span></span><br><span class="line">        t.maybeRunAsync()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// timer已经在最小堆中</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 设置timerModified标志位</span></span><br><span class="line">        t.state |= timerModified</span><br><span class="line">        <span class="comment">// timer无删除标记</span></span><br><span class="line">        <span class="keyword">if</span> t.state&amp;timerZombie == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 标记为删除</span></span><br><span class="line">            t.state |= timerZombie</span><br><span class="line">            <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">            t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pending := t.when &gt; <span class="number">0</span></span><br><span class="line">    <span class="comment">// 重置when</span></span><br><span class="line">    t.when = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        <span class="comment">// 版本计数器更新</span></span><br><span class="line">        t.seq++</span><br><span class="line">        <span class="comment">// 一次性定时器 and 已经在调用函数f了</span></span><br><span class="line">        <span class="keyword">if</span> t.period == <span class="number">0</span> &amp;&amp; t.isSending.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> !async &amp;&amp; t.isChan &#123;</span><br><span class="line">        unlock(&amp;t.sendLock)</span><br><span class="line">        <span class="comment">// 清空channel（t.arg）的buf缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> timerchandrain(t.hchan()) &#123;</span><br><span class="line">            pending = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pending</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重置定时器"><a href="#重置定时器" class="headerlink" title="重置定时器"></a>重置定时器</h3><p>重置定时器，本质是modify函数调用，更新timer状态、添加到最小堆、中断网络轮询。需要先调用Stop才能确保安全调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span></span> Reset(d Duration) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !t.initTimer &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: Reset called on uninitialized Timer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    w := when(d)</span><br><span class="line">    <span class="keyword">return</span> resetTimer(t, w, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span></span> Reset(d Duration) &#123;</span><br><span class="line">    <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;non-positive interval for Ticker.Reset&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !t.initTicker &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: Reset called on uninitialized Ticker&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resetTimer((*Timer)(unsafe.Pointer(t)), when(d), <span class="type">int64</span>(d))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetTimer</span><span class="params">(t *timeTimer, when, period <span class="type">int64</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;reset of synctest timer from outside bubble&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.reset(when, period)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> reset(when, period <span class="type">int64</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询</span></span><br><span class="line">    <span class="keyword">return</span> t.modify(when, period, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小堆相关"><a href="#最小堆相关" class="headerlink" title="最小堆相关"></a>最小堆相关</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> updateHeap() (updated <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// mu加锁、STW</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;t.mu)</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;updateHeap&quot;</span>)</span><br><span class="line">    <span class="comment">// 最小堆</span></span><br><span class="line">    ts := t.ts</span><br><span class="line">    <span class="comment">// 最小堆为nil（没有初始化） or 当前定时器不是最小堆中最小的，异常</span></span><br><span class="line">    <span class="keyword">if</span> ts == <span class="literal">nil</span> || t != ts.heap[<span class="number">0</span>].timer &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// timer已标记删除</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 移除标志位</span></span><br><span class="line">        t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">        <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">        ts.zombies.Add(<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// 移除最小的timer</span></span><br><span class="line">        ts.deleteMin()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前定时器已被修改</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerModified != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 移除标志位</span></span><br><span class="line">        t.state &amp;^= timerModified</span><br><span class="line">        <span class="comment">// 更新when</span></span><br><span class="line">        ts.heap[<span class="number">0</span>].when = t.when</span><br><span class="line">        <span class="comment">// 调整最小堆，从根节点开始，一直向下交换最小的子节点</span></span><br><span class="line">        ts.siftDown(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">        ts.updateMinWhenHeap()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆重新排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> initHeap() &#123;</span><br><span class="line">    <span class="comment">// 0或1个元素，不用排序</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父节点idx =&gt; (len(heap)-1-1)/4</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">int</span>(<span class="type">uint</span>(<span class="built_in">len</span>(ts.heap)<span class="number">-1</span><span class="number">-1</span>) / timerHeapN); i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        ts.siftDown(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把timer定时器加入到timers.heap最小堆中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> addHeap(t *timer) &#123;</span><br><span class="line">    <span class="comment">// mu加锁、STW</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 确保netpoll已初始化（依赖）</span></span><br><span class="line">    <span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        netpollGenericInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer已经放到了P的timers上</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;ts set in timer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 纪录P的timers指针</span></span><br><span class="line">    t.ts = ts</span><br><span class="line">    <span class="comment">// 放到最小堆末尾</span></span><br><span class="line">    ts.heap = <span class="built_in">append</span>(ts.heap, timerWhen&#123;t, t.when&#125;)</span><br><span class="line">    <span class="comment">// 重新调整最小堆，写入timer时触发</span></span><br><span class="line">    ts.siftUp(<span class="built_in">len</span>(ts.heap) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 是同一个定时器</span></span><br><span class="line">    <span class="keyword">if</span> t == ts.heap[<span class="number">0</span>].timer &#123;</span><br><span class="line">        <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">        ts.updateMinWhenHeap()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新调整最小堆，写入timer时触发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> siftUp(i <span class="type">int</span>) &#123;</span><br><span class="line">    heap := ts.heap</span><br><span class="line">    <span class="comment">// 指针超过数组长度，异常</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(heap) &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂存当前节点</span></span><br><span class="line">    tw := heap[i]</span><br><span class="line">    when := tw.when</span><br><span class="line">    <span class="comment">// 异常值</span></span><br><span class="line">    <span class="keyword">if</span> when &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果父节点的值比当前节点的值要大，交换两者</span></span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 找父节点idx =&gt; p = (i-1) / 4</span></span><br><span class="line">        p := <span class="type">int</span>(<span class="type">uint</span>(i<span class="number">-1</span>) / timerHeapN)</span><br><span class="line">        <span class="comment">// 如果父节点的when大于等于当前节点的when，调整完毕，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> when &gt;= heap[p].when &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换父节点和当前节点</span></span><br><span class="line">        heap[i] = heap[p]</span><br><span class="line">        i = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> heap[i].timer != tw.timer &#123;</span><br><span class="line">        <span class="comment">// 一般排序完都要执行这步才对</span></span><br><span class="line">        heap[i] = tw</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新调整最小堆，移除timer时触发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> siftDown(i <span class="type">int</span>) &#123;</span><br><span class="line">    heap := ts.heap</span><br><span class="line">    <span class="comment">// 指针超过数组长度，异常</span></span><br><span class="line">    n := <span class="built_in">len</span>(heap)</span><br><span class="line">    <span class="keyword">if</span> i &gt;= n &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点idx超过数组长度</span></span><br><span class="line">    <span class="comment">// i*4+1 &gt;= n</span></span><br><span class="line">    <span class="keyword">if</span> i*timerHeapN+<span class="number">1</span> &gt;= n &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂存当前节点</span></span><br><span class="line">    tw := heap[i]</span><br><span class="line">    when := tw.when</span><br><span class="line">    <span class="comment">// 异常值</span></span><br><span class="line">    <span class="keyword">if</span> when &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果子节点的值比当前节点的值要小，交换两者</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 子节点left_idx =&gt; i*4+1</span></span><br><span class="line">        leftChild := i*timerHeapN + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> leftChild &gt;= n &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        w := when     <span class="comment">// 当前节点when</span></span><br><span class="line">        c := <span class="number">-1</span>        <span class="comment">// 节点索引</span></span><br><span class="line">        <span class="comment">// 找到子节点中最小的when</span></span><br><span class="line">        <span class="comment">// 每个节点存储最多4个数据</span></span><br><span class="line">        <span class="keyword">for</span> j, tw := <span class="keyword">range</span> heap[leftChild:min(leftChild+timerHeapN, n)] &#123;</span><br><span class="line">            <span class="keyword">if</span> tw.when &lt; w &#123;</span><br><span class="line">                w = tw.when</span><br><span class="line">                c = leftChild + j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到更小的when，退出</span></span><br><span class="line">        <span class="keyword">if</span> c &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了，交换父子节点</span></span><br><span class="line">        heap[i] = heap[c]</span><br><span class="line">        i = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> heap[i].timer != tw.timer &#123;</span><br><span class="line">        <span class="comment">// 一般排序完都要执行这步</span></span><br><span class="line">        heap[i] = tw</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除最小的timer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> deleteMin() &#123;</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 最小堆第一个</span></span><br><span class="line">    t := ts.heap[<span class="number">0</span>].timer</span><br><span class="line">    <span class="comment">// 不在同一个P上</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">        throw(<span class="string">&quot;wrong timers&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解除绑定</span></span><br><span class="line">    t.ts = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 跟最小堆最后一个元素交换</span></span><br><span class="line">    last := <span class="built_in">len</span>(ts.heap) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ts.heap[<span class="number">0</span>] = ts.heap[last]</span><br><span class="line">    &#125;</span><br><span class="line">    ts.heap[last] = timerWhen&#123;&#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    ts.heap = ts.heap[:last]</span><br><span class="line">    <span class="comment">// 重新调整最小堆</span></span><br><span class="line">    <span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ts.siftDown(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">    ts.updateMinWhenHeap()</span><br><span class="line">    <span class="comment">// 最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> last == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 将minWhen设置为0</span></span><br><span class="line">        ts.minWhenModified.Store(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="goroutine调度相关"><a href="#goroutine调度相关" class="headerlink" title="goroutine调度相关"></a>goroutine调度相关</h2><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>销毁P时，把最小堆里的timer全部迁移走</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把一个timers最小堆的timer搬到当前timers最小堆中。P销毁时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> take(src *timers) &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;take&quot;</span>)</span><br><span class="line">    <span class="comment">// STW</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line">    <span class="comment">// src最小堆不为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(src.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// STW 忽略顺序</span></span><br><span class="line">        <span class="keyword">for</span> _, tw := <span class="keyword">range</span> src.heap &#123;</span><br><span class="line">            t := tw.timer</span><br><span class="line">            <span class="comment">// 解除P绑定</span></span><br><span class="line">            t.ts = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">// timer已标记删除</span></span><br><span class="line">            <span class="keyword">if</span> t.state&amp;timerZombie != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 清理状态位（为什么要去修改它？？？）</span></span><br><span class="line">                t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 清理timerModified位</span></span><br><span class="line">                t.state &amp;^= timerModified</span><br><span class="line">                <span class="comment">// 把timer定时器加入到timers.heap最小堆中</span></span><br><span class="line">                ts.addHeap(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把整个最小堆清空了</span></span><br><span class="line">        src.heap = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 下面的统计数据也全部重置</span></span><br><span class="line">        src.zombies.Store(<span class="number">0</span>)</span><br><span class="line">        src.minWhenHeap.Store(<span class="number">0</span>)</span><br><span class="line">        src.minWhenModified.Store(<span class="number">0</span>)</span><br><span class="line">        src.<span class="built_in">len</span>.Store(<span class="number">0</span>)</span><br><span class="line">        ts.<span class="built_in">len</span>.Store(<span class="type">uint32</span>(<span class="built_in">len</span>(ts.heap)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行。调度时，寻找可运行的G时调用（findRunnable或stealWork）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理最小堆，把所有标记删除的timer都移除出最小堆，如果最小的timer到期，则执行回调函数f运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> check(now <span class="type">int64</span>) (rnow, pollUntil <span class="type">int64</span>, ran <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;check&quot;</span>)</span><br><span class="line">    <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">    next := ts.wakeTime()</span><br><span class="line">    <span class="comment">// 最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> now, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记删除的timer数量</span></span><br><span class="line">    zombies := ts.zombies.Load()</span><br><span class="line">    <span class="keyword">if</span> zombies &lt; <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前P and 标记删除的timer数量超过总量的1/4</span></span><br><span class="line">    force := ts == &amp;getg().m.p.ptr().timers &amp;&amp; <span class="type">int</span>(zombies) &gt; <span class="type">int</span>(ts.<span class="built_in">len</span>.Load())/<span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// now小于最小when（下一个定时器还没准备好运行） and 非强制</span></span><br><span class="line">    <span class="keyword">if</span> now &lt; next &amp;&amp; !force &#123;</span><br><span class="line">        <span class="keyword">return</span> now, next, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的场景是：now大于等于最小when or 强制</span></span><br><span class="line"></span><br><span class="line">    ts.lock()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 清理最小堆，并重新排序（非强制）</span></span><br><span class="line">        <span class="comment">// 那么这里需要处理的场景就是now大于等于最小when（看了adjust代码感觉跟强制也没什么区别）</span></span><br><span class="line">        ts.adjust(now, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 清理后，heap不为空</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(ts.heap) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 运行最小的timer，如果还没到时间就不执行</span></span><br><span class="line">            <span class="keyword">if</span> tw := ts.run(now); tw != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// -1或0表示最小堆为空，其他表示最小timer的运行时刻</span></span><br><span class="line">                <span class="keyword">if</span> tw &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    pollUntil = tw</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ran = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新检测</span></span><br><span class="line">        force = ts == &amp;getg().m.p.ptr().timers &amp;&amp; <span class="type">int</span>(ts.zombies.Load()) &gt; <span class="type">int</span>(ts.<span class="built_in">len</span>.Load())/<span class="number">4</span></span><br><span class="line">        <span class="keyword">if</span> force &#123;</span><br><span class="line">            <span class="comment">// 清理最小堆，并重新排序（强制）</span></span><br><span class="line">            ts.adjust(now, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ts.unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> now, pollUntil, ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理最小堆，并重新排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> adjust(now <span class="type">int64</span>, force <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;adjust&quot;</span>)</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 非强制</span></span><br><span class="line">    <span class="keyword">if</span> !force &#123;</span><br><span class="line">        <span class="comment">// 设置了timerModified位的最小when</span></span><br><span class="line">        first := ts.minWhenModified.Load()</span><br><span class="line">        <span class="comment">// 最小堆为空 or now小于最小when（下一个定时器还没准备好运行）</span></span><br><span class="line">        <span class="keyword">if</span> first == <span class="number">0</span> || first &gt; now &#123;</span><br><span class="line">            <span class="comment">// debug用，忽略</span></span><br><span class="line">            <span class="keyword">if</span> verifyTimers &#123;</span><br><span class="line">                ts.verify()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">    <span class="comment">// minWhenHeap = min(minWhenHeap, minWhenModified)</span></span><br><span class="line">    ts.minWhenHeap.Store(ts.wakeTime())</span><br><span class="line">    <span class="comment">// minWhenModified = 0</span></span><br><span class="line">    ts.minWhenModified.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描整个最小堆</span></span><br><span class="line">    changed := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ts.heap); i++ &#123;</span><br><span class="line">        tw := &amp;ts.heap[i]</span><br><span class="line">        t := tw.timer</span><br><span class="line">        <span class="comment">// 不在同一个P上</span></span><br><span class="line">        <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad ts&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有被修改也没有标记删除，无须调整</span></span><br><span class="line">        <span class="keyword">if</span> t.astate.Load()&amp;(timerModified|timerZombie) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 加锁</span></span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> t.state&amp;timerHeaped == <span class="number">0</span>:         <span class="comment">// 异常状态</span></span><br><span class="line">            badTimer()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> t.state&amp;timerZombie != <span class="number">0</span>:         <span class="comment">// timer已标记删除</span></span><br><span class="line">            <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">            ts.zombies.Add(<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">// 移除标志位</span></span><br><span class="line">            t.state &amp;^= timerHeaped | timerZombie | timerModified</span><br><span class="line">            <span class="comment">// 总数量</span></span><br><span class="line">            n := <span class="built_in">len</span>(ts.heap)</span><br><span class="line">            <span class="comment">// 当前timer跟最小堆的最后一个交换</span></span><br><span class="line">            ts.heap[i] = ts.heap[n<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// 先用空的结构替换</span></span><br><span class="line">            ts.heap[n<span class="number">-1</span>] = timerWhen&#123;&#125;</span><br><span class="line">            <span class="comment">// 移除最后一个数据</span></span><br><span class="line">            ts.heap = ts.heap[:n<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// 表示从heap上移除</span></span><br><span class="line">            t.ts = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">// 重新扫描当前位置的timer</span></span><br><span class="line">            i--</span><br><span class="line">            changed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> t.state&amp;timerModified != <span class="number">0</span>:    <span class="comment">// 已修改</span></span><br><span class="line">            <span class="comment">// 更新when</span></span><br><span class="line">            tw.when = t.when</span><br><span class="line">            <span class="comment">// 移除标志位</span></span><br><span class="line">            t.state &amp;^= timerModified</span><br><span class="line">            changed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        t.unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有调整过最小堆</span></span><br><span class="line">    <span class="keyword">if</span> changed &#123;</span><br><span class="line">        <span class="comment">// 最小堆重新排序</span></span><br><span class="line">        ts.initHeap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新minWhenHeap字段</span></span><br><span class="line">    <span class="comment">// minWhenHeap = heap[0].when</span></span><br><span class="line">    ts.updateMinWhenHeap()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    <span class="keyword">if</span> verifyTimers &#123;</span><br><span class="line">        ts.verify()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证timers是最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> verify() &#123;</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="comment">// 扫描最小堆</span></span><br><span class="line">    <span class="keyword">for</span> i, tw := <span class="keyword">range</span> ts.heap &#123;</span><br><span class="line">        <span class="comment">// 第一个timer，没有父节点</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点，p=(i-1)/4</span></span><br><span class="line">        p := <span class="type">int</span>(<span class="type">uint</span>(i<span class="number">-1</span>) / timerHeapN)</span><br><span class="line">        <span class="comment">// 子节点比父节点的值小，异常</span></span><br><span class="line">        <span class="keyword">if</span> tw.when &lt; ts.heap[p].when &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;bad timer heap at &quot;</span>, i, <span class="string">&quot;: &quot;</span>, p, <span class="string">&quot;: &quot;</span>, ts.heap[p].when, <span class="string">&quot;, &quot;</span>, i, <span class="string">&quot;: &quot;</span>, tw.when, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;bad timer heap&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// len字段验证</span></span><br><span class="line">    <span class="keyword">if</span> n := <span class="type">int</span>(ts.<span class="built_in">len</span>.Load()); <span class="built_in">len</span>(ts.heap) != n &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;timer heap len&quot;</span>, <span class="built_in">len</span>(ts.heap), <span class="string">&quot;!= atomic len&quot;</span>, n)</span><br><span class="line">        throw(<span class="string">&quot;bad timer heap len&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行最小的timer，如果还没到时间就不执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *timers)</span></span> run(now <span class="type">int64</span>) <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    ts.trace(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    <span class="comment">// ts.mu加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">Redo:</span><br><span class="line">    <span class="comment">// 最小堆为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ts.heap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个/最小timer</span></span><br><span class="line">    tw := ts.heap[<span class="number">0</span>]</span><br><span class="line">    t := tw.timer</span><br><span class="line">    <span class="comment">// 不在同一个P上，异常</span></span><br><span class="line">    <span class="keyword">if</span> t.ts != ts &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad ts&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer没有修改/标记删除 and when大于now（还没准备运行）</span></span><br><span class="line">    <span class="keyword">if</span> t.astate.Load()&amp;(timerModified|timerZombie) == <span class="number">0</span> &amp;&amp; tw.when &gt; now &#123;</span><br><span class="line">        <span class="keyword">return</span> tw.when</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 根据timer状态更新最小堆，定时器已停止则删除，定时器已修改则同步</span></span><br><span class="line">    <span class="keyword">if</span> t.updateHeap() &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">goto</span> Redo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timer不在最小堆 or 当前定时器已被修改</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped == <span class="number">0</span> || t.state&amp;timerModified != <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when大于now（还没准备运行）</span></span><br><span class="line">    <span class="keyword">if</span> t.when &gt; now &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">return</span> t.when</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">    t.unlockAndRun(now)</span><br><span class="line">    <span class="comment">// ts重新加锁</span></span><br><span class="line">    assertLockHeld(&amp;ts.mu)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timeSleepUntil"><a href="#timeSleepUntil" class="headerlink" title="timeSleepUntil"></a>timeSleepUntil</h3><p>遍历所有P，找到全局最小的when。由sysmon、checkdead函数调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历所有P，找到全局最小的when</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeSleepUntil</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 最大值2^63-1</span></span><br><span class="line">    next := <span class="type">int64</span>(maxWhen)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保allp切片不会被更改</span></span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="comment">// 遍历所有P，获取在所有P中最小的when</span></span><br><span class="line">    <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 可能在扩容，还没有创建好新的P</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最小堆的最小when</span></span><br><span class="line">        <span class="keyword">if</span> w := pp.timers.wakeTime(); w != <span class="number">0</span> &#123;</span><br><span class="line">            next = min(next, w)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="channel相关"><a href="#channel相关" class="headerlink" title="channel相关"></a>channel相关</h2><p>虽说是跟channel相关，实际上，在执行<code>&lt;-t.C</code>等待超时时，就会使用到下面的方法</p>
<h3 id="maybeRunChan"><a href="#maybeRunChan" class="headerlink" title="maybeRunChan"></a>maybeRunChan</h3><p>判断是否需要更新timer状态、执行函数f。具体逻辑如下</p>
<ol>
<li>不满足条件则返回<ul>
<li>timer已经放在最小堆上，那么过期后自动发送到channel</li>
<li>timer从未执行过</li>
<li>timer还未到触发时刻</li>
</ul>
</li>
<li>满足条件则更新timer状态、执行函数f</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line"><span class="comment">// 目前只有channel、select相关的代码在使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeRunChan() &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="keyword">var</span> timerGroup *synctestGroup</span><br><span class="line">        <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">            timerGroup = t.ts.syncGroup</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        sg := getg().syncGroup</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;synctest timer accessed from outside bubble&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> timerGroup != <span class="literal">nil</span> &amp;&amp; sg != timerGroup &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;timer moved between synctest bubbles&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果timer已经在最小堆中，过期后自动发送到channel</span></span><br><span class="line">    <span class="keyword">if</span> t.astate.Load()&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 当前时刻，单调时钟</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 加锁后double-check</span></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer从未执行过</span></span><br><span class="line">    <span class="comment">// 3. timer还未到触发时刻</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> || t.when == <span class="number">0</span> || t.when &gt; now &#123;</span><br><span class="line">        <span class="comment">// debug用，忽略</span></span><br><span class="line">        t.trace(<span class="string">&quot;maybeRunChan-&quot;</span>)</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;maybeRunChan+&quot;</span>)</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">        t.unlockAndRun(now)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="blockTimerChan-unblockTimerChan"><a href="#blockTimerChan-unblockTimerChan" class="headerlink" title="blockTimerChan &amp; unblockTimerChan"></a>blockTimerChan &amp; unblockTimerChan</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个10ms过期的定时器</span></span><br><span class="line">t := time.NewTimer(<span class="number">10</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待定时器过期信号</span></span><br><span class="line">&lt;-t.C</span><br></pre></td></tr></table></figure>

<p>上述示例代码，如果这个channel是属于一个定时器的，那么在G挂起前、唤醒后，需要修改定时器的state-状态、blocked-标记等。函数详细注释如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// G挂起休眠之前，将定时器标记为阻塞并加入最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;blockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer已标记删除</span></span><br><span class="line">    <span class="comment">// 3. 过期时刻大于0</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie != <span class="number">0</span> &amp;&amp; t.when &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t.state &amp;^= timerZombie    <span class="comment">// 移除标志位</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">-1</span>)    <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要把定时器放到最小堆</span></span><br><span class="line">    add := t.needsAdd()</span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line">        t.maybeAdd()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G唤醒后，将定时器标记为非阻塞、删除状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unblockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;unblockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器 or 计数器为0，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan || t.blocked == <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器为0 and timer已经在最小堆中 and timer无删除标记</span></span><br><span class="line">    <span class="keyword">if</span> t.blocked == <span class="number">0</span> &amp;&amp; t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 标记为删除</span></span><br><span class="line">        t.state |= timerZombie</span><br><span class="line">        <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器示例解析"><a href="#定时器示例解析" class="headerlink" title="定时器示例解析"></a>定时器示例解析</h2><ol>
<li>创建定时器</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t := time.NewTimer(<span class="number">2</span> * time.Second) <span class="comment">// 调用NewTimer(2 * time.Second)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次创建timer，执行newTimer，此时不会触发任何其他函数操作，包括添加到最小堆等。</span></span><br><span class="line"><span class="comment">// timer数据初始化后，各字段数值如下</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//     |---------------------------------|</span></span><br><span class="line"><span class="comment">//     v                                 |</span></span><br><span class="line"><span class="comment">// timer.mu                         channel.timer</span></span><br><span class="line"><span class="comment">//      .f          =&gt; sendTime          ^</span></span><br><span class="line"><span class="comment">//      .arg        =&gt; *channel     -----|</span></span><br><span class="line"><span class="comment">//      .seq        =&gt; 1</span></span><br><span class="line"><span class="comment">//      .sendLock</span></span><br><span class="line"><span class="comment">//      .isChan     =&gt; true</span></span><br><span class="line"><span class="comment">//      .period     =&gt; 0</span></span><br><span class="line"><span class="comment">//      .when       =&gt; xyz</span></span><br><span class="line"><span class="comment">//      .state      =&gt; 0</span></span><br><span class="line"><span class="comment">//      .astate     =&gt; 0</span></span><br><span class="line"><span class="comment">//      .init       =&gt; true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当前G挂起等待</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;-t.C    <span class="comment">// 调用chanrecv函数，内部调用blockTimerChan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将timer放到最小堆</span></span><br><span class="line"><span class="comment">// timers.heap                        |---------------------------------|</span></span><br><span class="line"><span class="comment">//          |                         v                                 |</span></span><br><span class="line"><span class="comment">//  | timer0 | ... | timerx |  &lt;-- timer.mu                         channel.timer</span></span><br><span class="line"><span class="comment">//                                      .f          =&gt; sendTime          ^</span></span><br><span class="line"><span class="comment">//                                      .arg        =&gt; *channel     -----|</span></span><br><span class="line"><span class="comment">//                                      .seq        =&gt; 1</span></span><br><span class="line"><span class="comment">//                                      .sendLock</span></span><br><span class="line"><span class="comment">//                                      .isChan     =&gt; true</span></span><br><span class="line"><span class="comment">//                                      .period     =&gt; 0</span></span><br><span class="line"><span class="comment">//                                      .when       =&gt; xyz</span></span><br><span class="line"><span class="comment">//                                      .state      =&gt; 1</span></span><br><span class="line"><span class="comment">//                                      .astate     =&gt; 1(timerHeaped)</span></span><br><span class="line"><span class="comment">//                                      .init       =&gt; true</span></span><br><span class="line"><span class="comment">//                                      .blocked    =&gt; 1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定时器到期通知</li>
</ol>
<p>GMP调度执行findRunnable或stealWork，发现定时器过期，发送信号给channel，唤醒goroutine，流程如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sched -&gt; findRunnable -&gt; check -&gt; unlockAndRun -&gt; sendTime</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>当前G唤醒继续执行</li>
</ol>
<p>当前G唤醒后，调用unblockTimerChan</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行unblockTimerChan后，timer的数据状态大概如下</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//     |---------------------------------|</span></span><br><span class="line"><span class="comment">//     v                                 |</span></span><br><span class="line"><span class="comment">// timer.mu                         channel.timer</span></span><br><span class="line"><span class="comment">//      .f          =&gt; sendTime          ^</span></span><br><span class="line"><span class="comment">//      .arg        =&gt; *channel     -----|</span></span><br><span class="line"><span class="comment">//      .seq        =&gt; 1</span></span><br><span class="line"><span class="comment">//      .sendLock</span></span><br><span class="line"><span class="comment">//      .isChan     =&gt; true</span></span><br><span class="line"><span class="comment">//      .period     =&gt; 0</span></span><br><span class="line"><span class="comment">//      .when       =&gt; xyz(&lt;=now)</span></span><br><span class="line"><span class="comment">//      .state      =&gt; 0</span></span><br><span class="line"><span class="comment">//      .astate     =&gt; 5(timerHeaped|timerZombie)</span></span><br><span class="line"><span class="comment">//      .init       =&gt; true</span></span><br><span class="line"><span class="comment">//      .blocked    =&gt; 0</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://antonz.org/timer-reset/">Resetting timers in Go</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-netpoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-netpoll/" class="post-title-link" itemprop="url">golang系列之-netpoll</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-27 08:48:14 / 修改时间：17:24:14" itemprop="dateCreated datePublished" datetime="2025-02-27T08:48:14+08:00">2025-02-27</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>netpoll是golang用来处理网络I&#x2F;O事件的底层机制，主要通过操作系统的I&#x2F;O多路复用机制如Linux的epoll、BSD的kqueue、Windows的IOCP等来实现</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>核心的数据结构是pollDesc，用于存储与文件描述符相关的事件数据，一般被放入如epoll的epoll_event.data来传递信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">    _          sys.NotInHeap    <span class="comment">// 放置转换成interface&#123;&#125;时申请heap内存</span></span><br><span class="line">    link       *pollDesc        <span class="comment">// next指针，用于pollcache链表</span></span><br><span class="line">    fd         <span class="type">uintptr</span>          <span class="comment">// 文件描述符</span></span><br><span class="line">    fdseq      atomic.Uintptr   <span class="comment">// 计数器，类似时间戳，确保过期的消息不会被处理，只在获取/放回cache时改变</span></span><br><span class="line">    atomicInfo atomic.Uint32    <span class="comment">// 5个状态位+fdseq（这两个数据有位交叉冲突，没搞懂）</span></span><br><span class="line">    rg         atomic.Uintptr   <span class="comment">// 读状态，读G的地址也作为一种状态</span></span><br><span class="line">    wg         atomic.Uintptr   <span class="comment">// 写状态，写G的地址也作为一种状态</span></span><br><span class="line">    lock       mutex            <span class="comment">// 锁，保护下列字段</span></span><br><span class="line">    closing    <span class="type">bool</span>             <span class="comment">// 是否被移除出netpoll</span></span><br><span class="line">    rrun       <span class="type">bool</span>             <span class="comment">// rt-读定时器是否在运行</span></span><br><span class="line">    wrun       <span class="type">bool</span>             <span class="comment">// wt-写定时器是否在运行</span></span><br><span class="line">    user       <span class="type">uint32</span>           <span class="comment">// cookie，linux/bsd应该没用到</span></span><br><span class="line">    rseq       <span class="type">uintptr</span>          <span class="comment">// 读计数器，类似fdseq，只有获取/放回cache以及设置deadline时改变</span></span><br><span class="line">    rt         timer            <span class="comment">// 读定时器</span></span><br><span class="line">    rd         <span class="type">int64</span>            <span class="comment">// 读过期时刻，-1为已过期</span></span><br><span class="line">    wseq       <span class="type">uintptr</span>          <span class="comment">// 写计数器，类似fdseq，只有获取/放回cache以及设置deadline时改变</span></span><br><span class="line">    wt         timer            <span class="comment">// 写定时器</span></span><br><span class="line">    wd         <span class="type">int64</span>            <span class="comment">// 写过期时刻，-1为已过期</span></span><br><span class="line">    self       *pollDesc        <span class="comment">// 当前实例指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pollDesc缓存，重复使用，避免反复申请内存</span></span><br><span class="line"><span class="keyword">type</span> pollCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock  mutex                 <span class="comment">// 锁</span></span><br><span class="line">    first *pollDesc             <span class="comment">// 链表头部指针，pollDesc指针都从头部写入 new -&gt; old -&gt; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pollDesc部份字段讲解如下</p>
<ol>
<li><code>atomicInfo</code>是一个无符号32位整型数，每位用途如下</li>
</ol>
<table>
<thead>
<tr>
<th align="left">16bit</th>
<th align="left">11bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
<th align="left">1bit</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fdseq</td>
<td align="left">unused</td>
<td align="left">pollFDSeq</td>
<td align="left">pollExpiredWriteDeadline</td>
<td align="left">pollExpiredReadDeadline</td>
<td align="left">pollEventErr</td>
<td align="left">pollClosing</td>
</tr>
</tbody></table>
<p><em>注意</em>：fdseq占据20位数据，但在atomicInfo里，fdseq要向左移位16位，看起来是数据丢失了，没搞明白。同样有问题的还有taggedPointerPack</p>
<ol start="2">
<li><code>rg</code>和<code>wg</code>的状态列表如下</li>
</ol>
<table>
<thead>
<tr>
<th align="left">state_name</th>
<th align="left">state_val</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pdNil</td>
<td align="left">0</td>
<td align="left">默认值</td>
</tr>
<tr>
<td align="left">pdReady</td>
<td align="left">1</td>
<td align="left">io可读，下一个状态是pdNil</td>
</tr>
<tr>
<td align="left">pdWait</td>
<td align="left">2</td>
<td align="left">准备挂起，下一个状态是G pointer-挂起，pdReady-io可读，pdNil-超时&#x2F;关闭</td>
</tr>
<tr>
<td align="left">G pointer</td>
<td align="left">0xabc</td>
<td align="left">goroutine指针-挂起，下一个状态是pdReady-io可读，pdNil-超时&#x2F;关闭</td>
</tr>
</tbody></table>
<h2 id="netpoll初始化"><a href="#netpoll初始化" class="headerlink" title="netpoll初始化"></a>netpoll初始化</h2><p>初始化与netpoll有关的底层资源，如epoll实例、eventfd实例等，用sync.Once限制只执行一次。逻辑如下</p>
<ol>
<li>通用&#x2F;平台无关<ul>
<li>初始化锁，包括netpollInitLock、pollcache.lock</li>
<li>如果netpollInited为0，执行平台相关初始化，最后netpollInited设为1</li>
</ul>
</li>
<li>平台相关(linux-epoll)<ul>
<li>生成epoll实例</li>
<li>生成eventfd实例、封装epoll事件数据</li>
<li>将文件描述符eventfd和事件数据添加到epoll实例</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="comment">// src/runtime/netpoll.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    netpollInitLock mutex           <span class="comment">// netpoll初始化锁</span></span><br><span class="line">    netpollInited   atomic.Uint32   <span class="comment">// 判断netpoll是否已初始化</span></span><br><span class="line"></span><br><span class="line">    pollcache      pollCache        <span class="comment">// pollDesc链表</span></span><br><span class="line">    netpollWaiters atomic.Uint32    <span class="comment">// 挂起的goroutine数量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器链接为internal/poll.runtime_pollServerInit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollServerInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    netpollGenericInit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// netpoll初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollGenericInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        lockInit(&amp;netpollInitLock, lockRankNetpollInit)</span><br><span class="line">        lockInit(&amp;pollcache.lock, lockRankPollCache)</span><br><span class="line">        lock(&amp;netpollInitLock)</span><br><span class="line">        <span class="comment">// 加锁后double-check</span></span><br><span class="line">        <span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 调用平台相关实现，如linux-epoll</span></span><br><span class="line">            netpollinit()</span><br><span class="line">            <span class="comment">// 0 -&gt; 1（已初始化）</span></span><br><span class="line">            netpollInited.Store(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;netpollInitLock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台相关-linux/epoll</span></span><br><span class="line"><span class="comment">// src/runtime/netpoll_epoll.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    epfd           <span class="type">int32</span>         = <span class="number">-1</span> <span class="comment">// epoll实例</span></span><br><span class="line">    netpollEventFd <span class="type">uintptr</span>            <span class="comment">// eventfd实例</span></span><br><span class="line">    netpollWakeSig atomic.Uint32      <span class="comment">// 标志，防止重复调用netpollBreak</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> errno <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// 1. 创建epoll实例</span></span><br><span class="line">    <span class="comment">// EPOLL_CLOEXEC =&gt; 安全设置，fork()创建子进程或exec()执行新程序时，关闭epoll实例</span></span><br><span class="line">    epfd, errno = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: epollcreate failed with&quot;</span>, errno)</span><br><span class="line">        throw(<span class="string">&quot;runtime: netpollinit failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建eventfd实例</span></span><br><span class="line">    <span class="comment">// 2.1. 创建eventfd文件描述符</span></span><br><span class="line">    <span class="comment">// 0 =&gt; 计数器初始值，如果为0，epollWait时会阻塞住</span></span><br><span class="line">    <span class="comment">// EPOLL_CLOEXEC =&gt; 执行exec()时，关闭efd</span></span><br><span class="line">    <span class="comment">// EFD_NONBLOCK  =&gt; 非阻塞</span></span><br><span class="line">    efd, errno := syscall.Eventfd(<span class="number">0</span>, syscall.EFD_CLOEXEC|syscall.EFD_NONBLOCK)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: eventfd failed with&quot;</span>, -errno)</span><br><span class="line">        throw(<span class="string">&quot;runtime: eventfd failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2. 创建epoll事件</span></span><br><span class="line">    <span class="comment">// EPOLLIN =&gt; 可读时通知</span></span><br><span class="line">	<span class="comment">// 默认水平触发</span></span><br><span class="line">    ev := syscall.EpollEvent&#123;</span><br><span class="line">        Events: syscall.EPOLLIN,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 事件元数据绑定</span></span><br><span class="line">    <span class="comment">// efd指针存储在netpollEventFd，最后再存储于Data</span></span><br><span class="line">    *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.Data)) = &amp;netpollEventFd</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将eventfd文件描述符efd加入epoll实例epfd</span></span><br><span class="line">    errno = syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, efd, &amp;ev)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: epollctl failed with&quot;</span>, errno)</span><br><span class="line">        throw(<span class="string">&quot;runtime: epollctl failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    netpollEventFd = <span class="type">uintptr</span>(efd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll添加文件描述符"><a href="#netpoll添加文件描述符" class="headerlink" title="netpoll添加文件描述符"></a>netpoll添加文件描述符</h2><p>将一个文件描述符（FD）或网络连接添加到I&#x2F;O事件多路复用系统中，使其能够被监听，以便在该文件描述符上发生事件时被唤醒并进行相应处理。逻辑如下</p>
<ol>
<li>生成&#x2F;初始化事件元数据pd<ul>
<li>确保rg&#x2F;wg重置为pdNil</li>
<li>fdseq默认为1</li>
<li>更新atomicInfo错误标志</li>
<li>rd&#x2F;wd过期时刻设置为0，rseq&#x2F;wseq计数器更新</li>
<li>绑定self</li>
<li>重新更新atomicInfo</li>
</ul>
</li>
<li>将文件描述符、事件数据添加到epoll实例（平台相关）</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> (*pollDesc, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 生成/初始化事件元数据</span></span><br><span class="line">    pd := pollcache.alloc()</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    wg := pd.wg.Load()</span><br><span class="line">    <span class="keyword">if</span> wg != pdNil &amp;&amp; wg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked write on free polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    rg := pd.rg.Load()</span><br><span class="line">    <span class="keyword">if</span> rg != pdNil &amp;&amp; rg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked read on free polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pd.fd = fd</span><br><span class="line">    <span class="keyword">if</span> pd.fdseq.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 修改fdseq，0-特殊用途，不能使用</span></span><br><span class="line">        pd.fdseq.Store(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pd.closing = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 更新atomicInfo错误标志</span></span><br><span class="line">    pd.setEventErr(<span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    pd.rseq++</span><br><span class="line">    pd.rg.Store(pdNil)</span><br><span class="line">    pd.rd = <span class="number">0</span></span><br><span class="line">    pd.wseq++</span><br><span class="line">    pd.wg.Store(pdNil)</span><br><span class="line">    pd.wd = <span class="number">0</span></span><br><span class="line">    pd.self = pd</span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将fd加入epoll实例（平台相关）</span></span><br><span class="line">    errno := netpollopen(fd, pd)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        pollcache.free(pd)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="type">int</span>(errno)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回事件元数据、错误代码</span></span><br><span class="line">    <span class="keyword">return</span> pd, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台相关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建epoll事件</span></span><br><span class="line">    <span class="comment">// 1.1. 参数解读如下</span></span><br><span class="line">    <span class="comment">// EPOLLIN      =&gt; 可读</span></span><br><span class="line">    <span class="comment">// EPOLLOUT     =&gt; 可写</span></span><br><span class="line">    <span class="comment">// EPOLLRDHUP   =&gt; 连接被对端关闭（tcp服务器）</span></span><br><span class="line">    <span class="comment">// EPOLLET      =&gt; 边缘触发模式</span></span><br><span class="line">    <span class="keyword">var</span> ev syscall.EpollEvent</span><br><span class="line">    ev.Events = syscall.EPOLLIN | syscall.EPOLLOUT | syscall.EPOLLRDHUP | syscall.EPOLLET</span><br><span class="line">    <span class="comment">// 1.2. 将事件元数据pd组装成带标签的指针</span></span><br><span class="line">    <span class="comment">// pd指针放高48位，fdseq放低19位，这里交叉的3个位没搞懂</span></span><br><span class="line">    tp := taggedPointerPack(unsafe.Pointer(pd), pd.fdseq.Load())</span><br><span class="line">    <span class="comment">// 1.3. 绑定</span></span><br><span class="line">    *(*taggedPointer)(unsafe.Pointer(&amp;ev.Data)) = tp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将文件描述符fd加入epfd实例</span></span><br><span class="line">    <span class="keyword">return</span> syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个可用的事件元数据pollDesc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> alloc() *pollDesc &#123;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 链表为空</span></span><br><span class="line">    <span class="keyword">if</span> c.first == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> pdSize = unsafe.Sizeof(pollDesc&#123;&#125;)</span><br><span class="line">        <span class="comment">// n=4096/280=14</span></span><br><span class="line">        n := pollBlockSize / pdSize</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            n = <span class="number">1</span> <span class="comment">// 最低为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次性申请14个pollDesc的内存</span></span><br><span class="line">        <span class="comment">// 注意：这里必须位于非GC内存区域，epoll/queue内部使用</span></span><br><span class="line">        mem := persistentalloc(n*pdSize, <span class="number">0</span>, &amp;memstats.other_sys)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">            pd := (*pollDesc)(add(mem, i*pdSize))</span><br><span class="line">            lockInit(&amp;pd.lock, lockRankPollDesc)</span><br><span class="line">            pd.rt.init(<span class="literal">nil</span>, <span class="literal">nil</span>) <span class="comment">// 读定时器初始化</span></span><br><span class="line">            pd.wt.init(<span class="literal">nil</span>, <span class="literal">nil</span>) <span class="comment">// 写定时器初始化</span></span><br><span class="line">            pd.link = c.first    <span class="comment">// 放到cache链表</span></span><br><span class="line">            c.first = pd</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿链表头部第一个pollDesc</span></span><br><span class="line">    pd := c.first</span><br><span class="line">    c.first = pd.link</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> pd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把事件元数据pollDesc放到pollCache，留待后续使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> free(pd *pollDesc) &#123;</span><br><span class="line">    <span class="comment">// pd不能被共享</span></span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fdseq++，确保pd状态不会被设置为ready</span></span><br><span class="line">    fdseq := pd.fdseq.Load()</span><br><span class="line">    fdseq = (fdseq + <span class="number">1</span>) &amp; (<span class="number">1</span>&lt;&lt;taggedPointerBits - <span class="number">1</span>) <span class="comment">// fdseq++，保留低19位</span></span><br><span class="line">    pd.fdseq.Store(fdseq)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line"></span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把pollDesc放回cache链表的头部</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    pd.link = c.first</span><br><span class="line">    c.first = pd</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新atomicInfo错误标志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> setEventErr(b <span class="type">bool</span>, seq <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// fdseq1 =&gt; 参数值，只保留低20位</span></span><br><span class="line">    mSeq := <span class="type">uint32</span>(seq &amp; pollFDSeqMask)</span><br><span class="line">    <span class="comment">// 获取atomicInfo</span></span><br><span class="line">    x := pd.atomicInfo.Load()</span><br><span class="line">    <span class="comment">// fdseq2 =&gt; 事件元数据存储，atomicInfo丢弃低16位后再保留低20位</span></span><br><span class="line">    xSeq := (x &gt;&gt; pollFDSeq) &amp; pollFDSeqMask</span><br><span class="line">    <span class="comment">// 两者不相等</span></span><br><span class="line">    <span class="keyword">if</span> seq != <span class="number">0</span> &amp;&amp; xSeq != mSeq &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新错误标志失败时重试</span></span><br><span class="line">    <span class="comment">// 1. atomicInfo的错误标志跟b不同，表示错误标志变更</span></span><br><span class="line">    <span class="comment">// 2. 取反错误标志失败</span></span><br><span class="line">    <span class="keyword">for</span> (x&amp;pollEventErr != <span class="number">0</span>) != b &amp;&amp; !pd.atomicInfo.CompareAndSwap(x, x^pollEventErr) &#123;</span><br><span class="line">        <span class="comment">// 逻辑同上，这里应为double-check</span></span><br><span class="line">        x = pd.atomicInfo.Load()</span><br><span class="line">        xSeq := (x &gt;&gt; pollFDSeq) &amp; pollFDSeqMask</span><br><span class="line">        <span class="keyword">if</span> seq != <span class="number">0</span> &amp;&amp; xSeq != mSeq &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新atomicInfo字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> publishInfo() &#123;</span><br><span class="line">    <span class="keyword">var</span> info <span class="type">uint32</span></span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123; <span class="comment">// fd被移除出netpoll</span></span><br><span class="line">        info |= pollClosing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.rd &lt; <span class="number">0</span> &#123;  <span class="comment">// 读过期时刻，-1为已过期</span></span><br><span class="line">        info |= pollExpiredReadDeadline</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.wd &lt; <span class="number">0</span> &#123;  <span class="comment">// 写过期时刻，-1为已过期</span></span><br><span class="line">        info |= pollExpiredWriteDeadline</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fdseq低20位放到info高16位，没搞懂</span></span><br><span class="line">    info |= <span class="type">uint32</span>(pd.fdseq.Load()&amp;pollFDSeqMask) &lt;&lt; pollFDSeq</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧info</span></span><br><span class="line">    x := pd.atomicInfo.Load()</span><br><span class="line">    <span class="comment">// 旧info的错误标志位纪录到新的info，然后替换</span></span><br><span class="line">    <span class="keyword">for</span> !pd.atomicInfo.CompareAndSwap(x, (x&amp;pollEventErr)|info) &#123;</span><br><span class="line">        x = pd.atomicInfo.Load()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll移除文件描述符"><a href="#netpoll移除文件描述符" class="headerlink" title="netpoll移除文件描述符"></a>netpoll移除文件描述符</h2><p>将不再需要监听的文件描述符或网络连接从事件轮询中移除，以释放资源并停止对该描述符的轮询。逻辑如下</p>
<ol>
<li>guard，确认无异常情况</li>
<li>调用平台相关实现，如epoll实例，删除目标文件描述符fd</li>
<li>事件元数据清理<ul>
<li>fdseq++，确保pd状态不会被设置为ready</li>
<li>更新atomicInfo字段</li>
<li>把pd事件元数据放到cache链表的头部</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="comment">// 彻底删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollClose</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要先调用poll_runtime_pollUnblock</span></span><br><span class="line">    <span class="keyword">if</span> !pd.closing &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: close polldesc w/o unblock&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写G/读G状态异常</span></span><br><span class="line">    wg := pd.wg.Load()</span><br><span class="line">    <span class="keyword">if</span> wg != pdNil &amp;&amp; wg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked write on closing polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    rg := pd.rg.Load()</span><br><span class="line">    <span class="keyword">if</span> rg != pdNil &amp;&amp; rg != pdReady &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: blocked read on closing polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// epoll删除fd</span></span><br><span class="line">    netpollclose(pd.fd)</span><br><span class="line">    <span class="comment">// 把pollDesc放回cache链表</span></span><br><span class="line">    pollcache.free(pd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台相关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollclose</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ev syscall.EpollEvent</span><br><span class="line">    <span class="comment">// EPOLL_CTL_DEL =&gt; 删除</span></span><br><span class="line">    <span class="keyword">return</span> syscall.EpollCtl(epfd, syscall.EPOLL_CTL_DEL, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll轮询事件"><a href="#netpoll轮询事件" class="headerlink" title="netpoll轮询事件"></a>netpoll轮询事件</h2><p>通常由调度器触发，轮询所有的I&#x2F;O事件并唤醒相应的goroutine。与netpollBreak搭配使用，目前用在findRunnable、startTheWorldWithSema、pollWork、sysmon函数。具体逻辑如下</p>
<ol>
<li>计算等待事件waitms</li>
<li>调用syscall.EpollWait来等待事件<ul>
<li>异常情况中断轮询</li>
<li>被中断，重新执行</li>
</ul>
</li>
<li>遍历所有发生的事件<ul>
<li>如果Events为0，跳过</li>
<li>如果是eventfd事件，检查类型、读取事件数据并重置事件标志</li>
<li>其他事件<ul>
<li>检查事件类型是读&#x2F;写</li>
<li>通过fdseq和tag判断是否已处理</li>
<li>调用netpollready处理事件</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>参数delay的说明如下</p>
<table>
<thead>
<tr>
<th align="left">delay</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt;0</td>
<td align="left">永久阻塞，从代码看，没用到</td>
</tr>
<tr>
<td align="left">&#x3D;0</td>
<td align="left">非阻塞，轮训</td>
</tr>
<tr>
<td align="left">&gt;0</td>
<td align="left">阻塞delay时长，单位ms</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平台相关，不通用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> (gList, <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保epoll已初始化</span></span><br><span class="line">    <span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gList&#123;&#125;, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算等待时间（epoll需要毫秒）</span></span><br><span class="line">    <span class="keyword">var</span> waitms <span class="type">int32</span></span><br><span class="line">    <span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;              <span class="comment">// 无限等待</span></span><br><span class="line">        waitms = <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> delay == <span class="number">0</span> &#123;      <span class="comment">// 立刻返回，非阻塞</span></span><br><span class="line">        waitms = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e6</span> &#123;     <span class="comment">// 等待 1 毫秒</span></span><br><span class="line">        waitms = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e15</span> &#123;    <span class="comment">// 转换为毫秒</span></span><br><span class="line">        waitms = <span class="type">int32</span>(delay / <span class="number">1e6</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 超过最大值1e15，设置1e9，约为11.5天</span></span><br><span class="line">        waitms = <span class="number">1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 128个事件</span></span><br><span class="line">    <span class="keyword">var</span> events [<span class="number">128</span>]syscall.EpollEvent</span><br><span class="line">retry:</span><br><span class="line">    n, errno := syscall.EpollWait(epfd, events[:], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">    <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> errno != _EINTR &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: epollwait on fd&quot;</span>, epfd, <span class="string">&quot;failed with&quot;</span>, errno)</span><br><span class="line">            throw(<span class="string">&quot;runtime: netpoll failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被中断，重新执行</span></span><br><span class="line">        <span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gList&#123;&#125;, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> retry</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 待执行的 goroutines 列表</span></span><br><span class="line">    <span class="keyword">var</span> toRun gList</span><br><span class="line">    <span class="comment">// 累计处理事件</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 遍历所有发生的事件</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        ev := events[i]</span><br><span class="line">        <span class="comment">// 跳过，一般不为0</span></span><br><span class="line">        <span class="keyword">if</span> ev.Events == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// eventfd</span></span><br><span class="line">        <span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.Data)) == &amp;netpollEventFd &#123;</span><br><span class="line">            <span class="comment">// 是否可读</span></span><br><span class="line">            <span class="keyword">if</span> ev.Events != syscall.EPOLLIN &#123;</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;runtime: netpoll: eventfd ready for&quot;</span>, ev.Events)</span><br><span class="line">                throw(<span class="string">&quot;runtime: netpoll: eventfd ready for something unexpected&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> delay != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 读取事件数据</span></span><br><span class="line">                <span class="keyword">var</span> one <span class="type">uint64</span></span><br><span class="line">                read(<span class="type">int32</span>(netpollEventFd), noescape(unsafe.Pointer(&amp;one)), <span class="type">int32</span>(unsafe.Sizeof(one)))</span><br><span class="line">                <span class="comment">// 重置</span></span><br><span class="line">                netpollWakeSig.Store(<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他fd</span></span><br><span class="line">        <span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line">        <span class="comment">// 可读</span></span><br><span class="line">        <span class="keyword">if</span> ev.Events&amp;(syscall.EPOLLIN|syscall.EPOLLRDHUP|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">            mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可写</span></span><br><span class="line">        <span class="keyword">if</span> ev.Events&amp;(syscall.EPOLLOUT|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">            mode += <span class="string">&#x27;w&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 获取pollDesc以及fdseq</span></span><br><span class="line">            tp := *(*taggedPointer)(unsafe.Pointer(&amp;ev.Data))</span><br><span class="line">            pd := (*pollDesc)(tp.pointer()) <span class="comment">// *pollDesc</span></span><br><span class="line">            tag := tp.tag()                 <span class="comment">// fdseq</span></span><br><span class="line">            <span class="comment">// 只在获取/放回cache时改变</span></span><br><span class="line">            <span class="comment">// 如果fdseq不同，那么可能是过期的或重复使用的*pollDesc</span></span><br><span class="line">            <span class="keyword">if</span> pd.fdseq.Load() == tag &#123;</span><br><span class="line">                <span class="comment">// 更新atomicInfo错误标志</span></span><br><span class="line">                pd.setEventErr(ev.Events == syscall.EPOLLERR, tag)</span><br><span class="line">                <span class="comment">// 调用netpollready处理事件</span></span><br><span class="line">                delta += netpollready(&amp;toRun, pd, mode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toRun, delta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒goroutine，数据已经可读/可写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> rg, wg *g</span><br><span class="line">    <span class="comment">// 1. 唤醒goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rg/wg状态修改</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">true</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将唤醒的goroutine放到toRun列表</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        toRun.push(rg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        toRun.push(wg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累计唤醒的goroutine数量</span></span><br><span class="line">    <span class="keyword">return</span> delta</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rg/wg状态修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollunblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, ioready <span class="type">bool</span>, delta *<span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">    <span class="comment">// 读G/写G</span></span><br><span class="line">    gpp := &amp;pd.rg</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        gpp = &amp;pd.wg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pdReady/G pointer -&gt; pdReady</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := gpp.Load()</span><br><span class="line">        <span class="comment">// 已经是pdReady状态</span></span><br><span class="line">        <span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断io是否可读/写，超时/取消由runtime_pollWait负责判断</span></span><br><span class="line">        <span class="keyword">if</span> old == pdNil &amp;&amp; !ioready &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">new</span> := pdNil        <span class="comment">// 解除等待</span></span><br><span class="line">        <span class="keyword">if</span> ioready &#123;</span><br><span class="line">            <span class="built_in">new</span> = pdReady   <span class="comment">// 读/写就绪</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">if</span> gpp.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> old == pdWait &#123;          <span class="comment">// pdWait</span></span><br><span class="line">                old = pdNil</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> old != pdNil &#123;    <span class="comment">// G pointer</span></span><br><span class="line">                *delta -= <span class="number">1</span>             <span class="comment">// 挂起数量减一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (*g)(unsafe.Pointer(old))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打破当前I-O轮询循环"><a href="#打破当前I-O轮询循环" class="headerlink" title="打破当前I&#x2F;O轮询循环"></a>打破当前I&#x2F;O轮询循环</h2><p>打破当前的I&#x2F;O轮询循环，使得正在等待I&#x2F;O事件的goroutine能够被唤醒。与netpoll方法搭配使用，目前用在findRunnable和wakeNetPoller函数。具体逻辑如下</p>
<ol>
<li>guard，放置重复调用netpollBreak</li>
<li>中断信号准备</li>
<li>更新eventfd计数器，此时计数器的值不为0，epollWait被中断</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 防重验证</span></span><br><span class="line">    <span class="comment">// 标志为1，表示有其他G在执行当前函数</span></span><br><span class="line">    <span class="keyword">if</span> !netpollWakeSig.CompareAndSwap(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 数据准备</span></span><br><span class="line">    <span class="comment">// 中断信号数据</span></span><br><span class="line">    <span class="keyword">var</span> one <span class="type">uint64</span> = <span class="number">1</span></span><br><span class="line">    oneSize := <span class="type">int32</span>(unsafe.Sizeof(one))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发出信号，中断netpoll方法</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 更新eventfd计数器，此时计数器的值不为0，epollWait被中断</span></span><br><span class="line">        n := write(netpollEventFd, noescape(unsafe.Pointer(&amp;one)), oneSize)</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        <span class="keyword">if</span> n == oneSize &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被中断</span></span><br><span class="line">        <span class="keyword">if</span> n == -_EINTR &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 资源暂时不可用，如写缓冲区满</span></span><br><span class="line">        <span class="keyword">if</span> n == -_EAGAIN &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他异常</span></span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;runtime: netpollBreak write failed with&quot;</span>, -n)</span><br><span class="line">        throw(<span class="string">&quot;runtime: netpollBreak write failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为将要挂起的G设置超时"><a href="#为将要挂起的G设置超时" class="headerlink" title="为将要挂起的G设置超时"></a>为将要挂起的G设置超时</h2><p>通常在调用poll_runtime_pollWait之前使用，设置一个具体的超时时间，确保挂起的I&#x2F;O操作能够在指定的时间内完成。具体逻辑如下</p>
<ol>
<li>guard，已被移除出netpoll不处理</li>
<li>计算读&#x2F;写定时器新过期时刻、更新atomicInfo状态</li>
<li>修改读&#x2F;写定时器</li>
<li>rg&#x2F;wg状态修改，如果有读G&#x2F;写G需要唤醒，则唤醒并更新netpollWaiters计数器</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="type">int64</span>, mode <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 已被移除出netpoll</span></span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123;</span><br><span class="line">        unlock(&amp;pd.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取读G/写G旧过期时刻</span></span><br><span class="line">    rd0, wd0 := pd.rd, pd.wd</span><br><span class="line">    <span class="comment">// 是否读写都设置同一个过期时刻</span></span><br><span class="line">    combo0 := rd0 &gt; <span class="number">0</span> &amp;&amp; rd0 == wd0</span><br><span class="line">    <span class="keyword">if</span> d &gt; <span class="number">0</span> &#123;</span><br><span class="line">        d += nanotime()     <span class="comment">// 获取过期时刻-单调时钟</span></span><br><span class="line">        <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            d = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>   <span class="comment">// 溢出时设为最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置读G/写G新过期时刻</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        pd.rd = d</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        pd.wd = d</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line"></span><br><span class="line">    combo := pd.rd &gt; <span class="number">0</span> &amp;&amp; pd.rd == pd.wd</span><br><span class="line">    <span class="comment">// 选择定时器过期时触发的函数</span></span><br><span class="line">    rtf := netpollReadDeadline</span><br><span class="line">    <span class="keyword">if</span> combo &#123;</span><br><span class="line">        rtf = netpollDeadline</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读/写过期定时器是否在运行</span></span><br><span class="line">    <span class="keyword">if</span> !pd.rrun &#123;</span><br><span class="line">        <span class="comment">// 没有运行rt</span></span><br><span class="line">        <span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间</span></span><br><span class="line">            pd.rt.modify(pd.rd, <span class="number">0</span>, rtf, pd.makeArg(), pd.rseq)</span><br><span class="line">            pd.rrun = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.rd != rd0 || combo != combo0 &#123;</span><br><span class="line">        <span class="comment">// 有运行rt，但现在过期时刻有修改</span></span><br><span class="line">        pd.rseq++ <span class="comment">// 版本更新</span></span><br><span class="line">        <span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间</span></span><br><span class="line">            pd.rt.modify(pd.rd, <span class="number">0</span>, rtf, pd.makeArg(), pd.rseq)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &lt;=0，已过期</span></span><br><span class="line">            pd.rt.stop()</span><br><span class="line">            pd.rrun = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !pd.wrun &#123;</span><br><span class="line">        <span class="comment">// 没有运行wt</span></span><br><span class="line">        <span class="keyword">if</span> pd.wd &gt; <span class="number">0</span> &amp;&amp; !combo &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间，且读/写过期时刻不同</span></span><br><span class="line">            pd.wt.modify(pd.wd, <span class="number">0</span>, netpollWriteDeadline, pd.makeArg(), pd.wseq)</span><br><span class="line">            pd.wrun = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.wd != wd0 || combo != combo0 &#123;</span><br><span class="line">        <span class="comment">// 有运行wt，但现在过期时刻有修改</span></span><br><span class="line">        pd.wseq++ <span class="comment">// 版本更新</span></span><br><span class="line">        <span class="keyword">if</span> pd.wd &gt; <span class="number">0</span> &amp;&amp; !combo &#123;</span><br><span class="line">            <span class="comment">// 需要更新定时器过期时间，且读/写过期时刻不同</span></span><br><span class="line">            pd.wt.modify(pd.wd, <span class="number">0</span>, netpollWriteDeadline, pd.makeArg(), pd.wseq)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &lt;=0，已过期</span></span><br><span class="line">            pd.wt.stop()</span><br><span class="line">            pd.wrun = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计唤醒的G数量</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> rg, wg *g</span><br><span class="line">    <span class="comment">// rg/wg状态修改，ioready为false，不一定有G被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> pd.rd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.wd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 唤醒读G/写G</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(rg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(wg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">    netpollAdjustWaiters(delta)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写定时器同时刻过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollDeadline</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读定时器过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollReadDeadline</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写定时器过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollWriteDeadline</span><span class="params">(arg any, seq <span class="type">uintptr</span>, delta <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读/写定时器过期时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpolldeadlineimpl</span><span class="params">(pd *pollDesc, seq <span class="type">uintptr</span>, read, write <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 获取pollDesc当前版本的seq</span></span><br><span class="line">    currentSeq := pd.rseq</span><br><span class="line">    <span class="keyword">if</span> !read &#123;</span><br><span class="line">        <span class="comment">// 读写放rseq，只写放wseq</span></span><br><span class="line">        currentSeq = pd.wseq</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新旧版本号不一致，pd可能被重用或定时器reset</span></span><br><span class="line">    <span class="keyword">if</span> seq != currentSeq &#123;</span><br><span class="line">        unlock(&amp;pd.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计唤醒的G数量</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> rg *g</span><br><span class="line">    <span class="comment">// 读或读写</span></span><br><span class="line">    <span class="keyword">if</span> read &#123;</span><br><span class="line">        <span class="keyword">if</span> pd.rd &lt;= <span class="number">0</span> || !pd.rrun &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: inconsistent read deadline&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -1为已过期</span></span><br><span class="line">        pd.rd = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">        pd.publishInfo()</span><br><span class="line">        <span class="comment">// rg状态修改，ioready为false，不一定有goroutine被唤醒</span></span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> wg *g</span><br><span class="line">    <span class="keyword">if</span> write &#123;</span><br><span class="line">        <span class="keyword">if</span> pd.wd &lt;= <span class="number">0</span> || !pd.wrun &amp;&amp; !read &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: inconsistent write deadline&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -1为已过期</span></span><br><span class="line">        pd.wd = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">        pd.publishInfo()</span><br><span class="line">        <span class="comment">// wg状态修改，ioready为false，不一定有goroutine被唤醒</span></span><br><span class="line">        wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 唤醒读G/写G</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(rg, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(wg, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">    netpollAdjustWaiters(delta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollgoready</span><span class="params">(gp *g, traceskip <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    goready(gp, traceskip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollAdjustWaiters</span><span class="params">(delta <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> delta != <span class="number">0</span> &#123;</span><br><span class="line">        netpollWaiters.Add(delta)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> makeArg() (i any) &#123;</span><br><span class="line">    x := (*eface)(unsafe.Pointer(&amp;i))   <span class="comment">// 转换成interface&#123;&#125;</span></span><br><span class="line">    x._type = pdType                    <span class="comment">// 类型为pollDesc</span></span><br><span class="line">    x.data = unsafe.Pointer(&amp;pd.self)   <span class="comment">// 指向pollDesc实例</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重置当前G的状态"><a href="#重置当前G的状态" class="headerlink" title="重置当前G的状态"></a>重置当前G的状态</h2><p>不管是因为何种原因，如果当前G需要重新进入队列进行新的轮询，就需要调用该函数进行状态重置。在执行poll_runtime_pollWait之前设置。具体逻辑如下</p>
<ol>
<li>检测atomicInfo标志位，查看是否有异常</li>
<li>读G&#x2F;写G状态重置为pdNil</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollReset</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 查看atomicInfo是否有错误标志</span></span><br><span class="line">    errcode := netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">    <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">        <span class="keyword">return</span> errcode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读G/写G状态重置</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> &#123;</span><br><span class="line">        pd.rg.Store(pdNil)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        pd.wg.Store(pdNil)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免代码过长影响阅读，其他依赖方法列在下方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看atomicInfo是否有错误标志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollcheckerr</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// atomicInfo</span></span><br><span class="line">    info := pd.info()</span><br><span class="line">    <span class="comment">// pollClosing标志位是否已设置</span></span><br><span class="line">    <span class="keyword">if</span> info.closing() &#123;</span><br><span class="line">        <span class="keyword">return</span> pollErrClosing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读过期或写过期</span></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; info.expiredReadDeadline()) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; info.expiredWriteDeadline()) &#123;</span><br><span class="line">        <span class="keyword">return</span> pollErrTimeout</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读发生错误，写错误在写时处理，有更详细的错误信息</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; info.eventErr() &#123;</span><br><span class="line">        <span class="keyword">return</span> pollErrNotPollable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="当前G挂起等待事件发生"><a href="#当前G挂起等待事件发生" class="headerlink" title="当前G挂起等待事件发生"></a>当前G挂起等待事件发生</h2><p>将当前goroutine挂起，并等待事件通知，与poll_runtime_pollUnblock搭配使用。具体逻辑如下</p>
<ol>
<li>检测atomicInfo标志位，查看是否有异常</li>
<li>尝试将rg或wg状态改为pdWait，准备挂起</li>
<li>调用gopark将当前goroutine挂起等待，挂起前将rg或wg状态改为goroutine指针</li>
<li>被唤醒后，把当前状态（已准备好还是超时）告知上层函数</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用/平台无关</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 查看atomicInfo是否有错误标志</span></span><br><span class="line">    errcode := netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">    <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">        <span class="keyword">return</span> errcode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要使用水平触发的系统</span></span><br><span class="line">    <span class="keyword">if</span> GOOS == <span class="string">&quot;solaris&quot;</span> || GOOS == <span class="string">&quot;illumos&quot;</span> || GOOS == <span class="string">&quot;aix&quot;</span> || GOOS == <span class="string">&quot;wasip1&quot;</span> &#123;</span><br><span class="line">        netpollarm(pd, mode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前goroutine挂起休眠，唤醒后，rg/wg可读/写返回true</span></span><br><span class="line">    <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        errcode = netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">        <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">            <span class="keyword">return</span> errcode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, waitio <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 根据mode选择读G/写G</span></span><br><span class="line">    gpp := &amp;pd.rg</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        gpp = &amp;pd.wg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为pdWait状态</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 已经ready，返回</span></span><br><span class="line">        <span class="comment">// pdReady -&gt; pdNil</span></span><br><span class="line">        <span class="keyword">if</span> gpp.CompareAndSwap(pdReady, pdNil) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进入等待</span></span><br><span class="line">        <span class="comment">// pdNil -&gt; pdWait</span></span><br><span class="line">        <span class="keyword">if</span> gpp.CompareAndSwap(pdNil, pdWait) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常情况</span></span><br><span class="line">        <span class="keyword">if</span> v := gpp.Load(); v != pdReady &amp;&amp; v != pdNil &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: double wait&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pdWait or atomicInfo没有错误标志</span></span><br><span class="line">    <span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == pollNoError &#123;</span><br><span class="line">        <span class="comment">// 挂起等待，pdWait -&gt; goroutine指针，netpollWaiters++</span></span><br><span class="line">        gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceBlockNet, <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态设为pdNil</span></span><br><span class="line">    old := gpp.Swap(pdNil)</span><br><span class="line">    <span class="comment">// 如果old是goroutine的指针</span></span><br><span class="line">    <span class="keyword">if</span> old &gt; pdWait &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: corrupted polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起前处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblockcommit</span><span class="params">(gp *g, gpp unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// pdWait -&gt; goroutine指针</span></span><br><span class="line">    r := atomic.Casuintptr((*<span class="type">uintptr</span>)(gpp), pdWait, <span class="type">uintptr</span>(unsafe.Pointer(gp)))</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">    <span class="keyword">if</span> r &#123;</span><br><span class="line">        <span class="comment">// 计数器+1 =&gt; netpollWaiters++</span></span><br><span class="line">        netpollAdjustWaiters(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件发生唤醒挂起的G"><a href="#事件发生唤醒挂起的G" class="headerlink" title="事件发生唤醒挂起的G"></a>事件发生唤醒挂起的G</h2><p>事件发生时，唤醒被挂起等待的goroutine，与poll_runtime_pollWait搭配使用。具体逻辑如下</p>
<ol>
<li>guard，确保不会反复unblock已被移除出netpoll的pollDesc</li>
<li>事件元数据pollDesc更新<ul>
<li>计数器、atomicInfo、rg&#x2F;wg、读&#x2F;写定时器状态更新</li>
</ul>
</li>
<li>唤醒读G&#x2F;写G，并更新netpollWaiters计数器</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollUnblock</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">    lock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 已被移除出netpoll</span></span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123;</span><br><span class="line">        throw(<span class="string">&quot;runtime: unblock on closing polldesc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pd.closing = <span class="literal">true</span></span><br><span class="line">    pd.rseq++</span><br><span class="line">    pd.wseq++</span><br><span class="line">    <span class="keyword">var</span> rg, wg *g</span><br><span class="line">    <span class="comment">// 更新atomicInfo字段</span></span><br><span class="line">    pd.publishInfo()</span><br><span class="line">    <span class="comment">// 累计唤醒的G数量</span></span><br><span class="line">    delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// rg/wg状态修改</span></span><br><span class="line">    rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">false</span>, &amp;delta)</span><br><span class="line">    <span class="comment">// 停止读/写定时器</span></span><br><span class="line">    <span class="keyword">if</span> pd.rrun &#123;</span><br><span class="line">        pd.rt.stop()</span><br><span class="line">        pd.rrun = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pd.wrun &#123;</span><br><span class="line">        pd.wt.stop()</span><br><span class="line">        pd.wrun = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;pd.lock)</span><br><span class="line">    <span class="comment">// 唤醒读G/写G</span></span><br><span class="line">    <span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(rg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        netpollgoready(wg, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">    netpollAdjustWaiters(delta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://copyconstruct.medium.com/the-method-to-epolls-madness-d9d2d6378642">The method to epoll’s madness</a><br><a target="_blank" rel="noopener" href="https://www.sobyte.net/post/2021-09/golang-netpoll/">golang netpoll Explained</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6989608237226000391">Linux fd 系列 — eventfd 是什么？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-time/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-time/" class="post-title-link" itemprop="url">golang系列之-time</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-23 15:59:36 / 修改时间：17:37:59" itemprop="dateCreated datePublished" datetime="2025-02-23T15:59:36+08:00">2025-02-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>time涉及的内容较多，如生成&#x2F;存储时间、比较时间、获取时间信息、时区、夏令时等，本文仅介绍一些自己感兴趣的地方</p>
<p>日历计算基于格里高利历（公历），1年有365天（闰年有366天）。同时支持墙上时钟（wall clock）和单调时钟（monotonic clock），其中墙上时钟用于时间同步、报时（time-telling），单调时钟用于时间测量（time-measuring）。并不是所有函数都支持单调时钟，如字符串编码&#x2F;解码函数就会舍弃单调时钟数据</p>
<p>注意：</p>
<ol>
<li>时间精确度：纳秒</li>
<li>大部分都是线程安全，除了<ul>
<li>GobDecode</li>
<li>UnmarshalBinary</li>
<li>UnmarshalJSON</li>
<li>UnmarshalText</li>
</ul>
</li>
<li>有些系统会在进程休眠时停止单调时钟，会导致一些函数计算异常，如<ul>
<li>Sub</li>
<li>Since</li>
<li>Until</li>
<li>Before</li>
<li>After</li>
<li>Add</li>
<li>Equal</li>
<li>Compare</li>
</ul>
</li>
<li>字符串编码时，保存的是Location的offset，会导致dst-夏令时丢失，相关函数<ul>
<li>GobEncode</li>
<li>MarshalBinary</li>
<li>AppendBinary</li>
<li>MarshalJSON</li>
<li>MarshalText</li>
<li>AppendText</li>
</ul>
</li>
<li>字符串编码&#x2F;解码时，会丢弃单调时钟信息</li>
</ol>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := fmt.Println</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := time.Now()</span><br><span class="line">    p(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定时刻</span></span><br><span class="line">    then := time.Date(</span><br><span class="line">        <span class="number">2009</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">651387237</span>, time.UTC)</span><br><span class="line">    p(then)</span><br><span class="line"></span><br><span class="line">    p(then.Year())          <span class="comment">// 年</span></span><br><span class="line">    p(then.Month())         <span class="comment">// 月</span></span><br><span class="line">    p(then.Day())           <span class="comment">// 日</span></span><br><span class="line">    p(then.Hour())          <span class="comment">// 时</span></span><br><span class="line">    p(then.Minute())        <span class="comment">// 分</span></span><br><span class="line">    p(then.Second())        <span class="comment">// 秒</span></span><br><span class="line">    p(then.Nanosecond())    <span class="comment">// 纳秒</span></span><br><span class="line">    p(then.Location())      <span class="comment">// 时区</span></span><br><span class="line"></span><br><span class="line">    p(then.Weekday())       <span class="comment">// 星期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个时刻先后顺序</span></span><br><span class="line">    p(then.Before(now))</span><br><span class="line">    p(then.After(now))</span><br><span class="line">    p(then.Equal(now))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时长/时刻差值</span></span><br><span class="line">    diff := now.Sub(then)</span><br><span class="line">    p(diff)</span><br><span class="line"></span><br><span class="line">    p(diff.Hours())         <span class="comment">// 转换成总小时数</span></span><br><span class="line">    p(diff.Minutes())       <span class="comment">// 转换成总分钟数</span></span><br><span class="line">    p(diff.Seconds())       <span class="comment">// 转换成总秒数</span></span><br><span class="line">    p(diff.Nanoseconds())   <span class="comment">// 转换成总纳秒数</span></span><br><span class="line"></span><br><span class="line">    p(then.Add(diff))</span><br><span class="line">    p(then.Add(-diff))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下所示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2025-02-22 10:30:14.247195 +0800 CST m=+0.000103986  # 当前时刻</span></span><br><span class="line"><span class="comment"># 2009-11-17 20:34:58.651387237 +0000 UTC              # 指定时刻</span></span><br><span class="line"><span class="comment"># 2009                                                 # 年</span></span><br><span class="line"><span class="comment"># November                                             # 月</span></span><br><span class="line"><span class="comment"># 17                                                   # 日</span></span><br><span class="line"><span class="comment"># 20                                                   # 时</span></span><br><span class="line"><span class="comment"># 34                                                   # 分</span></span><br><span class="line"><span class="comment"># 58                                                   # 秒</span></span><br><span class="line"><span class="comment"># 651387237                                            # 纳秒</span></span><br><span class="line"><span class="comment"># UTC                                                  # 时区</span></span><br><span class="line"><span class="comment"># Tuesday                                              # 星期</span></span><br><span class="line"><span class="comment"># true</span></span><br><span class="line"><span class="comment"># false</span></span><br><span class="line"><span class="comment"># false</span></span><br><span class="line"><span class="comment"># 133805h55m15.595807763s                              # 时长/时刻差值</span></span><br><span class="line"><span class="comment"># 133805.9209988355                                    # 总小时数</span></span><br><span class="line"><span class="comment"># 8.028355259930129e+06                                # 总分钟数</span></span><br><span class="line"><span class="comment"># 4.817013155958078e+08                                # 总秒数</span></span><br><span class="line"><span class="comment"># 481701315595807763                                   # 总纳秒数</span></span><br><span class="line"><span class="comment"># 2025-02-22 02:30:14.247195 +0000 UTC</span></span><br><span class="line"><span class="comment"># 1994-08-13 14:39:43.055579474 +0000 UTC</span></span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>时间由Time数据结构表示，具体如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/time/time.go</span></span><br><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    wall <span class="type">uint64</span>      <span class="comment">// 1位表示flag，33位表示秒数，30位表示纳秒数</span></span><br><span class="line">    ext  <span class="type">int64</span>       <span class="comment">// wall与ext组合表示：秒数（墙上时钟）+纳秒数（墙上时钟）+纳秒数（单调时钟）【可选】</span></span><br><span class="line">    loc *Location    <span class="comment">// 时区，为nil时表示UTC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间存储"><a href="#时间存储" class="headerlink" title="时间存储"></a>时间存储</h3><p>Time结构使用wall和ext两个字段来存储时间，具体表示如下</p>
<ol>
<li>当wall第一位即flag为0时，表示没有单调时钟数据，wall和ext存储内容如下</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wall -&gt; | 1bit | 33bit                     | 30bit                     |</span></span><br><span class="line"><span class="comment">//         | 0    | 0                         | def(ns) -&gt; [0, 999999999] |</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// ext  -&gt; | 64bit                                                        |</span></span><br><span class="line"><span class="comment">//         | abc(s) =&gt; int64                                              |</span></span><br></pre></td></tr></table></figure>

<p>其中，abc伪数据表示秒数，从1年1月1日开始算起；def伪数据表示纳秒数，范围[0, 999999999]</p>
<ol start="2">
<li>当wall第一位为1时，表示有单调时钟数据，wall和ext存储内容如下</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wall -&gt; | 1bit | 33bit                     | 30bit                     |</span></span><br><span class="line"><span class="comment">//         | 1    | abc(s) =&gt; unsigned        | def(ns) -&gt; [0, 999999999] |</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// ext  -&gt; | 64bit                                                        |</span></span><br><span class="line"><span class="comment">//         | xyz(ns) =&gt; int64                                             |</span></span><br></pre></td></tr></table></figure>

<p>其中，abc伪数据表示秒数，def伪数据表示纳秒数，范围[0, 999999999]，xyz为单调时钟的纳秒数，从进程启动开始计时</p>
<p>此时，墙上时钟能表示的时间范围是[1885, 2157]</p>
<h2 id="获取时间对象Time"><a href="#获取时间对象Time" class="headerlink" title="获取时间对象Time"></a>获取时间对象Time</h2><h3 id="当前时刻Now"><a href="#当前时刻Now" class="headerlink" title="当前时刻Now"></a>当前时刻Now</h3><p>Now返回系统时间，返回的Time一般包含单调时钟数据</p>
<p>具体逻辑</p>
<ol>
<li>从系统获取时间数据（通过VDSO或clock_gettime获取）</li>
<li>如果返回的时间没有单调时钟数据，按墙上时钟格式存储</li>
<li>如果秒数出现溢出的情况，按墙上时钟格式存储</li>
<li>存储墙上时钟和单调时钟</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回本地当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 从系统获取时间数据</span></span><br><span class="line">    sec, nsec, mono := runtimeNow()</span><br><span class="line">    <span class="comment">// 没有单调时间</span></span><br><span class="line">    <span class="keyword">if</span> mono == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// unix时间戳存储时都要加上unixToInternal</span></span><br><span class="line">        <span class="keyword">return</span> Time&#123;<span class="type">uint64</span>(nsec), sec + unixToInternal, Local&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减去进程启动时获取的nanotime</span></span><br><span class="line">    mono -= startNano</span><br><span class="line">    <span class="comment">// 检测是否会溢出，2157年3月16日耗尽所有bit</span></span><br><span class="line">    sec += unixToInternal - minWall</span><br><span class="line">    <span class="comment">// 溢出？丢弃单调时钟，只存墙上时钟</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uint64</span>(sec)&gt;&gt;<span class="number">33</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Time&#123;<span class="type">uint64</span>(nsec), sec + minWall, Local&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 墙上时钟+单调时钟</span></span><br><span class="line">    <span class="keyword">return</span> Time&#123;hasMonotonic | <span class="type">uint64</span>(sec)&lt;&lt;nsecShift | <span class="type">uint64</span>(nsec), mono, Local&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程启动时初始化该变量</span></span><br><span class="line"><span class="keyword">var</span> startNano <span class="type">int64</span> = runtimeNano() - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">time_runtimeNow</span><span class="params">()</span></span> (sec <span class="type">int64</span>, nsec <span class="type">int32</span>, mono <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> sg := getg().syncGroup; sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        sec = sg.now / (<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>)</span><br><span class="line">        nsec = <span class="type">int32</span>(sg.now % (<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>))</span><br><span class="line">        <span class="keyword">return</span> sec, nsec, sg.now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time_now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/timestub.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">time_now</span><span class="params">()</span></span> (sec <span class="type">int64</span>, nsec <span class="type">int32</span>, mono <span class="type">int64</span>) &#123;</span><br><span class="line">    sec, nsec = walltime() <span class="comment">// 通过VDSO或clock_gettime获取</span></span><br><span class="line">    <span class="keyword">return</span> sec, nsec, nanotime()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">time_runtimeNano</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp.syncGroup.now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nanotime()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/time_nofake.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nanotime</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// linux+amd64看相关汇编代码 src/runtime/sys_linux_amd64.s</span></span><br><span class="line">	<span class="keyword">return</span> nanotime1() <span class="comment">// 通过VDSO或clock_gettime获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unix时间戳转换"><a href="#Unix时间戳转换" class="headerlink" title="Unix时间戳转换"></a>Unix时间戳转换</h3><p>根据秒数、纳秒数返回一个从1970年1月1日开始计时的unix时间戳的Time，该Time不包含单调时钟数据。按参数精度分为Unix&#x2F;UnixMilli&#x2F;UnixMicro</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 精度：秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unix</span><span class="params">(sec <span class="type">int64</span>, nsec <span class="type">int64</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 负数或超过1e9</span></span><br><span class="line">    <span class="keyword">if</span> nsec &lt; <span class="number">0</span> || nsec &gt;= <span class="number">1e9</span> &#123;</span><br><span class="line">        n := nsec / <span class="number">1e9</span></span><br><span class="line">        sec += n           <span class="comment">// 溢出部份换算成秒，加到sec</span></span><br><span class="line">        nsec -= n * <span class="number">1e9</span>    <span class="comment">// 移除溢出部份</span></span><br><span class="line">        <span class="keyword">if</span> nsec &lt; <span class="number">0</span> &#123;      <span class="comment">// 负数</span></span><br><span class="line">            nsec += <span class="number">1e9</span>    <span class="comment">// 从sec拿1s加上，使其为正</span></span><br><span class="line">            sec--          <span class="comment">// sec减去1s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unixTime(sec, <span class="type">int32</span>(nsec))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unixTime</span><span class="params">(sec <span class="type">int64</span>, nsec <span class="type">int32</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 存储时加上一个预设值unixToInternal，读取的时候减掉</span></span><br><span class="line">    <span class="keyword">return</span> Time&#123;<span class="type">uint64</span>(nsec), sec + unixToInternal, Local&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixMilli</span><span class="params">(msec <span class="type">int64</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="keyword">return</span> Unix(msec/<span class="number">1e3</span>, (msec%<span class="number">1e3</span>)*<span class="number">1e6</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：微秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixMicro</span><span class="params">(usec <span class="type">int64</span>)</span></span> Time &#123;</span><br><span class="line">    <span class="keyword">return</span> Unix(usec/<span class="number">1e6</span>, (usec%<span class="number">1e6</span>)*<span class="number">1e3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Date获取指定时刻"><a href="#Date获取指定时刻" class="headerlink" title="Date获取指定时刻"></a>Date获取指定时刻</h3><p>根据提供的时间信息如：年&#x2F;月&#x2F;日&#x2F;时&#x2F;分&#x2F;秒以及时区获得指定时刻，具体逻辑如下</p>
<ol>
<li>规范化后计算出一个unix时间戳</li>
<li>根据时区的偏移量调整unix时间戳</li>
<li>生成Time示例</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date</span><span class="params">(year <span class="type">int</span>, month Month, day, hour, min, sec, nsec <span class="type">int</span>, loc *Location)</span></span> Time &#123;</span><br><span class="line">    <span class="comment">// 时区不能为空</span></span><br><span class="line">    <span class="keyword">if</span> loc == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: missing Location in call to Date&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规范月份，溢出值加到年上</span></span><br><span class="line">    m := <span class="type">int</span>(month) - <span class="number">1</span></span><br><span class="line">    year, m = norm(year, m, <span class="number">12</span>)</span><br><span class="line">    month = Month(m) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规范nsec, sec, min, hour, 溢出值加到天上</span></span><br><span class="line">    sec, nsec = norm(sec, nsec, <span class="number">1e9</span>)</span><br><span class="line">    min, sec = norm(min, sec, <span class="number">60</span>)</span><br><span class="line">    hour, min = norm(hour, min, <span class="number">60</span>)</span><br><span class="line">    day, hour = norm(day, hour, <span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为绝对时间，然后转换为unix时间戳</span></span><br><span class="line">    unix := <span class="type">int64</span>(dateToAbsDays(<span class="type">int64</span>(year), month, day))*secondsPerDay +</span><br><span class="line">        <span class="type">int64</span>(hour*secondsPerHour+min*secondsPerMinute+sec) +</span><br><span class="line">        absoluteToUnix</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时区偏移量</span></span><br><span class="line">    _, offset, start, end, _ := loc.lookup(unix)</span><br><span class="line">    <span class="keyword">if</span> offset != <span class="number">0</span> &#123;</span><br><span class="line">        utc := unix - <span class="type">int64</span>(offset)</span><br><span class="line">        <span class="keyword">if</span> utc &lt; start || utc &gt;= end &#123;</span><br><span class="line">            _, offset, _, _, _ = loc.lookup(utc)</span><br><span class="line">        &#125;</span><br><span class="line">        unix -= <span class="type">int64</span>(offset)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unix时间戳</span></span><br><span class="line">    t := unixTime(unix, <span class="type">int32</span>(nsec))</span><br><span class="line">    t.setLoc(loc)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi * base + lo == nhi * base + nlo</span></span><br><span class="line"><span class="comment">// 0 &lt;= nlo &lt; base</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">norm</span><span class="params">(hi, lo, base <span class="type">int</span>)</span></span> (nhi, nlo <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span> &#123;</span><br><span class="line">        n := (-lo<span class="number">-1</span>)/base + <span class="number">1</span></span><br><span class="line">        hi -= n</span><br><span class="line">        lo += n * base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lo &gt;= base &#123;</span><br><span class="line">        n := lo / base</span><br><span class="line">        hi += n</span><br><span class="line">        lo -= n * base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hi, lo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为天数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dateToAbsDays</span><span class="params">(year <span class="type">int64</span>, month Month, day <span class="type">int</span>)</span></span> absDays &#123;</span><br><span class="line">    amonth := <span class="type">uint32</span>(month)</span><br><span class="line">    janFeb := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> amonth &lt; <span class="number">3</span> &#123;</span><br><span class="line">        janFeb = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是1月和2月，再加12个月</span></span><br><span class="line">    amonth += <span class="number">12</span> * janFeb</span><br><span class="line">    <span class="comment">// year-janFeb+292277022400</span></span><br><span class="line">    y := <span class="type">uint64</span>(year) - <span class="type">uint64</span>(janFeb) + absoluteYears</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果3 &lt;= amonth &lt;= 14</span></span><br><span class="line">    <span class="comment">// ayday := (153*amonth - 457) / 5</span></span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="comment">// ayday := (979*amonth - 2919) &gt;&gt; 5</span></span><br><span class="line">    ayday := (<span class="number">979</span>*amonth - <span class="number">2919</span>) &gt;&gt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    century := y / <span class="number">100</span></span><br><span class="line">    cyear := <span class="type">uint32</span>(y % <span class="number">100</span>)</span><br><span class="line">    cday := <span class="number">1461</span> * cyear / <span class="number">4</span></span><br><span class="line">    centurydays := <span class="number">146097</span> * century / <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// absDays =&gt; uint64的别名</span></span><br><span class="line">    <span class="keyword">return</span> absDays(centurydays + <span class="type">uint64</span>(<span class="type">int64</span>(cday+ayday)+<span class="type">int64</span>(day)<span class="number">-1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增加时长获取指定时刻"><a href="#增加时长获取指定时刻" class="headerlink" title="增加时长获取指定时刻"></a>增加时长获取指定时刻</h3><h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><p>时刻t增加时长d，获得指定时刻，该方法会同时更新墙上时钟和单调时钟</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Add(d Duration) Time &#123;</span><br><span class="line">    dsec := <span class="type">int64</span>(d / <span class="number">1e9</span>)            <span class="comment">// 秒数</span></span><br><span class="line">    nsec := t.nsec() + <span class="type">int32</span>(d%<span class="number">1e9</span>)   <span class="comment">// 纳秒数</span></span><br><span class="line">    <span class="keyword">if</span> nsec &gt;= <span class="number">1e9</span> &#123;</span><br><span class="line">        dsec++</span><br><span class="line">        nsec -= <span class="number">1e9</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nsec &lt; <span class="number">0</span> &#123;</span><br><span class="line">        dsec--</span><br><span class="line">        nsec += <span class="number">1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.wall = t.wall&amp;^nsecMask | <span class="type">uint64</span>(nsec) <span class="comment">// 更新纳秒数</span></span><br><span class="line">    t.addSec(dsec)</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        te := t.ext + <span class="type">int64</span>(d)</span><br><span class="line">        <span class="keyword">if</span> d &lt; <span class="number">0</span> &amp;&amp; te &gt; t.ext || d &gt; <span class="number">0</span> &amp;&amp; te &lt; t.ext &#123;</span><br><span class="line">            <span class="comment">// 单调时钟溢出，降级成墙上时钟</span></span><br><span class="line">            t.stripMono()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t.ext = te</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> addSec(d <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        sec := <span class="type">int64</span>(t.wall &lt;&lt; <span class="number">1</span> &gt;&gt; (nsecShift + <span class="number">1</span>))</span><br><span class="line">        dsec := sec + d</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= dsec &amp;&amp; dsec &lt;= <span class="number">1</span>&lt;&lt;<span class="number">33</span><span class="number">-1</span> &#123;</span><br><span class="line">            t.wall = t.wall&amp;nsecMask | <span class="type">uint64</span>(dsec)&lt;&lt;nsecShift | hasMonotonic</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 秒数溢出，把单调时钟数据移除，降级为墙上时钟</span></span><br><span class="line">        t.stripMono()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 墙上时钟</span></span><br><span class="line">    sum := t.ext + d</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; t.ext) == (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        t.ext = sum</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> d &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t.ext = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.ext = -(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除mono时钟数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> stripMono() &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        t.ext = t.sec()     <span class="comment">// 复制秒数到ext</span></span><br><span class="line">        t.wall &amp;= nsecMask    <span class="comment">// 移除flag</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AddDate"><a href="#AddDate" class="headerlink" title="AddDate"></a>AddDate</h4><p>Time根据提供的年数&#x2F;月数&#x2F;日数获得目标指定时刻，底层实际调用的是Date方法，只更新wall clock</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> AddDate(years <span class="type">int</span>, months <span class="type">int</span>, days <span class="type">int</span>) Time &#123;</span><br><span class="line">    year, month, day := t.Date()</span><br><span class="line">    hour, min, sec := t.Clock()</span><br><span class="line">    <span class="keyword">return</span> Date(year+years, month+Month(months), day+days, hour, min, sec, <span class="type">int</span>(t.nsec()), t.Location())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串转换成Time"><a href="#字符串转换成Time" class="headerlink" title="字符串转换成Time"></a>字符串转换成Time</h3><p>常用的layout有：</p>
<table>
<thead>
<tr>
<th align="left">constant</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DateTime</td>
<td align="left">“2006-01-02 15:04:05”</td>
</tr>
<tr>
<td align="left">DateOnly</td>
<td align="left">“2006-01-02”</td>
</tr>
<tr>
<td align="left">TimeOnly</td>
<td align="left">“15:04:05”</td>
</tr>
</tbody></table>
<h4 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h4><p>解析字符串获得Time对象以及异常信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="type">string</span>)</span></span> (Time, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// RFC3339 =&gt; 2006-01-02T15:04:05Z07:00</span></span><br><span class="line">    <span class="keyword">if</span> layout == RFC3339 || layout == RFC3339Nano &#123;</span><br><span class="line">        <span class="keyword">if</span> t, ok := parseRFC3339(value, Local); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parse函数太长了，有兴趣可以看源码</span></span><br><span class="line">    <span class="keyword">return</span> parse(layout, value, UTC, Local)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ParseInLocation"><a href="#ParseInLocation" class="headerlink" title="ParseInLocation"></a>ParseInLocation</h4><p>指定时区，解析字符串获得Time对象以及异常信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInLocation</span><span class="params">(layout, value <span class="type">string</span>, loc *Location)</span></span> (Time, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// RFC3339 =&gt; 2006-01-02T15:04:05Z07:00</span></span><br><span class="line">    <span class="keyword">if</span> layout == RFC3339 || layout == RFC3339Nano &#123;</span><br><span class="line">        <span class="keyword">if</span> t, ok := parseRFC3339(value, loc); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parse函数太长了，有兴趣可以看源码</span></span><br><span class="line">    <span class="keyword">return</span> parse(layout, value, loc, loc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算两个时刻的差值"><a href="#计算两个时刻的差值" class="headerlink" title="计算两个时刻的差值"></a>计算两个时刻的差值</h2><h3 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h3><p>计算t时刻-u时刻的差值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Sub(u Time) Duration &#123;</span><br><span class="line">    <span class="comment">// 两个时刻都有单调时钟</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subMono(t.ext, u.ext)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 秒数+纳秒数</span></span><br><span class="line">    d := Duration(t.sec()-u.sec())*Second + Duration(t.nsec()-u.nsec())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> u.Add(d).Equal(t):</span><br><span class="line">        <span class="keyword">return</span> d <span class="comment">// d is correct</span></span><br><span class="line">    <span class="keyword">case</span> t.Before(u):</span><br><span class="line">        <span class="keyword">return</span> minDuration <span class="comment">// t - u is negative out of range</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> maxDuration <span class="comment">// t - u is positive out of range</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subMono</span><span class="params">(t, u <span class="type">int64</span>)</span></span> Duration &#123;</span><br><span class="line">    d := Duration(t - u)</span><br><span class="line">    <span class="keyword">if</span> d &lt; <span class="number">0</span> &amp;&amp; t &gt; u &#123;</span><br><span class="line">        <span class="keyword">return</span> maxDuration <span class="comment">// t - u is positive out of range</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> d &gt; <span class="number">0</span> &amp;&amp; t &lt; u &#123;</span><br><span class="line">        <span class="keyword">return</span> minDuration <span class="comment">// t - u is negative out of range</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Since"><a href="#Since" class="headerlink" title="Since"></a>Since</h3><p>计算从指定时刻（过去）到现在时刻的差值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Since</span><span class="params">(t Time)</span></span> Duration &#123;</span><br><span class="line">    <span class="comment">// 目标时刻有单调时钟数据</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subMono(runtimeNano()-startNano, t.ext)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Now().Sub(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Until"><a href="#Until" class="headerlink" title="Until"></a>Until</h3><p>计算从现在时刻到指定时刻（将来）的差值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Until</span><span class="params">(t Time)</span></span> Duration &#123;</span><br><span class="line">    <span class="comment">// 目标时刻有单调时钟数据</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subMono(t.ext, runtimeNano()-startNano)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.Sub(Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比较两个时刻的先后顺序"><a href="#比较两个时刻的先后顺序" class="headerlink" title="比较两个时刻的先后顺序"></a>比较两个时刻的先后顺序</h2><p>如果两个Time都包含wall clock和mono clock，则只比较mono clock，否则比较wall clock</p>
<h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><p>判断t时刻是否先于u时刻</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Before(u Time) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.ext &lt; u.ext</span><br><span class="line">    &#125;</span><br><span class="line">    ts := t.sec()</span><br><span class="line">    us := u.sec()</span><br><span class="line">    <span class="keyword">return</span> ts &lt; us || ts == us &amp;&amp; t.nsec() &lt; u.nsec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><p>判断t时刻是否晚于u时刻</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> After(u Time) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.ext &gt; u.ext</span><br><span class="line">    &#125;</span><br><span class="line">    ts := t.sec()</span><br><span class="line">    us := u.sec()</span><br><span class="line">    <span class="keyword">return</span> ts &gt; us || ts == us &amp;&amp; t.nsec() &gt; u.nsec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h3><p>判断t时刻与u时刻是否相等</p>
<p>注意：时刻比较不要使用<code>==</code>，因为<code>==</code>会比较整个Time结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Equal(u Time) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.ext == u.ext</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.sec() == u.sec() &amp;&amp; t.nsec() == u.nsec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IsZero"><a href="#IsZero" class="headerlink" title="IsZero"></a>IsZero</h3><p>判断t时刻是否是零值。</p>
<p>注意：零值是UTC时间1年1月1日0时0分0秒</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> IsZero() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.sec() == <span class="number">0</span> &amp;&amp; t.nsec() == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h3><p>比较两个时刻</p>
<ol>
<li>如果t时刻先于u时刻，返回-1</li>
<li>如果t时刻晚与u时刻，返回+1</li>
<li>如果t时刻与u时刻相等，返回0</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Compare(u Time) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tc, uc <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;u.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        tc, uc = t.ext, u.ext</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tc, uc = t.sec(), u.sec()</span><br><span class="line">        <span class="keyword">if</span> tc == uc &#123;</span><br><span class="line">            tc, uc = <span class="type">int64</span>(t.nsec()), <span class="type">int64</span>(u.nsec())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> tc &lt; uc:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">case</span> tc &gt; uc:</span><br><span class="line">        <span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><h3 id="转换时区"><a href="#转换时区" class="headerlink" title="转换时区"></a>转换时区</h3><p>时区不会改变Time存储的数值，影响的是数据输出&#x2F;表示</p>
<h4 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h4><p>切换为本机时区</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Local() Time &#123;</span><br><span class="line">    t.setLoc(Local)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> setLoc(loc *Location) &#123;</span><br><span class="line">    <span class="comment">// nil表示UTC</span></span><br><span class="line">    <span class="keyword">if</span> loc == &amp;utcLoc &#123;</span><br><span class="line">        loc = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.stripMono()</span><br><span class="line">    t.loc = loc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h4><p>切换为UTC时区</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> utcLoc = Location&#123;name: <span class="string">&quot;UTC&quot;</span>&#125; <span class="comment">// 启动时初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UTC() Time &#123;</span><br><span class="line">    t.setLoc(&amp;utcLoc)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指定时区"><a href="#指定时区" class="headerlink" title="指定时区"></a>指定时区</h4><p>切换为指定时区</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> In(loc *Location) Time &#123;</span><br><span class="line">    <span class="keyword">if</span> loc == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;time: missing Location in call to Time.In&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.setLoc(loc)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取报时信息"><a href="#获取报时信息" class="headerlink" title="获取报时信息"></a>获取报时信息</h2><h3 id="获取Unix时间戳"><a href="#获取Unix时间戳" class="headerlink" title="获取Unix时间戳"></a>获取Unix时间戳</h3><p>获取从1970年1月1日开始到现在的秒数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 精度：秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Unix() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.unixSec()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UnixMilli() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.unixSec()*<span class="number">1e3</span> + <span class="type">int64</span>(t.nsec())/<span class="number">1e6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：微秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UnixMicro() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.unixSec()*<span class="number">1e6</span> + <span class="type">int64</span>(t.nsec())/<span class="number">1e3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度：纳秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> UnixNano() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (t.unixSec())*<span class="number">1e9</span> + <span class="type">int64</span>(t.nsec())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含秒数和纳秒数</span></span><br><span class="line"><span class="comment">// unix时间戳读取时都要加上internalToUnix（也就是减去unixToInternal）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span></span> unixSec() <span class="type">int64</span> &#123; <span class="keyword">return</span> t.sec() + internalToUnix &#125;</span><br></pre></td></tr></table></figure>

<h3 id="提取日期等信息"><a href="#提取日期等信息" class="headerlink" title="提取日期等信息"></a>提取日期等信息</h3><p>业务逻辑经常需要判断两个时刻是否处在同一天&#x2F;同一周等，此外，也需要获取当前周&#x2F;当前月等的起止时刻，列举如下依赖方法</p>
<table>
<thead>
<tr>
<th align="left">method</th>
<th align="left">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Date</td>
<td align="left">获取年月日</td>
</tr>
<tr>
<td align="left">Clock</td>
<td align="left">获取时分秒</td>
</tr>
<tr>
<td align="left">ISOWeek</td>
<td align="left">获取年和周数</td>
</tr>
<tr>
<td align="left">Year</td>
<td align="left">获取年</td>
</tr>
<tr>
<td align="left">Month</td>
<td align="left">获取月</td>
</tr>
<tr>
<td align="left">Day</td>
<td align="left">获取天</td>
</tr>
<tr>
<td align="left">Hour</td>
<td align="left">获取时</td>
</tr>
<tr>
<td align="left">Minute</td>
<td align="left">获取分</td>
</tr>
<tr>
<td align="left">Second</td>
<td align="left">获取秒</td>
</tr>
<tr>
<td align="left">Round</td>
<td align="left">获取秒</td>
</tr>
<tr>
<td align="left">Truncate</td>
<td align="left">按给定时长截断</td>
</tr>
<tr>
<td align="left">Round</td>
<td align="left">按给定时长向上取整</td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 两个时刻是否是同一天</span></span><br><span class="line">NewDate(t1.Date()) == NewDate(t2.Date())</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Date <span class="keyword">struct</span> &#123;</span><br><span class="line">    YearMonth</span><br><span class="line">    day <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDate</span><span class="params">(year <span class="type">int</span>, month time.Month, day <span class="type">int</span>)</span></span> Date &#123;</span><br><span class="line">    <span class="keyword">return</span> Date&#123;</span><br><span class="line">        YearMonth: YearMonth&#123;</span><br><span class="line">            year:  year,</span><br><span class="line">            month: month,</span><br><span class="line">        &#125;,</span><br><span class="line">        day: day,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取当月开始和结束时刻</span></span><br><span class="line">startOfMonth := time.Date(t1.Year(), t1.Month(), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, t1.Location())</span><br><span class="line">endOfMonth := startOfMonth.AddDate(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>).Add(<span class="number">-1</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取当个星期的开始和结束时刻</span></span><br><span class="line"><span class="comment">// 从星期天开始计起</span></span><br><span class="line">tmp := t1.Truncate(<span class="number">7</span> * <span class="number">24</span> * time.Hour)</span><br><span class="line">startOfWeek := time.Date(tmp.Year(), tmp.Month(), tmp.Day(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, tmp.Location())</span><br><span class="line">endOfWeek := startOfWeek.AddDate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>).Add(<span class="number">-1</span> * time.Second)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-channel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-channel/" class="post-title-link" itemprop="url">golang系列之-channel</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-21 19:38:32" itemprop="dateCreated datePublished" datetime="2025-02-21T19:38:32+08:00">2025-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-01 10:00:56" itemprop="dateModified" datetime="2025-03-01T10:00:56+08:00">2025-03-01</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>channel-管道，是go语言中一种常见的goroutine的通信方式</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>示例1. 两个goroutine之间使用channel传递数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新goroutine</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    message &lt;- <span class="string">&quot;Hello from goroutine!&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前goroutine</span></span><br><span class="line">msg := &lt;-message</span><br><span class="line">fmt.Println(msg)</span><br></pre></td></tr></table></figure>

<p>示例2. 使用select同时监听多个goroutine的响应数据，实际上，业务代码中一般都是跟定时器搭配使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">    ch1 &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    ch2 &lt;- <span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received from ch1:&quot;</span>, msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received from ch2:&quot;</span>, msg2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// len，元素个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// cap，循环队列的长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指针，指向一个循环队列</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// 元素大小</span></span><br><span class="line">    synctest <span class="type">bool</span>           <span class="comment">// true if created in a synctest bubble</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 是否已关闭</span></span><br><span class="line">    timer    *timer         <span class="comment">// 定时器，双向绑定timer</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>           <span class="comment">// 写索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>           <span class="comment">// 读索引</span></span><br><span class="line">    recvq    waitq          <span class="comment">// 读队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// 写队列</span></span><br><span class="line">    lock mutex              <span class="comment">// 锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向队列，sudog内部有prev和next指针</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog            <span class="comment">// head</span></span><br><span class="line">    last  *sudog            <span class="comment">// tail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h2><p>创建channel，具体逻辑如下</p>
<ol>
<li>guard，让错误尽早返回</li>
<li>计算创建channel所需的内存大小（header+buf）</li>
<li>创建channel、初始化字段数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">    elem := t.Elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保元素大小没有超过2^16=64KB</span></span><br><span class="line">    <span class="keyword">if</span> elem.Size_ &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.Align_ &gt; maxAlign &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果channel有buf缓冲区</span></span><br><span class="line">    <span class="comment">// 计算buf总大小=type_size*size</span></span><br><span class="line">    mem, overflow := math.MulUintptr(elem.Size_, <span class="type">uintptr</span>(size))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建channel</span></span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:          <span class="comment">// size=0或者type_size=0，无buf</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> !elem.Pointers():  <span class="comment">// 元素非指针类型，一次性为header和buf申请内存</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>:                <span class="comment">// 指针类型，分别为header和buf申请内存</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.elemsize = <span class="type">uint16</span>(elem.Size_)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">    <span class="comment">// synctest，忽略</span></span><br><span class="line">    <span class="keyword">if</span> getg().syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.synctest = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁优先级设置，见src/runtime/lockrank.go</span></span><br><span class="line">    lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.Size_, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取buf可写入的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanbuf</span><span class="params">(c *hchan, i <span class="type">uint</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="keyword">return</span> add(c.buf, <span class="type">uintptr</span>(i)*<span class="type">uintptr</span>(c.elemsize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">full</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 容量为0</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 有G在等待读数据</span></span><br><span class="line">        <span class="keyword">return</span> c.recvq.first == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容量不为0，确认队列是否已满</span></span><br><span class="line">    <span class="keyword">return</span> c.qcount == c.dataqsiz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">empty</span><span class="params">(c *hchan)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 容量为0</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atomic.Loadp(unsafe.Pointer(&amp;c.sendq.first)) == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步timer（&lt;=go1.22)</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line">        c.timer.maybeRunChan()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容量不为0，确认队列是否为空</span></span><br><span class="line">    <span class="keyword">return</span> atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>如何发送数据到channel？当使用代码<code>c &lt;- x</code>时，系统将编译为对chansend1的调用；当使用select发送数据时，编译为对selectnbsend的调用；而这两个函数最终会调用chansend</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `c &lt;- x`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chansend(c, elem, <span class="literal">true</span>, sys.GetCallerPC())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select代码块</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//    select &#123;</span></span><br><span class="line"><span class="comment">//    case c &lt;- v:</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    default:</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 编译为如下代码</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    if selectnbsend(c, v) &#123;</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, sys.GetCallerPC())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chansend代码如下，具体逻辑为</p>
<ol>
<li>select场景，非阻塞<ul>
<li>如果channel  已关闭，异常</li>
<li>如果channel  未初始化或buf已满，发送失败，返回</li>
</ul>
</li>
<li>c &lt;- v场景，阻塞<ul>
<li>如果channel  未初始化或已关闭，异常</li>
</ul>
</li>
<li>共同逻辑<ul>
<li>加锁double-check，如果channel  已关闭，异常</li>
<li>如果已经有读G在等待，说明buf为空，把数据给队列的第一个读G并唤醒，返回</li>
<li>buf未满，写入下一个空位置，更新索引、计数器，返回</li>
<li>buf已满，非阻塞返回写入失败，阻塞则把当前G封装到sudog放进写队列，挂起等待</li>
<li>被唤醒后<ul>
<li>如果是因为channel  被关闭导致的唤醒，异常</li>
<li>数据已被读G拿走，清理收尾</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递数据到channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 非阻塞-select</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;chansend: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞-select and channel未关闭 and buf已满</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 写入</span></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已关闭，异常</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经有读G在等待，说明buf为空，把数据给队列的第一个G并唤醒</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下场景：0 &lt;= buf_len &lt;= cap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf未满</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// 获取buf下一个可写入的地址</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        <span class="comment">// 写索引</span></span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素个数</span></span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf已满</span></span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="comment">// 加上上面的channel未关闭、buf已满，可以当作是double-check</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，挂起等待</span></span><br><span class="line">    <span class="comment">// Ps. 下面这交叉写看的好乱</span></span><br><span class="line">    gp := getg()                    <span class="comment">// 当前G</span></span><br><span class="line">    mysg := acquireSudog()          <span class="comment">// sudog</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span>            <span class="comment">// 纪录G在channel上阻塞的耗时</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    mysg.elem = ep                  <span class="comment">// x元素指针（c &lt;- x)</span></span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span>             <span class="comment">// ？</span></span><br><span class="line">    mysg.g = gp                     <span class="comment">// 把当前G放到sudog的g，双向绑定</span></span><br><span class="line">    mysg.isSelect = <span class="literal">false</span>           <span class="comment">// 非select操作</span></span><br><span class="line">    mysg.c = c                      <span class="comment">// channel</span></span><br><span class="line">    gp.waiting = mysg               <span class="comment">// 把sudog放到当前G的waiting，双向绑定</span></span><br><span class="line">    gp.param = <span class="literal">nil</span>                  <span class="comment">// 重置sudog指针</span></span><br><span class="line">    c.sendq.enqueue(mysg)           <span class="comment">// 把sudog放进队列</span></span><br><span class="line">    gp.parkingOnChan.Store(<span class="literal">true</span>)    <span class="comment">// 是否阻塞在channel</span></span><br><span class="line">    reason := waitReasonChanSend</span><br><span class="line">    <span class="keyword">if</span> c.synctest &#123;</span><br><span class="line">        reason = waitReasonSynctestChanSend</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起</span></span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), reason, traceBlockChanSend, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保x元素还活着</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向绑定异常</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span>                <span class="comment">// 当前G移除sudog绑定</span></span><br><span class="line">    gp.activeStackChans = <span class="literal">false</span>     <span class="comment">// 是否在等待channel操作</span></span><br><span class="line">    closed := !mysg.success         <span class="comment">// 关闭channel时设置为false，其他情况为true</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 纪录阻塞事件</span></span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span>                    <span class="comment">// 移除channel绑定</span></span><br><span class="line">    releaseSudog(mysg)              <span class="comment">// 删除sudog</span></span><br><span class="line">    <span class="comment">// 因为channel被关闭而导致的唤醒</span></span><br><span class="line">    <span class="keyword">if</span> closed &#123;、</span><br><span class="line">        <span class="comment">// 状态不匹配</span></span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已关闭channel不可写入</span></span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送元素value给读G并将其唤醒，buf为空才会走到这里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// synctest，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; sg.g.syncGroup != getg().syncGroup &#123;</span><br><span class="line">        unlockf()</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sg =&gt; 从recvq拿到的，ep =&gt; x元素指针（c &lt;- x)</span></span><br><span class="line">    <span class="comment">// y元素指针（y := &lt;- c)，如果是丢弃数值则不处理 =&gt; &lt;- c</span></span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep)</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读G</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    <span class="comment">// 纪录读sudog写到param</span></span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    sg.success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒读G</span></span><br><span class="line">    goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// sg =&gt; 从recvq获取的</span></span><br><span class="line">    <span class="comment">// 元素指针</span></span><br><span class="line">    dst := sg.elem</span><br><span class="line">    typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.Size_)</span><br><span class="line">    <span class="comment">// 复制数据</span></span><br><span class="line">    memmove(dst, src, t.Size_)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine被挂起休眠之前调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanparkcommit</span><span class="params">(gp *g, chanLock unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    gp.activeStackChans = <span class="literal">true</span>      <span class="comment">// 是否在等待channel操作</span></span><br><span class="line">    gp.parkingOnChan.Store(<span class="literal">false</span>)   <span class="comment">// 是否阻塞在channel</span></span><br><span class="line">    unlock((*mutex)(chanLock))      <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把sudog放进队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *waitq)</span></span> enqueue(sgp *sudog) &#123;</span><br><span class="line">    sgp.next = <span class="literal">nil</span></span><br><span class="line">    x := q.last</span><br><span class="line">    <span class="comment">// 队列为空</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        sgp.prev = <span class="literal">nil</span></span><br><span class="line">        q.first = sgp</span><br><span class="line">        q.last = sgp</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    sgp.prev = x</span><br><span class="line">    x.next = sgp</span><br><span class="line">    q.last = sgp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把sudog移出队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *waitq)</span></span> dequeue() *sudog &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 从头部开始</span></span><br><span class="line">        sgp := q.first</span><br><span class="line">        <span class="comment">// 队列为空</span></span><br><span class="line">        <span class="keyword">if</span> sgp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// next</span></span><br><span class="line">        y := sgp.next</span><br><span class="line">        <span class="comment">// 队列只有一个数据</span></span><br><span class="line">        <span class="keyword">if</span> y == <span class="literal">nil</span> &#123;</span><br><span class="line">            q.first = <span class="literal">nil</span></span><br><span class="line">            q.last = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 队列有多个数据</span></span><br><span class="line">            y.prev = <span class="literal">nil</span></span><br><span class="line">            q.first = y</span><br><span class="line">            sgp.next = <span class="literal">nil</span> <span class="comment">// mark as removed (see dequeueSudoG)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了一个sudog，但还有一个问题需要判断</span></span><br><span class="line">        <span class="comment">// G被select唤醒时，可能还未被移出队列</span></span><br><span class="line">        <span class="keyword">if</span> sgp.isSelect &#123;</span><br><span class="line">            <span class="keyword">if</span> !sgp.g.selectDone.CompareAndSwap(<span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// We lost the race to wake this goroutine.</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sgp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>如何从channel接收数据？当使用代码<code>&lt;- c</code>时，系统将根据返回值编译为对chanrecv1或chanrecv2的调用；当使用select接收数据时，编译为对selectnbrecv的调用；而这三个函数最终会调用chanrecv</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `&lt;- c` 或 `y := &lt;- c`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `y, ok := &lt;- c`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">    _, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select代码块</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    select &#123;</span></span><br><span class="line"><span class="comment">//    case v, ok = &lt;-c:</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    default:</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 编译为如下代码</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    if selected, ok = selectnbrecv(&amp;v, c); selected &#123;</span></span><br><span class="line"><span class="comment">//        ... foo</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//        ... bar</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chanrecv代码如下，具体逻辑为</p>
<ol>
<li>select场景，非阻塞<ul>
<li>如果  channel  未初始化或已关闭或buf为空，无数据，返回</li>
</ul>
</li>
<li>c &lt;- v场景，阻塞<ul>
<li>如果channel  未初始化，异常</li>
</ul>
</li>
<li>共同逻辑<ul>
<li>加锁double-check</li>
<li>如果channel  已关闭且buf为空，无数据，返回</li>
<li>如果已经有写G在等待，说明buf已满，读取队列的第一个写G并唤醒，返回</li>
<li>buf不为空，读循环队列，更新索引、计数器，返回</li>
<li>buf为空，非阻塞则返回读取失败，阻塞则把当前G封装到sudog放进读队列，挂起等待<ul>
<li>数据已从写G读到，清理收尾</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;chanrecv: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceBlockForever, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; getg().syncGroup == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;receive on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步timer（&lt;=go1.22)</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line">        c.timer.maybeRunChan()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞 and buf为空</span></span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line">        <span class="comment">// channel未关闭</span></span><br><span class="line">        <span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已关闭</span></span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="keyword">if</span> empty(c) &#123;</span><br><span class="line">            <span class="comment">// `y := &lt;- c` =&gt; ep不为nil，`&lt;- c` =&gt; ep为nil</span></span><br><span class="line">            <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">                typedmemclr(c.elemtype, ep)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 读取</span></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已关闭</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// buf为空</span></span><br><span class="line">        <span class="keyword">if</span> c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">            unlock(&amp;c.lock)</span><br><span class="line">            <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">                typedmemclr(c.elemtype, ep)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// channel已关闭但buf还有数据 0 &lt; buf_len &lt;= cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已经有写G在等待，说明buf已满，读取buf第一个数据，队列的第一个写G数据补上buf然后唤醒</span></span><br><span class="line">        <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">            recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// buf未满 0 &lt;= buf_len &lt; cap</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下场景：0 &lt;= buf_len &lt;= cap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf不为空</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取buf下一个可读取的地址</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemclr(c.elemtype, qp)</span><br><span class="line">        <span class="comment">// 读索引</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素个数</span></span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf为空</span></span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="comment">// 可以理解为加锁后的double-check</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，挂起等待</span></span><br><span class="line">    gp := getg()                    <span class="comment">// 当前G</span></span><br><span class="line">    mysg := acquireSudog()          <span class="comment">// 获取sudog</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span>            <span class="comment">// 纪录G在channel上阻塞的耗时</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    mysg.elem = ep                  <span class="comment">// y元素指针（y := &lt;- c)</span></span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span>             <span class="comment">// ？</span></span><br><span class="line">    gp.waiting = mysg               <span class="comment">// 把sudog放到当前G的waiting，双向绑定</span></span><br><span class="line">    mysg.g = gp                     <span class="comment">// 把当前G放到sudog的g，双向绑定</span></span><br><span class="line">    mysg.isSelect = <span class="literal">false</span>           <span class="comment">// 非select操作</span></span><br><span class="line">    mysg.c = c                      <span class="comment">// channel</span></span><br><span class="line">    gp.param = <span class="literal">nil</span>                  <span class="comment">// 重置sudog指针</span></span><br><span class="line">    c.recvq.enqueue(mysg)           <span class="comment">// 把sudog放进队列</span></span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// G挂起休眠之前，将定时器标记为阻塞并加入最小堆</span></span><br><span class="line">        blockTimerChan(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp.parkingOnChan.Store(<span class="literal">true</span>)    <span class="comment">// 是否阻塞在channel</span></span><br><span class="line">    reason := waitReasonChanReceive</span><br><span class="line">    <span class="keyword">if</span> c.synctest &#123;</span><br><span class="line">        reason = waitReasonSynctestChanReceive</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起</span></span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), reason, traceBlockChanRecv, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向绑定异常</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步定时器</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// G唤醒后，将定时器标记为非阻塞、删除状态</span></span><br><span class="line">        unblockTimerChan(c)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span>                <span class="comment">// 当前G移除sudog绑定</span></span><br><span class="line">    gp.activeStackChans = <span class="literal">false</span>     <span class="comment">// 是否在等待channel操作</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 纪录阻塞事件</span></span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    success := mysg.success         <span class="comment">// 关闭channel时设置为false，其他情况为true</span></span><br><span class="line">    gp.param = <span class="literal">nil</span>                  <span class="comment">// 重置sudog指针</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span>                    <span class="comment">// 移除channel绑定</span></span><br><span class="line">    releaseSudog(mysg)              <span class="comment">// 释放sudog</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从写G读取元素value并将其唤醒，buf已满才会走到这里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// synctest，忽略</span></span><br><span class="line">    <span class="keyword">if</span> c.synctest &amp;&amp; sg.g.syncGroup != getg().syncGroup &#123;</span><br><span class="line">        unlockf()</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;receive on synctest channel from outside bubble&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sg =&gt; 从sendq拿到的，ep =&gt; y元素指针（y := &lt;- c)</span></span><br><span class="line">    <span class="comment">// 无缓冲channel</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            recvDirect(c.elemtype, sg, ep)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有缓冲channel</span></span><br><span class="line">        <span class="comment">// buf已满</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="comment">// 把数组第一个可读元素复制给读G</span></span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把写G的数据复制到这个位置上，补充数组元素</span></span><br><span class="line">        typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">        <span class="comment">// 读索引</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写索引，既然buf已满，读跟写的位置自然一样</span></span><br><span class="line">        c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写G的数据已经复制到buf上了</span></span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 写G</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    <span class="comment">// 写G的sudog放到param</span></span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="comment">// 关闭channel时设置为false，其他情况为true</span></span><br><span class="line">    sg.success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒写G</span></span><br><span class="line">    goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// sg =&gt; 从sendq获取的</span></span><br><span class="line">    <span class="comment">// 元素指针</span></span><br><span class="line">    src := sg.elem</span><br><span class="line">    typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.Size_)</span><br><span class="line">    memmove(dst, src, t.Size_)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h2><p>关闭channel  ，具体逻辑如下</p>
<ol>
<li>如果channel  未初始化或已关闭，异常</li>
<li>channel  设为已关闭closed&#x3D;1</li>
<li>收集并唤醒所有在读写队列的G（写G会抛出异常）</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 已关闭，异常</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭channel</span></span><br><span class="line">    c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集所有在读写队列里的G</span></span><br><span class="line">    <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有读G</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.recvq.dequeue()</span><br><span class="line">        <span class="comment">// 没数据，退出</span></span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">            sg.elem = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = unsafe.Pointer(sg)</span><br><span class="line">        sg.success = <span class="literal">false</span></span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有写G</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.sendq.dequeue()</span><br><span class="line">        <span class="comment">// 没数据，退出</span></span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = unsafe.Pointer(sg)</span><br><span class="line">        sg.success = <span class="literal">false</span></span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有G</span></span><br><span class="line">    <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">        gp := glist.pop()</span><br><span class="line">        gp.schedlink = <span class="number">0</span></span><br><span class="line">        goready(gp, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取channel-数据量"><a href="#获取channel-数据量" class="headerlink" title="获取channel  数据量"></a>获取channel  数据量</h2><p>当调用<code>len(c)</code>时，系统调用chanlen实现，具体逻辑如下</p>
<ol>
<li>未初始化的channel  数据量为0</li>
<li>如果是异步timer，返回qcount的数值</li>
<li>如果是同步timer，返回0</li>
<li>其他情况一律返回channel  字段qcount的数值</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanlen</span><span class="params">(c *hchan)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// asynctimerchan=0 =&gt; 如果是go1.23版本及以后</span></span><br><span class="line">    <span class="comment">// asynctimerchan=1 =&gt; 如果是go1.22版本及以前</span></span><br><span class="line">    async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 异步timer（&lt;=go1.22)</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &amp;&amp; async &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line">        c.timer.maybeRunChan()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步timer（&gt;=go1.23)，dirty hack，让timer的len一直为0</span></span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &amp;&amp; !async &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(c.qcount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取channel-容量"><a href="#获取channel-容量" class="headerlink" title="获取channel  容量"></a>获取channel  容量</h2><p>当调用<code>cap(c)</code>时，系统调用chancap实现，具体逻辑如下</p>
<ol>
<li>未初始化的channel  容量为0</li>
<li>如果是异步timer，返回dataqsiz的数值</li>
<li>如果是同步timer，返回0</li>
<li>其他情况一律返回channel  字段dataqsiz的数值</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chancap</span><span class="params">(c *hchan)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// channel未初始化</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// asynctimerchan=0 =&gt; 如果是go1.23版本及以后</span></span><br><span class="line">        <span class="comment">// asynctimerchan=1 =&gt; 如果是go1.22版本及以前</span></span><br><span class="line">        async := debug.asynctimerchan.Load() != <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> async &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">int</span>(c.dataqsiz)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同步timer（&gt;=go1.23)，dirty hack，让timer的cap一直为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(c.dataqsiz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器相关"><a href="#定时器相关" class="headerlink" title="定时器相关"></a>定时器相关</h2><h3 id="maybeRunChan"><a href="#maybeRunChan" class="headerlink" title="maybeRunChan"></a>maybeRunChan</h3><p>判断是否需要更新timer状态、执行函数f。具体逻辑如下</p>
<ol>
<li>不满足条件则返回<ul>
<li>timer已经放在最小堆上，那么过期后自动发送到channel</li>
<li>timer从未执行过</li>
<li>timer还未到触发时刻</li>
</ul>
</li>
<li>满足条件则更新timer状态、执行函数f</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要更新timer状态、执行函数f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span></span> maybeRunChan() &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        t.lock()</span><br><span class="line">        <span class="keyword">var</span> timerGroup *synctestGroup</span><br><span class="line">        <span class="keyword">if</span> t.ts != <span class="literal">nil</span> &#123;</span><br><span class="line">            timerGroup = t.ts.syncGroup</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        sg := getg().syncGroup</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;synctest timer accessed from outside bubble&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> timerGroup != <span class="literal">nil</span> &amp;&amp; sg != timerGroup &#123;</span><br><span class="line">            <span class="built_in">panic</span>(plainError(<span class="string">&quot;timer moved between synctest bubbles&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果timer已经在最小堆中，过期后自动发送到channel</span></span><br><span class="line">    <span class="keyword">if</span> t.astate.Load()&amp;timerHeaped != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// 当前时刻，单调时钟</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 加锁后double-check</span></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer从未执行过</span></span><br><span class="line">    <span class="comment">// 3. timer还未到触发时刻</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> || t.when == <span class="number">0</span> || t.when &gt; now &#123;</span><br><span class="line">        <span class="comment">// debug用，忽略</span></span><br><span class="line">        t.trace(<span class="string">&quot;maybeRunChan-&quot;</span>)</span><br><span class="line">        <span class="comment">// 用state字段数据更新astate，然后再解锁</span></span><br><span class="line">        t.unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug用，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;maybeRunChan+&quot;</span>)</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、执行函数f</span></span><br><span class="line">        t.unlockAndRun(now)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="blockTimerChan-unblockTimerChan"><a href="#blockTimerChan-unblockTimerChan" class="headerlink" title="blockTimerChan &amp; unblockTimerChan"></a>blockTimerChan &amp; unblockTimerChan</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个10ms过期的定时器</span></span><br><span class="line">t := time.NewTimer(<span class="number">10</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待定时器过期信号</span></span><br><span class="line">&lt;-t.C</span><br></pre></td></tr></table></figure>

<p>上述示例代码，如果这个channel是属于一个定时器的，那么在G挂起前、唤醒后，需要修改定时器的state-状态、blocked-标记等。函数详细注释如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// G挂起休眠之前，将定时器标记为阻塞并加入最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;blockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. timer已经在最小堆中</span></span><br><span class="line">    <span class="comment">// 2. timer已标记删除</span></span><br><span class="line">    <span class="comment">// 3. 过期时刻大于0</span></span><br><span class="line">    <span class="keyword">if</span> t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie != <span class="number">0</span> &amp;&amp; t.when &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t.state &amp;^= timerZombie <span class="comment">// 移除标志位</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">-1</span>)    <span class="comment">// 计数器zombies-=1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要把定时器放到timers.heap</span></span><br><span class="line">    add := t.needsAdd()</span><br><span class="line">    t.unlock()</span><br><span class="line">    <span class="keyword">if</span> add &#123;</span><br><span class="line">        <span class="comment">// 更新timer状态、添加到最小堆、中断网络轮询（跟modify函数有些相似）</span></span><br><span class="line">        t.maybeAdd()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G唤醒后，将定时器标记为非阻塞、删除状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unblockTimerChan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    t := c.timer</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> t.isFake &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.lock()</span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    t.trace(<span class="string">&quot;unblockTimerChan&quot;</span>)</span><br><span class="line">    <span class="comment">// 异步定时器 or 计数器为0，异常</span></span><br><span class="line">    <span class="keyword">if</span> !t.isChan || t.blocked == <span class="number">0</span> &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的G数量</span></span><br><span class="line">    t.blocked--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器为0 and timer已经在最小堆中 and timer无删除标记</span></span><br><span class="line">    <span class="keyword">if</span> t.blocked == <span class="number">0</span> &amp;&amp; t.state&amp;timerHeaped != <span class="number">0</span> &amp;&amp; t.state&amp;timerZombie == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 标记为删除</span></span><br><span class="line">        t.state |= timerZombie</span><br><span class="line">        <span class="comment">// 计数器zombies+=1</span></span><br><span class="line">        t.ts.zombies.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">6.4 Channel</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-hashtriemap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-hashtriemap/" class="post-title-link" itemprop="url">golang系列之-sync.Map(HashTrieMap)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-20 23:06:09" itemprop="dateCreated datePublished" datetime="2025-02-20T23:06:09+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从1.24版开始，sync.Map改用HashTrieMap重构，与之前的双map实现不同，HashTrieMap更像是一个B树，简单的示例图如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  root -&gt; | idx0    | idx1       | ... | idx15 |</span></span><br><span class="line"><span class="comment">//          | &amp;entry0 | &amp;indirect0 | ... | nil   |</span></span><br><span class="line"><span class="comment">//                          |</span></span><br><span class="line"><span class="comment">//                       children</span></span><br><span class="line"><span class="comment">//                          v</span></span><br><span class="line"><span class="comment">//                    | idx0 | idx1    | ... | idx15 |</span></span><br><span class="line"><span class="comment">//                    | nil  | &amp;entry1 | ... | nil   |</span></span><br></pre></td></tr></table></figure>

<p>使用哈希函数生成64位的哈希值，从高到低4位为一个idx，最多有16层，每个节点可容纳16个元素，最多可容纳16^16&#x3D;2^64个元素</p>
<p>当前go版本：1.24</p>
<blockquote>
<p>HashTrieMap的开关放在文件<code>src/internal/buildcfg/exp.go</code>的函数<code>ParseGOEXPERIMENT</code>中</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HashTrieMap[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    inited   atomic.Uint32                          <span class="comment">// 是否已初始化</span></span><br><span class="line">    initMu   Mutex                                  <span class="comment">// 锁，用于初始化</span></span><br><span class="line">    root     atomic.Pointer[indirect[K, V]]         <span class="comment">// 根节点</span></span><br><span class="line">    keyHash  hashFunc                               <span class="comment">// 哈希函数，用于key</span></span><br><span class="line">    valEqual equalFunc                              <span class="comment">// cmp函数，用于value</span></span><br><span class="line">    seed     <span class="type">uintptr</span>                                <span class="comment">// 哈希种子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部节点</span></span><br><span class="line"><span class="keyword">type</span> indirect[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    node[K, V]                                      <span class="comment">// isEntry=false</span></span><br><span class="line">    dead     atomic.Bool                            <span class="comment">// 是否被删除</span></span><br><span class="line">    mu       Mutex                                  <span class="comment">// 锁，用于children</span></span><br><span class="line">    parent   *indirect[K, V]                        <span class="comment">// 父节点指针</span></span><br><span class="line">    children [nChildren]atomic.Pointer[node[K, V]]  <span class="comment">// 16个子节点，指向indirect或entry</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点</span></span><br><span class="line"><span class="keyword">type</span> entry[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    node[K, V]                                      <span class="comment">// isEntry=true</span></span><br><span class="line">    overflow atomic.Pointer[entry[K, V]]            <span class="comment">// 指针，当两个entry哈希值相同时以链表方式存储</span></span><br><span class="line">    key      K                                      <span class="comment">// 键</span></span><br><span class="line">    value    V                                      <span class="comment">// 值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry和indirect的共有属性</span></span><br><span class="line"><span class="keyword">type</span> node[K comparable, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    isEntry <span class="type">bool</span>                                    <span class="comment">// 判断是叶子节点还是内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>根据key获取value，具体逻辑如下</p>
<ol>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，即没找到，返回</li>
<li>如果子节点是叶子节点，搜索链表并返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Load(key K) (value V, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">    i := ht.root.Load()</span><br><span class="line">    <span class="comment">// hashShift=64 =&gt; 64/4=16，整个trie最多有16层</span></span><br><span class="line">    hashShift := <span class="number">8</span> * goarch.PtrSize</span><br><span class="line">    <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// hashShift-=4</span></span><br><span class="line">        hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">        n := i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask].Load()</span><br><span class="line">        <span class="comment">// 子节点为nil，返回空值</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> n.isEntry &#123;</span><br><span class="line">            <span class="comment">// 搜索链表</span></span><br><span class="line">            <span class="keyword">return</span> n.entry().lookup(key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// curr指针指向子节点</span></span><br><span class="line">        i = n.indirect()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> init() &#123;</span><br><span class="line">    <span class="keyword">if</span> ht.inited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 未初始化</span></span><br><span class="line">        ht.initSlow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> initSlow() &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    ht.initMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> ht.initMu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="keyword">if</span> ht.inited.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 其他G在当前G等待时已经初始化了</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[K]V                               <span class="comment">// 临时map</span></span><br><span class="line">    mapType := abi.TypeOf(m).MapType()          <span class="comment">// 获取maptype</span></span><br><span class="line">    ht.root.Store(newIndirectNode[K, V](<span class="literal">nil</span>))   <span class="comment">// parent=nil</span></span><br><span class="line">    ht.keyHash = mapType.Hasher                 <span class="comment">// 复制map的哈希函数</span></span><br><span class="line">    ht.valEqual = mapType.Elem.Equal            <span class="comment">// 复制map的cmp函数</span></span><br><span class="line">    ht.seed = <span class="type">uintptr</span>(runtime_rand())           <span class="comment">// 生成哈希种子</span></span><br><span class="line"></span><br><span class="line">    ht.inited.Store(<span class="number">1</span>)                          <span class="comment">// inited设为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成内部节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newIndirectNode</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(parent *indirect[K, V])</span></span> *indirect[K, V] &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;indirect[K, V]&#123;node: node[K, V]&#123;isEntry: <span class="literal">false</span>&#125;, parent: parent&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表搜索key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry[K, V])</span></span> lookup(key K) (V, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &#123;</span><br><span class="line">            <span class="keyword">return</span> e.value, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>存储key&#x2F;value。本质就是Swap方法，但丢弃其返回值，具体看Swap</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Store(key K, old V) &#123;</span><br><span class="line">    _, _ = ht.Swap(key, old)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadOrStore"><a href="#LoadOrStore" class="headerlink" title="LoadOrStore"></a>LoadOrStore</h3><p>根据key获取value，获取失败则保存key&#x2F;value，具体逻辑如下</p>
<ol>
<li>Load<ul>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则返回</li>
</ul>
</li>
<li>Store<ul>
<li>纪录搜索中断位置的curr节点指针i和子节点指针slot、n</li>
<li>如果n为nil，直接写入children</li>
<li>如果n为叶子节点，放进链表，或者分裂后再存储进children</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> LoadOrStore(key K, value V) (result V, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i *indirect[K, V]                   <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">    <span class="keyword">var</span> hashShift <span class="type">uint</span>                      <span class="comment">// 用于计算idx</span></span><br><span class="line">    <span class="keyword">var</span> slot *atomic.Pointer[node[K, V]]    <span class="comment">// 子节点指针的指针</span></span><br><span class="line">    <span class="keyword">var</span> n *node[K, V]                       <span class="comment">// 子节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Load</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">        i = ht.root.Load()</span><br><span class="line">        <span class="comment">// hashShift=64 =&gt; 64/4=16，整个trie最多有16层</span></span><br><span class="line">        hashShift = <span class="number">8</span> * goarch.PtrSize</span><br><span class="line">        <span class="comment">// 当前循环是否已经找到写入点</span></span><br><span class="line">        haveInsertPoint := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// hashShift-=4</span></span><br><span class="line">            hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取子节点指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">            slot = &amp;i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask]</span><br><span class="line">            n = slot.Load()</span><br><span class="line">            <span class="comment">// 子节点为nil，可写入，结束循环</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">                haveInsertPoint = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> n.isEntry &#123;</span><br><span class="line">                <span class="comment">// 搜索链表 -&gt; Load</span></span><br><span class="line">                <span class="keyword">if</span> v, ok := n.entry().lookup(key); ok &#123;</span><br><span class="line">                    <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 叶子节点默认可写</span></span><br><span class="line">                haveInsertPoint = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = n.indirect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> !haveInsertPoint &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        i.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        n = slot.Load()</span><br><span class="line">        <span class="comment">// 子节点为nil或叶子节点 and 当前节点未删除</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nil</span> || n.isEntry) &amp;&amp; !i.dead.Load() &#123;</span><br><span class="line">            <span class="comment">// 确认可写入，slot查找结束</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Load失败，改为Store</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在for循环里已经加锁了</span></span><br><span class="line">    <span class="keyword">defer</span> i.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oldEntry *entry[K, V]</span><br><span class="line">    <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">        oldEntry = n.entry()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="keyword">if</span> v, ok := oldEntry.lookup(key); ok &#123;</span><br><span class="line">            <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建叶子节点</span></span><br><span class="line">    newEntry := newEntryNode(key, value)</span><br><span class="line">    <span class="comment">// 原子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> oldEntry == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接存储</span></span><br><span class="line">        slot.Store(&amp;newEntry.node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 原子节点为叶子节点</span></span><br><span class="line">        <span class="comment">// 放进链表，或者分裂后再存储进children</span></span><br><span class="line">        slot.Store(ht.expand(oldEntry, newEntry, hash, hashShift, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> expand(oldEntry, newEntry *entry[K, V], newHash <span class="type">uintptr</span>, hashShift <span class="type">uint</span>, parent *indirect[K, V]) *node[K, V] &#123;</span><br><span class="line">    <span class="comment">// 哈希碰撞</span></span><br><span class="line">    oldHash := ht.keyHash(unsafe.Pointer(&amp;oldEntry.key), ht.seed)</span><br><span class="line">    <span class="comment">// 1. 新旧哈希值相同</span></span><br><span class="line">    <span class="keyword">if</span> oldHash == newHash &#123;</span><br><span class="line">        <span class="comment">// 放进链表开头</span></span><br><span class="line">        newEntry.overflow.Store(oldEntry)</span><br><span class="line">        <span class="keyword">return</span> &amp;newEntry.node</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 新旧哈希值不同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建内部节点</span></span><br><span class="line">    newIndirect := newIndirectNode(parent)</span><br><span class="line">    <span class="comment">// 纪录父节点</span></span><br><span class="line">    top := newIndirect</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> hashShift == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while inserting&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hashShift-=4</span></span><br><span class="line">        hashShift -= nChildrenLog2</span><br><span class="line">        <span class="comment">// 从高到低，找到两个哈希值不同的4位</span></span><br><span class="line">        oi := (oldHash &gt;&gt; hashShift) &amp; nChildrenMask</span><br><span class="line">        ni := (newHash &gt;&gt; hashShift) &amp; nChildrenMask</span><br><span class="line">        <span class="comment">// idx不同</span></span><br><span class="line">        <span class="keyword">if</span> oi != ni &#123;</span><br><span class="line">            newIndirect.children[oi].Store(&amp;oldEntry.node)</span><br><span class="line">            newIndirect.children[ni].Store(&amp;newEntry.node)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// idx相同</span></span><br><span class="line">        <span class="comment">// 把oldEntry向下挪动一层</span></span><br><span class="line">        nextIndirect := newIndirectNode(newIndirect)</span><br><span class="line">        newIndirect.children[oi].Store(&amp;nextIndirect.node)</span><br><span class="line">        newIndirect = nextIndirect</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回top节点</span></span><br><span class="line">    <span class="keyword">return</span> &amp;top.node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntryNode</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(key K, value V)</span></span> *entry[K, V] &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;entry[K, V]&#123;</span><br><span class="line">        node:  node[K, V]&#123;isEntry: <span class="literal">true</span>&#125;,</span><br><span class="line">        key:   key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>删除指定key，具体看LoadAndDelete</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Delete(key K) &#123;</span><br><span class="line">    _, _ = ht.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadAndDelete"><a href="#LoadAndDelete" class="headerlink" title="LoadAndDelete"></a>LoadAndDelete</h3><p>根据key获取value并删除该key，具体逻辑如下</p>
<ol>
<li>Load<ul>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，返回</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则纪录起来</li>
</ul>
</li>
<li>Delete<ul>
<li>纪录子节点位置的curr节点指针i和子节点指针slot、n</li>
<li>如果删除key后，叶子节点链表不为空，回写并返回</li>
<li>如果删除key后，叶子节点链表为空，从curr开始往上搜索删除空的节点</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> LoadAndDelete(key K) (value V, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key和value查找子节点，返回curr节点指针i、子节点索引idx、子节点指针slot、n</span></span><br><span class="line">    i, hashShift, slot, n := ht.find(key, hash, <span class="literal">nil</span>, *<span class="built_in">new</span>(V))</span><br><span class="line">    <span class="comment">// 子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 子节点被删除</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">            i.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点获取并删除指定key，返回旧值v、链表头e、是否成功获取loaded</span></span><br><span class="line">    v, e, loaded := n.entry().loadAndDelete(key)</span><br><span class="line">    <span class="comment">// 获取key失败</span></span><br><span class="line">    <span class="keyword">if</span> !loaded &#123;</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除key后，链表不为空</span></span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 回写</span></span><br><span class="line">        slot.Store(&amp;e.node)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除key后，链表为空，把叶子节点也删掉</span></span><br><span class="line">    slot.Store(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从curr开始往上搜索删除空的节点</span></span><br><span class="line">    <span class="comment">// curr节点的父节点不为nil and curr节点没有子节点</span></span><br><span class="line">    <span class="keyword">for</span> i.parent != <span class="literal">nil</span> &amp;&amp; i.empty() &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> hashShift == <span class="number">8</span>*goarch.PtrSize &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hashShift+=4</span></span><br><span class="line">        hashShift += nChildrenLog2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在父节点删除curr节点</span></span><br><span class="line">        parent := i.parent</span><br><span class="line">        parent.mu.Lock()</span><br><span class="line">        i.dead.Store(<span class="literal">true</span>)</span><br><span class="line">        parent.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask].Store(<span class="literal">nil</span>)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        i = parent</span><br><span class="line">    &#125;</span><br><span class="line">    i.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key和value查找子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> find(key K, hash <span class="type">uintptr</span>, valEqual equalFunc, value V) (i *indirect[K, V], hashShift <span class="type">uint</span>, slot *atomic.Pointer[node[K, V]], n *node[K, V]) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">        i = ht.root.Load()</span><br><span class="line">        hashShift = <span class="number">8</span> * goarch.PtrSize <span class="comment">// 64</span></span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 找到i和n</span></span><br><span class="line">        <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// hashShift-=4</span></span><br><span class="line">            hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">            slot = &amp;i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask]</span><br><span class="line">            n = slot.Load()</span><br><span class="line">            <span class="comment">// 子节点为nil</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">                i = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> n.isEntry &#123;</span><br><span class="line">                <span class="comment">// 根据key和value比对搜索</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := n.entry().lookupWithValue(key, value, valEqual); !ok &#123;</span><br><span class="line">                    i = <span class="literal">nil</span></span><br><span class="line">                    n = <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到了</span></span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = n.indirect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">if</span> !found &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到了</span></span><br><span class="line"></span><br><span class="line">        i.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        n = slot.Load()</span><br><span class="line">        <span class="comment">// 当前节点未删除</span></span><br><span class="line">        <span class="keyword">if</span> !i.dead.Load() &amp;&amp; (n == <span class="literal">nil</span> || n.isEntry) &#123;</span><br><span class="line">            <span class="comment">// 不管现在子节点是什么状态</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新扫描</span></span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key和value比对搜索</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry[K, V])</span></span> lookupWithValue(key K, value V, valEqual equalFunc) (V, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 比对key和value</span></span><br><span class="line">        <span class="keyword">if</span> e.key == key &amp;&amp; (valEqual == <span class="literal">nil</span> || valEqual(unsafe.Pointer(&amp;e.value), abi.NoEscape(unsafe.Pointer(&amp;value)))) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.value, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">new</span>(V), <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> loadAndDelete(key K) (V, *entry[K, V], <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> head.value, head.overflow.Load(), <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &#123;</span><br><span class="line">            <span class="comment">// 移除当前节点 =&gt; 使prev指向next</span></span><br><span class="line">            i.Store(e.overflow.Load())</span><br><span class="line">            <span class="keyword">return</span> e.value, head, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回零值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">new</span>(V), head, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点是否有children</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *indirect[K, V])</span></span> empty() <span class="type">bool</span> &#123;</span><br><span class="line">    nc := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> i.children &#123;</span><br><span class="line">        <span class="keyword">if</span> i.children[j].Load() != <span class="literal">nil</span> &#123;</span><br><span class="line">            nc++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nc == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndDelete"><a href="#CompareAndDelete" class="headerlink" title="CompareAndDelete"></a>CompareAndDelete</h3><p>根据key和value搜索，如找到则删除该数据，具体逻辑如下</p>
<ol>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，返回</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则删除</li>
<li>如果删除key后，叶子节点链表不为空，回写并返回</li>
<li>如果删除key后，叶子节点链表为空，从curr开始往上搜索删除空的节点</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> CompareAndDelete(key K, old V) (deleted <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// value对比函数不能为空 =&gt; 类型无法比对</span></span><br><span class="line">    <span class="keyword">if</span> ht.valEqual == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;called CompareAndDelete when value is not of comparable type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key和value查找子节点，返回curr节点指针i、子节点索引idx、子节点指针slot、n</span></span><br><span class="line">    i, hashShift, slot, n := ht.find(key, hash, <span class="literal">nil</span>, *<span class="built_in">new</span>(V))</span><br><span class="line">    <span class="comment">// 子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 被删除</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">            i.mu.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点比对并删除指定key/value，返回链表头e、是否成功删除deleted</span></span><br><span class="line">    e, deleted := n.entry().compareAndDelete(key, old, ht.valEqual)</span><br><span class="line">    <span class="comment">// 删除失败</span></span><br><span class="line">    <span class="keyword">if</span> !deleted &#123;</span><br><span class="line">        <span class="comment">// Nothing was actually deleted, which means the node is no longer there.</span></span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除key后，链表不为空</span></span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 回写</span></span><br><span class="line">        slot.Store(&amp;e.node)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除key后，链表为空，把叶子节点也删掉</span></span><br><span class="line">    slot.Store(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从curr开始往上搜索删除空的节点</span></span><br><span class="line">    <span class="comment">// curr节点的父节点不为nil and curr节点没有子节点</span></span><br><span class="line">    <span class="keyword">for</span> i.parent != <span class="literal">nil</span> &amp;&amp; i.empty() &#123;</span><br><span class="line">        <span class="keyword">if</span> hashShift == <span class="number">8</span>*goarch.PtrSize &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hashShift+=4</span></span><br><span class="line">        hashShift += nChildrenLog2</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在父节点中删除当前节点</span></span><br><span class="line">        parent := i.parent</span><br><span class="line">        parent.mu.Lock()</span><br><span class="line">        i.dead.Store(<span class="literal">true</span>)</span><br><span class="line">        parent.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask].Store(<span class="literal">nil</span>)</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">        i = parent</span><br><span class="line">    &#125;</span><br><span class="line">    i.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> compareAndDelete(key K, value V, valEqual equalFunc) (*entry[K, V], <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;head.value), abi.NoEscape(unsafe.Pointer(&amp;value))) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.overflow.Load(), <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;e.value), abi.NoEscape(unsafe.Pointer(&amp;value))) &#123;</span><br><span class="line">            <span class="comment">// 移除当前节点 =&gt; prev指向next</span></span><br><span class="line">            i.Store(e.overflow.Load())</span><br><span class="line">            <span class="keyword">return</span> head, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>用新的value替换旧的value，具体逻辑如下</p>
<ol>
<li>查找可替换key的位置<ul>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点为nil或叶子节点，且当前节点未被删除，纪录位置信息，结束查找</li>
</ul>
</li>
<li>替换value<ul>
<li>如果子节点是叶子节点，在链表查找并替换value，替换成功回写并返回</li>
<li>如果子节点是nil<ul>
<li>如果slot为空，直接写入</li>
<li>如果slot不为空，放进链表，或者分裂后再存储进children</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Swap(key K, <span class="built_in">new</span> V) (previous V, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i *indirect[K, V]                   <span class="comment">// curr节点指针，从根节点开始</span></span><br><span class="line">    <span class="keyword">var</span> hashShift <span class="type">uint</span>                      <span class="comment">// 用于计算idx</span></span><br><span class="line">    <span class="keyword">var</span> slot *atomic.Pointer[node[K, V]]    <span class="comment">// 子节点指针的指针</span></span><br><span class="line">    <span class="keyword">var</span> n *node[K, V]                       <span class="comment">// 子节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 查找可替换key的位置</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// curr指针，从根节点开始</span></span><br><span class="line">        i = ht.root.Load()</span><br><span class="line">        <span class="comment">// hashShift=64 =&gt; 64/4=16，整个trie最多有16层</span></span><br><span class="line">        hashShift = <span class="number">8</span> * goarch.PtrSize</span><br><span class="line">        <span class="comment">// 当前循环是否已经找到写入点</span></span><br><span class="line">        haveInsertPoint := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> hashShift != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// hashShift-=4</span></span><br><span class="line">            hashShift -= nChildrenLog2</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取子节点指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从高到低，每次拿4位bit作为idx</span></span><br><span class="line">            slot = &amp;i.children[(hash&gt;&gt;hashShift)&amp;nChildrenMask]</span><br><span class="line">            n = slot.Load()</span><br><span class="line">            <span class="comment">// 子节点为nil或叶子节点，可替换，结束循环</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> || n.isEntry &#123;</span><br><span class="line">                haveInsertPoint = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = n.indirect()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> !haveInsertPoint &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;internal/sync.HashTrieMap: ran out of hash bits while iterating&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        i.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        n = slot.Load()</span><br><span class="line">        <span class="comment">// 子节点为nil或叶子节点 and 当前节点未删除</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nil</span> || n.isEntry) &amp;&amp; !i.dead.Load() &#123;</span><br><span class="line">            <span class="comment">// 确认可替换，slot查找结束</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 替换value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在for循环里已经加锁了</span></span><br><span class="line">    <span class="keyword">defer</span> i.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> zero V</span><br><span class="line">    <span class="keyword">var</span> oldEntry *entry[K, V]</span><br><span class="line">    <span class="comment">// 子节点是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 替换value</span></span><br><span class="line">        oldEntry = n.entry()</span><br><span class="line">        newEntry, old, swapped := oldEntry.swap(key, <span class="built_in">new</span>)</span><br><span class="line">        <span class="keyword">if</span> swapped &#123;</span><br><span class="line">            <span class="comment">// 替换成功，回写</span></span><br><span class="line">            slot.Store(&amp;newEntry.node)</span><br><span class="line">            <span class="keyword">return</span> old, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建叶子节点</span></span><br><span class="line">    newEntry := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">    <span class="comment">// 原子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> oldEntry == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接存储</span></span><br><span class="line">        slot.Store(&amp;newEntry.node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 原子节点为叶子节点</span></span><br><span class="line">        <span class="comment">// 放进链表，或者分裂后再存储进children</span></span><br><span class="line">        slot.Store(ht.expand(oldEntry, newEntry, hash, hashShift, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zero, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> swap(key K, <span class="built_in">new</span> V) (*entry[K, V], V, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &#123;</span><br><span class="line">        <span class="comment">// 替换entry</span></span><br><span class="line">        e := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">        <span class="keyword">if</span> chain := head.overflow.Load(); chain != <span class="literal">nil</span> &#123;</span><br><span class="line">            e.overflow.Store(chain)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e, head.value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &#123;</span><br><span class="line">            <span class="comment">// 替换当前节点</span></span><br><span class="line">            eNew := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">            eNew.overflow.Store(e.overflow.Load())</span><br><span class="line">            i.Store(eNew)</span><br><span class="line">            <span class="keyword">return</span> head, e.value, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回零值</span></span><br><span class="line">    <span class="keyword">var</span> zero V</span><br><span class="line">    <span class="keyword">return</span> head, zero, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h3><p>根据key和value搜索，如找到则用新的value替换旧的value，具体逻辑如下</p>
<ol>
<li>从根节点开始，使用hash(key)计算出idx用于检索children</li>
<li>如果子节点是nil，返回</li>
<li>如果子节点是叶子节点，搜索链表，有比对成功的key&#x2F;value则替换</li>
<li>替换失败，直接返回；替换成功，回写并返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> CompareAndSwap(key K, old, <span class="built_in">new</span> V) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// value对比函数不能为空 =&gt; 类型无法比对</span></span><br><span class="line">    <span class="keyword">if</span> ht.valEqual == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;called CompareAndSwap when value is not of comparable type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    hash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&amp;key)), ht.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key和value查找子节点，返回curr节点指针i、子节点索引idx、子节点指针slot、n</span></span><br><span class="line">    i, _, slot, n := ht.find(key, hash, ht.valEqual, old)</span><br><span class="line">    <span class="keyword">if</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> i.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点为nil</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点搜索并替换指定key/value，返回链表头e、是否成功交换swapped</span></span><br><span class="line">    e, swapped := n.entry().compareAndSwap(key, old, <span class="built_in">new</span>, ht.valEqual)</span><br><span class="line">    <span class="comment">// 替换失败</span></span><br><span class="line">    <span class="keyword">if</span> !swapped &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功，回写</span></span><br><span class="line">    slot.Store(&amp;e.node)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *entry[K, V])</span></span> compareAndSwap(key K, old, <span class="built_in">new</span> V, valEqual equalFunc) (*entry[K, V], <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个数据就是目标</span></span><br><span class="line">    <span class="keyword">if</span> head.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;head.value), abi.NoEscape(unsafe.Pointer(&amp;old))) &#123;</span><br><span class="line">        e := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">        <span class="keyword">if</span> chain := head.overflow.Load(); chain != <span class="literal">nil</span> &#123;</span><br><span class="line">            e.overflow.Store(chain)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描整个链表</span></span><br><span class="line">    i := &amp;head.overflow</span><br><span class="line">    e := i.Load()</span><br><span class="line">    <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.key == key &amp;&amp; valEqual(unsafe.Pointer(&amp;e.value), abi.NoEscape(unsafe.Pointer(&amp;old))) &#123;</span><br><span class="line">            <span class="comment">// 替换当前节点</span></span><br><span class="line">            eNew := newEntryNode(key, <span class="built_in">new</span>)</span><br><span class="line">            eNew.overflow.Store(e.overflow.Load())</span><br><span class="line">            i.Store(eNew)</span><br><span class="line">            <span class="keyword">return</span> head, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = &amp;e.overflow</span><br><span class="line">        e = e.overflow.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>遍历整个HashTrieMap，逻辑如下</p>
<ol>
<li>从根节点开始遍历children</li>
<li>子节点为nil，跳过</li>
<li>子节点不是叶子节点，递归遍历children</li>
<li>子节点是叶子节点，遍历整个链表<ul>
<li>key&#x2F;value传递给用户自定义函数，失败中断整个遍历</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Range(yield <span class="function"><span class="keyword">func</span><span class="params">(K, V)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 遍历，从根节点开始</span></span><br><span class="line">    ht.iter(ht.root.Load(), yield)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> iter(i *indirect[K, V], yield <span class="function"><span class="keyword">func</span><span class="params">(key K, value V)</span></span> <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> i.children &#123;</span><br><span class="line">        n := i.children[j].Load()</span><br><span class="line">        <span class="comment">// 子节点为nil，继续下一个</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子节点不是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> !n.isEntry &#123;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="keyword">if</span> !ht.iter(n.indirect(), yield) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        e := n.entry()</span><br><span class="line">        <span class="comment">// 扫描整个链表</span></span><br><span class="line">        <span class="keyword">for</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，中断遍历</span></span><br><span class="line">            <span class="keyword">if</span> !yield(e.key, e.value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            e = e.overflow.Load()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="All"><a href="#All" class="headerlink" title="All"></a>All</h3><p>封装Range方法并返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> All() <span class="function"><span class="keyword">func</span><span class="params">(yield <span class="keyword">func</span>(K, V)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line">    <span class="comment">// 把Range方法封装在一个函数里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(yield <span class="keyword">func</span>(key K, value V)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">        ht.iter(ht.root.Load(), yield)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h3><p>清空整个HashTrieMap，直接用新的nil节点更新root</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTrieMap[K, V])</span></span> Clear() &#123;</span><br><span class="line">    <span class="comment">// 确保map已初始化</span></span><br><span class="line">    ht.init()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接用新的节点替换root</span></span><br><span class="line">    ht.root.Store(newIndirectNode[K, V](<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-sync-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-sync-map/" class="post-title-link" itemprop="url">golang系列之-sync.Map</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-20 09:45:01 / 修改时间：11:37:03" itemprop="dateCreated datePublished" datetime="2025-02-20T09:45:01+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>map不支持并发读写，但我们可以转变下思路，将value改为一个指向结构体entry的指针，结构体内部的字段我们是可以随意修改的，如下，将并发读写map改为并发读map，读写转移到entry</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]*entry</span><br></pre></td></tr></table></figure>

<p>上面的方法看起来解决了并发读写的问题，但还不够，当有新的key写入时，还是变回了原来的map并发读写。sync.Map提供了一种思路，使用两个map，read负责已有key的并发读写，dirty负责新key的读写，只有当read找不到key，才去找dirty。</p>
<p>现在还剩最后一个问题，read和dirty如何保证数据一致&#x2F;同步，我们可以改造entry，使其指向value的指针，如此一来，read和dirty的entry可以指向同一个value，如下，这就是sync.Map的大致思路</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p *any</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read  -&gt; key0|*entry0         entry0.p -&gt; &amp;value</span></span><br><span class="line"><span class="comment">//       -&gt; key1|*entry1</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// dirty -&gt; key0|*entry0</span></span><br><span class="line"><span class="comment">//       -&gt; key1|*entry1</span></span><br><span class="line"><span class="comment">//       -&gt; key2|*entry2</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>尽管如此，sync.Map并不完美，以上设计导致我们无法直接计算出哈希表的元素数量，需要遍历进行统计，而且还不一定准确</p>
<p>当前go版本：1.23，1.24版本改为HashTrieMap实现</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> syncMap sync.Map</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写</span></span><br><span class="line">    syncMap.Store(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;VictoriaMetrics&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读</span></span><br><span class="line">    value, ok := syncMap.Load(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">    fmt.Println(value, ok)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    syncMap.Delete(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">    value, ok = syncMap.Load(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">    fmt.Println(value, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># VictoriaMetrics true</span></span><br><span class="line"><span class="comment"># &lt;nil&gt; false</span></span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sync/map.go</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex                        <span class="comment">// dirty锁</span></span><br><span class="line">    read atomic.Pointer[readOnly]   <span class="comment">// 负责已有key的读写</span></span><br><span class="line">    dirty <span class="keyword">map</span>[any]*entry            <span class="comment">// 负责新key的读写，替换read后设置为nil</span></span><br><span class="line">    misses <span class="type">int</span>                      <span class="comment">// 计数器，如果read找不到key时加一，当misses==len(dirty)，用dirty替换掉read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map+amended</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    m       <span class="keyword">map</span>[any]*entry          <span class="comment">// </span></span><br><span class="line">    amended <span class="type">bool</span>                    <span class="comment">// 修正，当dirty有新的key写入时为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针-运行时生成，表示数据已完全删除</span></span><br><span class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any)</span><br><span class="line"></span><br><span class="line"><span class="comment">// value的封装，被read和dirty共享</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p atomic.Pointer[any]           <span class="comment">// 指针-任意类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里值得注意的是entry的p指针，有三个状态</p>
<table>
<thead>
<tr>
<th align="left">p</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;value</td>
<td align="left">正常状态</td>
</tr>
<tr>
<td align="left">nil</td>
<td align="left">已删除，可以当作是墓碑来理解</td>
</tr>
<tr>
<td align="left">expunged</td>
<td align="left">dirty替代read时，从nil改为expunged，在下一轮替换中，移除该key</td>
</tr>
</tbody></table>
<p>三种状态转移路线：</p>
<ol>
<li>&amp;value   -&gt; nil -&gt; expunged</li>
<li>expunged -&gt; nil -&gt; &amp;value</li>
</ol>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>根据key获取value，具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，返回</li>
<li>加锁，再找一遍read，如果找到，返回（double-check）</li>
<li>amended为true表示dirty有新的key，在dirty找</li>
<li>更新misses计数器，如果misses&#x3D;&#x3D;len(dirty)，用dirty替换掉read</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key any) (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 没找到但dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 在dirty找</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// misses++</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取m.read</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> loadReadOnly() readOnly &#123;</span><br><span class="line">    <span class="keyword">if</span> p := m.read.Load(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readOnly&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="comment">// 已删除</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// misses计数器更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// misses == len(m.dirty)</span></span><br><span class="line">    <span class="comment">// 用dirty替换read</span></span><br><span class="line">    m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>存储key&#x2F;value。本质就是Swap方法，但丢弃其返回值，具体看Swap</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    _, _ = m.Swap(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadOrStore"><a href="#LoadOrStore" class="headerlink" title="LoadOrStore"></a>LoadOrStore</h3><p>根据key获取value，如果没有该key&#x2F;value，则改为写入。该方法逻辑与Swap方法十分相似</p>
<p>具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，返回</li>
<li>加锁，再找一遍read，如果找到，返回（double-check）</li>
<li>如果在dirty找到，获取&#x2F;更新key，同时更新misses计数器，返回</li>
<li>都没找到说明是新key，写入dirty，返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value any) (actual any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// e有数值则获取，没有则更新并获取</span></span><br><span class="line">        actual, loaded, ok := e.tryLoadOrStore(value)</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> actual, loaded</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在read中没找到（dirty可能有）</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 在read找到</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// e指针从expunged改为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 凡是expunged变为nil状态的，read要同步到dirty</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 在dirty找到</span></span><br><span class="line">        actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">        <span class="comment">// misses++</span></span><br><span class="line">        m.missLocked()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dirty也没有 =&gt; 全新写入</span></span><br><span class="line">        <span class="comment">// 有新的key写入，需要更新amended</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            <span class="comment">// 克隆read到dirty（只保留未删除的纪录）</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            <span class="comment">// 有新key写入，需要将amended改为true</span></span><br><span class="line">            m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 凡是新key，都放在dirty</span></span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">        actual, loaded = value, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> actual, loaded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有数值则获取，没有则更新并获取返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryLoadOrStore(i any) (actual any, loaded, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="comment">// 完全删除</span></span><br><span class="line">    <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不为nil</span></span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *p, <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为nil</span></span><br><span class="line">    ic := i</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 替换成功</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, &amp;ic) &#123;</span><br><span class="line">            <span class="keyword">return</span> i, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重复上面的操作</span></span><br><span class="line">        p = e.p.Load()</span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *p, <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e指针从expunged改为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> unexpungeLocked() (wasExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> e.p.CompareAndSwap(expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">    <span class="comment">// dirty已经存在了，忽略</span></span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 创建dirty，与read同等大小</span></span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="comment">// 把nil的entry改为expunged</span></span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 其他非删除数据复制到dirty</span></span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.p指针从nil改为expunged</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// nil -&gt; expunged</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(<span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = e.p.Load()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>删除指定key，具体看LoadAndDelete</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key any) &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadAndDelete"><a href="#LoadAndDelete" class="headerlink" title="LoadAndDelete"></a>LoadAndDelete</h3><p>逻辑与Load相似，具体如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，将entry置为nil</li>
<li>加锁，再找一遍read，如果找到，将entry置为nil（double-check）</li>
<li>amended为true表示dirty有新的key，在dirty找</li>
<li>更新misses计数器，如果misses&#x3D;&#x3D;len(dirty)，将dirty迁移到read</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key any) (value any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 没找到但dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 在dirty找</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// read没有但dirty有，直接删除</span></span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">            <span class="comment">// misses++</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="comment">// e.p改为nil</span></span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.p改为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 已删除</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *p, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndDelete"><a href="#CompareAndDelete" class="headerlink" title="CompareAndDelete"></a>CompareAndDelete</h3><p>具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，纪录e</li>
<li>加锁，再找一遍read，如果找到，纪录e（double-check）</li>
<li>amended为true表示dirty有新的key，在dirty找</li>
<li>更新misses计数器，如果misses&#x3D;&#x3D;len(dirty)，用dirty替换掉read</li>
<li>已删除或比对失败返回false，否则将e.p置为nil，返回true</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> CompareAndDelete(key, old any) (deleted <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 没找到但dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 在dirty找</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// misses++</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ok &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 已删除或比对失败</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged || *p != old &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>使用value替换key当前存储的数据。具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，替换并返回</li>
<li>加锁，再找一遍read，如果找到，替换并返回（double-check）</li>
<li>如果在dirty找到，替换并返回</li>
<li>都没找到说明是新key，写入dirty，返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Swap(key, value any) (previous any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">if</span> v, ok := e.trySwap(&amp;value); ok &#123;</span><br><span class="line">            <span class="comment">// 已删除</span></span><br><span class="line">            <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有值，返回</span></span><br><span class="line">            <span class="keyword">return</span> *v, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在read中没找到（dirty可能有）</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 在read找到</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// e指针从expunged改为nil</span></span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 凡是expunged变为nil状态的，read要同步到dirty</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            loaded = <span class="literal">true</span></span><br><span class="line">            previous = *v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 在dirty找到</span></span><br><span class="line">        <span class="comment">// 修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">if</span> v := e.swapLocked(&amp;value); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            loaded = <span class="literal">true</span></span><br><span class="line">            previous = *v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dirty也没有 =&gt; 全新写入</span></span><br><span class="line">        <span class="comment">// 有新的key写入，需要更新amended</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            <span class="comment">// 克隆read到dirty（只保留未删除的纪录）</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            <span class="comment">// 有新key写入，需要将amended改为true</span></span><br><span class="line">            m.read.Store(&amp;readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 凡是新key，都放在dirty</span></span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> previous, loaded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> trySwap(i *any) (*any, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := e.p.Load()</span><br><span class="line">        <span class="comment">// 已删除</span></span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换成功</span></span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, i) &#123;</span><br><span class="line">            <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> swapLocked(i *any) *any &#123;</span><br><span class="line">    <span class="keyword">return</span> e.p.Swap(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h3><p>具体逻辑如下</p>
<ol>
<li>根据key在read中寻找entry，如果找到，替换并返回</li>
<li>如果dirty没有新key，到此为止，返回</li>
<li>加锁，再找一遍read，如果找到，替换并返回（double-check）</li>
<li>如果在dirty找到，替换并返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> CompareAndSwap(key, old, <span class="built_in">new</span> any) (swapped <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 在read找</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 尝试修改指针指向新的value</span></span><br><span class="line">        <span class="keyword">return</span> e.tryCompareAndSwap(old, <span class="built_in">new</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">        <span class="comment">// 没找到，dirty也没有新key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在read中没找到但dirty可能有</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    swapped = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        swapped = e.tryCompareAndSwap(old, <span class="built_in">new</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 在dirty找到</span></span><br><span class="line">        <span class="comment">// 尝试修改指针指向新的value</span></span><br><span class="line">        swapped = e.tryCompareAndSwap(old, <span class="built_in">new</span>)</span><br><span class="line">        <span class="comment">// misses++</span></span><br><span class="line">        m.missLocked()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> swapped</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryCompareAndSwap(old, <span class="built_in">new</span> any) <span class="type">bool</span> &#123;</span><br><span class="line">    p := e.p.Load()</span><br><span class="line">    <span class="comment">// 已删除或比对失败</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged || *p != old &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子替换</span></span><br><span class="line">    nc := <span class="built_in">new</span> <span class="comment">// 优化，具体看原注释</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.p.CompareAndSwap(p, &amp;nc) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = e.p.Load()</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged || *p != old &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>具体逻辑如下</p>
<ol>
<li>复制read，如果dirty有新key写入，则复制dirty并用dirty替换read</li>
<li>遍历哈希表</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value any)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 复制read</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// dirty有新key写入</span></span><br><span class="line">    <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read = m.loadReadOnly()</span><br><span class="line">        <span class="comment">// double-check</span></span><br><span class="line">        <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">            <span class="comment">// 复制dirty</span></span><br><span class="line">            read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">            copyRead := read</span><br><span class="line">            <span class="comment">// 用dirty替换掉read</span></span><br><span class="line">            m.read.Store(&amp;copyRead)</span><br><span class="line">            m.dirty = <span class="literal">nil</span></span><br><span class="line">            m.misses = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希表</span></span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        v, ok := e.load()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h3><p>具体逻辑如下</p>
<ol>
<li>read为空且dirty也为空，返回</li>
<li>read不为空或者dirty有新数据<ul>
<li>复制read并将read置空</li>
<li>将dirty清空</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Clear() &#123;</span><br><span class="line">    <span class="comment">// 复制read</span></span><br><span class="line">    read := m.loadReadOnly()</span><br><span class="line">    <span class="comment">// read为空且dirty也为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(read.m) == <span class="number">0</span> &amp;&amp; !read.amended &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read不为空或者dirty有新数据</span></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制read</span></span><br><span class="line">    read = m.loadReadOnly()</span><br><span class="line">    <span class="comment">// read置空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(read.m) &gt; <span class="number">0</span> || read.amended &#123;</span><br><span class="line">        m.read.Store(&amp;readOnly&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirty清空</span></span><br><span class="line">    clear(m.dirty)</span><br><span class="line">    <span class="comment">// Don&#x27;t immediately promote the newly-cleared dirty map on the next operation.</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://victoriametrics.com/blog/go-sync-map/index.html">Go sync.Map: The Right Tool for the Right Job</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-sync-singleflight/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-sync-singleflight/" class="post-title-link" itemprop="url">golang系列之-singleflight</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-19 11:26:47" itemprop="dateCreated datePublished" datetime="2025-02-19T11:26:47+08:00">2025-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-20 08:31:21" itemprop="dateModified" datetime="2025-02-20T08:31:21+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在使用redis&#x2F;memcached缓存系统时，可能会遇到以下三个问题</p>
<ol>
<li>cache penetration(缓存穿透) - 数据既不在cache中也不在db中，可以用布龙过滤器处理</li>
<li>cache avalanche(缓存雪崩) - 同一时刻出现大量的key失效，可以将过期时间随机化或者不设置过期时间</li>
<li>cache breakdown(缓存击穿)&#x2F;cache stampede(缓存踩踏) - 热门的key过期，客户端加锁或者不设置过期时间</li>
</ol>
<p>缓存击穿问题中，客户端加锁使穿行化访问是一个值得考虑的解决方法，可以降低服务器（cache&#x2F;db）的压力。但另一方面，这也会让大量的请求被阻塞，吞吐量下降。实际上，同一时刻的请求可以共享响应数据，这就是singleflight解决的问题</p>
<p>singleflight不是标准库的一部份，但go的internal目录内复制了一份singleflight源码，该源码也是本文在讨论的</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/singleflight&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callCount atomic.Int32</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟db请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    callCount.Add(<span class="number">1</span>)</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="comment">// 返回的数据是随机的</span></span><br><span class="line">    <span class="keyword">return</span> rand.Intn(<span class="number">100</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装fetchData和singleflight</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchDataWrapper</span><span class="params">(g *singleflight.Group, id <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Duration(id) * <span class="number">40</span> * time.Millisecond)</span><br><span class="line">    v, err, shared := g.Do(<span class="string">&quot;key-fetch-data&quot;</span>, fetchData)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Goroutine %d: result: %v, shared: %v\n&quot;</span>, id, v, shared)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> g singleflight.Group</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> numGoroutines = <span class="number">5</span></span><br><span class="line">    wg.Add(numGoroutines)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟：发起5个请求访问db</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGoroutines; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> fetchDataWrapper(&amp;g, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Function was called %d times\n&quot;</span>, callCount.Load())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下，结果是随机的</span></span><br><span class="line"><span class="comment"># Goroutine 1: result: 2, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 0: result: 2, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 2: result: 2, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 3: result: 94, shared: true</span></span><br><span class="line"><span class="comment"># Goroutine 4: result: 94, shared: true</span></span><br><span class="line"><span class="comment"># Function was called 2 times</span></span><br></pre></td></tr></table></figure>

<p>可以看到，G0、G1、G2共享result&#x3D;2，G3、G4共享result&#x3D;94</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>singleflight数据结构如下所示，其中</p>
<ul>
<li><code>Group</code>  - 由mutex和map组成，本质就是map，因为map不允许并发读写，所以才加了mutex</li>
<li><code>call</code>   - 是响应数据的封装，与请求key关联在一起，因为内部的dup计数器，或许可以将其按上下文来理解</li>
<li><code>Result</code> - 也是响应数据的封装，跟channel搭配使用</li>
</ul>
<p>响应数据的封装方式有两种</p>
<ol>
<li>通过函数返回值返回</li>
<li>通过channel返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/internal/singleflight/singleflight.go</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex           <span class="comment">// 锁，map不能并发读写</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="type">string</span>]*call     <span class="comment">// 关联key跟结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应数据封装</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    val any                    <span class="comment">// 结果值</span></span><br><span class="line">    err <span class="type">error</span>                <span class="comment">// 异常值</span></span><br><span class="line">    dups  <span class="type">int</span>                <span class="comment">// 计数器（等待中的goroutine），同时用来判断是否共享</span></span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    chans []<span class="keyword">chan</span>&lt;- Result    <span class="comment">// 结果值/异常值/是否共享（通过channel传递）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应数据封装，与channel搭配</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val    any                <span class="comment">// 结果值</span></span><br><span class="line">    Err    <span class="type">error</span>            <span class="comment">// 异常值</span></span><br><span class="line">    Shared <span class="type">bool</span>                <span class="comment">// 是否共享</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>核心的方法有Do、DoChan、ForgetUnshared，具体看下面描述</p>
<h3 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h3><p>具体逻辑如下</p>
<ol>
<li>如果key已存在，挂起等待，唤醒后读取响应数据</li>
<li>如果key不存在，为key创建响应数据封装，写入map，然后调用doCall获取响应数据</li>
<li>删除key</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (any, <span class="type">error</span>)) (v any, err <span class="type">error</span>, shared <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 为key与结果创建关联</span></span><br><span class="line"></span><br><span class="line">    g.mu.Lock() <span class="comment">// map不能并发读写，需要加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1. 相同的请求已存在，等待结果返回</span></span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        c.dups++</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        c.wg.Wait()        <span class="comment">// 挂起等待</span></span><br><span class="line">        <span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2. 新请求，创建结果并关联</span></span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 调用函数获取结果</span></span><br><span class="line">    g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> doCall(c *call, key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (any, <span class="type">error</span>)) &#123;</span><br><span class="line">    <span class="comment">// 1. 拿到结果</span></span><br><span class="line">    c.val, c.err = fn()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. map删除该key</span></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    c.wg.Done()</span><br><span class="line">    <span class="keyword">if</span> g.m[key] == c &#123;</span><br><span class="line">        <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是通过channel传递数据</span></span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">        ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DoChan"><a href="#DoChan" class="headerlink" title="DoChan"></a>DoChan</h3><p>具体逻辑同Do，只是响应数据是通过channel传递的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> DoChan(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (any, <span class="type">error</span>)) &lt;-<span class="keyword">chan</span> Result &#123;</span><br><span class="line">    <span class="comment">// 1. 为key与结果创建关联</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置容量，使当前goroutine不阻塞</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    g.mu.Lock() <span class="comment">// map不能并发读写，需要加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1. 相同的请求已存在，等待结果返回</span></span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        c.dups++</span><br><span class="line">        c.chans = <span class="built_in">append</span>(c.chans, ch)</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> ch</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2. 新请求，创建结果并关联</span></span><br><span class="line">    c := &amp;call&#123;chans: []<span class="keyword">chan</span>&lt;- Result&#123;ch&#125;&#125;</span><br><span class="line">    c.wg.Add(<span class="number">1</span>) <span class="comment">// 如果Do和DoChan混用还是需要使用到wg，否则异常</span></span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 调用函数获取结果</span></span><br><span class="line">    <span class="keyword">go</span> g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ForgetUnshared"><a href="#ForgetUnshared" class="headerlink" title="ForgetUnshared"></a>ForgetUnshared</h3><p>删除指定key，如果该key已经有其他goroutine等待，不处理</p>
<p>具体逻辑如下</p>
<ol>
<li>key不存在，返回true</li>
<li>key存在，如果dup等于0，删除并返回true，否则不处理，返回false</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> ForgetUnshared(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// map加锁</span></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">    c, ok := g.m[key]</span><br><span class="line">    <span class="comment">// key不存在</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key存在但没有共享</span></span><br><span class="line">    <span class="keyword">if</span> c.dups == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://victoriametrics.com/blog/go-singleflight/index.html">Go Singleflight Melts in Your Code, Not in Your DB</a><br><a target="_blank" rel="noopener" href="https://www.dragonflydb.io/blog/developing-with-dragonfly-part-02-solve-caching-problems">Developing with Dragonfly: Solve Caching Problems</a><br><a target="_blank" rel="noopener" href="https://philosophyotaku.medium.com/a-complete-beginner-guide-for-cache-penetration-stampede-avalanche-ecadd7f16009">A Complete Beginner Guide for Cache Penetration, Stampede, and Avalanche</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-sync-rwmutex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-sync-rwmutex/" class="post-title-link" itemprop="url">golang系列之-sync.RWMutex</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-18 17:12:21" itemprop="dateCreated datePublished" datetime="2025-02-18T17:12:21+08:00">2025-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-20 08:31:21" itemprop="dateModified" datetime="2025-02-20T08:31:21+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>975</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>RWMutex-读写锁，该锁可以被任意多个reader持有，或被一个writer持有。通过观察RWMutex的源代码实现，可以将RWMutex看作是FIFO队列，具体看后面的详细描述</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> rwm sync.RWMutex</span><br><span class="line"></span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="type">int</span>, size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">            rwm.Lock()          <span class="comment">// 写锁</span></span><br><span class="line">            count++             <span class="comment">// 更新资源</span></span><br><span class="line">            rwm.Unlock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        indx := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">            rwm.RLock()         <span class="comment">// 读锁</span></span><br><span class="line">            queue[indx] = count <span class="comment">// 只读</span></span><br><span class="line">            rwm.RUnlock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(count)</span><br><span class="line">    fmt.Println(queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>RWMutex结构如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sync/rwmutex.go</span></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex</span><br><span class="line">    writerSem   <span class="type">uint32</span></span><br><span class="line">    readerSem   <span class="type">uint32</span></span><br><span class="line">    readerCount atomic.Int32</span><br><span class="line">    readerWait  atomic.Int32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各字段说明如下</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>w</code></td>
<td align="left">写锁，所有的writer都会阻塞在这里</td>
</tr>
<tr>
<td align="left"><code>writerSem</code></td>
<td align="left">writer队列，获取w锁成功后，如果readerCount不为0，挂起等待reader释放锁</td>
</tr>
<tr>
<td align="left"><code>readerSem</code></td>
<td align="left">reader队列，readerCount为负时，新的reader都在这里挂起等待</td>
</tr>
<tr>
<td align="left"><code>readerCount</code></td>
<td align="left">读锁&#x2F;reader总数，max&#x3D;2^30&#x3D;1GB，为负数时表示有writer等待</td>
</tr>
<tr>
<td align="left"><code>readerWait</code></td>
<td align="left">待释放锁reader总数，获取w锁成功后纪录当前reader数量，等待reader释放读锁</td>
</tr>
</tbody></table>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><p>读加锁，具体逻辑如下</p>
<ol>
<li>readerCount++，如果返回的结果小于0，说明有writer在等待或执行，放进readerSem等待唤醒</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">    <span class="comment">// readerCount++</span></span><br><span class="line">    <span class="comment">// readerCount &lt; 0？有writer等待</span></span><br><span class="line">    <span class="keyword">if</span> rw.readerCount.Add(<span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 放到队列里等待</span></span><br><span class="line">        runtime_SemacquireRWMutexR(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryRLock"><a href="#TryRLock" class="headerlink" title="TryRLock"></a>TryRLock</h3><p>尝试获取读锁，具体逻辑如下</p>
<ol>
<li>readerCount如果小于0，说明有writer在等待或执行，返回false</li>
<li>CAS尝试更新readerCount，成功则返回，失败则回到第一步重试，永久尝试</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryRLock() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c := rw.readerCount.Load()</span><br><span class="line">        <span class="comment">// readerCount &lt; 0？有writer等待</span></span><br><span class="line">        <span class="keyword">if</span> c &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS加锁，成功则返回，失败则再次尝试</span></span><br><span class="line">        <span class="keyword">if</span> rw.readerCount.CompareAndSwap(c, c+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RUnlock"><a href="#RUnlock" class="headerlink" title="RUnlock"></a>RUnlock</h3><p>读解锁，具体逻辑如下</p>
<ol>
<li>readerCount减1，如果结果小于0，说明有writer在等待</li>
<li>readerWait减1，如果结果等于0，唤醒writer</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">    <span class="comment">// readerCount &lt; 0？有writer等待</span></span><br><span class="line">    <span class="keyword">if</span> r := rw.readerCount.Add(<span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        rw.rUnlockSlow(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复释放锁，异常</span></span><br><span class="line">    <span class="comment">// org_r == 0 =&gt; 无任何goroutine访问</span></span><br><span class="line">    <span class="comment">// org_r == -rwmutexMaxReaders =&gt; 有writer无reader</span></span><br><span class="line">    <span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">        fatal(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writer在等待，新reader肯定不会unlock，能unlock的只有readerWait</span></span><br><span class="line">    <span class="keyword">if</span> rw.readerWait.Add(<span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// readerWait归零，唤醒writer</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>写加锁，具体逻辑如下</p>
<ol>
<li>w加锁，使其它writer排队等待</li>
<li>readerCount-&#x3D;rwmutexMaxReaders，通知新的reader有writer在等待</li>
<li>原readerCount不为0，说明有reader在运行，纪录到readerWait</li>
<li>将writer放到writerSem队列，等待唤醒</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// w加锁，使其它writer排队等待</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知新的reader有writer在等待</span></span><br><span class="line">    <span class="comment">// r = readerCount =&gt; 理想情况下为0</span></span><br><span class="line">    <span class="comment">// readerCount -= 2^30</span></span><br><span class="line">    r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录在运行的reader的数量到readerWait</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; rw.readerWait.Add(r) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前goroutine放进writerSem队列，等待唤醒</span></span><br><span class="line">        runtime_SemacquireRWMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryLock"><a href="#TryLock" class="headerlink" title="TryLock"></a>TryLock</h3><p>尝试换取写锁，具体逻辑如下</p>
<ol>
<li>w尝试加锁，失败返回false</li>
<li>CAS尝试更新readerCount-&#x3D;rwmutexMaxReaders，成功则返回true，失败则解锁w并返回false</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryLock() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// w尝试加锁</span></span><br><span class="line">    <span class="keyword">if</span> !rw.w.TryLock() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知新的reader有writer在等待写入</span></span><br><span class="line">    <span class="comment">// readerCount=-rwmutexMaxReaders =&gt; 期望当前reader的数量为0</span></span><br><span class="line">    <span class="keyword">if</span> !rw.readerCount.CompareAndSwap(<span class="number">0</span>, -rwmutexMaxReaders) &#123;</span><br><span class="line">        <span class="comment">// 失败解锁w</span></span><br><span class="line">        rw.w.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><p>写解锁，具体逻辑如下</p>
<ol>
<li>readerCount+&#x3D;rwmutexMaxReaders，使其为正数，让新的reader知道锁可用</li>
<li>如果readerCount不为0，说明有reader在排队，唤醒全部reader</li>
<li>w解锁，唤醒其他排队的writer</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// 更新readerCount，让新的reader知道锁可用</span></span><br><span class="line">    r := rw.readerCount.Add(rwmutexMaxReaders)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复释放锁，异常</span></span><br><span class="line">    <span class="comment">// org_r == 0 =&gt; 无任何goroutine访问</span></span><br><span class="line">    <span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">        fatal(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将readerSem队列里等待的reader全部唤醒</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// w解锁，唤醒其他排队的writer</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-sync-mutex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-sync-mutex/" class="post-title-link" itemprop="url">golang系列之-sync.Mutex</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-18 09:28:12" itemprop="dateCreated datePublished" datetime="2025-02-18T09:28:12+08:00">2025-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-20 08:31:21" itemprop="dateModified" datetime="2025-02-20T08:31:21+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Mutex（MUTualEx）-互斥锁是一种可以保证每次只有一个goroutine访问贡献资源的方法。这个资源可以是一段程序代码、一个整数、一个map、一个struct、一个channel或其他任何东西。通过观察Mutex的源代码实现，可以将Mutex看作是一个队列（FIFO&#x2F;LIFO），具体看后面的详细描述</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu       sync.Mutex</span><br><span class="line">    counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span></span> inc(name <span class="type">string</span>) &#123;</span><br><span class="line">    c.mu.Lock()         <span class="comment">// 互斥锁，获取失败等待挂起</span></span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">    c.counters[name]++  <span class="comment">// 共享资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Container&#123;</span><br><span class="line">        counters: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">0</span>, <span class="string">&quot;b&quot;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    doIncrement := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            c.inc(name)</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> doIncrement(<span class="string">&quot;a&quot;</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">go</span> doIncrement(<span class="string">&quot;a&quot;</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">go</span> doIncrement(<span class="string">&quot;b&quot;</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(c.counters)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go run ./main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># map[a:20000 b:10000]</span></span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>sync.Mutex提供的数据结构跟方法只是一层封装，实际的代码放在<code>src/internal/sync/mutex.go</code></p>
<p>Mutex的数据结构由state、sema字段组成，其中state是由三个状态位和一个29位的waiter计数器组成，sema使waiter陷入等待</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/internal/sync/mutex.go</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 由29位的waiter_counter和3个状态位组成，结构如下</span></span><br><span class="line">    <span class="comment">// | &lt;- 29bit -&gt;    | 1bit          | 1bit       | 1bit        |</span></span><br><span class="line">    <span class="comment">// | waiter_counter | mutexStarving | mutexWoken | mutexLocked |</span></span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    <span class="comment">// semaphore</span></span><br><span class="line">    sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>mutex分为Normal-普通模式和Starvation-饥饿模式，两个模式的区别如下</p>
<p><strong>普通模式</strong></p>
<ol>
<li>新的goroutine不会进入队列排队等待，而是会尝试通过自旋抢占锁，排队中的goroutine会陷入更长时间的等待</li>
<li>当goroutine释放锁时，因为支持锁被抢占（避免CPU上下文切换）的缘故，不一定会唤醒其他goroutine</li>
</ol>
<p><strong>饥饿模式</strong></p>
<ol>
<li>禁止自旋抢占，在goroutine释放锁时，一定会唤醒队列中的其他goroutine</li>
</ol>
<p><strong>注意</strong></p>
<p>只有被唤醒woken的goroutine才能等待锁释放，其他都要挂起排队等待被唤醒</p>
<h3 id="状态位"><a href="#状态位" class="headerlink" title="状态位"></a>状态位</h3><p>mutex的三个状态位说明如下</p>
<p><strong>mutexLocked</strong></p>
<p>第1位，为0表示未锁定，为1表示已锁定</p>
<p><strong>mutexWoken</strong></p>
<p>第2位，只在普通模式使用，有woken位才能等待锁释放，该位可被新goroutine抢占。注意：goroutine在Unlock时如果判断有该标志位则不能唤醒队列中的goroutine</p>
<p><strong>mutexStarving</strong></p>
<p>第3位，goroutine等待超过1ms时设置该位，如果当前G的等待时间小于1ms或者是队列中最后一个排队的G则取消该位。该位被设置时的具体行为见上面饥饿模式的介绍</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>Mutex的方法有Lock、Unlock、TryLock，具体如下</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>大概逻辑如下</p>
<ol>
<li>CAS获取锁，成功返回</li>
<li>满足条件则进入自旋等待锁释放</li>
<li>更新state<ul>
<li>获取锁成功，返回（普通模式）</li>
<li>失败则挂起等待唤醒</li>
<li>唤醒后<ul>
<li>如果不是饥饿模式，回到第2步重试</li>
<li>如果是饥饿模式，直接获取锁返回</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// 设置locked位成功，返回</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="type">int64</span>     <span class="comment">// 用于计算等待耗时</span></span><br><span class="line">    starving := <span class="literal">false</span>           <span class="comment">// 排队等待超过1ms，进入饥饿模式</span></span><br><span class="line">    awoke := <span class="literal">false</span>              <span class="comment">// 普通模式自旋抢占锁</span></span><br><span class="line">    iter := <span class="number">0</span>                   <span class="comment">// 自旋计数器，最多4次，被唤醒后重置</span></span><br><span class="line">    old := m.state              <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 普通模式，进入自旋等待锁的释放</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">            <span class="comment">// 尝试抢占woken位，让Unlock方法不要唤醒其他goroutine</span></span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进入自旋等待</span></span><br><span class="line">            runtime_doSpin()</span><br><span class="line">            iter++</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 其他情况：饥饿模式 or 锁可用 or 自旋次数过多</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        <span class="comment">// 普通模式</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked <span class="comment">// 饥饿模式下不能动这个位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 饥饿模式 or 锁被占用</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 只要没拿到锁就等待，waiter_counter++</span></span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前G陷入饥饿 and 锁被占用</span></span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving <span class="comment">// 已经是饥饿模式的话不用再设置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通模式下被唤醒，清除woken位</span></span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清除woken位</span></span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 普通模式 获取锁成功</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 队列进出策略是LIFO还是FIFO</span></span><br><span class="line">            <span class="comment">// LIFO：如果被挂起等待好几次了，放队列前面</span></span><br><span class="line">            <span class="comment">// FIFO：新的goroutine，放队列后面</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 挂起等待</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">2</span>)</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算耗时，如果当前goroutine等待超过1ms，进入饥饿状态</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒后再一次读取state</span></span><br><span class="line">            old = m.state</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 饥饿模式</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Unlock已经将mutexLocked位设置为0</span></span><br><span class="line">                <span class="comment">// 饥饿模式下，Unlock唤醒goroutine时不会设置mutexWoken位，也不会更新waiter数量，由当前goroutine处理</span></span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// delta = 1-2^3 =&gt; -7 (0b00000111)</span></span><br><span class="line">                delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前G运行不超过1ms or 当前G是最后一个waiter</span></span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="comment">// delta -= 4 (0b00001011)</span></span><br><span class="line">                    delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 初始状态-delta -&gt; 结果状态</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 示例1：饥饿模式+两个排队的goroutine</span></span><br><span class="line">                <span class="comment">// 10 100 - 00 111(7)  -&gt; 01 101</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="comment">// 示例2：饥饿模式+1个排队的goroutine</span></span><br><span class="line">                <span class="comment">// 01 100 - 01 011(11) -&gt; 00 001</span></span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="comment">// 获取锁成功</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以下两个字段影响普通模式，对饥饿模式没影响</span></span><br><span class="line">            awoke = <span class="literal">true</span>    <span class="comment">// 唤醒后设置为true，因为woken标志位在goroutine唤醒时已设置，见Unlock</span></span><br><span class="line">            iter = <span class="number">0</span>        <span class="comment">// 可以重新进入自旋</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 更新失败，再一次读取state</span></span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname internal_sync_runtime_canSpin internal/sync.runtime_canSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internal_sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 自旋次数不能超过4次</span></span><br><span class="line">    <span class="comment">// 2. cpu只有一个的话不能自旋</span></span><br><span class="line">    <span class="comment">// 3. 不能有大量的空闲、自旋的goroutine</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= sched.npidle.Load()+sched.nmspinning.Load()+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前P的runq不为空，不应该自旋</span></span><br><span class="line">    <span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname internal_sync_runtime_SemacquireMutex internal/sync.runtime_SemacquireMutex</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internal_sync_runtime_SemacquireMutex</span><span class="params">(addr *<span class="type">uint32</span>, lifo <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile, skipframes, waitReasonSyncMutexLock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryLock"><a href="#TryLock" class="headerlink" title="TryLock"></a>TryLock</h3><p>大概逻辑如下</p>
<ol>
<li>获取state判断，如果锁被其他goroutine获取则返回false</li>
<li>锁可以被获取则使用CAS尝试获得锁，失败返回false，成功返回true</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> TryLock() <span class="type">bool</span> &#123;</span><br><span class="line">    old := m.state</span><br><span class="line">    <span class="comment">// 锁被其他goroutine获取 or 饥饿模式</span></span><br><span class="line">    <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置locked位</span></span><br><span class="line">    <span class="comment">// 直接return不行？</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><p>大概逻辑如下</p>
<ol>
<li>state-1，非常理想的情况下，如没有排队的goroutine，则state为0</li>
<li>如果unlock了一个unlocked的mutex，异常，不允许这么做</li>
<li>普通模式下因为支持抢占的原因，需要根据woken标记判断是否要唤醒队列中的goroutine</li>
<li>饥饿模式下直接唤醒一个goroutine</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// locked置0</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="comment">// 有waiter or 饥饿模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">        m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 异常，不能unlock已经unlocked的mutex</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否要去唤醒goroutine</span></span><br><span class="line">            <span class="comment">// 1. waiter数量为0，不用唤醒</span></span><br><span class="line">            <span class="comment">// 2. 锁已经被其他goroutine获取</span></span><br><span class="line">            <span class="comment">// 3. 如果有goroutine被唤醒，那么不再唤醒其他</span></span><br><span class="line">            <span class="comment">// 4. 饥饿模式不走这个逻辑</span></span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// waiter数量减一 并 设置woken位</span></span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                <span class="comment">// 唤醒一个goroutine</span></span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败重试</span></span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 饥饿模式，没有减少counter，也没有设置woken位</span></span><br><span class="line">        <span class="comment">// 唤醒一个goroutine</span></span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://victoriametrics.com/blog/go-sync-mutex/index.html">Go sync.Mutex: Normal and Starvation Mode</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-sync-cond/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/golang-series-sync-cond/" class="post-title-link" itemprop="url">golang系列之-sync.Cond</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-17 09:54:38" itemprop="dateCreated datePublished" datetime="2025-02-17T09:54:38+08:00">2025-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-20 08:31:21" itemprop="dateModified" datetime="2025-02-20T08:31:21+08:00">2025-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>sync.Cond经常用在多个 goroutine 等待，一个 goroutine 通知（事件发生）的场景。如果是一个通知，一个等待，使用互斥锁或 channel 就能搞定了</p>
<p>当前go版本：1.24</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>以下展示一个sync.Cond的使用案例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shared = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reader 打印shared[key]</span></span><br><span class="line">    reader := <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        cond.L.Lock()</span><br><span class="line">        <span class="comment">// 等待，直到shared有数据</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(shared) == <span class="number">0</span> &#123;</span><br><span class="line">            cond.Wait() <span class="comment">// Wait内部会暂时解锁/加锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(shared[key])</span><br><span class="line">        cond.L.Unlock()</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> reader(<span class="string">&quot;rsc1&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> reader(<span class="string">&quot;rsc2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writer</span></span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    shared[<span class="string">&quot;rsc1&quot;</span>] = <span class="string">&quot;foo&quot;</span></span><br><span class="line">    shared[<span class="string">&quot;rsc2&quot;</span>] = <span class="string">&quot;bar&quot;</span></span><br><span class="line">    <span class="comment">// 通知所有goroutine</span></span><br><span class="line">    cond.Broadcast()</span><br><span class="line">    cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>todo：文章图片待补充</p>
<p>Cond的数据结构如下</p>
<ul>
<li><code>L</code> - 只要实现Locker接口的类型都可以，比如Mutex</li>
<li><code>notify</code> - 计数器也是ticket生成器，可实现等待队列的先进先出-FIFO，由内部sema使用</li>
<li><code>checker</code> - 用来检测是否被复制</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cond implements a condition variable, a rendezvous point</span></span><br><span class="line"><span class="comment">// for goroutines waiting for or announcing the occurrence</span></span><br><span class="line"><span class="comment">// of an event.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Each Cond has an associated Locker L (often a [*Mutex] or [*RWMutex]),</span></span><br><span class="line"><span class="comment">// which must be held when changing the condition and</span></span><br><span class="line"><span class="comment">// when calling the [Cond.Wait] method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Cond must not be copied after first use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In the terminology of [the Go memory model], Cond arranges that</span></span><br><span class="line"><span class="comment">// a call to [Cond.Broadcast] or [Cond.Signal] “synchronizes before” any Wait call</span></span><br><span class="line"><span class="comment">// that it unblocks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For many simple use cases, users will be better off using channels than a</span></span><br><span class="line"><span class="comment">// Cond (Broadcast corresponds to closing a channel, and Signal corresponds to</span></span><br><span class="line"><span class="comment">// sending on a channel).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For more on replacements for [sync.Cond], see [Roberto Clapis&#x27;s series on</span></span><br><span class="line"><span class="comment">// advanced concurrency patterns], as well as [Bryan Mills&#x27;s talk on concurrency</span></span><br><span class="line"><span class="comment">// patterns].</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// [the Go memory model]: https://go.dev/ref/mem</span></span><br><span class="line"><span class="comment">// [Roberto Clapis&#x27;s series on advanced concurrency patterns]: https://blogtitle.github.io/categories/concurrency/</span></span><br><span class="line"><span class="comment">// [Bryan Mills&#x27;s talk on concurrency patterns]: https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view</span></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker                <span class="comment">// mutex，由外部传入</span></span><br><span class="line"></span><br><span class="line">    notify  notifyList      <span class="comment">// 计数器+sudog链表，内部sema使用</span></span><br><span class="line">    checker copyChecker     <span class="comment">// 检查Cond是否被复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">    wait atomic.Uint32      <span class="comment">// waiter计数器，只增不减</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// notify is the ticket number of the next waiter to be notified. It can</span></span><br><span class="line">    <span class="comment">// be read outside the lock, but is only written to with lock held.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Both wait &amp; notify can wrap around, and such cases will be correctly</span></span><br><span class="line">    <span class="comment">// handled as long as their &quot;unwrapped&quot; difference is bounded by 2^31.</span></span><br><span class="line">    <span class="comment">// For this not to be the case, we&#x27;d need to have 2^31+ goroutines</span></span><br><span class="line">    <span class="comment">// blocked on the same condvar, which is currently not possible.</span></span><br><span class="line">    notify <span class="type">uint32</span>           <span class="comment">// 范围[0,wait]，保证waiter先进先出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// List of parked waiters.</span></span><br><span class="line">    lock mutex              <span class="comment">// mutex</span></span><br><span class="line">    head *sudog             <span class="comment">// 指向第一个sudog</span></span><br><span class="line">    tail *sudog             <span class="comment">// 指向最后一个sudog</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="NewCond"><a href="#NewCond" class="headerlink" title="NewCond"></a>NewCond</h3><p>创建一个condition variable，没什么好讲的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewCond returns a new Cond with Locker l.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h2><p>大概逻辑如下</p>
<ol>
<li>更新wait计数器，获得ticket，临时解锁cond，让其他goroutine可以获得ticket并挂起</li>
<li>将当前goroutine和ticket打包进sudog，放进队列，当前goroutine挂起陷入等待</li>
<li>goroutine被唤醒，加锁cond</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait atomically unlocks c.L and suspends execution</span></span><br><span class="line"><span class="comment">// of the calling goroutine. After later resuming execution,</span></span><br><span class="line"><span class="comment">// Wait locks c.L before returning. Unlike in other systems,</span></span><br><span class="line"><span class="comment">// Wait cannot return unless awoken by [Cond.Broadcast] or [Cond.Signal].</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because c.L is not locked while Wait is waiting, the caller</span></span><br><span class="line"><span class="comment">// typically cannot assume that the condition is true when</span></span><br><span class="line"><span class="comment">// Wait returns. Instead, the caller should Wait in a loop:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c.L.Lock()</span></span><br><span class="line"><span class="comment">//    for !condition() &#123;</span></span><br><span class="line"><span class="comment">//        c.Wait()</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    ... make use of condition ...</span></span><br><span class="line"><span class="comment">//    c.L.Unlock()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 上层业务逻辑已加锁 =&gt; cond.L.Lock()</span></span><br><span class="line"></span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// waiter_counter++ =&gt; t = waiter_counter-1</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">    <span class="comment">// 解锁，这样其他goroutine现在可以调用Wait了</span></span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    <span class="comment">// 将当前goroutine挂起，等待唤醒</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁，由上层业务逻辑负责继续解锁 =&gt; cond.L.Unlock()</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// notifyListWait waits for a notification. If one has been sent since</span></span><br><span class="line"><span class="comment">// notifyListAdd was called, it returns immediately. Otherwise, it blocks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:linkname notifyListWait sync.runtime_notifyListWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return right away if this ticket has already been notified.</span></span><br><span class="line">	<span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">		unlock(&amp;l.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enqueue itself.</span></span><br><span class="line">	s := acquireSudog()</span><br><span class="line">	s.g = getg()</span><br><span class="line">	s.ticket = t</span><br><span class="line">	s.releasetime = <span class="number">0</span></span><br><span class="line">	t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">		s.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">		l.head = s</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		l.tail.next = s</span><br><span class="line">	&#125;</span><br><span class="line">	l.tail = s</span><br><span class="line">	goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceBlockCondWait, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>大概逻辑如下</p>
<ol>
<li>如果waiter数量为0（wait&#x3D;&#x3D;notify），不处理</li>
<li>根据notify计算出待唤醒的waiter_id，并更新notify</li>
<li>在sudog列表查找ticket&#x3D;&#x3D;waiter_id的goroutine，将其唤醒</li>
<li>如果goroutine在wait时就接到信号，那么它肯定不在sudog列表，不处理</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Signal wakes one goroutine waiting on c, if there is any.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is allowed but not required for the caller to hold c.L</span></span><br><span class="line"><span class="comment">// during the call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Signal() does not affect goroutine scheduling priority; if other goroutines</span></span><br><span class="line"><span class="comment">// are attempting to lock c.L, they may be awoken before a &quot;waiting&quot; goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 按顺序唤醒一个goroutine</span></span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// notifyListNotifyOne notifies one entry in the list.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:linkname notifyListNotifyOne sync.runtime_notifyListNotifyOne</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast-path: if there are no new waiters since the last notification</span></span><br><span class="line">	<span class="comment">// we don&#x27;t need to acquire the lock at all.</span></span><br><span class="line">	<span class="keyword">if</span> l.wait.Load() == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Re-check under the lock if we need to do anything.</span></span><br><span class="line">	t := l.notify</span><br><span class="line">	<span class="keyword">if</span> t == l.wait.Load() &#123;</span><br><span class="line">		unlock(&amp;l.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the next notify ticket number.</span></span><br><span class="line">	atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try to find the g that needs to be notified.</span></span><br><span class="line">	<span class="comment">// If it hasn&#x27;t made it to the list yet we won&#x27;t find it,</span></span><br><span class="line">	<span class="comment">// but it won&#x27;t park itself once it sees the new notify number.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This scan looks linear but essentially always stops quickly.</span></span><br><span class="line">	<span class="comment">// Because g&#x27;s queue separately from taking numbers,</span></span><br><span class="line">	<span class="comment">// there may be minor reorderings in the list, but we</span></span><br><span class="line">	<span class="comment">// expect the g we&#x27;re looking for to be near the front.</span></span><br><span class="line">	<span class="comment">// The g has others in front of it on the list only to the</span></span><br><span class="line">	<span class="comment">// extent that it lost the race, so the iteration will not</span></span><br><span class="line">	<span class="comment">// be too long. This applies even when the g is missing:</span></span><br><span class="line">	<span class="comment">// it hasn&#x27;t yet gotten to sleep and has lost the race to</span></span><br><span class="line">	<span class="comment">// the (few) other g&#x27;s that we find on the list.</span></span><br><span class="line">	<span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">		<span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">			n := s.next</span><br><span class="line">			<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.next = n</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l.head = n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">				l.tail = p</span><br><span class="line">			&#125;</span><br><span class="line">			unlock(&amp;l.lock)</span><br><span class="line">			s.next = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">if</span> s.g.syncGroup != <span class="literal">nil</span> &amp;&amp; getg().syncGroup != s.g.syncGroup &#123;</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">&quot;semaphore wake of synctest goroutine&quot;</span>, s.g.goid, <span class="string">&quot;from outside bubble&quot;</span>)</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;semaphore wake of synctest goroutine from outside bubble&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h2><p>大概逻辑如下</p>
<ol>
<li>如果waiter数量为0（wait&#x3D;&#x3D;notify），不处理</li>
<li>更新notify，使其等于wait</li>
<li>扫描sudog列表，逐个唤醒goroutine</li>
<li>如果goroutine在wait时就接到信号，那么它肯定不在sudog列表，不处理</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Broadcast wakes all goroutines waiting on c.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is allowed but not required for the caller to hold c.L</span></span><br><span class="line"><span class="comment">// during the call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 唤醒所有goroutine</span></span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// notifyListNotifyAll notifies all entries in the list.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:linkname notifyListNotifyAll sync.runtime_notifyListNotifyAll</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast-path: if there are no new waiters since the last notification</span></span><br><span class="line">	<span class="comment">// we don&#x27;t need to acquire the lock.</span></span><br><span class="line">	<span class="keyword">if</span> l.wait.Load() == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pull the list out into a local variable, waiters will be readied</span></span><br><span class="line">	<span class="comment">// outside the lock.</span></span><br><span class="line">	lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line">	s := l.head</span><br><span class="line">	l.head = <span class="literal">nil</span></span><br><span class="line">	l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the next ticket to be notified. We can set it to the current</span></span><br><span class="line">	<span class="comment">// value of wait because any previous waiters are already in the list</span></span><br><span class="line">	<span class="comment">// or will notice that they have already been notified when trying to</span></span><br><span class="line">	<span class="comment">// add themselves to the list.</span></span><br><span class="line">	atomic.Store(&amp;l.notify, l.wait.Load())</span><br><span class="line">	unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Go through the local list and ready all waiters.</span></span><br><span class="line">	<span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := s.next</span><br><span class="line">		s.next = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> s.g.syncGroup != <span class="literal">nil</span> &amp;&amp; getg().syncGroup != s.g.syncGroup &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;semaphore wake of synctest goroutine&quot;</span>, s.g.goid, <span class="string">&quot;from outside bubble&quot;</span>)</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;semaphore wake of synctest goroutine from outside bubble&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">		s = next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://victoriametrics.com/blog/go-sync-cond/index.html">Go sync.Cond, the Most Overlooked Sync Mechanism</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">y2k38</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">81k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:54</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Y2k38/y2k38.github.io","repo_id":"R_kgDOMZGvZA","category":"Announcements","category_id":"DIC_kwDOMZGvZM4CirXX","mapping":"pathname","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"preferred_color_scheme","lang":"zh-CN","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
