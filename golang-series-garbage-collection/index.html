<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"y2k38.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="go的垃圾回收原理官方说法是是三色标记法+混合写屏障，但是，理论上怎么说是一回事，具体实现又是另一回事了，或者说实现已经偏离文档描述。总的来说，GC这部份的内容要比GMP跟内存分配都要复杂的多且出人意料。当前go版本：1.24 前言目标对象Go的GC并不扫描整个内存，只关注以下区域：  heap上分配的对象（在mspan管理范围） data&#x2F;bss段的全局变量 栈上的引用（扫描stack">
<meta property="og:type" content="article">
<meta property="og:title" content="golang系列之-垃圾回收">
<meta property="og:url" content="https://y2k38.github.io/golang-series-garbage-collection/index.html">
<meta property="og:site_name" content="noname">
<meta property="og:description" content="go的垃圾回收原理官方说法是是三色标记法+混合写屏障，但是，理论上怎么说是一回事，具体实现又是另一回事了，或者说实现已经偏离文档描述。总的来说，GC这部份的内容要比GMP跟内存分配都要复杂的多且出人意料。当前go版本：1.24 前言目标对象Go的GC并不扫描整个内存，只关注以下区域：  heap上分配的对象（在mspan管理范围） data&#x2F;bss段的全局变量 栈上的引用（扫描stack">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-04-06T02:58:06.000Z">
<meta property="article:modified_time" content="2025-04-06T08:57:28.945Z">
<meta property="article:author" content="y2k38">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://y2k38.github.io/golang-series-garbage-collection/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://y2k38.github.io/golang-series-garbage-collection/","path":"golang-series-garbage-collection/","title":"golang系列之-垃圾回收"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>golang系列之-垃圾回收 | noname</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">noname</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.</span> <span class="nav-text">目标对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">触发类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%92%E8%89%B2-%E5%88%86%E5%B7%A5"><span class="nav-number">1.3.</span> <span class="nav-text">角色&#x2F;分工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">完整运行流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#workType"><span class="nav-number">2.1.</span> <span class="nav-text">workType</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcControllerState"><span class="nav-number">2.2.</span> <span class="nav-text">gcControllerState</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcCPULimiterState"><span class="nav-number">2.3.</span> <span class="nav-text">gcCPULimiterState</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E6%89%AB%E5%99%A8"><span class="nav-number">2.4.</span> <span class="nav-text">清扫器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">2.5.</span> <span class="nav-text">内存回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">2.6.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">2.7.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">触发方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E8%A7%A6%E5%8F%91"><span class="nav-number">3.1.</span> <span class="nav-text">时间触发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%A4%A7%E5%B0%8F%E8%A7%A6%E5%8F%91"><span class="nav-number">3.2.</span> <span class="nav-text">堆大小触发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="nav-number">3.3.</span> <span class="nav-text">手动触发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">完整流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC1%E9%98%B6%E6%AE%B5%EF%BC%9ASweep-Termination%EF%BC%88%E6%B8%85%E7%90%86%E7%BB%88%E6%AD%A2%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">第1阶段：Sweep Termination（清理终止）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC2%E9%98%B6%E6%AE%B5%EF%BC%9AMark%EF%BC%88%E6%A0%87%E8%AE%B0%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">第2阶段：Mark（标记）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC3%E9%98%B6%E6%AE%B5%EF%BC%9AMark-Termination%EF%BC%88%E6%A0%87%E8%AE%B0%E7%BB%88%E6%AD%A2%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">第3阶段：Mark Termination（标记终止）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC4%E9%98%B6%E6%AE%B5%EF%BC%9ASweep%EF%BC%88%E6%B8%85%E7%90%86%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">第4阶段：Sweep（清理）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">5.</span> <span class="nav-text">混合写屏障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">相关依赖函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.1.</span> <span class="nav-text">GC初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcTrigger-GC%E8%A7%A6%E5%8F%91"><span class="nav-number">6.2.</span> <span class="nav-text">gcTrigger-GC触发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%96%E7%95%8C%E5%81%9C%E6%AD%A2-%E6%81%A2%E5%A4%8D"><span class="nav-number">6.3.</span> <span class="nav-text">世界停止&#x2F;恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">6.4.</span> <span class="nav-text">标记线程相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E6%89%AB%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="nav-number">6.5.</span> <span class="nav-text">清扫器相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="nav-number">6.6.</span> <span class="nav-text">内存回收器相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#scavengerState-%E8%8A%82%E5%A5%8F%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">6.6.1.</span> <span class="nav-text">scavengerState-节奏调度器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scavengeIndex-%E5%9B%9E%E6%94%B6%E7%B4%A2%E5%BC%95"><span class="nav-number">6.6.2.</span> <span class="nav-text">scavengeIndex-回收索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3"><span class="nav-number">6.6.3.</span> <span class="nav-text">内存管理相关</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA-1"><span class="nav-number">6.7.</span> <span class="nav-text">缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">6.7.1.</span> <span class="nav-text">任务缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">6.7.2.</span> <span class="nav-text">写屏障缓冲区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcControllerState-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%8A%82%E5%A5%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">6.8.</span> <span class="nav-text">gcControllerState-垃圾回收节奏控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcCPULimiterState-CPU%E9%99%90%E5%88%B6%E5%99%A8"><span class="nav-number">6.9.</span> <span class="nav-text">gcCPULimiterState-CPU限制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GMP%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3"><span class="nav-number">6.10.</span> <span class="nav-text">GMP调度相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9B%B8%E5%85%B3"><span class="nav-number">6.11.</span> <span class="nav-text">栈相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitmap%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3"><span class="nav-number">6.12.</span> <span class="nav-text">bitmap操作相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">7.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">y2k38</p>
  <div class="site-description" itemprop="description">个人笔记</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://y2k38.github.io/golang-series-garbage-collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="y2k38">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="noname">
      <meta itemprop="description" content="个人笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="golang系列之-垃圾回收 | noname">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          golang系列之-垃圾回收
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-04-06 10:58:06 / 修改时间：16:57:28" itemprop="dateCreated datePublished" datetime="2025-04-06T10:58:06+08:00">2025-04-06</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>35k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:08</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>go的垃圾回收原理官方说法是是三色标记法+混合写屏障，但是，理论上怎么说是一回事，具体实现又是另一回事了，或者说实现已经偏离文档描述。总的来说，GC这部份的内容要比GMP跟内存分配都要复杂的多且出人意料。当前go版本：1.24</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h3><p>Go的GC并不扫描整个内存，只关注以下区域：</p>
<ol>
<li>heap上分配的对象（在mspan管理范围）</li>
<li>data&#x2F;bss段的全局变量</li>
<li>栈上的引用（扫描stackRoots）</li>
</ol>
<h3 id="触发类型"><a href="#触发类型" class="headerlink" title="触发类型"></a>触发类型</h3><table>
<thead>
<tr>
<th align="left">触发类型</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gcTriggerHeap</td>
<td align="left">堆大小触发，heap内存达到一个临界点触发（最常用）</td>
</tr>
<tr>
<td align="left">gcTriggerTime</td>
<td align="left">时间触发，超时2min未执行GC则强制执行</td>
</tr>
<tr>
<td align="left">gcTriggerCycle</td>
<td align="left">手动触发，用户调用runtime.GC()</td>
</tr>
</tbody></table>
<h3 id="角色-分工"><a href="#角色-分工" class="headerlink" title="角色&#x2F;分工"></a>角色&#x2F;分工</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
<th>工作阶段</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Mark Worker（标记工作线程）</td>
<td>遍历对象图，标记存活对象，防止被错误回收</td>
<td>标记阶段（Marking）</td>
<td>运行时创建多个并发 Mark Worker，加快标记速度</td>
</tr>
<tr>
<td>Sweeper（清扫器）</td>
<td>清理未标记的对象，将其内存释放回空闲列表（mheap.free）</td>
<td>清扫阶段（Sweeping）</td>
<td>逐步清理，避免一次性 STW（Stop The World）</td>
</tr>
<tr>
<td>Scavenger（内存回收器）</td>
<td>释放长期未使用的堆内存，归还给OS以减少RSS</td>
<td>后台运行（定期触发）</td>
<td>主要针对大对象或空闲mspans，减少物理内存占用</td>
</tr>
</tbody></table>
<p><strong>标记工作线程</strong></p>
<p>其中，标记工作线程的会根据工作模式进一步区分，如下</p>
<table>
<thead>
<tr>
<th align="left">标记工作线程模式</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gcMarkWorkerNotWorker</td>
<td align="left">默认，未运行</td>
</tr>
<tr>
<td align="left">gcMarkWorkerDedicatedMode</td>
<td align="left">专用标记任务，最高优先级，非抢占</td>
</tr>
<tr>
<td align="left">gcMarkWorkerFractionalMode</td>
<td align="left">比例标记任务，跟其他g共享时间，可被抢占</td>
</tr>
<tr>
<td align="left">gcMarkWorkerIdleMode</td>
<td align="left">空闲时执行的低优先级标记任务，需要p空闲</td>
</tr>
</tbody></table>
<p><strong>CPU限制</strong></p>
<p>标记工作线程的CPU使用率被限制在25%（GOGC&#x3D;100时），假设系统使用一个6核CPU，那么GC在标记阶段大约会使用1.5个CPU资源：</p>
<ol>
<li>1个CPU由Dedicated（专用模式）的标记工作线程持续占用，该线程不允许抢占，直到标记任务完成</li>
<li>0.5个CPU由Fractional（比例模式）的标记工作线程使用，该线程仅在由额外CPU资源可用时运行，并会根据系统负责动态调整自身的CPU使用率</li>
</ol>
<h3 id="完整运行流程"><a href="#完整运行流程" class="headerlink" title="完整运行流程"></a>完整运行流程</h3><ol>
<li><p>Sweep Termination（清理终止）</p>
<ul>
<li>STW（Stop The World），确保所有P都达到GC安全点</li>
<li>完成上一轮GC未完成的sweep（清扫），回收剩余的的mspan</li>
<li>准备GC统计数据，为新一轮的GC计算目标heap大小、触发阈值等</li>
</ul>
</li>
<li><p>Mark（标记）</p>
<ul>
<li>STW，切换GC状态<ul>
<li>gcphase从_GCoff切换到_GCmark</li>
<li>开启写屏障（write barrier），允许Mutator协助GC标记，以维护三色标记不变性</li>
<li>启动GC后台线程，执行并发标记任务</li>
<li>根对象入队（包括栈、全局变量）</li>
</ul>
</li>
<li>恢复世界（Start The World），GC线程进入并发标记阶段<ul>
<li>从根对象开始标记，遍历所有可达对象</li>
<li>扫描灰色对象（已发现但未完全扫描的对象）并进行扫描，将其置黑，并将其引用的对象入队为灰色</li>
<li>混合写屏障（Hybrid Write Barrier）确保一致性</li>
</ul>
</li>
<li>完成标记</li>
</ul>
</li>
<li><p>Mark Termination（标记终止）</p>
<ul>
<li>STW，切换GC状态<ul>
<li>gcphase从_GCmark切换到_GCmarktermination</li>
<li>停止并发标记任务</li>
<li>执行终结器finalizer，如果有的话</li>
<li>清理mcache以确保没有悬挂对象</li>
</ul>
</li>
</ul>
</li>
<li><p>Sweep（清理）</p>
<ul>
<li>切换GC状态<ul>
<li>gcphase从_GCmarktermination切换回_GCoff</li>
<li>关闭写屏障（Mutator不再协助GC标记）</li>
</ul>
</li>
<li>恢复世界（Start The World），进入并发清扫阶段<ul>
<li>清理未被标记的对象</li>
<li>回收mspan到mheap或mcentral，部份回收到mcache</li>
<li>Mutator分配内存时，可能会触发增量清扫（Incremental Sweeping），加快回收过程</li>
</ul>
</li>
</ul>
</li>
<li><p>满足触发条件，启动下一轮GC</p>
</li>
</ol>
<p>简单的说，标记然后清扫</p>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>如果没有特别说明的话，下面的耗时字段都指一个GC周期内的</p>
<h3 id="workType"><a href="#workType" class="headerlink" title="workType"></a>workType</h3><p>workType类似GMP里的全局调度器schedt，负责GC的任务调度与阶段状态，包括管理GC周期中的各类任务、调度器状态、根对象索引、全局任务队列、并发控制等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 世界停止前获取，恢复世界后释放。确保同一时间只有一个GC流程在运行</span></span><br><span class="line"><span class="keyword">var</span> gcsema <span class="type">uint32</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 世界停止前获取，恢复世界后释放。确保同一时间只能有一个线程执行STW（其他组件也能STW）</span></span><br><span class="line"><span class="keyword">var</span> worldsema <span class="type">uint32</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// workType.startSema    // 第1阶段启动前获取并在末尾释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> work workType</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">type</span> workType <span class="keyword">struct</span> &#123;</span><br><span class="line">    full      lfstack          <span class="comment">// 全局任务缓冲区，wbuf中元素数量不为0</span></span><br><span class="line">    _         cpu.CacheLinePad <span class="comment">// 防止false-sharing</span></span><br><span class="line">    empty     lfstack          <span class="comment">// 全局任务缓冲区，wbuf中元素数量为0</span></span><br><span class="line">    _         cpu.CacheLinePad</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan，用于分配、存储wbuf-任务缓冲区</span></span><br><span class="line">    <span class="comment">// mspan会一次性创建n个mspan，一个返回，剩余n-1个放到empty</span></span><br><span class="line">    wbufSpans <span class="keyword">struct</span> &#123;</span><br><span class="line">        lock mutex</span><br><span class="line">        free mSpanList         <span class="comment">// 空的mspan，一般是busy清空后放到这里</span></span><br><span class="line">        busy mSpanList         <span class="comment">// 含有wbuf的mspan</span></span><br><span class="line">    &#125;</span><br><span class="line">    _            <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">    bytesMarked  <span class="type">uint64</span>        <span class="comment">// 已标记字节数</span></span><br><span class="line">    markrootNext <span class="type">uint32</span>        <span class="comment">// markroot任务id/计数器</span></span><br><span class="line">    markrootJobs <span class="type">uint32</span>        <span class="comment">// markroot任务总数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// nproc是固定值，跟nwait是一对，用于表示标记工作线程数量（Assist-协助线程也会调整这个计数器）</span></span><br><span class="line">    nproc        <span class="type">uint32</span>        <span class="comment">// 初始值为2^32-1</span></span><br><span class="line">    tstart       <span class="type">int64</span>         <span class="comment">//</span></span><br><span class="line">    nwait        <span class="type">uint32</span>        <span class="comment">// 初始值为2^32-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根对象块数量，如nStackRoots == len(stackRoots)</span></span><br><span class="line">    nDataRoots, nBSSRoots, nSpanRoots, nStackRoots    <span class="type">int</span></span><br><span class="line">    <span class="comment">// 根对象块的基地址（索引），baseEnd是边界</span></span><br><span class="line">    baseData, baseBSS, baseSpans, baseStacks, baseEnd <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">    stackRoots      []*g       <span class="comment">// allgs快照（在标记之前获取）</span></span><br><span class="line">    startSema       <span class="type">uint32</span>     <span class="comment">// 信号量，GC启动前获取，</span></span><br><span class="line">    markDoneSema    <span class="type">uint32</span>     <span class="comment">// 信号量，gcMarkDone时使用</span></span><br><span class="line">    bgMarkDone      <span class="type">uint32</span>     <span class="comment">// 这个字段整个源代码都没有使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0-并发标记清扫 1-STW标记+并发清扫 2-STW标记+STW清扫</span></span><br><span class="line">    mode            gcMode     <span class="comment">// 模式，默认0-gcBackgroundMode，debug时可设置其他模式</span></span><br><span class="line"></span><br><span class="line">    userForced      <span class="type">bool</span>       <span class="comment">// 是否用户手动/强制运行</span></span><br><span class="line">    initialHeapLive <span class="type">uint64</span>     <span class="comment">// heapLive快照</span></span><br><span class="line">    assistQueue     <span class="keyword">struct</span> &#123;   <span class="comment">// bgScanCredit额度不足时将g挂起</span></span><br><span class="line">        lock mutex</span><br><span class="line">        q    gQueue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sweepWaiters <span class="keyword">struct</span> &#123;      <span class="comment">// 当前g挂起等待第n个GC周期结束（手动触发使用）</span></span><br><span class="line">        lock mutex</span><br><span class="line">        list gList             <span class="comment">// 执行runtime.GC的g，_GCmarktermination时唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strongFromWeak <span class="keyword">struct</span> &#123;    <span class="comment">// 控制weak-&gt;strong指针转换</span></span><br><span class="line">        block <span class="type">bool</span>             <span class="comment">// 是否阻止weak-&gt;strong转换</span></span><br><span class="line">        lock  mutex</span><br><span class="line">        q     gQueue           <span class="comment">// block为true时将g放到q，false时将q内全部g放进p本地/全局队列</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cycles                             atomic.Uint32 <span class="comment">// 周期计数器，gcStart时递增</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// stwprocs=max(gomaxprocs,ncpu), maxprocs=gomaxprocs</span></span><br><span class="line">    stwprocs, maxprocs                 <span class="type">int32</span>         <span class="comment">// 同p数量</span></span><br><span class="line">    <span class="comment">// tSweepTerm - 第1阶段开始时刻</span></span><br><span class="line">    <span class="comment">// tMark      - 第2阶段开始时刻</span></span><br><span class="line">    <span class="comment">// tMarkTerm  - 第3阶段开始时刻</span></span><br><span class="line">    <span class="comment">// tEnd       - 第4阶段开始时刻</span></span><br><span class="line">    tSweepTerm, tMark, tMarkTerm, tEnd <span class="type">int64</span>         <span class="comment">// 当前时刻</span></span><br><span class="line">    pauseNS                            <span class="type">int64</span>         <span class="comment">// 当前GC循环累计STW耗时</span></span><br><span class="line">    <span class="comment">// heap0 =&gt; heapLive快照-heap存活字节数</span></span><br><span class="line">    <span class="comment">// heap1 =&gt; heapLive快照-heap存活字节数</span></span><br><span class="line">    <span class="comment">// heap2 =&gt; bytesMarked快照-已标记字节数</span></span><br><span class="line">    heap0, heap1, heap2                <span class="type">uint64</span>        <span class="comment">// 当前循环的debug.gctrace heap大小</span></span><br><span class="line">    <span class="comment">// GC暂停耗时、GC流程总耗时</span></span><br><span class="line">    cpuStats                                         <span class="comment">// CPU统计信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcControllerState"><a href="#gcControllerState" class="headerlink" title="gcControllerState"></a>gcControllerState</h3><p>gcControllerState-垃圾回收节奏控制（pacing），保持系统平稳运行。负责内存使用与触发GC的策略控制，包括控制GC何时触发，计算下一次触发时机、控制GC比例（目标）、动态调整参数（如GOGC）等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gcController gcControllerState</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似schedt结构体</span></span><br><span class="line"><span class="keyword">type</span> gcControllerState <span class="keyword">struct</span> &#123;</span><br><span class="line">    gcPercent                  atomic.Int32     <span class="comment">// 从GOGC环境变量获取，默认100</span></span><br><span class="line">    memoryLimit                atomic.Int64     <span class="comment">// 从GOMEMLIMIT环境变量获取，默认2^64-1</span></span><br><span class="line"></span><br><span class="line">    heapMinimum                <span class="type">uint64</span>           <span class="comment">// heap内存空间大小，默认为4MB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跑道，飞机起飞前需要滑行的距离</span></span><br><span class="line">    <span class="comment">// 控制goroutine是否需要协助标记，避免GC跑不完。默认情况下为根对象大小的3倍</span></span><br><span class="line">    runway                     atomic.Uint64</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前并发标记进度</span></span><br><span class="line">    <span class="comment">// consMark &gt; 1.0 =&gt; GC当前落后于内存分配速度，会启用更激进的GC策略</span></span><br><span class="line">    <span class="comment">// consMark &lt; 1.0 =&gt; GC当前标记进度是健康的</span></span><br><span class="line">    consMark                   <span class="type">float64</span></span><br><span class="line"></span><br><span class="line">    lastConsMark               [<span class="number">4</span>]<span class="type">float64</span>       <span class="comment">// 历史4次GC的并发标记进度</span></span><br><span class="line">    gcPercentHeapGoal          atomic.Uint64    <span class="comment">// 目标heap大小</span></span><br><span class="line">    sweepDistMinTrigger        atomic.Uint64    <span class="comment">// GC启动的一个底线阈值，非清扫阶段为0，否则为heapLive+1MB</span></span><br><span class="line">    triggered                  <span class="type">uint64</span>           <span class="comment">// 默认2^64-1，GC启动时为heapLive快照</span></span><br><span class="line">    lastHeapGoal               <span class="type">uint64</span>           <span class="comment">// GC结束时计算的目标heap大小</span></span><br><span class="line">    heapLive                   atomic.Uint64    <span class="comment">// heap存活字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记终止阶段同步heapScanWork，与lastHeapScan不同，内存分配时也会继续累计</span></span><br><span class="line">    heapScan                   atomic.Uint64    <span class="comment">// heapScanWork快照</span></span><br><span class="line">    lastHeapScan               <span class="type">uint64</span>           <span class="comment">// heapScanWork快照</span></span><br><span class="line">    lastStackScan              atomic.Uint64    <span class="comment">// stackScanWork快照</span></span><br><span class="line">    maxStackScan               atomic.Uint64    <span class="comment">// 累计所有的栈字节数</span></span><br><span class="line">    globalsScan                atomic.Uint64    <span class="comment">// 全部模块的bss+data段大小</span></span><br><span class="line"></span><br><span class="line">    heapMarked                 <span class="type">uint64</span>           <span class="comment">// 上一次GC后heap存活字节数，heapLive快照</span></span><br><span class="line"></span><br><span class="line">    heapScanWork               atomic.Int64     <span class="comment">// heap扫描字节数，同gcw.heapScanWork</span></span><br><span class="line">    stackScanWork              atomic.Int64     <span class="comment">// stack扫描字节数</span></span><br><span class="line">    globalsScanWork            atomic.Int64     <span class="comment">// bss/data扫描字节数</span></span><br><span class="line"></span><br><span class="line">    bgScanCredit               atomic.Int64     <span class="comment">// 扫描额度，同gcw.heapScanWork</span></span><br><span class="line">    assistTime                 atomic.Int64     <span class="comment">// GC助攻耗时</span></span><br><span class="line"></span><br><span class="line">    dedicatedMarkTime          atomic.Int64     <span class="comment">// 累计所有p的标记耗时（专用标记任务）</span></span><br><span class="line">    fractionalMarkTime         atomic.Int64     <span class="comment">// 累计所有p的标记耗时（比例标记任务）</span></span><br><span class="line">    idleMarkTime               atomic.Int64     <span class="comment">// 累计所有p的标记耗时（空闲标记任务）</span></span><br><span class="line"></span><br><span class="line">    markStartTime              <span class="type">int64</span>            <span class="comment">// 当前循环开始时刻，gcStart时纪录</span></span><br><span class="line"></span><br><span class="line">    dedicatedMarkWorkersNeeded atomic.Int64     <span class="comment">// 专用标记任务需要的线程数量</span></span><br><span class="line">    idleMarkWorkers            atomic.Uint64    <span class="comment">// 空闲标记线程数量，一般是procs-专用标记线程数量</span></span><br><span class="line">    <span class="comment">// 下面两个互为倒数</span></span><br><span class="line">    assistWorkPerByte          atomic.Float64   <span class="comment">// 每分配1字节需要辅助完成多少GC工作量</span></span><br><span class="line">    assistBytesPerWork         atomic.Float64   <span class="comment">// 每完成1单位GC工作量可以分配多少字节</span></span><br><span class="line">    fractionalUtilizationGoal  <span class="type">float64</span>          <span class="comment">// 比例标记任务利用率目标，为0时不需要标记线程</span></span><br><span class="line"></span><br><span class="line">    heapInUse                  sysMemStat       <span class="comment">// heap内存使用量（mSpanInUse）</span></span><br><span class="line">    heapReleased               sysMemStat       <span class="comment">// heap内存释放量（释放回OS）</span></span><br><span class="line">    <span class="comment">// heapFree在allocSpan时减少，freeSpanLocked时增加，一般为负数</span></span><br><span class="line">    heapFree                   sysMemStat       <span class="comment">// heap内存可复用量</span></span><br><span class="line"></span><br><span class="line">    totalAlloc                 atomic.Uint64    <span class="comment">// 累计已分配字节数</span></span><br><span class="line">    totalFree                  atomic.Uint64    <span class="comment">// 累计回收量</span></span><br><span class="line">    <span class="comment">// 已映射且可用的内存量（总内存），最底层OS级别的内存统计</span></span><br><span class="line">    <span class="comment">// sysAlloc、sysUsed时增加，sysUnused、sysFree、sysFault时减少</span></span><br><span class="line">    mappedReady                atomic.Uint64</span><br><span class="line"></span><br><span class="line">    test                       <span class="type">bool</span>             <span class="comment">// 测试，忽略</span></span><br><span class="line">    _                          cpu.CacheLinePad</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcCPULimiterState"><a href="#gcCPULimiterState" class="headerlink" title="gcCPULimiterState"></a>gcCPULimiterState</h3><p>CPU限制器，负责限制GC对CPU的占用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gcCPULimiter gcCPULimiterState</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会在gcStart和gcMarkDone调整</span></span><br><span class="line"><span class="keyword">type</span> gcCPULimiterState <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock          atomic.Uint32    <span class="comment">// 0-未锁定，1-已锁定</span></span><br><span class="line">    enabled       atomic.Bool      <span class="comment">// 是否已经触发限速状态，fill==capacity时限制GC运行</span></span><br><span class="line">    gcEnabled     <span class="type">bool</span>             <span class="comment">// gcBlackenEnabled快照</span></span><br><span class="line">    transitioning <span class="type">bool</span>             <span class="comment">// 是否处于过渡状态，true-意味着GC目前正在调整CPU限制</span></span><br><span class="line">    test          <span class="type">bool</span>             <span class="comment">// 测试，忽略</span></span><br><span class="line"></span><br><span class="line">    bucket        <span class="keyword">struct</span> &#123;         <span class="comment">// 水桶</span></span><br><span class="line">        <span class="comment">// capacity是整个水桶的容量，=nprocs*1e9 =&gt; 每个CPU有1s</span></span><br><span class="line">        <span class="comment">// fill是水桶剩余量，可以理解为GC额度，初始值为capacity，意味着从一开始就限制GC运行</span></span><br><span class="line">        fill, capacity <span class="type">uint64</span>      <span class="comment">// fill &lt;= capacity</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    overflow         <span class="type">uint64</span>        <span class="comment">// 累计bucket溢出部份（从程序开始一直累计）</span></span><br><span class="line">    assistTimePool   atomic.Int64  <span class="comment">// 从上一次更新开始累计的助攻积分</span></span><br><span class="line">    idleMarkTimePool atomic.Int64  <span class="comment">//</span></span><br><span class="line">    idleTimePool     atomic.Int64  <span class="comment">// 从上一次更新开始累计的p空闲时辅助标记的耗时</span></span><br><span class="line">    lastUpdate       atomic.Int64  <span class="comment">// 上一次更新的时刻</span></span><br><span class="line">    lastEnabledCycle atomic.Uint32 <span class="comment">// enabled为true时，纪录为numgc+1。numgc =&gt; gc计数器，类似cycle</span></span><br><span class="line">    nprocs           <span class="type">int32</span>         <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清扫器"><a href="#清扫器" class="headerlink" title="清扫器"></a>清扫器</h3><p>sweeper-清扫器，负责将内存回收到mheap</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sweep sweepdata</span><br><span class="line"></span><br><span class="line"><span class="comment">// sweeper状态，负责清理不可达对象的内存</span></span><br><span class="line"><span class="keyword">type</span> sweepdata <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock         mutex</span><br><span class="line">    <span class="comment">// 下面两个是sweeper专用的</span></span><br><span class="line">    g            *g          <span class="comment">// sweeper</span></span><br><span class="line">    parked       <span class="type">bool</span>        <span class="comment">// 挂起时为true，被唤醒后重置为false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他g可以协助sweeper并发清扫</span></span><br><span class="line">    <span class="comment">// 为什么还有计数器呢？因为除了第一个默认的sweeper，其他的g可以协助并发清扫</span></span><br><span class="line">    active       activeSweep <span class="comment">// 计数器，最高位为1时表示清扫完毕</span></span><br><span class="line">    centralIndex sweepClass  <span class="comment">// 索引，指向当前未清扫的mspan，用于mcentral</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> activeSweep <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 最高位是flag，为1时表示队列为空，剩余31位为计数器</span></span><br><span class="line">    state atomic.Uint32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sweepClass <span class="type">uint32</span></span><br></pre></td></tr></table></figure>

<h3 id="内存回收器"><a href="#内存回收器" class="headerlink" title="内存回收器"></a>内存回收器</h3><p>内存回收器负责将内存归还OS，其中</p>
<ol>
<li>scavenge-负责回收目标计算、回收时机判断</li>
<li>scavenger-节奏调度器<ul>
<li>当前目标释放速率（sleepRatio, targetCPUFraction）</li>
<li>实际是否要执行（shouldStop）</li>
<li>具体怎么执行（scavenge回调函数由pageAlloc注入）</li>
<li>用PI控制器sleepController平滑地控制回收速率：更类似GC的pacer</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回收目标计算、回收时机判断</span></span><br><span class="line"><span class="keyword">var</span> scavenge <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 1. lastHeapGoal为0</span></span><br><span class="line">    <span class="comment">// 2. heapInUse+heapFree &lt; gcPercentGoal</span></span><br><span class="line">    <span class="comment">// 3. heapInUse+heapFree &lt; gcPercentGoal+physPageSize</span></span><br><span class="line">    <span class="comment">// 以上三种情况设置为2^64-1，否则需要计算得出</span></span><br><span class="line">    gcPercentGoal   atomic.Uint64 <span class="comment">// GC触发临界点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果超过95%的memoryLimit则设置为95%的memoryLimit，否则设置为2^64-1</span></span><br><span class="line">    memoryLimitGoal atomic.Uint64 <span class="comment">// 内存限制</span></span><br><span class="line"></span><br><span class="line">    assistTime      atomic.Int64  <span class="comment">// 助攻耗时</span></span><br><span class="line">    backgroundTime  atomic.Int64  <span class="comment">// 运行耗时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scavenger scavengerState</span><br><span class="line"></span><br><span class="line"><span class="comment">// pacing-节奏调度器</span></span><br><span class="line"><span class="keyword">type</span> scavengerState <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock                 mutex</span><br><span class="line"></span><br><span class="line">    g                    *g                               <span class="comment">// scavenger</span></span><br><span class="line">    timer                *timer                           <span class="comment">// 定时器，看起来没什么用</span></span><br><span class="line">    sysmonWake           atomic.Uint32                    <span class="comment">// 为1时sysmon将会唤醒scavenger</span></span><br><span class="line">    parked               <span class="type">bool</span>                             <span class="comment">// 是否挂起</span></span><br><span class="line">    printControllerReset <span class="type">bool</span>                             <span class="comment">// </span></span><br><span class="line">    targetCPUFraction    <span class="type">float64</span>                          <span class="comment">// </span></span><br><span class="line">    sleepRatio           <span class="type">float64</span>                          <span class="comment">// 低值意味着更多睡眠，高值意味着更激进的scavenging</span></span><br><span class="line">    sleepController      piController                     <span class="comment">// </span></span><br><span class="line">    controllerCooldown   <span class="type">int64</span>                            <span class="comment">// </span></span><br><span class="line">    sleepStub            <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int64</span>)</span></span> <span class="type">int64</span>              <span class="comment">// </span></span><br><span class="line">    scavenge             <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">uintptr</span>)</span></span> (<span class="type">uintptr</span>, <span class="type">int64</span>) <span class="comment">// pageAlloc执行scavenge，累计耗时到backgroundTime</span></span><br><span class="line">    shouldStop           <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>                      <span class="comment">// 只要没达到阈值，scavenger就不需要回收</span></span><br><span class="line"></span><br><span class="line">    gomaxprocs           <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int32</span>                     <span class="comment">// 测试用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pageAlloc相关</span></span><br><span class="line"><span class="comment">// 回收索引-负责追踪哪些内存物理页已经被回收或可被回收</span></span><br><span class="line"><span class="keyword">type</span> scavengeIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 用于追踪chunk中哪些页已经被释放</span></span><br><span class="line">    <span class="comment">// 总大小512MB，可通过load方法转换为scavChunkData</span></span><br><span class="line">    chunks          []atomicScavChunkData <span class="comment">//</span></span><br><span class="line">    min, max        atomic.Uintptr        <span class="comment">// 最小base、最大limit</span></span><br><span class="line">    minHeapIdx      atomic.Uintptr        <span class="comment">// 全局最小的chunkIndex</span></span><br><span class="line">    searchAddrBg    atomicOffAddr         <span class="comment">// 搜索地址，由后台运行的scavenger更新</span></span><br><span class="line">    searchAddrForce atomicOffAddr         <span class="comment">// 搜索地址，由分配内存时协助回收更新</span></span><br><span class="line">    freeHWM         offAddr               <span class="comment">// free函数执行时纪录的最高地址</span></span><br><span class="line">    gen             <span class="type">uint32</span>                <span class="comment">// 版本计数器</span></span><br><span class="line">    test            <span class="type">bool</span>                  <span class="comment">// 测试用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8字节，可转换为scavChunkData</span></span><br><span class="line"><span class="keyword">type</span> atomicScavChunkData <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// | 32bit | 6bit           | 10bit     | 16bit |</span></span><br><span class="line">    <span class="comment">// | gen   | scavChunkFlags | lastInUse | inUse |</span></span><br><span class="line">    value atomic.Uint64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12个字节</span></span><br><span class="line"><span class="keyword">type</span> scavChunkData <span class="keyword">struct</span> &#123;</span><br><span class="line">    inUse          <span class="type">uint16</span> <span class="comment">// 页数，表示有多少个页当前已分配，只有低10位被使用</span></span><br><span class="line">    lastInUse      <span class="type">uint16</span> <span class="comment">// inUse快照，版本变更时纪录</span></span><br><span class="line">    gen            <span class="type">uint32</span> <span class="comment">// 版本计数器</span></span><br><span class="line">    scavChunkFlags        <span class="comment">// 只有低6位在使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> scavChunkFlags <span class="type">uint8</span></span><br></pre></td></tr></table></figure>

<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>这几个缓冲区都放在P内部，作为本地缓冲区，全局缓冲区放在workType</p>
<ol>
<li>workbuf-任务缓冲区</li>
<li>wbBuf-写屏障缓冲区</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作队列</span></span><br><span class="line"><span class="keyword">type</span> gcWork <span class="keyword">struct</span> &#123;</span><br><span class="line">    wbuf1, wbuf2 *workbuf <span class="comment">// 任务缓冲区</span></span><br><span class="line">    bytesMarked  <span class="type">uint64</span>   <span class="comment">// </span></span><br><span class="line">    heapScanWork <span class="type">int64</span>    <span class="comment">// 扫描字节数</span></span><br><span class="line">    flushedWork  <span class="type">bool</span>     <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务缓冲区，固定2KB</span></span><br><span class="line"><span class="keyword">type</span> workbuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ sys.NotInHeap</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    workbufhdr</span><br><span class="line">    <span class="comment">// 253个指针</span></span><br><span class="line">    obj [(_WorkbufSize - unsafe.Sizeof(workbufhdr&#123;&#125;)) / goarch.PtrSize]<span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 24字节</span></span><br><span class="line"><span class="keyword">type</span> workbufhdr <span class="keyword">struct</span> &#123;</span><br><span class="line">    node lfnode           <span class="comment">//</span></span><br><span class="line">    nobj <span class="type">int</span>              <span class="comment">// 对象数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写屏障缓冲，4112字节</span></span><br><span class="line"><span class="keyword">type</span> wbBuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    next <span class="type">uintptr</span>               <span class="comment">// 指针的地址，指向下一个元素时移动8个字节（指针大小）</span></span><br><span class="line">    end  <span class="type">uintptr</span>               <span class="comment">// 边界，指向最后一个元素的末尾</span></span><br><span class="line">    <span class="comment">// 不直接使用buf</span></span><br><span class="line">    buf  [wbBufEntries]<span class="type">uintptr</span> <span class="comment">// 512个指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>gcTrigger-触发类型</li>
<li>gcBgMarkWorkerNode-标记工作线程</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发类型</span></span><br><span class="line"><span class="keyword">type</span> gcTrigger <span class="keyword">struct</span> &#123;</span><br><span class="line">    kind gcTriggerKind    <span class="comment">// 类型</span></span><br><span class="line">    now  <span class="type">int64</span>            <span class="comment">// 当前时刻，时间触发才有</span></span><br><span class="line">    n    <span class="type">uint32</span>           <span class="comment">// 版本计数器，手动触发才有，从work.cycles同步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记工作线程，这是单个节点，所有的节点会存储在全局变量gcBgMarkWorkerPool中</span></span><br><span class="line"><span class="keyword">type</span> gcBgMarkWorkerNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    node lfnode           <span class="comment">// 链表，将当前节点跟其他节点链接起来</span></span><br><span class="line">    gp   guintptr         <span class="comment">// g</span></span><br><span class="line">    m    muintptr         <span class="comment">// m，禁止抢占</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无锁栈</span></span><br><span class="line"><span class="keyword">type</span> lfnode <span class="keyword">struct</span> &#123;</span><br><span class="line">    next    <span class="type">uint64</span>        <span class="comment">// next指针</span></span><br><span class="line">    pushcnt <span class="type">uintptr</span>       <span class="comment">// 计数器/索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><h3 id="时间触发"><a href="#时间触发" class="headerlink" title="时间触发"></a>时间触发</h3><p>时间触发的GC注册在init函数，由runtime.main负责启动，如果检查到2min内没有执行过任何GC，则触发运行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// start forcegc helper goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// gcTriggerTime类型的GC</span></span><br><span class="line">    <span class="keyword">go</span> forcegchelper()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由sysmon管理</span></span><br><span class="line"><span class="keyword">type</span> forcegcstate <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock mutex       <span class="comment">// 锁</span></span><br><span class="line">    g    *g          <span class="comment">// g</span></span><br><span class="line">    idle atomic.Bool <span class="comment">// 空闲时挂起休眠，g运行时设置为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> forcegc forcegcstate</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcTriggerTime类型的GC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forcegchelper</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 纪录当前g</span></span><br><span class="line">    forcegc.g = getg()</span><br><span class="line">    <span class="comment">// 锁初始化</span></span><br><span class="line">    lockInit(&amp;forcegc.lock, lockRankForcegc)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock(&amp;forcegc.lock)</span><br><span class="line">        <span class="comment">// 期望idle为false</span></span><br><span class="line">        <span class="keyword">if</span> forcegc.idle.Load() &#123;</span><br><span class="line">            throw(<span class="string">&quot;forcegc: phase error&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// idle设置为true</span></span><br><span class="line">        forcegc.idle.Store(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前g让出CPU，g0执行调度运行其他g</span></span><br><span class="line">        <span class="comment">// 在内部g、m解除绑定后会解锁forcegc.lock</span></span><br><span class="line">        goparkunlock(&amp;forcegc.lock, waitReasonForceGCIdle, traceBlockSystemGoroutine, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被sysmon唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为0，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.gctrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;GC forced&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gcTriggerTime类型，超过2min未GC则强制运行</span></span><br><span class="line">        gcStart(gcTrigger&#123;kind: gcTriggerTime, now: nanotime()&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆大小触发"><a href="#堆大小触发" class="headerlink" title="堆大小触发"></a>堆大小触发</h3><p>每次分配内存时，判断heap内存大小是否达到临界点，达到临界点则触发运行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">    gcStart(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>由用户调用runtime.GC()手动触发，大概的逻辑为：</p>
<ol>
<li>等待当前周期结束</li>
<li>执行新周期的GC</li>
<li>等待标记、清扫完全结束</li>
<li>更新heap统计数据</li>
</ol>
<p>该操作会阻塞当前线程，甚至是阻塞整个程序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := work.cycles.Load()</span><br><span class="line">    <span class="comment">// 等待第n个周期结束（_GCmarktermination时唤醒）</span></span><br><span class="line">    gcWaitOnMark(n)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行GC</span></span><br><span class="line">    gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待第n+1个周期结束（_GCmarktermination时唤醒）</span></span><br><span class="line">    gcWaitOnMark(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtime.GC()被很多测试、压测调用，需要确保GC完成sweep阶段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前周期 and 完成剩余mspan的清扫</span></span><br><span class="line">    <span class="keyword">for</span> work.cycles.Load() == n+<span class="number">1</span> &amp;&amp; sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 清理了一个mspan</span></span><br><span class="line">        <span class="comment">// 同协程yield关键字，当前G让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">        Gosched()</span><br><span class="line">        <span class="comment">// 被重新调度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap的状态可能还在周期n</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前周期 and sweep阶段还没结束</span></span><br><span class="line">    <span class="keyword">for</span> work.cycles.Load() == n+<span class="number">1</span> &amp;&amp; !isSweepDone() &#123;</span><br><span class="line">        <span class="comment">// 同协程yield关键字，当前G让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">        Gosched()</span><br><span class="line">        <span class="comment">// 被重新调度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，sweep阶段确定是结束了</span></span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    cycle := work.cycles.Load()</span><br><span class="line">    <span class="comment">// 当前周期 or 下一个周期</span></span><br><span class="line">    <span class="keyword">if</span> cycle == n+<span class="number">1</span> || (gcphase == _GCmark &amp;&amp; cycle == n+<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 将的heap统计数据累加到active</span></span><br><span class="line">        mProf_PostSweep()</span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><h3 id="第1阶段：Sweep-Termination（清理终止）"><a href="#第1阶段：Sweep-Termination（清理终止）" class="headerlink" title="第1阶段：Sweep Termination（清理终止）"></a>第1阶段：Sweep Termination（清理终止）</h3><p>大概流程如下</p>
<ol>
<li>guard，检查函数运行的前提条件</li>
<li>协助sweeper清理剩余的mspan</li>
<li>创建标记工作线程（这个阶段前，将世界停止）</li>
<li>重置GC状态</li>
<li>停止所有p</li>
<li>清扫、回收</li>
<li>开始启动GC（设置各种状态、纪录快照等，开启写屏障）</li>
<li>一切都准备好了，可以并发标记了（这个阶段后，恢复世界）</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. guard</span></span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// g0或m禁止抢占</span></span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp == mp.g0 || mp.locks &gt; <span class="number">1</span> || mp.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 不处理</span></span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line">    mp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp.syncGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">        sg := gp.syncGroup</span><br><span class="line">        gp.syncGroup = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            gp.syncGroup = sg</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 协助清扫</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果满足运行条件就把剩余的mspan都清扫完</span></span><br><span class="line">    <span class="keyword">for</span> trigger.test() &amp;&amp; sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不满足GC运行条件 or 没有mspan需要清扫</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取work.startSema，失败则挂起等待</span></span><br><span class="line">    semacquire(&amp;work.startSema)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="comment">// 不满足GC运行条件</span></span><br><span class="line">    <span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">        <span class="comment">// 恢复世界后释放，唤醒其他g，可以运行其他GC了，虽然可能会被阻挡</span></span><br><span class="line">        semrelease(&amp;work.startSema)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有mspan需要清扫，可以启动新流程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认，并发GC和sweep</span></span><br><span class="line">    mode := gcBackgroundMode</span><br><span class="line">    <span class="comment">// gcstoptheworld默认为0，下面两个条件不管</span></span><br><span class="line">    <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">1</span> &#123;</span><br><span class="line">        mode = gcForceMode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">2</span> &#123;</span><br><span class="line">        mode = gcForceBlockMode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取gcsema，失败则挂起等待（确保同一时间只有一个GC流程在运行）</span></span><br><span class="line">    semacquire(&amp;gcsema)</span><br><span class="line">    <span class="comment">// 尝试获取worldsema，失败则挂起等待（确保同一时间只能有一个线程执行STW）</span></span><br><span class="line">    semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcTriggerCycle =&gt; 手动强制执行（这里用于统计）</span></span><br><span class="line">    work.userForced = trigger.kind == gcTriggerCycle</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历allp</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// 一般情况下flushGen与sweepgen是同步的</span></span><br><span class="line">        <span class="keyword">if</span> fg := p.mcache.flushGen.Load(); fg != mheap_.sweepgen &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: p&quot;</span>, p.id, <span class="string">&quot;flushGen&quot;</span>, fg, <span class="string">&quot;!= sweepgen&quot;</span>, mheap_.sweepgen)</span><br><span class="line">            throw(<span class="string">&quot;p mcache not flushed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建标记工作线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个p启动一个标记工作线程gcBgMarkWorker，负责第2阶段，先挂起等待调度器调度</span></span><br><span class="line">    <span class="comment">// （调度的前提是gcBlackenEnabled=1，下方设置）</span></span><br><span class="line">    gcBgMarkStartWorkers()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 重置GC状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇编，切换到g0运行gcResetMarkState</span></span><br><span class="line">    <span class="comment">// 所有g标记为栈未扫描、助攻积分清0，所有heapArena清除pageMarks，重置bytesMarked、同步heapLive</span></span><br><span class="line">    systemstack(gcResetMarkState)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 停止所有p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同p的总量</span></span><br><span class="line">    work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs</span><br><span class="line">    <span class="comment">// =max(gomaxprocs,ncpu)</span></span><br><span class="line">    <span class="keyword">if</span> work.stwprocs &gt; ncpu &#123;</span><br><span class="line">        <span class="comment">// 取实际CPU核心数量</span></span><br><span class="line">        work.stwprocs = ncpu</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// heap存活字节数</span></span><br><span class="line">    work.heap0 = gcController.heapLive.Load()</span><br><span class="line">    <span class="comment">// STW耗时</span></span><br><span class="line">    work.pauseNS = <span class="number">0</span></span><br><span class="line">    <span class="comment">// gcBackgroundMode，默认，并发标记、清扫</span></span><br><span class="line">    work.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 第1阶段开始时刻</span></span><br><span class="line">    work.tSweepTerm = now</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STW原因、耗时信息</span></span><br><span class="line">    <span class="keyword">var</span> stw worldStop</span><br><span class="line">    <span class="comment">// 切换到g0执行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 将所有p都停止，返回原因、时间信息</span></span><br><span class="line">        stw = stopTheWorldWithSema(stwGCSweepTerm)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，所有的p都放进空闲队列了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 清扫、回收</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU暂停时间GCPauseTime、GCTotalTime更新 =&gt; +=stoppingCPUTime*1</span></span><br><span class="line">    work.cpuStats.accumulateGCPauseTime(stw.stoppingCPUTime, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到g0执行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 清理所有mspan、重置mcentral、唤醒scavenger、gcBitsArenas迭代</span></span><br><span class="line">        finishsweep_m()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC第1阶段时，清理sync.Pool、sudog缓存、defer pool及其他</span></span><br><span class="line">    clearpools()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 开始启动GC</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 周期计数器n+1</span></span><br><span class="line">    work.cycles.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置相关字段，计算不同模式的标记工作线程目标，设置最大标记工作线程数，计算辅助GC的工作量转换参数</span></span><br><span class="line">    gcController.startCycle(now, <span class="type">int</span>(gomaxprocs), trigger)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步gcEnabled、标记当前处于过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">    gcCPULimiter.startGCTransition(<span class="literal">true</span>, now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非默认模式，忽略</span></span><br><span class="line">    <span class="keyword">if</span> mode != gcBackgroundMode &#123;</span><br><span class="line">        <span class="comment">// 同步标记，如果允许user类型g运行则把阻塞的g全部放回全局队列并尝试获取p绑定m唤醒运行</span></span><br><span class="line">        schedEnableUser(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步gcphase，如果是_GCmark或_GCmarktermination，开启写屏障</span></span><br><span class="line">    setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nproc、nwait设为32位无符号数最大值（需要在协助线程启动前运行）</span></span><br><span class="line">    gcBgMarkPrepare()</span><br><span class="line">    <span class="comment">// 获取快照，计算各个根对象的块数量、基地址（索引）</span></span><br><span class="line">    gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tiny区域对象置灰放入队列</span></span><br><span class="line">    gcMarkTinyAllocs()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcBlackenEnabled意味着写屏障、协助线程已开启，可以开始标记</span></span><br><span class="line">    atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 到这里，第2阶段已经可以准备运行了 =&gt; gcBgMarkWorker可以开始标记了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    mp = acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU暂停时间GCPauseTime、GCTotalTime更新 =&gt; +=d*maxprocs</span></span><br><span class="line">    work.cpuStats.accumulateGCPauseTime(nanotime()-stw.finishedStopping, work.maxprocs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 一切都准备好了，可以并发标记了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发标记</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</span></span><br><span class="line">        now = startTheWorldWithSema(<span class="number">0</span>, stw)</span><br><span class="line">        <span class="comment">// 到这里，已经有p和m被唤醒绑定并去寻找g运行了，第2阶段确实在运行了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// STW耗时</span></span><br><span class="line">        work.pauseNS += now - stw.startedStopping</span><br><span class="line">        <span class="comment">// 第2阶段开始时刻</span></span><br><span class="line">        work.tMark = now</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解除过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">        gcCPULimiter.finishGCTransition(now)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复世界后释放，唤醒其他g，其他组件可以开始STW</span></span><br><span class="line">    <span class="comment">// 注意：需要在Gosched前先释放，后面会重新获取，否则造成死锁</span></span><br><span class="line">    semrelease(&amp;worldsema)</span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非默认模式，忽略</span></span><br><span class="line">    <span class="keyword">if</span> mode != gcBackgroundMode &#123;</span><br><span class="line">        <span class="comment">// 同协程yield关键字，当前G让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">        Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复世界后释放，唤醒其他g，可以运行其他GC了，虽然可能会被阻挡</span></span><br><span class="line">    semrelease(&amp;work.startSema)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个p启动一个标记工作线程gcBgMarkWorker，负责第2阶段，先挂起等待调度器调度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 数量足够</span></span><br><span class="line">    <span class="keyword">if</span> gcBgMarkWorkerCount &gt;= gomaxprocs &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 带缓存channel</span></span><br><span class="line">    ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 恢复</span></span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数量不足</span></span><br><span class="line">    <span class="keyword">for</span> gcBgMarkWorkerCount &lt; gomaxprocs &#123;</span><br><span class="line">        <span class="comment">// 禁止抢占</span></span><br><span class="line">        mp := acquirem()</span><br><span class="line">        <span class="comment">// 启动gcBgMarkWorker</span></span><br><span class="line">        <span class="keyword">go</span> gcBgMarkWorker(ready)</span><br><span class="line">        <span class="comment">// 恢复</span></span><br><span class="line">        releasem(mp)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待gcBgMarkWorker准备好</span></span><br><span class="line">        &lt;-ready</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器更新</span></span><br><span class="line">        gcBgMarkWorkerCount++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第2阶段：Mark（标记）"><a href="#第2阶段：Mark（标记）" class="headerlink" title="第2阶段：Mark（标记）"></a>第2阶段：Mark（标记）</h3><p>大概流程如下</p>
<ol>
<li>挂起等待调度器唤醒</li>
<li>根据模式设置标志位，运行标记任务<ol>
<li>初始化参数</li>
<li>扫描根对象</li>
<li>从队列获取灰色对象标记</li>
</ol>
</li>
<li>重置相关字段、纪录耗时，如果是最后一个标记工作线程，启动第3阶段：Mark Termination（标记终止）<ol>
<li>STW，确定已经没有标记任务</li>
<li>根据统计数据调整栈的初始大小</li>
<li>唤醒所有因为辅助标记、weak-&gt;strong转换挂起的g</li>
<li>运行user类型的g运行</li>
<li>计算目标heap大小和并发标记进度</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记工作线程，负责第2阶段：Mark（标记）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">(ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    gp.m.preemptoff = <span class="string">&quot;GC worker init&quot;</span></span><br><span class="line">    <span class="comment">// worker</span></span><br><span class="line">    node := <span class="built_in">new</span>(gcBgMarkWorkerNode)</span><br><span class="line">    <span class="comment">// 重置（可抢占）</span></span><br><span class="line">    gp.m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂存g</span></span><br><span class="line">    node.gp.set(gp)</span><br><span class="line">    <span class="comment">// 暂存m</span></span><br><span class="line">    node.m.set(acquirem())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知父g</span></span><br><span class="line">    ready &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后台mark线程由gcController.findRunnableGCWorker调度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 当前G让出CPU，g0执行调度运行其他g</span></span><br><span class="line">        gopark(<span class="function"><span class="keyword">func</span><span class="params">(g *g, nodep unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="comment">// 挂起前运行</span></span><br><span class="line">            <span class="comment">// 创建worker放到gcBgMarkWorkerPool</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 类型转换</span></span><br><span class="line">            node := (*gcBgMarkWorkerNode)(nodep)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// g与m已关联</span></span><br><span class="line">            <span class="keyword">if</span> mp := node.m.ptr(); mp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 释放</span></span><br><span class="line">                releasem(mp)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把g放到gcBgMarkWorkerPool队列头部</span></span><br><span class="line">            gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;, unsafe.Pointer(node), waitReasonGCWorkerIdle, traceBlockSystemGoroutine, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 被调度器唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止抢占</span></span><br><span class="line">        node.m.set(acquirem())</span><br><span class="line">        <span class="comment">// m.p不会被改变</span></span><br><span class="line">        pp := gp.m.p.ptr()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC未启动/停止，异常</span></span><br><span class="line">        <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;worker mode&quot;</span>, pp.gcMarkWorkerMode)</span><br><span class="line">            throw(<span class="string">&quot;gcBgMarkWorker: blackening not enabled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mode为默认值 =&gt; 未更新</span></span><br><span class="line">        <span class="keyword">if</span> pp.gcMarkWorkerMode == gcMarkWorkerNotWorker &#123;</span><br><span class="line">            throw(<span class="string">&quot;gcBgMarkWorker: mode not set&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC标记线程的执行开始时刻</span></span><br><span class="line">        startTime := nanotime()</span><br><span class="line">        pp.gcMarkWorkerStartTime = startTime</span><br><span class="line">        <span class="keyword">var</span> trackLimiterEvent <span class="type">bool</span></span><br><span class="line">        <span class="comment">// 空闲标记任务</span></span><br><span class="line">        <span class="keyword">if</span> pp.gcMarkWorkerMode == gcMarkWorkerIdleMode &#123;</span><br><span class="line">            <span class="comment">// stamp存储limiterEventIdleMarkWork和startTime</span></span><br><span class="line">            trackLimiterEvent = pp.limiterEvent.start(limiterEventIdleMarkWork, startTime)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列容量/计数器 nwait-=1</span></span><br><span class="line">        decnwait := atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// 异常，nproc&gt;=nwait</span></span><br><span class="line">        <span class="keyword">if</span> decnwait == work.nproc &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: work.nwait=&quot;</span>, decnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">            throw(<span class="string">&quot;work.nwait was &gt; work.nproc&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面扫描根对象、灰色对象队列并标记（标记g为可抢占，使得栈可被扫描）</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">            casGToWaitingForGC(gp, _Grunning, waitReasonGCWorkerActive)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// gcMarkWorkerMode在findRunnableGCWorker设置</span></span><br><span class="line">            <span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// 为0或其他，异常状态</span></span><br><span class="line">                throw(<span class="string">&quot;gcBgMarkWorker: unexpected gcMarkWorkerMode&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerDedicatedMode:     <span class="comment">// 专用标记任务，p被mark线程占用，不可被抢占</span></span><br><span class="line">                <span class="comment">// 设置gcDrainFlushBgCredit|gcDrainUntilPreempt标记，执行gcDrain（可被抢占）</span></span><br><span class="line">                gcDrainMarkWorkerDedicated(&amp;pp.gcw, <span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 被抢占中</span></span><br><span class="line">                <span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">                    <span class="comment">// 抽走p本地队列所有数据</span></span><br><span class="line">                    <span class="keyword">if</span> drainQ, n := runqdrain(pp); n &gt; <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 全局队列加锁</span></span><br><span class="line">                        lock(&amp;sched.lock)</span><br><span class="line">                        <span class="comment">// 把一批g放到全局队列</span></span><br><span class="line">                        globrunqputbatch(&amp;drainQ, <span class="type">int32</span>(n))</span><br><span class="line">                        <span class="comment">// 解锁</span></span><br><span class="line">                        unlock(&amp;sched.lock)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置gcDrainFlushBgCredit标记，执行gcDrain（不可被抢占）</span></span><br><span class="line">                gcDrainMarkWorkerDedicated(&amp;pp.gcw, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerFractionalMode:     <span class="comment">// 比例标记任务，可被抢占</span></span><br><span class="line">                <span class="comment">// 设置gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit标记，执行gcDrain</span></span><br><span class="line">                <span class="comment">// pollFractionalWorkerExit返回true时会自行抢占</span></span><br><span class="line">                gcDrainMarkWorkerFractional(&amp;pp.gcw)</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerIdleMode:             <span class="comment">// 空闲标记任务</span></span><br><span class="line">                <span class="comment">// 设置gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit标记，执行gcDrain</span></span><br><span class="line">                <span class="comment">// 如果p有其他g，转而执行其他g</span></span><br><span class="line">                gcDrainMarkWorkerIdle(&amp;pp.gcw)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 耗时</span></span><br><span class="line">        now := nanotime()</span><br><span class="line">        duration := now - startTime</span><br><span class="line">        <span class="comment">// 累计标记耗时、复原计数器</span></span><br><span class="line">        gcController.markWorkerStop(pp.gcMarkWorkerMode, duration)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> trackLimiterEvent &#123;</span><br><span class="line">            <span class="comment">// 重置stamp字段，纪录耗时</span></span><br><span class="line">            pp.limiterEvent.stop(limiterEventIdleMarkWork, now)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比例标记任务</span></span><br><span class="line">        <span class="keyword">if</span> pp.gcMarkWorkerMode == gcMarkWorkerFractionalMode &#123;</span><br><span class="line">            <span class="comment">// 累计比例标记任务任务下的标记耗时</span></span><br><span class="line">            atomic.Xaddint64(&amp;pp.gcFractionalMarkTime, duration)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器，同时也是用于判断是否是最后一个标记工作线程</span></span><br><span class="line">        incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> incnwait &gt; work.nproc &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: p.gcMarkWorkerMode=&quot;</span>, pp.gcMarkWorkerMode,</span><br><span class="line">                <span class="string">&quot;work.nwait=&quot;</span>, incnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">            throw(<span class="string">&quot;work.nwait &gt; work.nproc&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置为0</span></span><br><span class="line">        pp.gcMarkWorkerMode = gcMarkWorkerNotWorker</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列为空（最后一个标记工作线程） and 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）</span></span><br><span class="line">        <span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">            releasem(node.m.ptr())</span><br><span class="line">            <span class="comment">// 解除m绑定</span></span><br><span class="line">            node.m.set(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            gcMarkDone()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲标记任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrainMarkWorkerIdle</span><span class="params">(gcw *gcWork)</span></span> &#123;</span><br><span class="line">    gcDrain(gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 专用标记任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrainMarkWorkerDedicated</span><span class="params">(gcw *gcWork, untilPreempt <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    flags := gcDrainFlushBgCredit</span><br><span class="line">    <span class="keyword">if</span> untilPreempt &#123;</span><br><span class="line">        <span class="comment">// 可被抢占</span></span><br><span class="line">        flags |= gcDrainUntilPreempt</span><br><span class="line">    &#125;</span><br><span class="line">    gcDrain(gcw, flags)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比例标记任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrainMarkWorkerFractional</span><span class="params">(gcw *gcWork)</span></span> &#123;</span><br><span class="line">    gcDrain(gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描根对象、灰色对象队列并标记</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 写屏障未开启</span></span><br><span class="line">    <span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcDrain phase incorrect&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    gp := getg().m.curg</span><br><span class="line">    <span class="comment">// p （前提是非抢占）</span></span><br><span class="line">    pp := gp.m.p.ptr()</span><br><span class="line">    <span class="comment">// 一般都有设置gcDrainUntilPreempt</span></span><br><span class="line">    preemptible := flags&amp;gcDrainUntilPreempt != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 默认开启</span></span><br><span class="line">    flushBgCredit := flags&amp;gcDrainFlushBgCredit != <span class="number">0</span></span><br><span class="line">    <span class="comment">// p空闲</span></span><br><span class="line">    idle := flags&amp;gcDrainIdle != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快照</span></span><br><span class="line">    initScanWork := gcw.heapScanWork</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始为2^64-1，后面根据任务类型调整，空闲标记任务和比例标记任务只有100000额度</span></span><br><span class="line">    checkWork := <span class="type">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有空闲标记任务和比例标记任务才有</span></span><br><span class="line">    <span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空闲标记任务 or 比例标记任务</span></span><br><span class="line">    <span class="keyword">if</span> flags&amp;(gcDrainIdle|gcDrainFractional) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// heapScanWork快照+100000</span></span><br><span class="line">        checkWork = initScanWork + drainCheckThreshold</span><br><span class="line">        <span class="keyword">if</span> idle &#123;</span><br><span class="line">            <span class="comment">// 空闲标记任务</span></span><br><span class="line">            <span class="comment">// 队列为空时执行netpoll轮询，检查有g返回true</span></span><br><span class="line">            check = pollWork</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> flags&amp;gcDrainFractional != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 比例标记任务</span></span><br><span class="line">            <span class="comment">// 判断标记工作线程是否需要自我抢占，超过目标值返回true</span></span><br><span class="line">            check = pollFractionalWorkerExit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描根对象</span></span><br><span class="line">    <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="comment">// 如果可抢占、有g想要STW、有g在运行forEachP，停止</span></span><br><span class="line">        <span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || sched.gcwaiting.Load() || pp.runSafePointFn != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// job=markrootNext; markrootNext+=1</span></span><br><span class="line">            job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">            <span class="comment">// 索引/计数器超限，没任务了</span></span><br><span class="line">            <span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line">                <span class="comment">// 退出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据索引扫描指定的根对象，扫描的字节数除了返回还会累计到gcController</span></span><br><span class="line">            markroot(gcw, job, flushBgCredit)</span><br><span class="line">            <span class="comment">// 空闲标记任务和比例标记任务需要运行check函数</span></span><br><span class="line">            <span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">                <span class="comment">// 需要让出CPU，退出标记任务</span></span><br><span class="line">                <span class="keyword">goto</span> done</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描灰色对象队列</span></span><br><span class="line">    <span class="comment">// 如果可抢占、有g想要STW、有g在运行forEachP，停止</span></span><br><span class="line">    <span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || sched.gcwaiting.Load() || pp.runSafePointFn != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// work.full为空 =&gt; 确保work.full不为空</span></span><br><span class="line">        <span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// wbuf2不为空则全部放入work.full，否则将wbuf1的一半放到work.full</span></span><br><span class="line">            gcw.balance()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先从工作队列拿数据，没有就从写屏障拿</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从wbuf获取一个obj，未初始化或为空直接返回</span></span><br><span class="line">        b := gcw.tryGetFast()</span><br><span class="line">        <span class="comment">// 没有拿到</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 从wbuf获取一个obj</span></span><br><span class="line">            b = gcw.tryGet()</span><br><span class="line">            <span class="comment">// 还是没有</span></span><br><span class="line">            <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">                wbBufFlush()</span><br><span class="line">                <span class="comment">// 从wbuf获取一个obj</span></span><br><span class="line">                b = gcw.tryGet()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3次均失败</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从本地任务缓冲区获取到对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描一个对象（最多128KB，剩余放到任务缓冲区）内所有指针，设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">        scanobject(b, gcw)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;= 2000 =&gt; heapScanWork每达到2000则刷新到全局计数器里</span></span><br><span class="line">        <span class="keyword">if</span> gcw.heapScanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">            <span class="comment">// 累计到全局heapScanWork</span></span><br><span class="line">            gcController.heapScanWork.Add(gcw.heapScanWork)</span><br><span class="line">            <span class="comment">// 默认开启</span></span><br><span class="line">            <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">                <span class="comment">// 根据额度唤醒一批g，额度有剩余就累计到全局额度bgScanCredit（与gcParkAssist成对使用）</span></span><br><span class="line">                gcFlushBgCredit(gcw.heapScanWork - initScanWork)</span><br><span class="line">                <span class="comment">// 快照清0，跟heapScanWork同步</span></span><br><span class="line">                initScanWork = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 额度扣除</span></span><br><span class="line">            checkWork -= gcw.heapScanWork</span><br><span class="line">            <span class="comment">//重置</span></span><br><span class="line">            gcw.heapScanWork = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 额度不足</span></span><br><span class="line">            <span class="keyword">if</span> checkWork &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 说明是空闲标记任务和比例标记任务</span></span><br><span class="line">                <span class="comment">// 额度再加100000</span></span><br><span class="line">                checkWork += drainCheckThreshold</span><br><span class="line">                <span class="comment">// 空闲标记任务和比例标记任务需要运行check函数</span></span><br><span class="line">                <span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">                    <span class="comment">// 需要让出CPU，退出标记任务</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// 收尾，循环后，本地heapScanWork有剩余，刷新到全局计数器里（看循环内部代码即可）</span></span><br><span class="line">    <span class="keyword">if</span> gcw.heapScanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 累计到全局heapScanWork</span></span><br><span class="line">        gcController.heapScanWork.Add(gcw.heapScanWork)</span><br><span class="line">        <span class="comment">// 默认开启</span></span><br><span class="line">        <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">            <span class="comment">// 根据额度唤醒一批g，额度有剩余就累计到全局额度bgScanCredit（与gcParkAssist成对使用）</span></span><br><span class="line">            gcFlushBgCredit(gcw.heapScanWork - initScanWork)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        gcw.heapScanWork = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责启动第3阶段：Mark Termination（标记终止）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取work.markDoneSema，失败则挂起等待（确保只有一个线程在执行）</span></span><br><span class="line">    semacquire(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="comment">// !(标记阶段 and 队列为空 and 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）)</span></span><br><span class="line">    <span class="keyword">if</span> !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>)) &#123;</span><br><span class="line">        <span class="comment">// 还在有对象需要标记</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放信号量，唤醒其他g</span></span><br><span class="line">        semrelease(&amp;work.markDoneSema)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取worldsema，失败则挂起等待（STW）</span></span><br><span class="line">    semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止weak-&gt;strong转换</span></span><br><span class="line">    work.strongFromWeak.block = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空所有本地缓存并收集标记</span></span><br><span class="line">    gcMarkDoneFlushed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让p的g进入等待，强制让p进入空闲状态，执行safePoint函数</span></span><br><span class="line">    forEachP(waitReasonGCMarkTermination, <span class="function"><span class="keyword">func</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">        wbBufFlush1(pp)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf1、wbuf2根据容量选择放入work.empty或work.full队列</span></span><br><span class="line">        pp.gcw.dispose()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">        <span class="keyword">if</span> pp.gcw.flushedWork &#123;</span><br><span class="line">            <span class="comment">// 累计</span></span><br><span class="line">            atomic.Xadd(&amp;gcMarkDoneFlushed, <span class="number">1</span>)</span><br><span class="line">            pp.gcw.flushedWork = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有更多灰色对象被发现，不能进入第3阶段</span></span><br><span class="line">    <span class="keyword">if</span> gcMarkDoneFlushed != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复世界后释放，唤醒其他g，其他组件可以开始STW</span></span><br><span class="line">        semrelease(&amp;worldsema)</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug，忽略</span></span><br><span class="line">    <span class="keyword">for</span> gcDebugMarkDone.spinAfterRaggedBarrier.Load() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经没有任何标记任务了，可以开启第3阶段</span></span><br><span class="line"></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 第3阶段开始时刻</span></span><br><span class="line">    work.tMarkTerm = now</span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    getg().m.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stw worldStop</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 将所有p都停止，返回原因、时间信息</span></span><br><span class="line">        stw = stopTheWorldWithSema(stwGCMarkTerm)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU暂停时间GCPauseTime、GCTotalTime更新 =&gt; +=d*maxprocs</span></span><br><span class="line">    work.cpuStats.accumulateGCPauseTime(stw.stoppingCPUTime, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为写屏障的缘故，可能还有一些任务残留</span></span><br><span class="line">    restart := <span class="literal">false</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">            wbBufFlush1(p)</span><br><span class="line">            <span class="comment">// wbuf队列不为空，不能进入第3阶段</span></span><br><span class="line">            <span class="keyword">if</span> !p.gcw.empty() &#123;</span><br><span class="line">                restart = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 回到开头重试</span></span><br><span class="line">    <span class="keyword">if</span> restart &#123;</span><br><span class="line">        gcDebugMarkDone.restartedDueTo27993 = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置（可抢占）</span></span><br><span class="line">        getg().m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// CPU暂停时间GCPauseTime、GCTotalTime更新 =&gt; +=d*maxprocs</span></span><br><span class="line">            work.cpuStats.accumulateGCPauseTime(nanotime()-stw.finishedStopping, work.maxprocs)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</span></span><br><span class="line">            now := startTheWorldWithSema(<span class="number">0</span>, stw)</span><br><span class="line">            <span class="comment">// STW耗时</span></span><br><span class="line">            work.pauseNS += now - stw.startedStopping</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 恢复世界后释放，唤醒其他g，其他组件可以开始STW</span></span><br><span class="line">        semrelease(&amp;worldsema)</span><br><span class="line">        <span class="comment">// 重试</span></span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里确定可以进入第3阶段了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据统计数据调整栈的初始大小</span></span><br><span class="line">    gcComputeStartingStackSize()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC未启动/停止 =&gt; 协助线程、标记工作线程已停止，禁止标记</span></span><br><span class="line">    atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步gcEnabled、标记当前处于过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">    gcCPULimiter.startGCTransition(<span class="literal">false</span>, now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有被阻塞的g（辅助标记）</span></span><br><span class="line">    gcWakeAllAssists()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许所有weak-&gt;strong转换</span></span><br><span class="line">    work.strongFromWeak.block = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 将strongFromWeak.q所有的g放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">    gcWakeAllStrongFromWeak()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放信号量，唤醒其他g，使其他g可以调用gcMarkDone</span></span><br><span class="line">    semrelease(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步标记，如果允许user类型g运行则把阻塞的g全部放回全局队列并尝试获取p绑定m唤醒运行</span></span><br><span class="line">    schedEnableUser(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从gcStart启动循环，到这里终止循环</span></span><br><span class="line">    <span class="comment">// 计算目标heap大小和并发标记进度</span></span><br><span class="line">    gcController.endCycle(now, <span class="type">int</span>(gomaxprocs), work.userForced)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入第3阶段：Mark Termination（标记终止）（该函数会恢复世界-Start The World）</span></span><br><span class="line">    gcMarkTermination(stw)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第3阶段：Mark-Termination（标记终止）"><a href="#第3阶段：Mark-Termination（标记终止）" class="headerlink" title="第3阶段：Mark Termination（标记终止）"></a>第3阶段：Mark Termination（标记终止）</h3><p>大概流程如下</p>
<ol>
<li>设置各种状态<ul>
<li>gcphase切换到_GCmarktermination，继续开启写屏障</li>
<li>m禁止抢占，g切换到_Gwaiting，可抢占</li>
<li>清空allgs快照、gcw&#x2F;mcache等残留处理</li>
</ul>
</li>
<li>gcphase切换到_GCoff，关闭写屏障，开启第4阶段：Sweep（清理）</li>
<li>统计信息并计算pacing参数，重置scavenger状态<ul>
<li>同步heap内存使用量</li>
<li>更新memstats、cpuStats耗时信息</li>
<li>设置GC启动阈值、计算目标heap大小和跑道大小</li>
<li>计算辅助GC的工作量转换参数</li>
<li>计算GC触发阈值和目标heap大小</li>
<li>更新sweeper、scavenger的pacing参数</li>
<li>重置scavenge状态、更新scavengeIndex状态</li>
</ul>
</li>
<li>收尾&#x2F;清理<ul>
<li>g切换到_Grunning，m允许抢占</li>
<li>将sweepWaiters放进本地&#x2F;全局队列，并尝试唤醒m处理</li>
<li>epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</li>
<li>清空empty链表，将busy链表数据搬到free链表</li>
<li>stackpool内所有allocCount为0的mspan以及stackLarge所有mspan全部释放</li>
<li>mcache清理<ul>
<li>alloc列表mspan放到partial或full链表、tiny区域清空</li>
<li>清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</li>
</ul>
</li>
<li>pageCache清空</li>
<li>如果目标heap大小超过1GB，尝试开启大页支持</li>
</ul>
</li>
</ol>
<p>到这里，世界开始恢复</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTermination</span><span class="params">(stw worldStop)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 同步gcphase，如果是_GCmark或_GCmarktermination，开启写屏障</span></span><br><span class="line">    setGCPhase(_GCmarktermination)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步heapLive快照</span></span><br><span class="line">    work.heap1 = gcController.heapLive.Load()</span><br><span class="line">    <span class="comment">// 单调时钟</span></span><br><span class="line">    startTime := nanotime()</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    mp.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">    mp.traceback = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    curgp := mp.curg</span><br><span class="line">    <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">    casGToWaitingForGC(curgp, _Grunning, waitReasonGarbageCollection)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到g0执行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 清空allgs快照、gcw/mcache等残留处理</span></span><br><span class="line">        gcMark(startTime)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stwSwept <span class="type">bool</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 同步bytesMarked-已标记字节数</span></span><br><span class="line">        work.heap2 = work.bytesMarked</span><br><span class="line">        <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &#123;</span><br><span class="line">            startCheckmarks()</span><br><span class="line">            gcResetMarkState()</span><br><span class="line">            gcw := &amp;getg().m.p.ptr().gcw</span><br><span class="line">            gcDrain(gcw, <span class="number">0</span>)</span><br><span class="line">            wbBufFlush1(getg().m.p.ptr())</span><br><span class="line">            gcw.dispose()</span><br><span class="line">            endCheckmarks()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步gcphase，如果是_GCmark或_GCmarktermination，开启写屏障</span></span><br><span class="line">        setGCPhase(_GCoff)</span><br><span class="line">        <span class="comment">// 启动第4阶段</span></span><br><span class="line">        stwSwept = gcSweep(work.mode)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    mp.traceback = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">    casgstatus(curgp, _Gwaiting, _Grunning)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置（可抢占）</span></span><br><span class="line">    mp.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">        throw(<span class="string">&quot;gc done but gcphase != _GCoff&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步heap内存使用量，用于scavenge</span></span><br><span class="line">    memstats.lastHeapInUse = gcController.heapInUse.load()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行gcControllerCommit</span></span><br><span class="line">    <span class="comment">// 设置GC启动阈值、计算目标heap大小和跑道大小，计算辅助GC的工作量转换参数，计算GC触发阈值和目标heap大小，更新sweeper、scavenger的pacing参数</span></span><br><span class="line">    systemstack(gcControllerCommit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新memstats</span></span><br><span class="line">    now := nanotime()                         <span class="comment">// 当前时刻（单调时钟）</span></span><br><span class="line">    sec, nsec, _ := time_now()                <span class="comment">// 获取墙上时钟</span></span><br><span class="line">    unixNow := sec*<span class="number">1e9</span> + <span class="type">int64</span>(nsec)          <span class="comment">// unix时间戳</span></span><br><span class="line">    work.pauseNS += now - stw.startedStopping <span class="comment">// STW耗时</span></span><br><span class="line">    work.tEnd = now                           <span class="comment">// 第4阶段开始时刻</span></span><br><span class="line">    atomic.Store64(&amp;memstats.last_gc_unix, <span class="type">uint64</span>(unixNow)) <span class="comment">// unix时间戳比较好理解</span></span><br><span class="line">    atomic.Store64(&amp;memstats.last_gc_nanotime, <span class="type">uint64</span>(now)) <span class="comment">// 单调时钟</span></span><br><span class="line">    memstats.pause_ns[memstats.numgc%<span class="type">uint32</span>(<span class="built_in">len</span>(memstats.pause_ns))] = <span class="type">uint64</span>(work.pauseNS)</span><br><span class="line">    memstats.pause_end[memstats.numgc%<span class="type">uint32</span>(<span class="built_in">len</span>(memstats.pause_end))] = <span class="type">uint64</span>(unixNow)</span><br><span class="line">    memstats.pause_total_ns += <span class="type">uint64</span>(work.pauseNS)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU暂停时间GCPauseTime、GCTotalTime更新 =&gt; +=d*maxprocs</span></span><br><span class="line">    work.cpuStats.accumulateGCPauseTime(now-stw.finishedStopping, work.maxprocs)</span><br><span class="line">    <span class="comment">// GC、scavenge的累计耗时更新</span></span><br><span class="line">    work.cpuStats.accumulate(now, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =(GCTotalTime-GCIdleTime)/TotalTime</span></span><br><span class="line">    memstats.gc_cpu_fraction = <span class="type">float64</span>(work.cpuStats.GCTotalTime-work.cpuStats.GCIdleTime) / <span class="type">float64</span>(work.cpuStats.TotalTime)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC助攻累计时间</span></span><br><span class="line">    scavenge.assistTime.Store(<span class="number">0</span>)</span><br><span class="line">    scavenge.backgroundTime.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲耗时</span></span><br><span class="line">    sched.idleTime.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动启动</span></span><br><span class="line">    <span class="keyword">if</span> work.userForced &#123;</span><br><span class="line">        <span class="comment">// 计数器更新</span></span><br><span class="line">        memstats.numforcedgc++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前g挂起等待第n个GC周期结束</span></span><br><span class="line">    lock(&amp;work.sweepWaiters.lock)</span><br><span class="line">    <span class="comment">// gc计数器</span></span><br><span class="line">    memstats.numgc++</span><br><span class="line">    <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">    injectglist(&amp;work.sweepWaiters.list)</span><br><span class="line">    unlock(&amp;work.sweepWaiters.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新内存回收器（scavengeIndex）版本计数器、searchAddr、freeHWM</span></span><br><span class="line">    mheap_.pages.scav.index.nextGen()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">    gcCPULimiter.finishGCTransition(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mProfCycle计数器更新</span></span><br><span class="line">    mProf_NextCycle()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器加1，返回mheap_.sweepgen及sweepDrainedMask标记是否已设置</span></span><br><span class="line">    sl := sweep.active.begin()</span><br><span class="line">    <span class="comment">// sweepDrainedMask标记已设置（表示sweeper队列为空）</span></span><br><span class="line">    <span class="keyword">if</span> !stwSwept &amp;&amp; !sl.valid &#123;</span><br><span class="line">        throw(<span class="string">&quot;failed to set sweep barrier&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> stwSwept &amp;&amp; sl.valid &#123;</span><br><span class="line">        throw(<span class="string">&quot;non-concurrent sweep failed to drain all sweep queues&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</span></span><br><span class="line">        startTheWorldWithSema(now, stw)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mProfCycle最低位设置为1</span></span><br><span class="line">    mProf_Flush()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空empty链表，将busy链表数据搬到free链表</span></span><br><span class="line">    prepareFreeWorkbufs()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用freeStackSpans</span></span><br><span class="line">    <span class="comment">// stackpool内所有allocCount为0的mspan以及stackLarge所有mspan全部释放</span></span><br><span class="line">    systemstack(freeStackSpans)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让p的g进入等待，强制让p进入空闲状态，执行safePoint函数</span></span><br><span class="line">    forEachP(waitReasonFlushProcCaches, <span class="function"><span class="keyword">func</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">        <span class="comment">// mcache清理</span></span><br><span class="line">        <span class="comment">// alloc列表mspan放到partial或full链表、tiny区域清空</span></span><br><span class="line">        <span class="comment">// 清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</span></span><br><span class="line">        pp.mcache.prepareForSweep()</span><br><span class="line">        <span class="keyword">if</span> pp.status == _Pidle &#123;</span><br><span class="line">            <span class="comment">// 空闲状态</span></span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                lock(&amp;mheap_.lock)</span><br><span class="line">                <span class="comment">// 清空pageCache</span></span><br><span class="line">                pp.pcache.flush(&amp;mheap_.pages)</span><br><span class="line">                unlock(&amp;mheap_.lock)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        pp.pinnerCache = <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果更新sl.state计数器成功</span></span><br><span class="line">    <span class="keyword">if</span> sl.valid &#123;</span><br><span class="line">        <span class="comment">// 计数器减1</span></span><br><span class="line">        sweep.active.end(sl)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arena包相关，手动管理内存，不讲</span></span><br><span class="line">    lock(&amp;userArenaState.lock)</span><br><span class="line">    faultList := userArenaState.fault</span><br><span class="line">    userArenaState.fault = <span class="literal">nil</span></span><br><span class="line">    unlock(&amp;userArenaState.lock)</span><br><span class="line">    <span class="keyword">for</span> _, lc := <span class="keyword">range</span> faultList &#123;</span><br><span class="line">        <span class="comment">// 使用sysFault将mspan的内存区域标记为不可访问，更新统计信息，最后放到quarantineList列表</span></span><br><span class="line">        lc.mspan.setUserArenaChunkToFault()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果目标heap大小超过1GB</span></span><br><span class="line">    <span class="keyword">if</span> gcController.heapGoal() &gt; minHeapForMetadataHugePages &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 相关内存如heapArena、chunk元素重新按huge_page的大小对齐（linux才有，不一定成功）</span></span><br><span class="line">            mheap_.enableMetadataHugePages()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复世界后释放，唤醒其他g，其他组件可以开始STW</span></span><br><span class="line">    semrelease(&amp;worldsema)</span><br><span class="line">    semrelease(&amp;gcsema)</span><br><span class="line">    <span class="comment">// 到这里，另一个GC循环可能会开始启动</span></span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">    mp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// concurrentSweep默认为true，故这里的判断失败，不执行</span></span><br><span class="line">    <span class="keyword">if</span> !concurrentSweep &#123;</span><br><span class="line">        <span class="comment">// 运行finalizers</span></span><br><span class="line">        <span class="comment">// 同协程yield关键字，当前G让出CPU，g0执行调度运行其他g，非抢占</span></span><br><span class="line">        Gosched()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第4阶段：Sweep（清理）"><a href="#第4阶段：Sweep（清理）" class="headerlink" title="第4阶段：Sweep（清理）"></a>第4阶段：Sweep（清理）</h3><p>大概流程如下</p>
<ol>
<li>重置mheap、sweep相关状态</li>
<li>非并发清理模式或手动强制GC<ul>
<li>mcache清理<ul>
<li>alloc列表mspan放到partial或full链表、tiny区域清空</li>
<li>清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</li>
</ul>
</li>
<li>不断的逐个清理mspan</li>
<li>清空empty链表，将busy链表数据搬到free链表</li>
<li>wbuf的free链表清理64个mspan、mspan内存释放回mheap</li>
</ul>
</li>
<li>并发清理模式（默认）<ul>
<li>唤醒后台清扫器-sweeper清扫<ul>
<li>不断的逐个清理mspan，每10个执行一次goschedIfBusy，当可抢占时让出CPU</li>
<li>wbuf的free链表清理64个mspan、mspan内存释放回mheap，当可抢占时让出CPU</li>
<li>还有sweeper在运行时，继续清理mspan，否则挂起休眠</li>
<li>清理mspan时，如果判断已经没有更多的mspan需要清理则设置完结标记，最后一个sweeper通知sysmon唤醒scavenger</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>当scavenger被唤醒后，大概逻辑如下</p>
<ol>
<li>scavenger开始回收，运行时间限制1ms<ol>
<li>如果heap内存没有超过GC触发临界点且总内存没有超过限制，退出</li>
<li>执行mheap_.pages.scavenge，回收64KB字节数量的内存，统计累计耗时</li>
<li>如果回收字节数不足64KB，说明没有更多内存需要回收，退出</li>
<li>如果累计耗时超过1ms，退出</li>
</ol>
</li>
<li>如果释放的字节数为0，挂起休眠，唤醒后重试</li>
<li>累计释放字节数，让出CPU挂起一段时间，更新sleepRatio等信息</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动清扫</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcSweep</span><span class="params">(mode gcMode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非_GCoff阶段</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcSweep being done but phase is not GCoff&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新、重置相关字段</span></span><br><span class="line">    mheap_.sweepgen += <span class="number">2</span> <span class="comment">// 每次清扫完毕都+2</span></span><br><span class="line">    sweep.active.reset() <span class="comment">// sweep.active.state设为0</span></span><br><span class="line">    mheap_.pagesSwept.Store(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// sweepArenas为allArenas快照（凡是heap管理的arena都会放在这里，用户手动管理则不会）</span></span><br><span class="line">    mheap_.sweepArenas = mheap_.allArenas</span><br><span class="line">    mheap_.reclaimIndex.Store(<span class="number">0</span>)</span><br><span class="line">    mheap_.reclaimCredit.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    unlock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置为0</span></span><br><span class="line">    sweep.centralIndex.clear()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非并发GC并发清扫模式（默认） or 手动强制执行</span></span><br><span class="line">    <span class="keyword">if</span> !concurrentSweep || mode == gcForceBlockMode &#123;</span><br><span class="line">        lock(&amp;mheap_.lock)</span><br><span class="line">        <span class="comment">// 每分配1字节需要清扫的页数</span></span><br><span class="line">        mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">        unlock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有p</span></span><br><span class="line">        <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            <span class="comment">// mcache清理</span></span><br><span class="line">            <span class="comment">// alloc列表mspan放到partial或full链表、tiny区域清空</span></span><br><span class="line">            <span class="comment">// 清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</span></span><br><span class="line">            pp.mcache.prepareForSweep()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不断的逐个清理mspan</span></span><br><span class="line">        <span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空empty链表，将busy链表数据搬到free链表</span></span><br><span class="line">        prepareFreeWorkbufs()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf的free链表清理64个mspan、mspan内存释放回mheap</span></span><br><span class="line">        <span class="keyword">for</span> freeSomeWbufs(<span class="literal">false</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mProfCycle计数器更新</span></span><br><span class="line">        mProf_NextCycle()</span><br><span class="line">        <span class="comment">// mProfCycle最低位设置为1</span></span><br><span class="line">        mProf_Flush()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非默认模式手动强制执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒sweeper</span></span><br><span class="line">    lock(&amp;sweep.lock)</span><br><span class="line">    <span class="keyword">if</span> sweep.parked &#123;</span><br><span class="line">        sweep.parked = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 将g放到p.runq队列头部，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">        ready(sweep.g, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sweep.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台sweeper，被唤醒时，不停清理wbuf的mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bgsweep</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 纪录当前g</span></span><br><span class="line">    sweep.g = getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    lockInit(&amp;sweep.lock, lockRankSweep)</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;sweep.lock)</span><br><span class="line">    <span class="comment">// 挂起</span></span><br><span class="line">    sweep.parked = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 发送信号给gcenable</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    <span class="comment">// 当前g让出CPU，g0执行调度运行其他g（其内部lock会被解锁）</span></span><br><span class="line">    goparkunlock(&amp;sweep.lock, waitReasonGCSweepWait, traceBlockGCSweep, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 低优先级，尽量空闲时运行</span></span><br><span class="line">        <span class="keyword">const</span> sweepBatchSize = <span class="number">10</span></span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        nSwept := <span class="number">0</span></span><br><span class="line">        <span class="comment">// 不断的逐个清理mspan</span></span><br><span class="line">        <span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            nSwept++</span><br><span class="line">            <span class="comment">// 每10个执行一次goschedIfBusy</span></span><br><span class="line">            <span class="keyword">if</span> nSwept%sweepBatchSize == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 可抢占时让出CPU</span></span><br><span class="line">                goschedIfBusy()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wbuf的free链表清理64个mspan、mspan内存释放回mheap</span></span><br><span class="line">        <span class="keyword">for</span> freeSomeWbufs(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时free链表还有数据</span></span><br><span class="line">            <span class="comment">// 可抢占时让出CPU</span></span><br><span class="line">            goschedIfBusy()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock(&amp;sweep.lock)</span><br><span class="line">        <span class="comment">// sweeper数量不为0</span></span><br><span class="line">        <span class="keyword">if</span> !isSweepDone() &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;sweep.lock)</span><br><span class="line">            <span class="comment">// 继续清理mspan</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清理完毕，设置为挂起状态</span></span><br><span class="line">        sweep.parked = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前g让出CPU，g0执行调度运行其他g（其内部lock会被解锁）</span></span><br><span class="line">        goparkunlock(&amp;sweep.lock, waitReasonGCSweepWait, traceBlockGCSweep, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理一个mspan，返回释放页数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweepone</span><span class="params">()</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放置抢占</span></span><br><span class="line">    gp.m.locks++</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计数器加1，返回mheap_.sweepgen及sweepDrainedMask标记是否已设置</span></span><br><span class="line">    sl := sweep.active.begin()</span><br><span class="line">    <span class="comment">// sweeper数量为0</span></span><br><span class="line">    <span class="keyword">if</span> !sl.valid &#123;</span><br><span class="line">        <span class="comment">// sweepDrainedMask标记已设置（表示sweeper队列为空）</span></span><br><span class="line">        gp.m.locks--</span><br><span class="line">        <span class="keyword">return</span> ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =2^64-1</span></span><br><span class="line">    npages := ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> noMoreWork <span class="type">bool</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 根据centralIndex在mcentral寻找未清理的mspan</span></span><br><span class="line">        s := mheap_.nextSpanForSweep()</span><br><span class="line">        <span class="comment">// mspan为nil</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 设置sweepDrainedMask标记，表示sweep已完成</span></span><br><span class="line">            noMoreWork = sweep.active.markDrained()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清理只针对heap管理类型，手动不管</span></span><br><span class="line">        <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> !(s.sweepgen == sl.sweepGen || s.sweepgen == sl.sweepGen+<span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;runtime: bad span s.state=&quot;</span>, state, <span class="string">&quot; s.sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; sweepgen=&quot;</span>, sl.sweepGen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                throw(<span class="string">&quot;non in-use span in unswept list&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试获得mspan的所有权</span></span><br><span class="line">        <span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            npages = s.npages</span><br><span class="line">            <span class="comment">// 清理一个mspan，释放回heap返回true</span></span><br><span class="line">            <span class="keyword">if</span> s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="comment">// 整个mspan都被清理释放</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                mheap_.reclaimCredit.Add(npages)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mspan还在使用中</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                npages = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器减1</span></span><br><span class="line">    sweep.active.end(sl)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sweep已完成</span></span><br><span class="line">    <span class="keyword">if</span> noMoreWork &#123;</span><br><span class="line">        <span class="comment">// 最后一个sweeper负责唤醒scavenger（此时可能还有sweeper在并发运行）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// debug，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.scavtrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                lock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">                releasedBg := mheap_.pages.scav.releasedBg.Load()</span><br><span class="line">                releasedEager := mheap_.pages.scav.releasedEager.Load()</span><br><span class="line"></span><br><span class="line">                printScavTrace(releasedBg, releasedEager, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">                mheap_.pages.scav.releasedBg.Add(-releasedBg)</span><br><span class="line">                mheap_.pages.scav.releasedEager.Add(-releasedEager)</span><br><span class="line">                unlock(&amp;mheap_.lock)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知sysmon唤醒scavenger</span></span><br><span class="line">        scavenger.ready()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp.m.locks--</span><br><span class="line">    <span class="keyword">return</span> npages</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有g标记为栈未扫描、助攻积分清0，所有heapArena清除pageMarks，重置bytesMarked、同步heapLive</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcResetMarkState</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// allg中每个g都执行一遍该函数，期间allglock会被锁住</span></span><br><span class="line">    forEachG(<span class="function"><span class="keyword">func</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 标记栈未扫描</span></span><br><span class="line">        gp.gcscandone = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// Assist额度/助攻积分清0</span></span><br><span class="line">        gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    lock(&amp;mheap_.lock)</span><br><span class="line">    <span class="comment">// allArenas快照 =&gt; []arenaIdx</span></span><br><span class="line">    arenas := mheap_.allArenas</span><br><span class="line">    unlock(&amp;mheap_.lock)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历allArenas快照</span></span><br><span class="line">    <span class="keyword">for</span> _, ai := <span class="keyword">range</span> arenas &#123;</span><br><span class="line">        <span class="comment">// 找到heapArena</span></span><br><span class="line">        ha := mheap_.arenas[ai.l1()][ai.l2()]</span><br><span class="line">        <span class="comment">// 清除pageMarks，共1024*8=8192个位</span></span><br><span class="line">        clear(ha.pageMarks[:])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已标记字节数为0</span></span><br><span class="line">    work.bytesMarked = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 同步heapLive-heap存活字节数快照</span></span><br><span class="line">    work.initialHeapLive = gcController.heapLive.Load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理所有mspan、重置mcentral、唤醒scavenger、gcBitsArenas迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finishsweep_m</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的逐个清理mspan</span></span><br><span class="line">    <span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有mspan可以清理了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从state获取sweeper数量，如果不为0，异常</span></span><br><span class="line">    <span class="keyword">if</span> sweep.active.sweepers() != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;active sweepers found at start of mark phase&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置所有未清理的mspan</span></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// 遍历所有mcentral</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> mheap_.central &#123;</span><br><span class="line">        c := &amp;mheap_.central[i].mcentral</span><br><span class="line">        <span class="comment">// 重置空的spanSet，清理残留的block</span></span><br><span class="line">        c.partialUnswept(sg).reset()</span><br><span class="line">        <span class="comment">// 重置空的spanSet，清理残留的block</span></span><br><span class="line">        c.fullUnswept(sg).reset()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置scavenger状态，修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">    scavenger.wake()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcBitsArenas迭代，如用next替换current等</span></span><br><span class="line">    nextMarkBitArenaEpoch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可抢占时让出CPU</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedIfBusy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 不可抢占 and 空闲p数量不为0</span></span><br><span class="line">    <span class="keyword">if</span> !gp.preempt &amp;&amp; sched.npidle.Load() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前g切换到g0，运行gosched_m函数</span></span><br><span class="line">    <span class="comment">// 当前g、m解除绑定，g交给其他空闲m执行，当前m重新寻找并运行可运行的g</span></span><br><span class="line">    mcall(gosched_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不断执行mheap_.pages.scavenge</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bgscavenge</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// scavenger初始化，绑定g</span></span><br><span class="line">    scavenger.init()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信号给gcenable</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// scavenger让出CPU挂起休眠</span></span><br><span class="line">    scavenger.park()</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// func (s *scavengerState) run() (released uintptr, worked float64)</span></span><br><span class="line">        <span class="comment">// 执行mheap_.pages.scavenge，直到heap耗尽</span></span><br><span class="line">        released, workTime := scavenger.run()</span><br><span class="line">        <span class="comment">// 释放字节数</span></span><br><span class="line">        <span class="keyword">if</span> released == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// scavenger让出CPU挂起休眠</span></span><br><span class="line">            scavenger.park()</span><br><span class="line">            <span class="comment">// 被唤醒</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 累计释放字节数</span></span><br><span class="line">        mheap_.pages.scav.releasedBg.Add(released)</span><br><span class="line">        <span class="comment">// 让出CPU挂起一段时间，更新sleepRatio等信息</span></span><br><span class="line">        scavenger.sleep(workTime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h2><p><strong>不知道怎么说，从源代码看，跟设计思路对不上</strong></p>
<p>设计思路伪代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//     writePointer(slot, ptr):</span></span><br><span class="line"><span class="comment">//         shade(*slot)              // 删除写屏障</span></span><br><span class="line"><span class="comment">//         if current stack is grey:</span></span><br><span class="line"><span class="comment">//             shade(ptr)            // 插入写屏障</span></span><br><span class="line"><span class="comment">//         *slot = ptr</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// *slot - 旧指针</span></span><br><span class="line"><span class="comment">// ptr   - 新指针</span></span><br></pre></td></tr></table></figure>

<p>实际：</p>
<p>在开启写屏障后，一些内存复制函数会将源内存区域跟目标内存区域内的指针对象收集起来，放入写屏障缓冲区，交给标记工作线程标记。涉及到slice、map、channel等组件，相关内存处理函数如下所示：</p>
<ul>
<li>typedmemmove</li>
<li>typedslicecopy</li>
<li>typedmemclr</li>
<li>memclrHasPointers</li>
<li>makeslicecopy</li>
<li>growslice</li>
<li>reflect.typedmemclr</li>
<li>reflect.typedmemclrpartial</li>
<li>reflect.typedarrayclear</li>
</ul>
<p>其中，typedmemmove源码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从src复制数据到dst</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typedmemmove</span><span class="params">(typ *abi.Type, dst, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 同一个指针</span></span><br><span class="line">    <span class="keyword">if</span> dst == src &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障开启 and 该类型包含指针</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &amp;&amp; typ.Pointers() &#123;</span><br><span class="line">        <span class="comment">// 在src和dst内存区域内寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line">        bulkBarrierPreWrite(<span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), typ.PtrBytes, typ)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从src复制n个字节到dst</span></span><br><span class="line">    memmove(dst, src, typ.Size_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认为false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> goexperiment.CgoCheck2 &#123;</span><br><span class="line">        cgoCheckMemmove2(typ, dst, src, <span class="number">0</span>, typ.Size_)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在src和dst内存区域内寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bulkBarrierPreWrite</span><span class="params">(dst, src, size <span class="type">uintptr</span>, typ *abi.Type)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 非8的倍数</span></span><br><span class="line">    <span class="keyword">if</span> (dst|src|size)&amp;(goarch.PtrSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;bulkBarrierPreWrite: unaligned arguments&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障未开启</span></span><br><span class="line">    <span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据地址找到heapArena再找到mspan</span></span><br><span class="line">    s := spanOf(dst)</span><br><span class="line">    <span class="comment">// p可能在data、bss段上或已释放或其他内存区域如mmap共享内存</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// data段</span></span><br><span class="line">        <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">            <span class="keyword">if</span> datap.data &lt;= dst &amp;&amp; dst &lt; datap.edata &#123;</span><br><span class="line">                <span class="comment">// 根据bitmap信息在src和dst内存区域寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line">                bulkBarrierBitmap(dst, src, size, dst-datap.data, datap.gcdatamask.bytedata)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bss段</span></span><br><span class="line">        <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">            <span class="keyword">if</span> datap.bss &lt;= dst &amp;&amp; dst &lt; datap.ebss &#123;</span><br><span class="line">                <span class="comment">// 根据bitmap信息在src和dst内存区域寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line">                bulkBarrierBitmap(dst, src, size, dst-datap.bss, datap.gcbssmask.bytedata)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s.state.get() != mSpanInUse || dst &lt; s.base() || s.limit &lt;= dst &#123;</span><br><span class="line">        <span class="comment">// 手动管理内存（栈上的引用） or 指针不在mspan管理范围</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面三种情况之一，不管</span></span><br><span class="line">        <span class="comment">// 1. mspan是被释放的heap空间</span></span><br><span class="line">        <span class="comment">// 2. 是某个goroutine的栈</span></span><br><span class="line">        <span class="comment">// 3. 是通过unsafe操作、channel发送，临时出现在其他栈上的指针</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写屏障缓冲</span></span><br><span class="line">    buf := &amp;getg().m.p.ptr().wbBuf</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">const</span> doubleCheck = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> doubleCheck &#123;</span><br><span class="line">        doubleCheckTypePointersOfType(s, typ, dst, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据对象的类型信息在一片内存区域内寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tp typePointers</span><br><span class="line">    <span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息（大对象）</span></span><br><span class="line">        tp = s.typePointersOfType(typ, dst)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息（小对象/对象内部）</span></span><br><span class="line">        tp = s.typePointersOf(dst, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// src为nil，只有一个数需要纪录</span></span><br><span class="line">    <span class="keyword">if</span> src == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> addr <span class="type">uintptr</span></span><br><span class="line">            <span class="comment">// mask第一个uint64不为0则调用nextFast，否则移动下一个uint64再重新判断</span></span><br><span class="line">            <span class="keyword">if</span> tp, addr = tp.next(dst + size); addr == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 扫描到末尾还是没有</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            dstx := (*<span class="type">uintptr</span>)(unsafe.Pointer(addr))</span><br><span class="line">            <span class="comment">// 获取写屏障缓冲区可写入位置（容量为1个指针）</span></span><br><span class="line">            p := buf.get1()</span><br><span class="line">            <span class="comment">// 将dstx写入到写屏障缓冲区</span></span><br><span class="line">            p[<span class="number">0</span>] = *dstx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> addr <span class="type">uintptr</span></span><br><span class="line">            <span class="comment">// mask第一个uint64不为0则调用nextFast，否则移动下一个uint64再重新判断</span></span><br><span class="line">            <span class="keyword">if</span> tp, addr = tp.next(dst + size); addr == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 扫描到末尾还是没有</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            dstx := (*<span class="type">uintptr</span>)(unsafe.Pointer(addr))</span><br><span class="line">            srcx := (*<span class="type">uintptr</span>)(unsafe.Pointer(src + (addr - dst)))</span><br><span class="line">            <span class="comment">// 获取写屏障缓冲区可写入位置（容量为2个指针）</span></span><br><span class="line">            p := buf.get2()</span><br><span class="line">            <span class="comment">// 将dstx、srcx写入到写屏障缓冲区</span></span><br><span class="line">            p[<span class="number">0</span>] = *dstx</span><br><span class="line">            p[<span class="number">1</span>] = *srcx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据bitmap信息在src和dst内存区域寻找指针数据，放入写屏障缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bulkBarrierBitmap</span><span class="params">(dst, src, size, maskOffset <span class="type">uintptr</span>, bits *<span class="type">uint8</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// =内存字节数/8 =&gt; 共word个指针</span></span><br><span class="line">    word := maskOffset / goarch.PtrSize</span><br><span class="line">    <span class="comment">// 定位到指针对应的bitmap</span></span><br><span class="line">    bits = addb(bits, word/<span class="number">8</span>)</span><br><span class="line">    <span class="comment">// uint8内第几位</span></span><br><span class="line">    mask := <span class="type">uint8</span>(<span class="number">1</span>) &lt;&lt; (word % <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写屏障缓冲区</span></span><br><span class="line">    buf := &amp;getg().m.p.ptr().wbBuf</span><br><span class="line">    <span class="comment">// 遍历复制的字节数，步进为8</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; size; i += goarch.PtrSize &#123;</span><br><span class="line">        <span class="comment">// mask溢出，回到1开始</span></span><br><span class="line">        <span class="keyword">if</span> mask == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 下一个字节</span></span><br><span class="line">            bits = addb(bits, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 8个对象都不是指针类型</span></span><br><span class="line">            <span class="keyword">if</span> *bits == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 跳过这8个数据</span></span><br><span class="line">                i += <span class="number">7</span> * goarch.PtrSize</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回到1开始</span></span><br><span class="line">            mask = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到指针</span></span><br><span class="line">        <span class="keyword">if</span> *bits&amp;mask != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 地址</span></span><br><span class="line">            dstx := (*<span class="type">uintptr</span>)(unsafe.Pointer(dst + i))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// src为nil，只有一个数需要纪录</span></span><br><span class="line">            <span class="keyword">if</span> src == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 获取写屏障缓冲区可写入位置（容量为1个指针）</span></span><br><span class="line">                p := buf.get1()</span><br><span class="line">                <span class="comment">// 将dstx写入到写屏障缓冲区</span></span><br><span class="line">                p[<span class="number">0</span>] = *dstx</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                srcx := (*<span class="type">uintptr</span>)(unsafe.Pointer(src + i))</span><br><span class="line">                <span class="comment">// 获取写屏障缓冲区可写入位置（容量为2个指针）</span></span><br><span class="line">                p := buf.get2()</span><br><span class="line">                <span class="comment">// 将dstx、srcx写入到写屏障缓冲区</span></span><br><span class="line">                p[<span class="number">0</span>] = *dstx</span><br><span class="line">                p[<span class="number">1</span>] = *srcx</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往后寻找一个</span></span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关依赖函数"><a href="#相关依赖函数" class="headerlink" title="相关依赖函数"></a>相关依赖函数</h2><h3 id="GC初始化"><a href="#GC初始化" class="headerlink" title="GC初始化"></a>GC初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC初始化，调度器初始化时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 确保workbuf结构有2KB大小</span></span><br><span class="line">    <span class="keyword">if</span> unsafe.Sizeof(workbuf&#123;&#125;) != _WorkbufSize &#123;</span><br><span class="line">        throw(<span class="string">&quot;size of Workbuf is suboptimal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示sweep阶段已完成</span></span><br><span class="line">    <span class="comment">// sweepDrainedMask = 2^31 =&gt; 2GB</span></span><br><span class="line">    sweep.active.state.Store(sweepDrainedMask)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pacer状态初始化（gcPercent从GOGC获取，memoryLimit从GOMEMLIMIT获取）</span></span><br><span class="line">    gcController.init(readGOGC(), readGOMEMLIMIT())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号量初始化</span></span><br><span class="line">    work.startSema = <span class="number">1</span></span><br><span class="line">    work.markDoneSema = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 锁初始化</span></span><br><span class="line">    lockInit(&amp;work.sweepWaiters.lock, lockRankSweepWaiters)</span><br><span class="line">    lockInit(&amp;work.assistQueue.lock, lockRankAssistQueue)</span><br><span class="line">    lockInit(&amp;work.strongFromWeak.lock, lockRankStrongFromWeakQueue)</span><br><span class="line">    lockInit(&amp;work.wbufSpans.lock, lockRankWbufSpans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动sweeper、scavenger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcenable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// sweeper</span></span><br><span class="line">    <span class="comment">// 被唤醒时，不停清理wbuf的mspan</span></span><br><span class="line">    <span class="keyword">go</span> bgsweep(c)</span><br><span class="line">    <span class="comment">// scavenger</span></span><br><span class="line">    <span class="comment">// 不断执行mheap_.pages.scavenge</span></span><br><span class="line">    <span class="keyword">go</span> bgscavenge(c)</span><br><span class="line">    &lt;-c</span><br><span class="line">    &lt;-c</span><br><span class="line">    <span class="comment">// 标记sweeper和scavenger已运行，可以开始运行GC</span></span><br><span class="line">    memstats.enablegc = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcTrigger-GC触发"><a href="#gcTrigger-GC触发" class="headerlink" title="gcTrigger-GC触发"></a>gcTrigger-GC触发</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否满足条件运行GC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span></span> test() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. gcenable执行后memstats.enablegc为true，false就是还没执行</span></span><br><span class="line">    <span class="comment">// 2. 遇到无法recover的panic时，panicking不为0</span></span><br><span class="line">    <span class="comment">// 3. GC处于非GCoff阶段</span></span><br><span class="line">    <span class="keyword">if</span> !memstats.enablegc || panicking.Load() != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">    <span class="keyword">case</span> gcTriggerHeap: <span class="comment">// heap达到一定大小</span></span><br><span class="line">        <span class="comment">// 计算GC触发阈值和目标heap大小</span></span><br><span class="line">        trigger, _ := gcController.trigger()</span><br><span class="line">        <span class="comment">// heap存活字节数 &gt;= </span></span><br><span class="line">        <span class="keyword">return</span> gcController.heapLive.Load() &gt;= trigger</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> gcTriggerTime: <span class="comment">// 有2min没执行GC</span></span><br><span class="line">        <span class="comment">// gcPercent默认为100</span></span><br><span class="line">        <span class="keyword">if</span> gcController.gcPercent.Load() &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// GC被关闭，不可以执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上一次GC的时刻</span></span><br><span class="line">        lastgc := <span class="type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超过2min未执行GC，可以执行</span></span><br><span class="line">        <span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> gcTriggerCycle: <span class="comment">// 手动、强制执行</span></span><br><span class="line">        <span class="comment">// 如果周期t.n大于全局周期work.cycles，可以执行，否则不执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">int32</span>(t.n-work.cycles.Load()) &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="世界停止-恢复"><a href="#世界停止-恢复" class="headerlink" title="世界停止&#x2F;恢复"></a>世界停止&#x2F;恢复</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使其他p中断/停止执行g进入安全点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorld</span><span class="params">(reason stwReason)</span></span> worldStop &#123;</span><br><span class="line">    <span class="comment">// 尝试获取worldsema，失败则挂起等待</span></span><br><span class="line">    semacquire(&amp;worldsema)</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    gp.m.preemptoff = reason.String()</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">        casGToWaitingForGC(gp, _Grunning, waitReasonStoppingTheWorld)</span><br><span class="line">        <span class="comment">// 将所有p都停止，返回原因、时间信息</span></span><br><span class="line">        stopTheWorldContext = stopTheWorldWithSema(reason)</span><br><span class="line">        <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> stopTheWorldContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等，最后唤醒阻塞在stopTheWorldGC的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorld</span><span class="params">(w worldStop)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 执行startTheWorldWithSema</span></span><br><span class="line">    <span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; startTheWorldWithSema(<span class="number">0</span>, w) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 重置（可抢占）</span></span><br><span class="line">    mp.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">// 释放信号量，唤醒其他阻塞在stopTheWorldGC的g</span></span><br><span class="line">    semrelease1(&amp;worldsema, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使其他p中断/停止执行g进入安全点（阻塞，按顺序执行）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldGC</span><span class="params">(reason stwReason)</span></span> worldStop &#123;</span><br><span class="line">    <span class="comment">// 尝试获取gcsema，失败则挂起等待</span></span><br><span class="line">    semacquire(&amp;gcsema)</span><br><span class="line">    <span class="comment">// 使其他p中断/停止执行g进入安全点</span></span><br><span class="line">    <span class="keyword">return</span> stopTheWorld(reason)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等，最后唤醒阻塞在stopTheWorldGC的g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorldGC</span><span class="params">(w worldStop)</span></span> &#123;</span><br><span class="line">    <span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等，最后唤醒阻塞在stopTheWorldGC的g</span></span><br><span class="line">    startTheWorld(w)</span><br><span class="line">    <span class="comment">// 释放信号量，唤醒其他g</span></span><br><span class="line">    semrelease(&amp;gcsema)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有p都停止，返回原因、时间信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldWithSema</span><span class="params">(reason stwReason)</span></span> worldStop &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止抢占（这里容易造成死锁）</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.locks &gt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;stopTheWorld: holding locks&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    start := nanotime()</span><br><span class="line">    <span class="comment">// 待_Pgcstop的p数量</span></span><br><span class="line">    sched.stopwait = gomaxprocs</span><br><span class="line">    <span class="comment">// 调度器通知其他线程，有STW信号</span></span><br><span class="line">    sched.gcwaiting.Store(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 逐个设置p的抢占标志，发送信号给线程（把其他p丢到空闲队列）</span></span><br><span class="line">    preemptall()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前p丢到空闲队列</span></span><br><span class="line">    <span class="comment">// 状态改为_Pgcstop</span></span><br><span class="line">    gp.m.p.ptr().status = _Pgcstop</span><br><span class="line">    <span class="comment">// 停止时刻</span></span><br><span class="line">    gp.m.p.ptr().gcStopTime = start</span><br><span class="line">    <span class="comment">// 数量减1</span></span><br><span class="line">    sched.stopwait--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试回收正在执行系统调用的p</span></span><br><span class="line">    <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        s := pp.status</span><br><span class="line">        <span class="comment">// 系统调用中，切换到_Pgcstop</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &amp;&amp; atomic.Cas(&amp;pp.status, s, _Pgcstop) &#123;</span><br><span class="line">            <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">            pp.syscalltick++</span><br><span class="line">            <span class="comment">// 停止时刻</span></span><br><span class="line">            pp.gcStopTime = nanotime()</span><br><span class="line">            <span class="comment">// 数量减1</span></span><br><span class="line">            sched.stopwait--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经放在空闲队列的p状态修改</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 从空闲链表拿一个p，如果没拿到则通知所有m，让其中一个m让出p并进入自旋等待</span></span><br><span class="line">        pp, _ := pidleget(now)</span><br><span class="line">        <span class="comment">// 没有拿到</span></span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        pp.status = _Pgcstop</span><br><span class="line">        <span class="comment">// 停止时刻</span></span><br><span class="line">        pp.gcStopTime = nanotime()</span><br><span class="line">        <span class="comment">// 数量减1</span></span><br><span class="line">        sched.stopwait--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否还有p没有放到空闲队列</span></span><br><span class="line">    wait := sched.stopwait &gt; <span class="number">0</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有p未停止</span></span><br><span class="line">    <span class="keyword">if</span> wait &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 挂起休眠100us（m放在stopnote.key），标记blocked为true</span></span><br><span class="line">            <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 被唤醒</span></span><br><span class="line">                <span class="comment">// 将stopnote.key重置为0</span></span><br><span class="line">                noteclear(&amp;sched.stopnote)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 逐个设置p的抢占标志，发送信号给线程</span></span><br><span class="line">            preemptall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束时间</span></span><br><span class="line">    finish := nanotime()</span><br><span class="line">    <span class="comment">// 耗时</span></span><br><span class="line">    startTime := finish - start</span><br><span class="line">    <span class="comment">// 如果是gcStart或gcMarkDone这两个函数调用 =&gt; stwGCSweepTerm || stwGCMarkTerm</span></span><br><span class="line">    <span class="keyword">if</span> reason.isGC() &#123;</span><br><span class="line">        sched.stwStoppingTimeGC.record(startTime)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched.stwStoppingTimeOther.record(startTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计所有p的STW耗时</span></span><br><span class="line">    stoppingCPUTime := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 错误信息</span></span><br><span class="line">    bad := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sched.stopwait != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 仍有p未停止</span></span><br><span class="line">        bad = <span class="string">&quot;stopTheWorld: not stopped (stopwait != 0)&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 所有的p都停止了</span></span><br><span class="line">        <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            <span class="comment">// 状态核对</span></span><br><span class="line">            <span class="keyword">if</span> pp.status != _Pgcstop &#123;</span><br><span class="line">                bad = <span class="string">&quot;stopTheWorld: not stopped (status != _Pgcstop)&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> pp.gcStopTime == <span class="number">0</span> &amp;&amp; bad == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                bad = <span class="string">&quot;stopTheWorld: broken CPU time accounting&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 累计耗时</span></span><br><span class="line">            stoppingCPUTime += finish - pp.gcStopTime</span><br><span class="line">            <span class="comment">// 重置为0</span></span><br><span class="line">            pp.gcStopTime = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现无法恢复的panic</span></span><br><span class="line">    <span class="keyword">if</span> freezing.Load() &#123;</span><br><span class="line">        lock(&amp;deadlock)</span><br><span class="line">        lock(&amp;deadlock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> bad != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        throw(bad)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    worldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回原因、时间信息</span></span><br><span class="line">    <span class="keyword">return</span> worldStop&#123;</span><br><span class="line">        reason:           reason,          <span class="comment">// STW原因</span></span><br><span class="line">        startedStopping:  start,           <span class="comment">// 函数执行的开始时刻</span></span><br><span class="line">        finishedStopping: finish,          <span class="comment">// 所有p都停止了的时刻</span></span><br><span class="line">        stoppingCPUTime:  stoppingCPUTime, <span class="comment">// 累计STW耗时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll轮询、p数量调整、唤醒sysmon、唤醒m绑定p执行任务、统计等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorldWithSema</span><span class="params">(now <span class="type">int64</span>, w worldStop)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// netpoll已初始化</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &#123;</span><br><span class="line">        <span class="comment">// 执行epollWait检查，0-没有数据立即返回</span></span><br><span class="line">        list, delta := netpoll(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">        injectglist(&amp;list)</span><br><span class="line">        <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">        netpollAdjustWaiters(delta)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU数量</span></span><br><span class="line">    procs := gomaxprocs</span><br><span class="line">    <span class="comment">// 如果newprocs不为0，意味着用户调用GOMAXPROCS修改了p数量</span></span><br><span class="line">    <span class="keyword">if</span> newprocs != <span class="number">0</span> &#123;</span><br><span class="line">        procs = newprocs</span><br><span class="line">        newprocs = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据数量n扩容/缩容p</span></span><br><span class="line">    p1 := procresize(procs)</span><br><span class="line">    <span class="comment">// 调度器通知其他线程，STW停止，恢复世界</span></span><br><span class="line">    sched.gcwaiting.Store(<span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// sysmon挂起休眠了</span></span><br><span class="line">    <span class="keyword">if</span> sched.sysmonwait.Load() &#123;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 唤醒sysmon（m放在sysmonnote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    worldStarted()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲p数量不为0</span></span><br><span class="line">    <span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 获取第一个p</span></span><br><span class="line">        p := p1</span><br><span class="line">        <span class="comment">// 链表调整</span></span><br><span class="line">        p1 = p1.link.ptr()</span><br><span class="line">        <span class="comment">// p已被m持有</span></span><br><span class="line">        <span class="keyword">if</span> p.m != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// m</span></span><br><span class="line">            mp := p.m.ptr()</span><br><span class="line">            <span class="comment">// 移除m</span></span><br><span class="line">            p.m = <span class="number">0</span></span><br><span class="line">            <span class="comment">// nextp字段不为0</span></span><br><span class="line">            <span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;startTheWorld: inconsistent mp-&gt;nextp&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把p放到nextp字段</span></span><br><span class="line">            mp.nextp.set(p)</span><br><span class="line">            <span class="comment">// 唤醒m（m放在m.park.key）</span></span><br><span class="line">            notewakeup(&amp;mp.park)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// p未被m持有</span></span><br><span class="line">            <span class="comment">// 清理freem链表，创建并初始化m，locked或cgo类型的m由模板线程延迟创建，其他类型则立即调用平台相关函数创建线程</span></span><br><span class="line">            newm(<span class="literal">nil</span>, p, <span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// STW耗时</span></span><br><span class="line">    totalTime := now - w.startedStopping</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是gcStart或gcMarkDone这两个函数调用 =&gt; stwGCSweepTerm || stwGCMarkTerm</span></span><br><span class="line">    <span class="keyword">if</span> w.reason.isGC() &#123;</span><br><span class="line">        sched.stwTotalTimeGC.record(totalTime)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched.stwTotalTimeOther.record(totalTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">    wakep()</span><br><span class="line"></span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="keyword">return</span> now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让p的g进入等待，强制让p进入空闲状态，执行safePoint函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forEachP</span><span class="params">(reason waitReason, fn <span class="keyword">func</span>(*p)</span></span>) &#123;</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        gp := getg().m.curg</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">        casGToWaitingForGC(gp, _Grunning, reason)</span><br><span class="line">        <span class="comment">// 强制让p进入空闲状态，执行safePoint函数</span></span><br><span class="line">        forEachPInternal(fn)</span><br><span class="line">        <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制让p进入空闲状态，执行safePoint函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forEachPInternal</span><span class="params">(fn <span class="keyword">func</span>(*p)</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 防抢占</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> sched.safePointWait != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;forEachP: sched.safePointWait != 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sched.safePointWait = gomaxprocs - <span class="number">1</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sched.safePointFn = fn</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让其他p执行safePoint函数</span></span><br><span class="line">    <span class="keyword">for</span> _, p2 := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="keyword">if</span> p2 != pp &#123;</span><br><span class="line">            atomic.Store(&amp;p2.runSafePointFn, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个设置p的抢占标志，发送抢占信号给线程</span></span><br><span class="line">    preemptall()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历空闲p链表</span></span><br><span class="line">    <span class="keyword">for</span> p := sched.pidle.ptr(); p != <span class="literal">nil</span>; p = p.link.ptr() &#123;</span><br><span class="line">        <span class="comment">// 重置状态</span></span><br><span class="line">        <span class="keyword">if</span> atomic.Cas(&amp;p.runSafePointFn, <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行safePoint函数</span></span><br><span class="line">            fn(p)</span><br><span class="line">            <span class="comment">// 计数器-1</span></span><br><span class="line">            sched.safePointWait--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有p未执行safePoint函数</span></span><br><span class="line">    wait := sched.safePointWait &gt; <span class="number">0</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前p执行safePoint函数</span></span><br><span class="line">    fn(pp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制将_Psyscall的p转为_Pidle并运行safePoint函数</span></span><br><span class="line">    <span class="keyword">for</span> _, p2 := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        s := p2.status</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从_Psyscall状态改为_Pidle</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &amp;&amp; p2.runSafePointFn == <span class="number">1</span> &amp;&amp; atomic.Cas(&amp;p2.status, s, _Pidle) &#123;</span><br><span class="line">            <span class="comment">// p的syscall次数+=1</span></span><br><span class="line">            p2.syscalltick++</span><br><span class="line">            <span class="comment">// 当m执行syscall或锁定时，让出p给其他m或者把p放回空闲队列</span></span><br><span class="line">            <span class="comment">// （其内部会执行safePoint函数、更新safePointWait计数器）</span></span><br><span class="line">            handoffp(p2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有p没运行safePoint函数</span></span><br><span class="line">    <span class="keyword">if</span> wait &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 挂起休眠100us（m放在safePointNote.key），标记blocked为true</span></span><br><span class="line">            <span class="keyword">if</span> notetsleep(&amp;sched.safePointNote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// 被唤醒/超时</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将safePointNote.key重置为0</span></span><br><span class="line">                noteclear(&amp;sched.safePointNote)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超时</span></span><br><span class="line">            <span class="comment">// 逐个设置p的抢占标志，发送抢占信号给线程</span></span><br><span class="line">            preemptall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> sched.safePointWait != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;forEachP: not done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查每个p的状态</span></span><br><span class="line">    <span class="keyword">for</span> _, p2 := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="keyword">if</span> p2.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;forEachP: P did not run fn&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 重置函数指针</span></span><br><span class="line">    sched.safePointFn = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标记线程相关"><a href="#标记线程相关" class="headerlink" title="标记线程相关"></a>标记线程相关</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取快照，计算各个根对象的块数量、基地址（索引）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkRootPrepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算有多少个块，每个块256KB</span></span><br><span class="line">    nBlocks := <span class="function"><span class="keyword">func</span><span class="params">(bytes <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="comment">// 按256KB的倍数向上取整</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">int</span>(divRoundUp(bytes, rootBlockBytes))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    work.nDataRoots = <span class="number">0</span></span><br><span class="line">    work.nBSSRoots = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计data、bss的块数量</span></span><br><span class="line">    <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">        <span class="comment">// 计算data包含多少个块（已初始化的全局变量和静态变量）</span></span><br><span class="line">        nDataRoots := nBlocks(datap.edata - datap.data)</span><br><span class="line">        <span class="keyword">if</span> nDataRoots &gt; work.nDataRoots &#123;</span><br><span class="line">            work.nDataRoots = nDataRoots</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算bss包含多少个块（未初始化的全局变量和静态变量）</span></span><br><span class="line">        nBSSRoots := nBlocks(datap.ebss - datap.bss)</span><br><span class="line">        <span class="keyword">if</span> nBSSRoots &gt; work.nBSSRoots &#123;</span><br><span class="line">            work.nBSSRoots = nBSSRoots</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描mspan的finalizer、specials纪录</span></span><br><span class="line">    <span class="comment">// markArenas为allArenas快照（凡是heap管理的arena都会放在这里，用户手动管理则不会）</span></span><br><span class="line">    mheap_.markArenas = mheap_.allArenas[:<span class="built_in">len</span>(mheap_.allArenas):<span class="built_in">len</span>(mheap_.allArenas)]</span><br><span class="line">    <span class="comment">// =length*8192/512 = length*16</span></span><br><span class="line">    work.nSpanRoots = <span class="built_in">len</span>(mheap_.markArenas) * (pagesPerArena / pagesPerSpanRoot)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描栈</span></span><br><span class="line">    <span class="comment">// allgs快照</span></span><br><span class="line">    work.stackRoots = allGsSnapshot()</span><br><span class="line">    work.nStackRoots = <span class="built_in">len</span>(work.stackRoots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟对象块id/计数器</span></span><br><span class="line">    work.markrootNext = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 跟对象块总数 = 2+data块数量+bss块数量+mspan块数量+stack数量</span></span><br><span class="line">    <span class="comment">// 这里有2个索引被占用了，0索引-扫描finalizer，1索引-扫描gFree.stack释放所有栈</span></span><br><span class="line">    work.markrootJobs = <span class="type">uint32</span>(fixedRootCount + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算索引</span></span><br><span class="line">    work.baseData = <span class="type">uint32</span>(fixedRootCount)</span><br><span class="line">    work.baseBSS = work.baseData + <span class="type">uint32</span>(work.nDataRoots)</span><br><span class="line">    work.baseSpans = work.baseBSS + <span class="type">uint32</span>(work.nBSSRoots)</span><br><span class="line">    work.baseStacks = work.baseSpans + <span class="type">uint32</span>(work.nSpanRoots)</span><br><span class="line">    work.baseEnd = work.baseStacks + <span class="type">uint32</span>(work.nStackRoots)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tiny区域对象置灰放入队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTinyAllocs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// 获取p.mcache</span></span><br><span class="line">        c := p.mcache</span><br><span class="line">        <span class="comment">// 未初始化</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="literal">nil</span> || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据p查找mspan，找到了返回对象在mspan内的位置和对象起始地址</span></span><br><span class="line">        _, span, objIndex := findObject(c.tiny, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前p的wbuf队列</span></span><br><span class="line">        gcw := &amp;p.gcw</span><br><span class="line">        <span class="comment">// 设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">        greyobject(c.tiny, <span class="number">0</span>, <span class="number">0</span>, span, gcw, objIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空allgs快照、gcw/mcache等残留处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMark</span><span class="params">(startTime <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 非_GCmarktermination阶段</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCmarktermination &#123;</span><br><span class="line">        throw(<span class="string">&quot;in gcMark expecting to see gcphase as _GCmarktermination&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    work.tstart = startTime</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认无标记任务残留</span></span><br><span class="line">    <span class="keyword">if</span> work.full != <span class="number">0</span> || work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: full=&quot;</span>, hex(work.full), <span class="string">&quot; next=&quot;</span>, work.markrootNext, <span class="string">&quot; jobs=&quot;</span>, work.markrootJobs, <span class="string">&quot; nDataRoots=&quot;</span>, work.nDataRoots, <span class="string">&quot; nBSSRoots=&quot;</span>, work.nBSSRoots, <span class="string">&quot; nSpanRoots=&quot;</span>, work.nSpanRoots, <span class="string">&quot; nStackRoots=&quot;</span>, work.nStackRoots, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;non-empty mark queue after concurrent mark&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &#123;</span><br><span class="line">        gcMarkRootCheck()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空allgs快照</span></span><br><span class="line">    work.stackRoots = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">            wbBufFlush1(p)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重置wbBuf的next、end指针</span></span><br><span class="line">            p.wbBuf.reset()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gcw := &amp;p.gcw</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gcw不为空，异常</span></span><br><span class="line">        <span class="keyword">if</span> !gcw.empty() &#123;</span><br><span class="line">            printlock()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: P &quot;</span>, p.id, <span class="string">&quot; flushedWork &quot;</span>, gcw.flushedWork)</span><br><span class="line">            <span class="keyword">if</span> gcw.wbuf1 == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot; wbuf1=&lt;nil&gt;&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot; wbuf1.n=&quot;</span>, gcw.wbuf1.nobj)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> gcw.wbuf2 == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot; wbuf2=&lt;nil&gt;&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot; wbuf2.n=&quot;</span>, gcw.wbuf2.nobj)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;P has cached GC work at end of mark termination&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gcw为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf1、wbuf2根据容量选择放入work.empty或work.full队列</span></span><br><span class="line">        gcw.dispose()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// mcache</span></span><br><span class="line">        c := p.mcache</span><br><span class="line">        <span class="comment">// 未初始化</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        c.scanAlloc = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记终止时，纪录快照，重置heapLive、heapMarked等字段</span></span><br><span class="line">    gcController.resetLive(work.bytesMarked)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GC第1阶段时，清理sync.Pool、sudog缓存、defer pool及其他</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clearpools</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 函数不为空</span></span><br><span class="line">    <span class="keyword">if</span> poolcleanup != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        poolcleanup()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除boringcrypto缓存</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> boringCaches &#123;</span><br><span class="line">        <span class="comment">// p置为nil</span></span><br><span class="line">        atomicstorep(p, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理unique map</span></span><br><span class="line">    <span class="keyword">if</span> uniqueMapCleanup != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> uniqueMapCleanup &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理全局sudog缓存</span></span><br><span class="line">    <span class="comment">// sudoglock加锁</span></span><br><span class="line">    lock(&amp;sched.sudoglock)</span><br><span class="line">    <span class="keyword">var</span> sg, sgnext *sudog</span><br><span class="line">    <span class="comment">// 遍历全局sudog链表</span></span><br><span class="line">    <span class="keyword">for</span> sg = sched.sudogcache; sg != <span class="literal">nil</span>; sg = sgnext &#123;</span><br><span class="line">        sgnext = sg.next</span><br><span class="line">        <span class="comment">// 取消链接</span></span><br><span class="line">        sg.next = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 置为nil</span></span><br><span class="line">    sched.sudogcache = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.sudoglock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空全局defer pool</span></span><br><span class="line">    <span class="comment">// deferlock加锁</span></span><br><span class="line">    lock(&amp;sched.deferlock)</span><br><span class="line">    <span class="keyword">var</span> d, dlink *_defer</span><br><span class="line">    <span class="comment">// 遍历全局defer pool</span></span><br><span class="line">    <span class="keyword">for</span> d = sched.deferpool; d != <span class="literal">nil</span>; d = dlink &#123;</span><br><span class="line">        dlink = d.link</span><br><span class="line">        <span class="comment">// 取消链接</span></span><br><span class="line">        d.link = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 置为nil</span></span><br><span class="line">    sched.deferpool = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.deferlock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkWorkAvailable</span><span class="params">(p *p)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 本地任务缓冲区p.gcw不为空</span></span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.gcw.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局任务缓冲区不为空</span></span><br><span class="line">    <span class="keyword">if</span> !work.full.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根对象还没扫描完</span></span><br><span class="line">    <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcBitsArenas迭代，如用next替换current等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextMarkBitArenaEpoch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lock(&amp;gcBitsArenas.lock)</span><br><span class="line">    <span class="comment">// 用previous替换free</span></span><br><span class="line">    <span class="keyword">if</span> gcBitsArenas.previous != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果free为nil，放到free</span></span><br><span class="line">        <span class="keyword">if</span> gcBitsArenas.free == <span class="literal">nil</span> &#123;</span><br><span class="line">            gcBitsArenas.free = gcBitsArenas.previous</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// free不为nil，previous放到free前，作为新的free</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到previous最后一个元素</span></span><br><span class="line">            last := gcBitsArenas.previous</span><br><span class="line">            <span class="keyword">for</span> last = gcBitsArenas.previous; last.next != <span class="literal">nil</span>; last = last.next &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// previous链接free</span></span><br><span class="line">            last.next = gcBitsArenas.free</span><br><span class="line">            <span class="comment">// 替换free</span></span><br><span class="line">            gcBitsArenas.free = gcBitsArenas.previous</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用current替换previous</span></span><br><span class="line">    gcBitsArenas.previous = gcBitsArenas.current</span><br><span class="line">    <span class="comment">// 用next替换current</span></span><br><span class="line">    gcBitsArenas.current = gcBitsArenas.next</span><br><span class="line">    <span class="comment">// next置为nil</span></span><br><span class="line">    atomic.StorepNoWB(unsafe.Pointer(&amp;gcBitsArenas.next), <span class="literal">nil</span>)</span><br><span class="line">    unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引扫描指定的根对象，扫描的字节数除了返回还会累计到gcController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markroot</span><span class="params">(gcw *gcWork, i <span class="type">uint32</span>, flushBgCredit <span class="type">bool</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> workDone <span class="type">int64</span></span><br><span class="line">    <span class="keyword">var</span> workCounter *atomic.Int64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> work.baseData &lt;= i &amp;&amp; i &lt; work.baseBSS: <span class="comment">// data段</span></span><br><span class="line">        workCounter = &amp;gcController.globalsScanWork</span><br><span class="line">        <span class="comment">// 遍历所有go module、动态库、plugin</span></span><br><span class="line">        <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">            <span class="comment">// 扫描bss/data内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            workDone += markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, <span class="type">int</span>(i-work.baseData))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> work.baseBSS &lt;= i &amp;&amp; i &lt; work.baseSpans: <span class="comment">// bss段</span></span><br><span class="line">        workCounter = &amp;gcController.globalsScanWork</span><br><span class="line">        <span class="comment">// // 遍历所有go module、动态库、plugin</span></span><br><span class="line">        <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">            <span class="comment">// 扫描bss/data内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            workDone += markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, <span class="type">int</span>(i-work.baseBSS))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> i == fixedRootFinalizers: <span class="comment">// i为0</span></span><br><span class="line">        <span class="comment">// 遍历finalizer链表</span></span><br><span class="line">        <span class="keyword">for</span> fb := allfin; fb != <span class="literal">nil</span>; fb = fb.alllink &#123;</span><br><span class="line">            <span class="comment">// 总数</span></span><br><span class="line">            cnt := <span class="type">uintptr</span>(atomic.Load(&amp;fb.cnt))</span><br><span class="line">            <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;fb.fin[<span class="number">0</span>])), cnt*unsafe.Sizeof(fb.fin[<span class="number">0</span>]), &amp;finptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> i == fixedRootFreeGStacks: <span class="comment">// i为1</span></span><br><span class="line">        <span class="comment">// 运行markrootFreeGStacks</span></span><br><span class="line">        <span class="comment">// 将gFree.stack的所有g的栈释放掉，然后放回gFree.noStack</span></span><br><span class="line">        systemstack(markrootFreeGStacks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> work.baseSpans &lt;= i &amp;&amp; i &lt; work.baseStacks: <span class="comment">// mspan</span></span><br><span class="line">        <span class="comment">// 扫描specials内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">        markrootSpans(gcw, <span class="type">int</span>(i-work.baseSpans))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// stack</span></span><br><span class="line">        <span class="comment">// stack扫描字节数</span></span><br><span class="line">        workCounter = &amp;gcController.stackScanWork</span><br><span class="line">        <span class="comment">// 不在stack索引范围</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; work.baseStacks || work.baseEnd &lt;= i &#123;</span><br><span class="line">            printlock()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: markroot index &quot;</span>, i, <span class="string">&quot; not in stack roots range [&quot;</span>, work.baseStacks, <span class="string">&quot;, &quot;</span>, work.baseEnd, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;markroot: bad index&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据索引找到g</span></span><br><span class="line">        gp := work.stackRoots[i-work.baseStacks]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取g.atomicstatus状态，当前非scan状态</span></span><br><span class="line">        status := readgstatus(gp)</span><br><span class="line">        <span class="comment">// 阻塞时，纪录开始时刻</span></span><br><span class="line">        <span class="keyword">if</span> (status == _Gwaiting || status == _Gsyscall) &amp;&amp; gp.waitsince == <span class="number">0</span> &#123;</span><br><span class="line">            gp.waitsince = work.tstart</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 汇编，切换到g0运行，扫描stack需要切换到系统stack下运行</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// g</span></span><br><span class="line">            userG := getg().m.curg</span><br><span class="line">            <span class="comment">// 扫描自身</span></span><br><span class="line">            selfScan := gp == userG &amp;&amp; readgstatus(userG) == _Grunning</span><br><span class="line">            <span class="comment">// 防止死锁</span></span><br><span class="line">            <span class="keyword">if</span> selfScan &#123;</span><br><span class="line">                <span class="comment">// 改为_Gwaiting状态并设置waitreason，可抢占</span></span><br><span class="line">                casGToWaitingForGC(userG, _Grunning, waitReasonGarbageCollectionScan)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// g运行中则抢占使其停止，否则改为_Gscan状态</span></span><br><span class="line">            stopped := suspendG(gp)</span><br><span class="line">            <span class="comment">// g的状态为_Gdead</span></span><br><span class="line">            <span class="keyword">if</span> stopped.dead &#123;</span><br><span class="line">                <span class="comment">// 已经完成栈扫描</span></span><br><span class="line">                gp.gcscandone = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 异常状态</span></span><br><span class="line">            <span class="keyword">if</span> gp.gcscandone &#123;</span><br><span class="line">                throw(<span class="string">&quot;g already scanned&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 扫描栈帧内指针、defer链、panic、state.buf队列</span></span><br><span class="line">            workDone += scanstack(gp, gcw)</span><br><span class="line">            <span class="comment">// 已经完成栈扫描</span></span><br><span class="line">            gp.gcscandone = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 移除_Gscan状态，如果被抢占停止则唤醒g</span></span><br><span class="line">            resumeG(stopped)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复状态</span></span><br><span class="line">            <span class="keyword">if</span> selfScan &#123;</span><br><span class="line">                <span class="comment">// 非_Gscan状态转换，统计g位于_Grunnable、_Gwaiting状态时所耗费的时间</span></span><br><span class="line">                casgstatus(userG, _Gwaiting, _Grunning)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除非i&lt;2，否则下面的条件一般都满足</span></span><br><span class="line">    <span class="keyword">if</span> workCounter != <span class="literal">nil</span> &amp;&amp; workDone != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 累计到gcController对应的字段如globalsScanWork、stackScanWork</span></span><br><span class="line">        workCounter.Add(workDone)</span><br><span class="line">        <span class="comment">// 一般都为true</span></span><br><span class="line">        <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">            <span class="comment">// 根据额度唤醒一批g，额度有剩余就累计到全局额度bgScanCredit（与gcParkAssist成对使用）</span></span><br><span class="line">            gcFlushBgCredit(workDone)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将gFree.stack的所有g的栈释放掉，然后放回gFree.noStack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markrootFreeGStacks</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器gFree加锁</span></span><br><span class="line">    lock(&amp;sched.gFree.lock)</span><br><span class="line">    <span class="comment">// 有栈</span></span><br><span class="line">    list := sched.gFree.stack</span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    sched.gFree.stack = gList&#123;&#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.gFree.lock)</span><br><span class="line">    <span class="comment">// 为空</span></span><br><span class="line">    <span class="keyword">if</span> list.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换类型</span></span><br><span class="line">    q := gQueue&#123;list.head, list.head&#125;</span><br><span class="line">    <span class="comment">// 遍历gFree链表</span></span><br><span class="line">    <span class="keyword">for</span> gp := list.head.ptr(); gp != <span class="literal">nil</span>; gp = gp.schedlink.ptr() &#123;</span><br><span class="line">        <span class="comment">// 释放栈</span></span><br><span class="line">        stackfree(gp.stack)</span><br><span class="line">        gp.stack.lo = <span class="number">0</span></span><br><span class="line">        gp.stack.hi = <span class="number">0</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        q.tail.set(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度器gFree加锁</span></span><br><span class="line">    lock(&amp;sched.gFree.lock)</span><br><span class="line">    <span class="comment">// 无栈</span></span><br><span class="line">    sched.gFree.noStack.pushAll(q)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.gFree.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描specials内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markrootSpans</span><span class="params">(gcw *gcWork, shard <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// sweepgen</span></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从allArenas快照找到arenaIdx =markArenas[shard/16]</span></span><br><span class="line">    ai := mheap_.markArenas[shard/(pagesPerArena/pagesPerSpanRoot)]</span><br><span class="line">    <span class="comment">// 根据arenaIdx找到heapArena</span></span><br><span class="line">    ha := mheap_.arenas[ai.l1()][ai.l2()]</span><br><span class="line">    <span class="comment">// =shard*512%8192</span></span><br><span class="line">    arenaPage := <span class="type">uint</span>(<span class="type">uintptr</span>(shard) * pagesPerSpanRoot % pagesPerArena)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specials的bitmap</span></span><br><span class="line">    specialsbits := ha.pageSpecials[arenaPage/<span class="number">8</span>:]</span><br><span class="line">    specialsbits = specialsbits[:pagesPerSpanRoot/<span class="number">8</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> specialsbits &#123;</span><br><span class="line">        <span class="comment">// 8个位</span></span><br><span class="line">        specials := atomic.Load8(&amp;specialsbits[i])</span><br><span class="line">        <span class="comment">// 8个位全为0</span></span><br><span class="line">        <span class="keyword">if</span> specials == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历8个位</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="type">uint</span>(<span class="number">0</span>); j &lt; <span class="number">8</span>; j++ &#123;</span><br><span class="line">            <span class="comment">// 该位为0</span></span><br><span class="line">            <span class="keyword">if</span> specials&amp;(<span class="number">1</span>&lt;&lt;j) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据页索引找到mspan</span></span><br><span class="line">            s := ha.spans[arenaPage+<span class="type">uint</span>(i)*<span class="number">8</span>+j]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 状态必须是mSpanInUse</span></span><br><span class="line">            <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;s.state = &quot;</span>, state, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                throw(<span class="string">&quot;non in-use span found with specials bit set&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 确保mspan已经清理</span></span><br><span class="line">            <span class="keyword">if</span> !useCheckmark &amp;&amp; !(s.sweepgen == sg || s.sweepgen == sg+<span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;sweep &quot;</span>, s.sweepgen, <span class="string">&quot; &quot;</span>, sg, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                throw(<span class="string">&quot;gc: unswept span&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁，防止special在遍历时被移除</span></span><br><span class="line">            lock(&amp;s.speciallock)</span><br><span class="line">            <span class="comment">// 遍历specials</span></span><br><span class="line">            <span class="keyword">for</span> sp := s.specials; sp != <span class="literal">nil</span>; sp = sp.next &#123;</span><br><span class="line">                <span class="keyword">switch</span> sp.kind &#123;</span><br><span class="line">                <span class="keyword">case</span> _KindSpecialFinalizer: <span class="comment">// finalizer</span></span><br><span class="line">                    <span class="comment">// 不标记、只扫描</span></span><br><span class="line">                    spf := (*specialfinalizer)(unsafe.Pointer(sp))</span><br><span class="line">                    <span class="comment">// 找到这个对象</span></span><br><span class="line">                    p := s.base() + <span class="type">uintptr</span>(spf.special.offset)/s.elemsize*s.elemsize</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 标记从这个对象出发可达的所有对象（不包括当前对象）</span></span><br><span class="line">                    <span class="keyword">if</span> !s.spanclass.noscan() &#123;</span><br><span class="line">                        <span class="comment">// 扫描一个对象（最多128KB，剩余放到任务缓冲区）内所有指针，设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                        scanobject(p, gcw)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// special本身是一个根对象</span></span><br><span class="line">                    <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                    scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;spf.fn)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">                <span class="keyword">case</span> _KindSpecialWeakHandle: <span class="comment">// weak handle</span></span><br><span class="line">                    spw := (*specialWeakHandle)(unsafe.Pointer(sp))</span><br><span class="line">                    <span class="comment">// special本身是一个根对象</span></span><br><span class="line">                    <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                    scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;spw.handle)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">                <span class="keyword">case</span> _KindSpecialCleanup: <span class="comment">// cleanup</span></span><br><span class="line">                    spc := (*specialCleanup)(unsafe.Pointer(sp))</span><br><span class="line">                    <span class="comment">// special本身是一个根对象</span></span><br><span class="line">                    <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                    scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;spc.fn)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            unlock(&amp;s.speciallock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描bss/data内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markrootBlock</span><span class="params">(b0, n0 <span class="type">uintptr</span>, ptrmask0 *<span class="type">uint8</span>, gcw *gcWork, shard <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 256KB =&gt; 262144</span></span><br><span class="line">    <span class="keyword">if</span> rootBlockBytes%(<span class="number">8</span>*goarch.PtrSize) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;rootBlockBytes must be a multiple of 8*ptrSize&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shard =&gt; bss/data块的起始索引，每个块有256KB，用于迅速定位内存块</span></span><br><span class="line">    off := <span class="type">uintptr</span>(shard) * rootBlockBytes</span><br><span class="line">    <span class="comment">// b0 =&gt; bss/data内存起始地址，n0 =&gt; bss/data内存终止地址</span></span><br><span class="line">    <span class="keyword">if</span> off &gt;= n0 &#123;</span><br><span class="line">        <span class="comment">// 越界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 块起始地址</span></span><br><span class="line">    b := b0 + off</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个块的bitmap起始地址（整个bss/data区域有4KB的bitmap）</span></span><br><span class="line">    ptrmask := (*<span class="type">uint8</span>)(add(unsafe.Pointer(ptrmask0), <span class="type">uintptr</span>(shard)*(rootBlockBytes/(<span class="number">8</span>*goarch.PtrSize))))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 256KB</span></span><br><span class="line">    n := <span class="type">uintptr</span>(rootBlockBytes)</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">if</span> off+n &gt; n0 &#123;</span><br><span class="line">        <span class="comment">// 调整要扫描的字节数，=min(n0-off, 256KB)</span></span><br><span class="line">        n = n0 - off</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">    scanblock(b, n, ptrmask, gcw, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanblock</span><span class="params">(b0, n0 <span class="type">uintptr</span>, ptrmask *<span class="type">uint8</span>, gcw *gcWork, stk *stackScanState)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 复制，debug时可以查看初始值，用于参考</span></span><br><span class="line">    b := b0</span><br><span class="line">    n := n0</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描n个字节</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; &#123;</span><br><span class="line">        <span class="comment">// 调整指针指向正确的mask =&gt; ptrmask+i/64，uint8扩展成uint32</span></span><br><span class="line">        bits := <span class="type">uint32</span>(*addb(ptrmask, i/(goarch.PtrSize*<span class="number">8</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8个对象都不是指针类型</span></span><br><span class="line">        <span class="keyword">if</span> bits == <span class="number">0</span> &#123;</span><br><span class="line">            i += goarch.PtrSize * <span class="number">8</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8个对象中，至少有一个是指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历uint8的8个位</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">8</span> &amp;&amp; i &lt; n; j++ &#123;</span><br><span class="line">            <span class="comment">// 该对象是指针</span></span><br><span class="line">            <span class="keyword">if</span> bits&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 下面同scanobject</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 读取指针位置的内容</span></span><br><span class="line">                p := *(*<span class="type">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line">                <span class="keyword">if</span> p != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 需要进一步判断是不是指针类型</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 根据p查找mspan，找到了返回对象在mspan内的位置和对象起始地址</span></span><br><span class="line">                    <span class="keyword">if</span> obj, span, objIndex := findObject(p, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                        greyobject(obj, b, i, span, gcw, objIndex)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> stk != <span class="literal">nil</span> &amp;&amp; p &gt;= stk.stack.lo &amp;&amp; p &lt; stk.stack.hi &#123;</span><br><span class="line">                        <span class="comment">// 如果在mspan内找不到，检查这个地址是不是在栈内</span></span><br><span class="line">                        <span class="comment">// 在栈内则把指针放到stk.buf队列</span></span><br><span class="line">                        stk.putPtr(p, <span class="literal">false</span>)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 不管是heap管理还是手动管理的mspan都没找到</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右移1位</span></span><br><span class="line">            bits &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="comment">// 指针大小</span></span><br><span class="line">            i += goarch.PtrSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描一个对象（最多128KB，剩余放到任务缓冲区）内所有指针，设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanobject</span><span class="params">(b <span class="type">uintptr</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 提前加载数据到CPU缓存</span></span><br><span class="line">    sys.Prefetch(b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据地址找到heapArena再找到mspan</span></span><br><span class="line">    s := spanOfUnchecked(b)</span><br><span class="line">    <span class="comment">// 对象大小</span></span><br><span class="line">    n := s.elemsize</span><br><span class="line">    <span class="comment">// 为0，异常</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;scanobject n == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// noscan，不需要扫描</span></span><br><span class="line">    <span class="keyword">if</span> s.spanclass.noscan() &#123;</span><br><span class="line">        throw(<span class="string">&quot;scanobject of a noscan object&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tp typePointers</span><br><span class="line">    <span class="comment">// 大对象 elemsize&gt;128KB =&gt; 131072</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">        <span class="comment">// 先将整个mspan切块</span></span><br><span class="line">        <span class="keyword">if</span> b == s.base() &#123;</span><br><span class="line">            <span class="comment">// 按128KB分块，保留第一个块，剩下放到wbuf</span></span><br><span class="line">            <span class="keyword">for</span> oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes &#123;</span><br><span class="line">                <span class="comment">// 将对象放到wbuf-任务缓冲区，未初始化或已满直接返回</span></span><br><span class="line">                <span class="keyword">if</span> !gcw.putFast(oblet) &#123;</span><br><span class="line">                    <span class="comment">// 将对象放到wbuf-任务缓冲区，已满则从work.empty获取一个wbuf替换用</span></span><br><span class="line">                    gcw.put(oblet)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b到limit的字节数</span></span><br><span class="line">        n = s.base() + s.elemsize - b</span><br><span class="line">        <span class="comment">// n最多128KB =min(n,131072)</span></span><br><span class="line">        n = min(n, maxObletBytes)</span><br><span class="line">        <span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息</span></span><br><span class="line">        tp = s.typePointersOfUnchecked(s.base())</span><br><span class="line">        <span class="comment">// 地址往后移动n字节，获取实际对象地址和bitmap</span></span><br><span class="line">        tp = tp.fastForward(b-tp.addr, b+n)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// elemsize&lt;=128KB</span></span><br><span class="line">        <span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息</span></span><br><span class="line">        tp = s.typePointersOfUnchecked(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> scanSize <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> addr <span class="type">uintptr</span></span><br><span class="line">        <span class="comment">// 将mask第一个uint64内的第一个指针的位置为0，返回修改后的tp和指针地址</span></span><br><span class="line">        <span class="keyword">if</span> tp, addr = tp.nextFast(); addr == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// uint64没数据了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// mask第一个uint64不为0则调用nextFast，否则移动下一个uint64再重新判断</span></span><br><span class="line">            <span class="keyword">if</span> tp, addr = tp.next(b + n); addr == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 扫描到末尾还是没有</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已扫描字节数 =addr-b+8 =&gt; =scalar类型占用的字节数+8字节指针</span></span><br><span class="line">        scanSize = addr - b + goarch.PtrSize</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象指针</span></span><br><span class="line">        obj := *(*<span class="type">uintptr</span>)(unsafe.Pointer(addr))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指针不为0 and 超过对象大小或超过一个块大小</span></span><br><span class="line">        <span class="keyword">if</span> obj != <span class="number">0</span> &amp;&amp; obj-b &gt;= n &#123;</span><br><span class="line">            <span class="comment">// 指针不为0时需要进一步判断是不是指针类型</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据p查找mspan，找到了返回对象在mspan内的位置和对象起始地址</span></span><br><span class="line">            <span class="keyword">if</span> obj, span, objIndex := findObject(obj, b, addr-b); obj != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">                greyobject(obj, b, addr-b, span, gcw, objIndex)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被标记的字节总数</span></span><br><span class="line">    gcw.bytesMarked += <span class="type">uint64</span>(n)</span><br><span class="line">    <span class="comment">// 被扫描字节数</span></span><br><span class="line">    gcw.heapScanWork += <span class="type">int64</span>(scanSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据p查找mspan，找到了返回对象在mspan内的位置和对象起始地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findObject</span><span class="params">(p, refBase, refOff <span class="type">uintptr</span>)</span></span> (base <span class="type">uintptr</span>, s *mspan, objIndex <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据地址找到heapArena再找到mspan</span></span><br><span class="line">    s = spanOf(p)</span><br><span class="line">    <span class="comment">// p可能在data、bss段上或已释放或其他内存区域如mmap共享内存</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (GOARCH == <span class="string">&quot;amd64&quot;</span> || GOARCH == <span class="string">&quot;arm64&quot;</span>) &amp;&amp; p == clobberdeadPtr &amp;&amp; debug.invalidptr != <span class="number">0</span> &#123;</span><br><span class="line">            badPointer(s, p, refBase, refOff)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动管理内存（栈上的引用） or 指针不在mspan管理范围</span></span><br><span class="line">    <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse || p &lt; s.base() || p &gt;= s.limit &#123;</span><br><span class="line">        <span class="comment">// 手动管理内存</span></span><br><span class="line">        <span class="keyword">if</span> state == mSpanManual &#123;</span><br><span class="line">            <span class="comment">// 此时base、objIndex为0</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面三种情况之一，不管</span></span><br><span class="line">        <span class="comment">// 1. mspan是被释放的heap空间</span></span><br><span class="line">        <span class="comment">// 2. 是某个goroutine的栈</span></span><br><span class="line">        <span class="comment">// 3. 是通过unsafe操作、channel发送，临时出现在其他栈上的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> debug.invalidptr != <span class="number">0</span> &#123;</span><br><span class="line">            badPointer(s, p, refBase, refOff)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象在mspan内的位置</span></span><br><span class="line">    <span class="comment">// =(p-s.base)/s.elemsize</span></span><br><span class="line">    objIndex = s.objIndex(p)</span><br><span class="line">    <span class="comment">// 对象起始地址</span></span><br><span class="line">    base = s.base() + objIndex*s.elemsize</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greyobject</span><span class="params">(obj, base, off <span class="type">uintptr</span>, span *mspan, gcw *gcWork, objIndex <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//base和off用于debug，可以忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象是否是8的倍数</span></span><br><span class="line">    <span class="keyword">if</span> obj&amp;(goarch.PtrSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;greyobject: obj not pointer-aligned&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取该对象的bitmap（从gcmarkBits获取，第几个字节、字节内第几位）</span></span><br><span class="line">    mbits := span.markBitsForIndex(objIndex)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> useCheckmark &#123;</span><br><span class="line">        <span class="comment">// debug.gccheckmark不为0</span></span><br><span class="line">        <span class="keyword">if</span> setCheckmark(obj, base, off, mbits) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 看这里</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// debug.gccheckmark默认为0，忽略</span></span><br><span class="line">        <span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &amp;&amp; span.isFree(objIndex) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;runtime: marking free object &quot;</span>, hex(obj), <span class="string">&quot; found at *(&quot;</span>, hex(base), <span class="string">&quot;+&quot;</span>, hex(off), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">            gcDumpObject(<span class="string">&quot;base&quot;</span>, base, off)</span><br><span class="line">            gcDumpObject(<span class="string">&quot;obj&quot;</span>, obj, ^<span class="type">uintptr</span>(<span class="number">0</span>))</span><br><span class="line">            getg().m.traceback = <span class="number">2</span></span><br><span class="line">            throw(<span class="string">&quot;marking free object&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该位是否已经设置为1</span></span><br><span class="line">        <span class="keyword">if</span> mbits.isMarked() &#123;</span><br><span class="line">            <span class="comment">// 已设置，不处理</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该位设置为1（只要用mask跟gcmarkBits按位或）</span></span><br><span class="line">        mbits.setMarked()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据mspan起始地址获取heapArena、页索引、页bitmap位置</span></span><br><span class="line">        arena, pageIdx, pageMask := pageIndexOf(span.base())</span><br><span class="line">        <span class="comment">// 将这个页的bitmap设置为1（粗略，只设置一页，不是所有页，此外，pageMarks在GC启动时清0）</span></span><br><span class="line">        <span class="keyword">if</span> arena.pageMarks[pageIdx]&amp;pageMask == <span class="number">0</span> &#123;</span><br><span class="line">            atomic.Or8(&amp;arena.pageMarks[pageIdx], pageMask)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mspan是scalar类型，到这里结束，否则放进wbuf缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> span.spanclass.noscan() &#123;</span><br><span class="line">            <span class="comment">// 对象大小累计到bytesMarked-被标记的字节总数</span></span><br><span class="line">            gcw.bytesMarked += <span class="type">uint64</span>(span.elemsize)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前加载数据到CPU缓存</span></span><br><span class="line">    sys.Prefetch(obj)</span><br><span class="line">    <span class="comment">// 将对象放到wbuf-任务缓冲区，未初始化或已满直接返回</span></span><br><span class="line">    <span class="keyword">if</span> !gcw.putFast(obj) &#123;</span><br><span class="line">        <span class="comment">// 将对象放到wbuf-任务缓冲区，已满则从work.empty获取一个wbuf替换用</span></span><br><span class="line">        gcw.put(obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清扫器相关"><a href="#清扫器相关" class="headerlink" title="清扫器相关"></a>清扫器相关</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数器加1，返回mheap_.sweepgen及sweepDrainedMask标记是否已设置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *activeSweep)</span></span> begin() sweepLocker &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := a.state.Load()</span><br><span class="line">        <span class="comment">// 最高位不为0，队列已经没有sweeper</span></span><br><span class="line">        <span class="keyword">if</span> state&amp;sweepDrainedMask != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sweepLocker&#123;mheap_.sweepgen, <span class="literal">false</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器+1</span></span><br><span class="line">        <span class="keyword">if</span> a.state.CompareAndSwap(state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="keyword">return</span> sweepLocker&#123;mheap_.sweepgen, <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 失败重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *activeSweep)</span></span> end(sl sweepLocker) &#123;</span><br><span class="line">    <span class="keyword">if</span> sl.sweepGen != mheap_.sweepgen &#123;</span><br><span class="line">        throw(<span class="string">&quot;sweeper left outstanding across sweep generations&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := a.state.Load()</span><br><span class="line">        <span class="comment">// 丢弃最高位后减1</span></span><br><span class="line">        <span class="keyword">if</span> (state&amp;^sweepDrainedMask)<span class="number">-1</span> &gt;= sweepDrainedMask &#123;</span><br><span class="line">            throw(<span class="string">&quot;mismatched begin/end of activeSweep&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器减1</span></span><br><span class="line">        <span class="keyword">if</span> a.state.CompareAndSwap(state, state<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="comment">// 下面跟debug有关，忽略</span></span><br><span class="line">            <span class="keyword">if</span> state != sweepDrainedMask &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// debug，忽略</span></span><br><span class="line">            <span class="keyword">if</span> debug.gcpacertrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">                live := gcController.heapLive.Load()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;pacer: sweep done at heap size &quot;</span>, live&gt;&gt;<span class="number">20</span>, <span class="string">&quot;MB; allocated &quot;</span>, (live-mheap_.sweepHeapLiveBasis)&gt;&gt;<span class="number">20</span>, <span class="string">&quot;MB during sweep; swept &quot;</span>, mheap_.pagesSwept.Load(), <span class="string">&quot; pages at &quot;</span>, mheap_.sweepPagesPerByte, <span class="string">&quot; pages/byte\n&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 失败重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置sweepDrainedMask标记，表示sweep已完成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *activeSweep)</span></span> markDrained() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := a.state.Load()</span><br><span class="line">        <span class="comment">// 已设置</span></span><br><span class="line">        <span class="keyword">if</span> state&amp;sweepDrainedMask != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置sweepDrainedMask</span></span><br><span class="line">        <span class="keyword">if</span> a.state.CompareAndSwap(state, state|sweepDrainedMask) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获得mspan的所有权</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *sweepLocker)</span></span> tryAcquire(s *mspan) (sweepLocked, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// sweepDrainedMask标记已设置（表示sweeper队列为空）</span></span><br><span class="line">    <span class="keyword">if</span> !l.valid &#123;</span><br><span class="line">        throw(<span class="string">&quot;use of invalid sweepLocker&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态不符</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;s.sweepgen) != l.sweepGen<span class="number">-2</span> &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="keyword">return</span> sweepLocked&#123;&#125;, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从sweepGen-2改为sweepGen-1</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;s.sweepgen, l.sweepGen<span class="number">-2</span>, l.sweepGen<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新失败</span></span><br><span class="line">        <span class="keyword">return</span> sweepLocked&#123;&#125;, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新成功</span></span><br><span class="line">    <span class="keyword">return</span> sweepLocked&#123;s&#125;, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理一个mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sweepLocked)</span></span> sweep(preserve <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 禁止抢占标记</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.locks == <span class="number">0</span> &amp;&amp; gp.m.mallocing == <span class="number">0</span> &amp;&amp; gp != gp.m.g0 &#123;</span><br><span class="line">        throw(<span class="string">&quot;mspan.sweep: m is not locked&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s := sl.mspan</span><br><span class="line">    <span class="comment">// 如果不保留（一般情况下都是不保留，除了mcentral.cacheSpan）</span></span><br><span class="line">    <span class="keyword">if</span> !preserve &#123;</span><br><span class="line">        <span class="comment">// 释放所有权</span></span><br><span class="line">        sl.mspan = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sweepgen := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// 状态异常</span></span><br><span class="line">    <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse || s.sweepgen != sweepgen<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;mspan.sweep: state=&quot;</span>, state, <span class="string">&quot; sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; mheap.sweepgen=&quot;</span>, sweepgen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;mspan.sweep: bad span state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    mheap_.pagesSwept.Add(<span class="type">int64</span>(s.npages))</span><br><span class="line"></span><br><span class="line">    spc := s.spanclass</span><br><span class="line">    size := s.elemsize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 一个对象可同时拥有finalizer、profile，finalizer会加入队列，而profile则会被保留</span></span><br><span class="line">    <span class="comment">// 2. tiny对象可以有多个finalizer作用在不同的offset，需要一次性将所有finalizer加入队列</span></span><br><span class="line">    hadSpecials := s.specials != <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 纪录specials</span></span><br><span class="line">    siter := newSpecialsIter(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specials不为nil</span></span><br><span class="line">    <span class="keyword">for</span> siter.valid() &#123;</span><br><span class="line">        <span class="comment">// 对象起始索引</span></span><br><span class="line">        objIndex := <span class="type">uintptr</span>(siter.s.offset) / size</span><br><span class="line">        <span class="comment">// 对象起始地址</span></span><br><span class="line">        p := s.base() + objIndex*size</span><br><span class="line">        <span class="comment">// 获取该对象的bitmap（从gcmarkBits获取，第几个字节、字节内第几位）</span></span><br><span class="line">        mbits := s.markBitsForIndex(objIndex)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该位为0</span></span><br><span class="line">        <span class="keyword">if</span> !mbits.isMarked() &#123;</span><br><span class="line">            <span class="comment">// 检查是否有finalizer</span></span><br><span class="line">            hasFinAndRevived := <span class="literal">false</span></span><br><span class="line">            <span class="comment">// 终止地址的offset</span></span><br><span class="line">            endOffset := p - s.base() + size</span><br><span class="line">            <span class="comment">// 寻找finalizer</span></span><br><span class="line">            <span class="keyword">for</span> tmp := siter.s; tmp != <span class="literal">nil</span> &amp;&amp; <span class="type">uintptr</span>(tmp.offset) &lt; endOffset; tmp = tmp.next &#123;</span><br><span class="line">                <span class="comment">// 找到有finalizer</span></span><br><span class="line">                <span class="keyword">if</span> tmp.kind == _KindSpecialFinalizer &#123;</span><br><span class="line">                    <span class="comment">// bitmap该位设置为1（复活这个对象）</span></span><br><span class="line">                    mbits.setMarkedNonAtomic()</span><br><span class="line">                    hasFinAndRevived = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有finalizer</span></span><br><span class="line">            <span class="keyword">if</span> hasFinAndRevived &#123;</span><br><span class="line">                <span class="comment">// 把所有finalizer加入队列，清除所有weak handle</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扫描所有与对象相关的special纪录</span></span><br><span class="line">                <span class="keyword">for</span> siter.valid() &amp;&amp; <span class="type">uintptr</span>(siter.s.offset) &lt; endOffset &#123;</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    special := siter.s</span><br><span class="line">                    <span class="comment">// 对象地址</span></span><br><span class="line">                    p := s.base() + <span class="type">uintptr</span>(special.offset)</span><br><span class="line">                    <span class="comment">// finalizer or weak handle</span></span><br><span class="line">                    <span class="keyword">if</span> special.kind == _KindSpecialFinalizer || special.kind == _KindSpecialWeakHandle &#123;</span><br><span class="line">                        <span class="comment">// 把当前节点从链表里移除</span></span><br><span class="line">                        siter.unlinkAndNext()</span><br><span class="line">                        <span class="comment">// 释放special（不同类型的处理方式不同，有些实际上不需要释放）</span></span><br><span class="line">                        <span class="comment">// 如果是finalizer，则将finalizer信息加入队列，然后释放</span></span><br><span class="line">                        <span class="comment">// 如果是weak handle，则重置相关字段，然后释放</span></span><br><span class="line">                        freeSpecial(special, unsafe.Pointer(p), size)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 保留，其他类型的special都只会在对象释放时执行</span></span><br><span class="line">                        siter.next()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有finalizer</span></span><br><span class="line">                <span class="comment">// 对象已死，释放所有special</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扫描所有与对象相关的special纪录</span></span><br><span class="line">                <span class="keyword">for</span> siter.valid() &amp;&amp; <span class="type">uintptr</span>(siter.s.offset) &lt; endOffset &#123;</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    special := siter.s</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    p := s.base() + <span class="type">uintptr</span>(special.offset)</span><br><span class="line">                    <span class="comment">// 把当前节点从链表里移除</span></span><br><span class="line">                    siter.unlinkAndNext()</span><br><span class="line">                    <span class="comment">// 释放special（不同类型的处理方式不同，有些实际上不需要释放）</span></span><br><span class="line">                    freeSpecial(special, unsafe.Pointer(p), size)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果该位为1，寻找reachable类型的special</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果找到的是reachable（对象仍然存活）</span></span><br><span class="line">            <span class="keyword">if</span> siter.s.kind == _KindSpecialReachable &#123;</span><br><span class="line">                <span class="comment">// 把当前节点从链表里移除</span></span><br><span class="line">                special := siter.unlinkAndNext()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 以下两行代码更新reachable和done字段，不需要释放</span></span><br><span class="line">                (*specialReachable)(unsafe.Pointer(special)).reachable = <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 释放special（不同类型的处理方式不同，有些实际上不需要释放）</span></span><br><span class="line">                freeSpecial(special, unsafe.Pointer(p), size)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 扫描下一个</span></span><br><span class="line">                siter.next()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// special已全部释放</span></span><br><span class="line">    <span class="keyword">if</span> hadSpecials &amp;&amp; s.specials == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 更新pageSpecials</span></span><br><span class="line">        spanHasNoSpecials(s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查僵尸对象</span></span><br><span class="line">    <span class="keyword">if</span> s.freeindex &lt; s.nelems &#123;</span><br><span class="line">        <span class="comment">// &lt;freeindex的对象不能是僵尸对象</span></span><br><span class="line"></span><br><span class="line">        obj := <span class="type">uintptr</span>(s.freeindex)</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (*s.gcmarkBits.bytep(obj / <span class="number">8</span>)&amp;^*s.allocBits.bytep(obj / <span class="number">8</span>))&gt;&gt;(obj%<span class="number">8</span>) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 打印mspann内标记但已释放的对象并抛出异常</span></span><br><span class="line">            s.reportZombies()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查剩余字节</span></span><br><span class="line">        <span class="keyword">for</span> i := obj/<span class="number">8</span> + <span class="number">1</span>; i &lt; divRoundUp(<span class="type">uintptr</span>(s.nelems), <span class="number">8</span>); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> *s.gcmarkBits.bytep(i)&amp;^*s.allocBits.bytep(i) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 打印mspann内标记但已释放的对象并抛出异常</span></span><br><span class="line">                s.reportZombies()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过gcmarkBits计算已用对象数</span></span><br><span class="line">    nalloc := <span class="type">uint16</span>(s.countAlloc())</span><br><span class="line">    <span class="comment">// 释放的对象数量</span></span><br><span class="line">    nfreed := s.allocCount - nalloc</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> nalloc &gt; s.allocCount &#123;</span><br><span class="line">        <span class="comment">// 僵尸对象检查应该已经解决这个问题</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: nelems=&quot;</span>, s.nelems, <span class="string">&quot; nalloc=&quot;</span>, nalloc, <span class="string">&quot; previous allocCount=&quot;</span>, s.allocCount, <span class="string">&quot; nfreed=&quot;</span>, nfreed, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;sweep increased allocation count&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    s.allocCount = nalloc</span><br><span class="line">    s.freeindex = <span class="number">0</span></span><br><span class="line">    s.freeIndexForScan = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用gcmarkBits替换allocBits</span></span><br><span class="line">    s.allocBits = s.gcmarkBits</span><br><span class="line">    <span class="comment">// 从gcBitsArenas分配足以容纳nelems个位的内存（64的倍数向上取整）</span></span><br><span class="line">    s.gcmarkBits = newMarkBits(<span class="type">uintptr</span>(s.nelems))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// refresh pinnerBits if they exists</span></span><br><span class="line">    <span class="keyword">if</span> s.pinnerBits != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.refreshPinnerBits()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从s.allocBits分配8个字节替换为新的s.allocCache</span></span><br><span class="line">    s.refillAllocCache(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sweepgen更新前检查</span></span><br><span class="line">    <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse || s.sweepgen != sweepgen<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;mspan.sweep: state=&quot;</span>, state, <span class="string">&quot; sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; mheap.sweepgen=&quot;</span>, sweepgen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;mspan.sweep: bad span state after sweep&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.sweepgen == sweepgen+<span class="number">1</span> || s.sweepgen == sweepgen+<span class="number">3</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;swept cached span&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新为mheap.sweepgen</span></span><br><span class="line">    atomic.Store(&amp;s.sweepgen, sweepgen)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归属于arena包，用户手动管理，暂时忽略</span></span><br><span class="line">    <span class="keyword">if</span> s.isUserArenaChunk &#123;</span><br><span class="line">        <span class="comment">// 保留，异常</span></span><br><span class="line">        <span class="keyword">if</span> preserve &#123;</span><br><span class="line">            throw(<span class="string">&quot;sweep: tried to preserve a user arena span&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> nalloc &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// mspan还有指针、未释放，放入full swept链表</span></span><br><span class="line">            mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nalloc为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        mheap_.pagesInUse.Add(-s.npages)</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        s.state.set(mSpanDead)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从quarantineList移除，放入readyList</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 异常</span></span><br><span class="line">            <span class="keyword">if</span> s.list != &amp;mheap_.userArena.quarantineList &#123;</span><br><span class="line">                throw(<span class="string">&quot;user arena span is on the wrong list&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            lock(&amp;mheap_.lock)</span><br><span class="line">            mheap_.userArena.quarantineList.remove(s)</span><br><span class="line">            mheap_.userArena.readyList.insert(s)</span><br><span class="line">            unlock(&amp;mheap_.lock)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap管理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小对象</span></span><br><span class="line">    <span class="keyword">if</span> spc.sizeclass() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 有nfreed个对象被释放</span></span><br><span class="line">        <span class="keyword">if</span> nfreed &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 标记为需要清0</span></span><br><span class="line">            s.needzero = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            stats := memstats.heapStats.acquire()</span><br><span class="line">            atomic.Xadd64(&amp;stats.smallFreeCount[spc.sizeclass()], <span class="type">int64</span>(nfreed))</span><br><span class="line">            memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            gcController.totalFree.Add(<span class="type">int64</span>(nfreed) * <span class="type">int64</span>(s.elemsize))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不保留</span></span><br><span class="line">        <span class="keyword">if</span> !preserve &#123;</span><br><span class="line">            <span class="comment">// 全部对象都已释放</span></span><br><span class="line">            <span class="keyword">if</span> nalloc == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 释放页和mspan</span></span><br><span class="line">                mheap_.freeSpan(s)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nalloc == s.nelems &#123;</span><br><span class="line">                <span class="comment">// mspan已满</span></span><br><span class="line">                <span class="comment">// 放入full swept链表</span></span><br><span class="line">                mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mspan未满</span></span><br><span class="line">                <span class="comment">// 放入partial swept链表</span></span><br><span class="line">                mheap_.central[spc].mcentral.partialSwept(sweepgen).push(s)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !preserve &#123;</span><br><span class="line">        <span class="comment">// 大对象 and 不保留</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有nfreed个对象被释放</span></span><br><span class="line">        <span class="keyword">if</span> nfreed != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            stats := memstats.heapStats.acquire()</span><br><span class="line">            atomic.Xadd64(&amp;stats.largeFreeCount, <span class="number">1</span>)</span><br><span class="line">            atomic.Xadd64(&amp;stats.largeFree, <span class="type">int64</span>(size))</span><br><span class="line">            memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            gcController.totalFree.Add(<span class="type">int64</span>(size))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// debug，忽略</span></span><br><span class="line">            <span class="keyword">if</span> debug.efence &gt; <span class="number">0</span> &#123;</span><br><span class="line">                s.limit = <span class="number">0</span> <span class="comment">// prevent mlookup from finding this span</span></span><br><span class="line">                sysFault(unsafe.Pointer(s.base()), size)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 释放页和mspan</span></span><br><span class="line">                mheap_.freeSpan(s)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无对象释放</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入full swept链表</span></span><br><span class="line">        mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大对象 and 保留</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存回收器相关"><a href="#内存回收器相关" class="headerlink" title="内存回收器相关"></a>内存回收器相关</h3><h4 id="scavengerState-节奏调度器"><a href="#scavengerState-节奏调度器" class="headerlink" title="scavengerState-节奏调度器"></a>scavengerState-节奏调度器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scavenger初始化，绑定g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> init() &#123;</span><br><span class="line">    <span class="keyword">if</span> s.g != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;scavenger state is already wired&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    lockInit(&amp;s.lock, lockRankScavenge)</span><br><span class="line">    <span class="comment">// 绑定g</span></span><br><span class="line">    s.g = getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器</span></span><br><span class="line">    s.timer = <span class="built_in">new</span>(timer)</span><br><span class="line">    <span class="comment">// 过期函数</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(s any, _ <span class="type">uintptr</span>, _ <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 重置scavenger状态，修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">        s.(*scavengerState).wake()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mu/f/arg参数初始化</span></span><br><span class="line">    s.timer.init(f, s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    s.sleepController = piController&#123;</span><br><span class="line">        <span class="comment">// Tuned loosely via Ziegler-Nichols process.</span></span><br><span class="line">        kp: <span class="number">0.3375</span>,</span><br><span class="line">        ti: <span class="number">3.2e6</span>,</span><br><span class="line">        tt: <span class="number">1e9</span>,    <span class="comment">// 1s</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        min: <span class="number">0.001</span>,  <span class="comment">// 1:1000</span></span><br><span class="line">        max: <span class="number">1000.0</span>, <span class="comment">// 1000:1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =0.001</span></span><br><span class="line">    s.sleepRatio = startingScavSleepRatio</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="keyword">if</span> s.scavenge == <span class="literal">nil</span> &#123;</span><br><span class="line">        s.scavenge = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">uintptr</span>)</span></span> (<span class="type">uintptr</span>, <span class="type">int64</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前时刻</span></span><br><span class="line">            start := nanotime()</span><br><span class="line">            <span class="comment">// func (p *pageAlloc) scavenge(nbytes uintptr, shouldStop func() bool, force bool) uintptr</span></span><br><span class="line">            <span class="comment">// 回收指定字节数量的内存（扫描时是从高地址向低地址进行搜索）</span></span><br><span class="line">            r := mheap_.pages.scavenge(n, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">            <span class="comment">// 当前时刻</span></span><br><span class="line">            end := nanotime()</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">                <span class="keyword">return</span> r, <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            scavenge.backgroundTime.Add(end - start)</span><br><span class="line">            <span class="keyword">return</span> r, end - start</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scavenger是否需要停止</span></span><br><span class="line">    <span class="keyword">if</span> s.shouldStop == <span class="literal">nil</span> &#123;</span><br><span class="line">        s.shouldStop = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="comment">// heap内存没有超过GC触发临界点 and 总内存没有超过限制</span></span><br><span class="line">            <span class="keyword">return</span> heapRetained() &lt;= scavenge.gcPercentGoal.Load() &amp;&amp;</span><br><span class="line">                gcController.mappedReady.Load() &lt;= scavenge.memoryLimitGoal.Load()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试用</span></span><br><span class="line">    <span class="keyword">if</span> s.gomaxprocs == <span class="literal">nil</span> &#123;</span><br><span class="line">        s.gomaxprocs = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gomaxprocs</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scavenger让出CPU挂起休眠</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> park() &#123;</span><br><span class="line">    lock(&amp;s.lock)</span><br><span class="line">    <span class="comment">// 其他g调用</span></span><br><span class="line">    <span class="keyword">if</span> getg() != s.g &#123;</span><br><span class="line">        throw(<span class="string">&quot;tried to park scavenger from another goroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示挂起</span></span><br><span class="line">    s.parked = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 当前g让出CPU，g0执行调度运行其他g（在内部g、m解除绑定后会解锁lock）</span></span><br><span class="line">    goparkunlock(&amp;s.lock, waitReasonGCScavengeWait, traceBlockSystemGoroutine, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 被唤醒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知sysmon唤醒scavenger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> ready() &#123;</span><br><span class="line">    s.sysmonWake.Store(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置scavenger状态，修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> wake() &#123;</span><br><span class="line">    lock(&amp;s.lock)</span><br><span class="line">    <span class="comment">// scavenger是否挂起休眠中</span></span><br><span class="line">    <span class="keyword">if</span> s.parked &#123;</span><br><span class="line">        <span class="comment">// 重置sysmonWake</span></span><br><span class="line">        s.sysmonWake.Store(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置parked</span></span><br><span class="line">        s.parked = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> list gList</span><br><span class="line">        list.push(s.g)</span><br><span class="line">        <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">        injectglist(&amp;list)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;s.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让出CPU挂起一段时间，更新sleepRatio等信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> sleep(worked <span class="type">float64</span>) &#123;</span><br><span class="line">    lock(&amp;s.lock)</span><br><span class="line">    <span class="keyword">if</span> getg() != s.g &#123;</span><br><span class="line">        throw(<span class="string">&quot;tried to sleep scavenger from another goroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// worked最低为1ms</span></span><br><span class="line">    <span class="keyword">if</span> worked &lt; minScavWorkTime &#123;</span><br><span class="line">        worked = minScavWorkTime</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =worked*1.7</span></span><br><span class="line">    worked *= <span class="number">1</span> + scavengeCostRatio</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =worked/sleepRatio =&gt; sleepRatio默认初始值为0.001</span></span><br><span class="line">    sleepTime := <span class="type">int64</span>(worked / s.sleepRatio)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> slept <span class="type">int64</span></span><br><span class="line">    <span class="comment">// 一般情况下都是nil</span></span><br><span class="line">    <span class="keyword">if</span> s.sleepStub == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 设置定时器</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始时刻</span></span><br><span class="line">        start := nanotime()</span><br><span class="line">        <span class="comment">// 重置，设置睡眠时间</span></span><br><span class="line">        s.timer.reset(start+sleepTime, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示挂起</span></span><br><span class="line">        s.parked = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 当前g让出CPU，g0执行调度运行其他g（在内部g、m解除绑定后会解锁lock）</span></span><br><span class="line">        goparkunlock(&amp;s.lock, waitReasonSleep, traceBlockSleep, <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算休眠耗时</span></span><br><span class="line">        slept = nanotime() - start</span><br><span class="line"></span><br><span class="line">        lock(&amp;s.lock)</span><br><span class="line">        <span class="comment">// 停止定时器，不管是否成功</span></span><br><span class="line">        s.timer.stop()</span><br><span class="line">        unlock(&amp;s.lock)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        unlock(&amp;s.lock)</span><br><span class="line">        slept = s.sleepStub(sleepTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> s.controllerCooldown &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        t := slept + <span class="type">int64</span>(worked)</span><br><span class="line">        <span class="keyword">if</span> t &gt; s.controllerCooldown &#123;</span><br><span class="line">            s.controllerCooldown = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.controllerCooldown -= t</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =1/100</span></span><br><span class="line">    idealFraction := <span class="type">float64</span>(scavengePercent) / <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算CPU耗时</span></span><br><span class="line">    cpuFraction := worked / ((<span class="type">float64</span>(slept) + worked) * <span class="type">float64</span>(s.gomaxprocs()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    s.sleepRatio, ok = s.sleepController.next(cpuFraction, idealFraction, <span class="type">float64</span>(slept)+worked)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="comment">// =0.001</span></span><br><span class="line">        s.sleepRatio = startingScavSleepRatio</span><br><span class="line">        <span class="comment">// 5秒</span></span><br><span class="line">        s.controllerCooldown = <span class="number">5e9</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将printControllerReset置为true</span></span><br><span class="line">        s.controllerFailed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行mheap_.pages.scavenge，直到heap耗尽</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengerState)</span></span> run() (released <span class="type">uintptr</span>, worked <span class="type">float64</span>) &#123;</span><br><span class="line">    lock(&amp;s.lock)</span><br><span class="line">    <span class="keyword">if</span> getg() != s.g &#123;</span><br><span class="line">        throw(<span class="string">&quot;tried to run scavenger from another goroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;s.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;1ms</span></span><br><span class="line">    <span class="keyword">for</span> worked &lt; minScavWorkTime &#123;</span><br><span class="line">        <span class="comment">// 如果scavenger需要停止</span></span><br><span class="line">        <span class="keyword">if</span> s.shouldStop() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 64KB</span></span><br><span class="line">        <span class="keyword">const</span> scavengeQuantum = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行mheap_.pages.scavenge，回收指定字节数量的内存，统计累计耗时</span></span><br><span class="line">        r, duration := s.scavenge(scavengeQuantum)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设每个物理页需耗时10µs</span></span><br><span class="line">        <span class="keyword">const</span> approxWorkedNSPerPhysicalPage = <span class="number">10e3</span></span><br><span class="line">        <span class="keyword">if</span> duration == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 耗时为0</span></span><br><span class="line">            <span class="comment">// 总耗时+=10µs*r/physPageSize</span></span><br><span class="line">            worked += approxWorkedNSPerPhysicalPage * <span class="type">float64</span>(r/physPageSize)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 耗时不为0</span></span><br><span class="line">            <span class="comment">// 直接累计</span></span><br><span class="line">            worked += <span class="type">float64</span>(duration)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放字节数</span></span><br><span class="line">        released += r</span><br><span class="line"></span><br><span class="line">        <span class="comment">// r&lt;64KB</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; scavengeQuantum &#123;</span><br><span class="line">            <span class="comment">// heap已经耗尽</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用faketime时，只执行一次</span></span><br><span class="line">        <span class="keyword">if</span> faketime != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 期望是整页，这里不足1页，异常</span></span><br><span class="line">    <span class="keyword">if</span> released &gt; <span class="number">0</span> &amp;&amp; released &lt; physPageSize &#123;</span><br><span class="line">        throw(<span class="string">&quot;released less than one physical page of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="scavengeIndex-回收索引"><a href="#scavengeIndex-回收索引" class="headerlink" title="scavengeIndex-回收索引"></a>scavengeIndex-回收索引</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> init(test <span class="type">bool</span>, sysStat *sysMemStat) <span class="type">uintptr</span> &#123;</span><br><span class="line">    s.searchAddrBg.Clear()    <span class="comment">// 设为0</span></span><br><span class="line">    s.searchAddrForce.Clear() <span class="comment">// 设为0</span></span><br><span class="line">    s.freeHWM = minOffAddr    <span class="comment">// 最小地址0xffff800000000000</span></span><br><span class="line">    s.test = test</span><br><span class="line">    <span class="comment">// 从系统申请内存（Reserved）初始化chunks（512MB）</span></span><br><span class="line">    <span class="keyword">return</span> s.sysInit(test, sysStat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从系统申请内存（Reserved）初始化chunks（512MB）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> sysInit(test <span class="type">bool</span>, sysStat *sysMemStat) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// =1&lt;&lt;48/4194304 =&gt; 最大地址能分多少个chunk =&gt; 64M个chunk</span></span><br><span class="line">    n := <span class="type">uintptr</span>(<span class="number">1</span>&lt;&lt;heapAddrBits) / pallocChunkBytes</span><br><span class="line">    <span class="comment">// =n*8 =&gt; 512MB</span></span><br><span class="line">    nbytes := n * unsafe.Sizeof(atomicScavChunkData&#123;&#125;)</span><br><span class="line">    <span class="comment">// 向系统申请内存（Reserved）</span></span><br><span class="line">    r := sysReserve(<span class="literal">nil</span>, nbytes)</span><br><span class="line">    sl := notInHeapSlice&#123;(*notInHeap)(r), <span class="type">int</span>(n), <span class="type">int</span>(n)&#125;</span><br><span class="line">    s.chunks = *(*[]atomicScavChunkData)(unsafe.Pointer(&amp;sl))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新minHeapIdx，分配/映射物理内存使地址变为可用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> grow(base, limit <span class="type">uintptr</span>, sysStat *sysMemStat) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 更新minHeapIdx</span></span><br><span class="line">    minHeapIdx := s.minHeapIdx.Load()</span><br><span class="line">    <span class="keyword">if</span> baseIdx := <span class="type">uintptr</span>(chunkIndex(base)); minHeapIdx == <span class="number">0</span> || baseIdx &lt; minHeapIdx &#123;</span><br><span class="line">        <span class="comment">// 不为0时=min(minHeapIdx,baseIdx)</span></span><br><span class="line">        s.minHeapIdx.Store(baseIdx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在指定的虚拟地址范围内分配/映射物理内存，让该地址变为可用</span></span><br><span class="line">    <span class="keyword">return</span> s.sysGrow(base, limit, sysStat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定的虚拟地址范围内分配/映射物理内存，让该地址变为可用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> sysGrow(base, limit <span class="type">uintptr</span>, sysStat *sysMemStat) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 4MB对齐</span></span><br><span class="line">    <span class="keyword">if</span> base%pallocChunkBytes != <span class="number">0</span> || limit%pallocChunkBytes != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: base = &quot;</span>, hex(base), <span class="string">&quot;, limit = &quot;</span>, hex(limit), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;sysGrow bounds not aligned to pallocChunkBytes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sc大小</span></span><br><span class="line">    scSize := unsafe.Sizeof(atomicScavChunkData&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    haveMin := s.min.Load()</span><br><span class="line">    haveMax := s.max.Load()</span><br><span class="line">    <span class="comment">// 向下取整</span></span><br><span class="line">    needMin := alignDown(<span class="type">uintptr</span>(chunkIndex(base)), physPageSize/scSize)</span><br><span class="line">    <span class="comment">// 向上取整</span></span><br><span class="line">    needMax := alignUp(<span class="type">uintptr</span>(chunkIndex(limit)), physPageSize/scSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> needMax &lt; haveMin &#123;</span><br><span class="line">        needMax = haveMin</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> haveMax != <span class="number">0</span> &amp;&amp; needMin &gt; haveMax &#123;</span><br><span class="line">        needMin = haveMax</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个chunk</span></span><br><span class="line">    chunksBase := <span class="type">uintptr</span>(unsafe.Pointer(&amp;s.chunks[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment">// 封装base、limit</span></span><br><span class="line">    have := makeAddrRange(chunksBase+haveMin*scSize, chunksBase+haveMax*scSize)</span><br><span class="line">    need := makeAddrRange(chunksBase+needMin*scSize, chunksBase+needMax*scSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 根据地址计算出起始、终止索引</span></span><br><span class="line">    <span class="comment">// 2. need根据have的地址范围调整base和limit</span></span><br><span class="line">    need = need.subtract(have)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果need的地址范围被包含在have的地址范围内时，base和limit设置为0</span></span><br><span class="line">    <span class="keyword">if</span> need.size() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 使用sysMap直接映射，内存状态从Reserved改为Prepared</span></span><br><span class="line">        sysMap(unsafe.Pointer(need.base.addr()), need.size(), sysStat)</span><br><span class="line">        <span class="comment">// 内存状态从Prepared改为Ready</span></span><br><span class="line">        sysUsed(unsafe.Pointer(need.base.addr()), need.size(), need.size())</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> haveMax == <span class="number">0</span> || needMin &lt; haveMin &#123;</span><br><span class="line">            s.min.Store(needMin)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> needMax &gt; haveMax &#123;</span><br><span class="line">            s.max.Store(needMax)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容字节大小</span></span><br><span class="line">    <span class="keyword">return</span> need.size()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可能含有可清理页的chunk的最大索引（扫描时是从高地址向低地址进行搜索）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> find(force <span class="type">bool</span>) (chunkIdx, <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据force选择搜索地址</span></span><br><span class="line">    cursor := &amp;s.searchAddrBg</span><br><span class="line">    <span class="keyword">if</span> force &#123;</span><br><span class="line">        cursor = &amp;s.searchAddrForce</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面负数表示marked，绝对值为地址</span></span><br><span class="line">    searchAddr, marked := cursor.Load()</span><br><span class="line">    <span class="comment">// 如果是最小地址0xffff800000000000</span></span><br><span class="line">    <span class="keyword">if</span> searchAddr == minOffAddr.addr() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gen := s.gen</span><br><span class="line">    <span class="comment">// 最小chunk索引</span></span><br><span class="line">    min := chunkIdx(s.minHeapIdx.Load())</span><br><span class="line">    <span class="comment">// 搜索地址chunk索引</span></span><br><span class="line">    start := chunkIndex(searchAddr)</span><br><span class="line">    <span class="comment">// 从高到低扫描</span></span><br><span class="line">    <span class="keyword">for</span> i := start; i &gt;= min; i-- &#123;</span><br><span class="line">        <span class="comment">// chunk不需要回收内存</span></span><br><span class="line">        <span class="keyword">if</span> !s.chunks[i].load().shouldScavenge(gen, force) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个</span></span><br><span class="line">        <span class="keyword">if</span> i == start &#123;</span><br><span class="line">            <span class="comment">// i, 位于512位bitmap的位置</span></span><br><span class="line">            <span class="keyword">return</span> i, chunkPageIndex(searchAddr)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =searchAddr+4MB-8KB</span></span><br><span class="line">        newSearchAddr := chunkBase(i) + pallocChunkBytes - pageSize</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> marked &#123;</span><br><span class="line">            <span class="comment">// 替换为newSearchAddr（负数-&gt;正数）</span></span><br><span class="line">            cursor.StoreUnmark(searchAddr, newSearchAddr)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 替换为newSearchAddr（正数-&gt;正数）</span></span><br><span class="line">            cursor.StoreMin(newSearchAddr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i,511</span></span><br><span class="line">        <span class="keyword">return</span> i, pallocChunkPages - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// searchAddrBg或searchAddrForce设为0</span></span><br><span class="line">    cursor.Clear()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等。防止scavenger错误回收已分配的页</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> alloc(ci chunkIdx, npages <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取scavChunkData</span></span><br><span class="line">    sc := s.chunks[ci].load()</span><br><span class="line">    <span class="comment">// 更新元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">    sc.alloc(npages, s.gen)</span><br><span class="line">    <span class="comment">// 回写</span></span><br><span class="line">    s.chunks[ci].store(sc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> free(ci chunkIdx, page, npages <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// chunk</span></span><br><span class="line">    sc := s.chunks[ci].load()</span><br><span class="line">    <span class="comment">// 更新元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line">    sc.free(npages, s.gen)</span><br><span class="line">    <span class="comment">// 回写</span></span><br><span class="line">    s.chunks[ci].store(sc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新freeHWM</span></span><br><span class="line">    <span class="comment">// =chunk起始地址+(页索引+n-1)*8192</span></span><br><span class="line">    addr := chunkBase(ci) + <span class="type">uintptr</span>(page+npages<span class="number">-1</span>)*pageSize</span><br><span class="line">    <span class="keyword">if</span> s.freeHWM.lessThan(offAddr&#123;addr&#125;) &#123;</span><br><span class="line">        s.freeHWM = offAddr&#123;addr&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面负数表示marked，绝对值为地址</span></span><br><span class="line">    <span class="comment">// 更新searchAddrForce</span></span><br><span class="line">    searchAddr, _ := s.searchAddrForce.Load()</span><br><span class="line">    <span class="keyword">if</span> (offAddr&#123;searchAddr&#125;).lessThan(offAddr&#123;addr&#125;) &#123;</span><br><span class="line">        s.searchAddrForce.StoreMarked(addr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新scavengeIndex版本计数器、searchAddr、freeHWM</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scavengeIndex)</span></span> nextGen() &#123;</span><br><span class="line">    <span class="comment">// 版本计数器+=1</span></span><br><span class="line">    s.gen++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面负数表示marked，绝对值为地址</span></span><br><span class="line">    <span class="comment">// searchAddrBg=max(searchAddrBg,freeHWM)</span></span><br><span class="line">    searchAddr, _ := s.searchAddrBg.Load()</span><br><span class="line">    <span class="keyword">if</span> (offAddr&#123;searchAddr&#125;).lessThan(s.freeHWM) &#123;</span><br><span class="line">        s.searchAddrBg.StoreMarked(s.freeHWM.addr())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基地址 0xffff800000000000</span></span><br><span class="line">    s.freeHWM = minOffAddr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *scavChunkData)</span></span> alloc(npages <span class="type">uint</span>, newGen <span class="type">uint32</span>) &#123;</span><br><span class="line">    <span class="comment">// 超过512个页</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uint</span>(sc.inUse)+npages &gt; pallocChunkPages &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: inUse=&quot;</span>, sc.inUse, <span class="string">&quot; npages=&quot;</span>, npages, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;too many pages allocated in chunk?&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 版本不一致</span></span><br><span class="line">    <span class="keyword">if</span> sc.gen != newGen &#123;</span><br><span class="line">        <span class="comment">// 纪录历史版本</span></span><br><span class="line">        sc.lastInUse = sc.inUse</span><br><span class="line">        <span class="comment">// 同步</span></span><br><span class="line">        sc.gen = newGen</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sc.inUse += <span class="type">uint16</span>(npages)</span><br><span class="line">    <span class="comment">// ==512</span></span><br><span class="line">    <span class="keyword">if</span> sc.inUse == pallocChunkPages &#123;</span><br><span class="line">        <span class="comment">// 清除scavChunkHasFree标志</span></span><br><span class="line">        sc.setEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新指定chunk元信息，如inUse、gen、scavChunkFlags等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *scavChunkData)</span></span> free(npages <span class="type">uint</span>, newGen <span class="type">uint32</span>) &#123;</span><br><span class="line">    <span class="comment">// 相减会小于0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uint</span>(sc.inUse) &lt; npages &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: inUse=&quot;</span>, sc.inUse, <span class="string">&quot; npages=&quot;</span>, npages, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;allocated pages below zero?&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    <span class="keyword">if</span> sc.gen != newGen &#123;</span><br><span class="line">        <span class="comment">// 纪录上一个inUse</span></span><br><span class="line">        sc.lastInUse = sc.inUse</span><br><span class="line">        <span class="comment">// 更新版本</span></span><br><span class="line">        sc.gen = newGen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回收n页</span></span><br><span class="line">    sc.inUse -= <span class="type">uint16</span>(npages)</span><br><span class="line">    <span class="comment">// 设置scavChunkHasFree标志</span></span><br><span class="line">    sc.setNonEmpty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chunk是否需要回收内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc scavChunkData)</span></span> shouldScavenge(currGen <span class="type">uint32</span>, force <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 没有scavChunkHasFree标志</span></span><br><span class="line">    <span class="keyword">if</span> sc.isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制性</span></span><br><span class="line">    <span class="keyword">if</span> force &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本一致</span></span><br><span class="line">    <span class="keyword">if</span> sc.gen == currGen &#123;</span><br><span class="line">        <span class="comment">// &lt;496</span></span><br><span class="line">        <span class="keyword">return</span> sc.inUse &lt; scavChunkHiOccPages &amp;&amp; sc.lastInUse &lt; scavChunkHiOccPages</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本不一致</span></span><br><span class="line">    <span class="comment">// &lt;496</span></span><br><span class="line">    <span class="keyword">return</span> sc.inUse &lt; scavChunkHiOccPages</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存管理相关"><a href="#内存管理相关" class="headerlink" title="内存管理相关"></a>内存管理相关</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据centralIndex获取mspan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> nextSpanForSweep() *mspan &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sg := h.sweepgen</span><br><span class="line">    <span class="comment">// centralIndex &lt; 272</span></span><br><span class="line">    <span class="keyword">for</span> sc := sweep.centralIndex.load(); sc &lt; numSweepClasses; sc++ &#123;</span><br><span class="line">        <span class="comment">// spc = sweepClass&gt;&gt;1; full = sweepClass&amp;1==0</span></span><br><span class="line">        spc, full := sc.split()</span><br><span class="line">        <span class="comment">// 获取mcentral</span></span><br><span class="line">        c := &amp;h.central[spc].mcentral</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> s *mspan</span><br><span class="line">        <span class="keyword">if</span> full &#123;</span><br><span class="line">            <span class="comment">// full类型</span></span><br><span class="line">            <span class="comment">// 从full[1-sweepgen/2%2]尾部获取一个mspan</span></span><br><span class="line">            s = c.fullUnswept(sg).pop()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// partial类型</span></span><br><span class="line">            <span class="comment">// 从partial[1-sweepgen/2%2]尾部获取一个mspan</span></span><br><span class="line">            s = c.partialUnswept(sg).pop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取mspan成功</span></span><br><span class="line">        <span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// func (s *sweepClass) update(sNew sweepClass)</span></span><br><span class="line">            <span class="comment">// 用sc替换centralIndex（前提：sc &lt; centralIndex）</span></span><br><span class="line">            sweep.centralIndex.update(sc)</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到这里，没有找到任何mspan</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// func (s *sweepClass) update(sNew sweepClass)</span></span><br><span class="line">    <span class="comment">// 32位全设置为1</span></span><br><span class="line">    sweep.centralIndex.update(sweepClassDone)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用sNew替换s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sweepClass)</span></span> update(sNew sweepClass) &#123;</span><br><span class="line">    <span class="comment">// 旧值</span></span><br><span class="line">    sOld := s.load()</span><br><span class="line">    <span class="comment">// 只有旧值比新值小才替换</span></span><br><span class="line">    <span class="keyword">for</span> sOld &lt; sNew &amp;&amp; !atomic.Cas((*<span class="type">uint32</span>)(s), <span class="type">uint32</span>(sOld), <span class="type">uint32</span>(sNew)) &#123;</span><br><span class="line">        sOld = s.load()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新pageSpecials</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spanHasNoSpecials</span><span class="params">(s *mspan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// arena内第几个页</span></span><br><span class="line">    arenaPage := (s.base() / pageSize) % pagesPerArena</span><br><span class="line">    <span class="comment">// arena索引</span></span><br><span class="line">    ai := arenaIndex(s.base())</span><br><span class="line">    <span class="comment">// 找到heapArena</span></span><br><span class="line">    ha := mheap_.arenas[ai.l1()][ai.l2()]</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    atomic.And8(&amp;ha.pageSpecials[arenaPage/<span class="number">8</span>], ^(<span class="type">uint8</span>(<span class="number">1</span>) &lt;&lt; (arenaPage % <span class="number">8</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过gcmarkBits计算已用对象数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span></span> countAlloc() <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 按8的倍数向上取整</span></span><br><span class="line">    bytes := divRoundUp(<span class="type">uintptr</span>(s.nelems), <span class="number">8</span>)</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bytes; i += <span class="number">8</span> &#123;</span><br><span class="line">        mrkBits := *(*<span class="type">uint64</span>)(unsafe.Pointer(s.gcmarkBits.bytep(i)))</span><br><span class="line">        <span class="comment">// 不区分大端/小端，只计算有多少个1</span></span><br><span class="line">        count += sys.OnesCount64(mrkBits)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息（大对象）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> typePointersOfType(typ *abi.Type, addr <span class="type">uintptr</span>) typePointers &#123;</span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">const</span> doubleCheck = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> doubleCheck &amp;&amp; typ == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad type passed to typePointersOfType&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// noscan类型</span></span><br><span class="line">    <span class="keyword">if</span> span.spanclass.noscan() &#123;</span><br><span class="line">        <span class="keyword">return</span> typePointers&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据类型的GCMask</span></span><br><span class="line">    gcmask := getGCMask(typ)</span><br><span class="line">    <span class="comment">// 这里应该是大对象才有</span></span><br><span class="line">    <span class="keyword">return</span> typePointers&#123;elem: addr, addr: addr, mask: readUintptr(gcmask), typ: typ&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息（小对象/对象内部）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> typePointersOf(addr, size <span class="type">uintptr</span>) typePointers &#123;</span><br><span class="line">    <span class="comment">// 从mspan内地址转全局地址</span></span><br><span class="line">    base := span.objBase(addr)</span><br><span class="line">    <span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息</span></span><br><span class="line">    tp := span.typePointersOfUnchecked(base)</span><br><span class="line">    <span class="keyword">if</span> base == addr &amp;&amp; size == span.elemsize &#123;</span><br><span class="line">        <span class="keyword">return</span> tp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明是在对象内部，需要重新定位</span></span><br><span class="line">    <span class="comment">// 地址往后移动n字节，获取实际对象地址和bitmap</span></span><br><span class="line">    <span class="keyword">return</span> tp.fastForward(addr-tp.addr, addr+size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的起始地址及bitmap信息、对象的类型信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> typePointersOfUnchecked(addr <span class="type">uintptr</span>) typePointers &#123;</span><br><span class="line">    <span class="keyword">const</span> doubleCheck = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">if</span> doubleCheck &amp;&amp; span.objBase(addr) != addr &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: addr=&quot;</span>, addr, <span class="string">&quot; base=&quot;</span>, span.objBase(addr), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;typePointersOfUnchecked consisting of non-base-address for object&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spc := span.spanclass</span><br><span class="line"></span><br><span class="line">    <span class="comment">// noscan =&gt; scalar没有bitmap信息（这里只判断小对象）</span></span><br><span class="line">    <span class="keyword">if</span> spc.noscan() &#123;</span><br><span class="line">        <span class="keyword">return</span> typePointers&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是scan类型或大对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象大小 &lt;=512B</span></span><br><span class="line">    <span class="keyword">if</span> heapBitsInSpan(span.elemsize) &#123;</span><br><span class="line">        <span class="comment">// bitmap共64~128个bit</span></span><br><span class="line">        <span class="keyword">return</span> typePointers&#123;elem: addr, addr: addr, mask: span.heapBitsSmallForAddr(addr)&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象大小 &gt;512B</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> typ *_type</span><br><span class="line">    <span class="keyword">if</span> spc.sizeclass() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 小对象</span></span><br><span class="line">        <span class="comment">// 头8个字节为header</span></span><br><span class="line">        typ = *(**_type)(unsafe.Pointer(addr))</span><br><span class="line">        <span class="comment">// 起始地址往后移动8个字节</span></span><br><span class="line">        addr += mallocHeaderSize</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 大对象</span></span><br><span class="line">        <span class="comment">// type在mspan.largeType</span></span><br><span class="line">        typ = span.largeType</span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// noscan为nil，或者因为延迟扫描时，暂时不扫描</span></span><br><span class="line">            <span class="keyword">return</span> typePointers&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// type Example struct &#123;</span></span><br><span class="line">    <span class="comment">//     a *int8   // 8B (指针)</span></span><br><span class="line">    <span class="comment">//     b int16   // 2B (非指针，编译器会对齐b为8字节)</span></span><br><span class="line">    <span class="comment">//     c *int32  // 8B (指针)</span></span><br><span class="line">    <span class="comment">//     d float64 // 8B (非指针)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据类型的GCMask，如上为0b0101</span></span><br><span class="line">    gcmask := getGCMask(typ)</span><br><span class="line">    <span class="comment">// 大对象才有typ字段信息</span></span><br><span class="line">    <span class="keyword">return</span> typePointers&#123;elem: addr, addr: addr, mask: readUintptr(gcmask), typ: typ&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将mask第一个uint64内的第一个指针的位置为0，返回修改后的tp和指针地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp typePointers)</span></span> nextFast() (typePointers, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> tp.mask == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tp, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">        <span class="comment">// 二进制数尾部0个数</span></span><br><span class="line">        i = sys.TrailingZeros64(<span class="type">uint64</span>(tp.mask))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = sys.TrailingZeros32(<span class="type">uint32</span>(tp.mask))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mask内第i位置为0，表示这个指针已经被扫描</span></span><br><span class="line">    tp.mask ^= <span class="type">uintptr</span>(<span class="number">1</span>) &lt;&lt; (i &amp; (ptrBits - <span class="number">1</span>))</span><br><span class="line">    <span class="comment">// tp，指针地址</span></span><br><span class="line">    <span class="keyword">return</span> tp, tp.addr + <span class="type">uintptr</span>(i)*goarch.PtrSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mask第一个uint64不为0则调用nextFast，否则移动下一个uint64再重新判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp typePointers)</span></span> next(limit <span class="type">uintptr</span>) (typePointers, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// mask不为0</span></span><br><span class="line">        <span class="keyword">if</span> tp.mask != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 将mask第一个uint64内的第一个指针的位置为0，返回修改后的tp和指针地址</span></span><br><span class="line">            <span class="keyword">return</span> tp.nextFast()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面mask为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有类型信息-对象&lt;512B或scalar或延迟设置</span></span><br><span class="line">        <span class="keyword">if</span> tp.typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> typePointers&#123;&#125;, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象&gt;512B</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// addr+8*64 &gt; PtrBytes =&gt; 表示后面的数据非指针，不用扫描</span></span><br><span class="line">        <span class="keyword">if</span> tp.addr+goarch.PtrSize*ptrBits &gt;= tp.elem+tp.typ.PtrBytes &#123;</span><br><span class="line">            <span class="comment">// 指向下一个对象</span></span><br><span class="line">            tp.elem += tp.typ.Size_</span><br><span class="line">            tp.addr = tp.elem</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对象内部扫描</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动512字节</span></span><br><span class="line">            tp.addr += ptrBits * goarch.PtrSize</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 越界</span></span><br><span class="line">        <span class="keyword">if</span> tp.addr &gt;= limit &#123;</span><br><span class="line">            <span class="keyword">return</span> typePointers&#123;&#125;, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到addr所在到bitmap字节</span></span><br><span class="line">        tp.mask = readUintptr(addb(getGCMask(tp.typ), (tp.addr-tp.elem)/goarch.PtrSize/<span class="number">8</span>))</span><br><span class="line">        <span class="comment">// addr+8*64 &gt; limit =&gt; 越界，丢弃limit后的位</span></span><br><span class="line">        <span class="keyword">if</span> tp.addr+goarch.PtrSize*ptrBits &gt; limit &#123;</span><br><span class="line">            <span class="comment">// 多余的位</span></span><br><span class="line">            bits := (tp.addr + goarch.PtrSize*ptrBits - limit) / goarch.PtrSize</span><br><span class="line">            <span class="comment">// 移除高bits位</span></span><br><span class="line">            tp.mask &amp;^= ((<span class="number">1</span> &lt;&lt; (bits)) - <span class="number">1</span>) &lt;&lt; (ptrBits - bits)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址往后移动n字节，获取实际对象地址和bitmap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp typePointers)</span></span> fastForward(n, limit <span class="type">uintptr</span>) typePointers &#123;</span><br><span class="line">    <span class="comment">// 对象起始地址</span></span><br><span class="line">    target := tp.addr + n</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">if</span> target &gt;= limit &#123;</span><br><span class="line">        <span class="keyword">return</span> typePointers&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有类型信息（从源码看，是小对象&lt;=512B）</span></span><br><span class="line">    <span class="keyword">if</span> tp.typ == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// =1&lt;&lt;(n/8)-1 =&gt; 丢弃target前的位</span></span><br><span class="line">        tp.mask &amp;^= (<span class="number">1</span> &lt;&lt; ((target - tp.addr) / goarch.PtrSize)) - <span class="number">1</span></span><br><span class="line">        <span class="comment">// addr+8*64 &gt; limit =&gt; 越界，丢弃limit后的位</span></span><br><span class="line">        <span class="keyword">if</span> tp.addr+goarch.PtrSize*ptrBits &gt; limit &#123;</span><br><span class="line">            <span class="comment">// 多余的位</span></span><br><span class="line">            bits := (tp.addr + goarch.PtrSize*ptrBits - limit) / goarch.PtrSize</span><br><span class="line">            <span class="comment">// 移除高bits位</span></span><br><span class="line">            tp.mask &amp;^= ((<span class="number">1</span> &lt;&lt; (bits)) - <span class="number">1</span>) &lt;&lt; (ptrBits - bits)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有类型信息（大对象&gt;512B）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有多个对象</span></span><br><span class="line">    <span class="keyword">if</span> n &gt;= tp.typ.Size_ &#123;</span><br><span class="line">        <span class="comment">// 起始地址</span></span><br><span class="line">        oldelem := tp.elem</span><br><span class="line">        <span class="comment">// +=n/type_size*type_size =&gt; 按type_size的倍数取整，对齐</span></span><br><span class="line">        tp.elem += (tp.addr - tp.elem + n) / tp.typ.Size_ * tp.typ.Size_</span><br><span class="line">        <span class="comment">// 到这里tp.elem-oldelem &lt;= n</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际地址按512的倍数向下取整（tp.addr &gt;= tp.elem） =&gt; 实际地址addr可能在对象内部</span></span><br><span class="line">        tp.addr = tp.elem + alignDown(n-(tp.elem-oldelem), ptrBits*goarch.PtrSize)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// n &lt; type_size =&gt; 单个对象内部</span></span><br><span class="line">        <span class="comment">// +=n按512的倍数向下取整（tp.elem不变）</span></span><br><span class="line">        tp.addr += alignDown(n, ptrBits*goarch.PtrSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示addr后面的数据非指针，不用扫描</span></span><br><span class="line">    <span class="keyword">if</span> tp.addr-tp.elem &gt;= tp.typ.PtrBytes &#123;</span><br><span class="line">        <span class="comment">// 指向下一个对象</span></span><br><span class="line">        tp.elem += tp.typ.Size_</span><br><span class="line">        tp.addr = tp.elem</span><br><span class="line">        <span class="comment">// 获取数据类型的GCMask</span></span><br><span class="line">        tp.mask = readUintptr(getGCMask(tp.typ))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 越界</span></span><br><span class="line">        <span class="keyword">if</span> tp.addr &gt;= limit &#123;</span><br><span class="line">            <span class="keyword">return</span> typePointers&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对象内部扫描</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到addr所在到bitmap字节</span></span><br><span class="line">        tp.mask = readUintptr(addb(getGCMask(tp.typ), (tp.addr-tp.elem)/goarch.PtrSize/<span class="number">8</span>))</span><br><span class="line">        <span class="comment">// 丢弃target前的位</span></span><br><span class="line">        tp.mask &amp;^= (<span class="number">1</span> &lt;&lt; ((target - tp.addr) / goarch.PtrSize)) - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// addr+8*64 &gt; limit =&gt; 越界，丢弃limit后的位</span></span><br><span class="line">    <span class="keyword">if</span> tp.addr+goarch.PtrSize*ptrBits &gt; limit &#123;</span><br><span class="line">        <span class="comment">// 多余的位</span></span><br><span class="line">        bits := (tp.addr + goarch.PtrSize*ptrBits - limit) / goarch.PtrSize</span><br><span class="line">        <span class="comment">// 移除高bits位</span></span><br><span class="line">        tp.mask &amp;^= ((<span class="number">1</span> &lt;&lt; (bits)) - <span class="number">1</span>) &lt;&lt; (ptrBits - bits)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并other链表的mspan数据到list链表前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *mSpanList)</span></span> takeAll(other *mSpanList) &#123;</span><br><span class="line">    <span class="comment">// 链表为空</span></span><br><span class="line">    <span class="keyword">if</span> other.isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有mspan纪录list指针（debug用）</span></span><br><span class="line">    <span class="keyword">for</span> s := other.first; s != <span class="literal">nil</span>; s = s.next &#123;</span><br><span class="line">        s.list = list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list链表为空</span></span><br><span class="line">    <span class="keyword">if</span> list.isEmpty() &#123;</span><br><span class="line">        *list = *other</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不为空，other在前，list在后</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新next指针</span></span><br><span class="line">        other.last.next = list.first</span><br><span class="line">        <span class="comment">// 更新prev指针</span></span><br><span class="line">        list.first.prev = other.last</span><br><span class="line">        <span class="comment">// 更新first指针</span></span><br><span class="line">        list.first = other.first</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表字段重置</span></span><br><span class="line">    other.first, other.last = <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据地址返回对象的bitmap（64~128个bit）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(span *mspan)</span></span> heapBitsSmallForAddr(addr <span class="type">uintptr</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 只有对象大小 &lt;=512B才会访问这个函数，因此需要64个指针的bitmap（1个uint64，最多2个uint64）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan总字节数</span></span><br><span class="line">    spanSize := span.npages * pageSize</span><br><span class="line">    <span class="comment">// bitmap大小</span></span><br><span class="line">    bitmapSize := spanSize / goarch.PtrSize / <span class="number">8</span></span><br><span class="line">    <span class="comment">// 定位到bitmap起始地址</span></span><br><span class="line">    hbits := (*<span class="type">byte</span>)(unsafe.Pointer(span.base() + spanSize - bitmapSize))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第几个uint64</span></span><br><span class="line">    i := (addr - span.base()) / goarch.PtrSize / ptrBits</span><br><span class="line">    <span class="comment">// 具体bit位置</span></span><br><span class="line">    j := (addr - span.base()) / goarch.PtrSize % ptrBits</span><br><span class="line">    <span class="comment">// 指针数量</span></span><br><span class="line">    bits := span.elemsize / goarch.PtrSize</span><br><span class="line">    <span class="comment">// 第1个uint64</span></span><br><span class="line">    word0 := (*<span class="type">uintptr</span>)(unsafe.Pointer(addb(hbits, goarch.PtrSize*(i+<span class="number">0</span>))))</span><br><span class="line">    <span class="comment">// 第2个uint64</span></span><br><span class="line">    word1 := (*<span class="type">uintptr</span>)(unsafe.Pointer(addb(hbits, goarch.PtrSize*(i+<span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> read <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">if</span> j+bits &gt; ptrBits &#123;</span><br><span class="line">        <span class="comment">// 需要访问两个uint64</span></span><br><span class="line">        <span class="comment">// 第1个uint64要访问的位数量</span></span><br><span class="line">        bits0 := ptrBits - j</span><br><span class="line">        <span class="comment">// 第2个uint64要访问的位数量</span></span><br><span class="line">        bits1 := bits - bits0</span><br><span class="line">        read = *word0 &gt;&gt; j</span><br><span class="line">        read |= (*word1 &amp; ((<span class="number">1</span> &lt;&lt; bits1) - <span class="number">1</span>)) &lt;&lt; bits0</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 单个uint64足以容纳</span></span><br><span class="line">        read = (*word0 &gt;&gt; j) &amp; ((<span class="number">1</span> &lt;&lt; bits) - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> read</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置空的spanSet，清理残留的block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *spanSet)</span></span> reset() &#123;</span><br><span class="line">    <span class="comment">// 头部、尾部索引</span></span><br><span class="line">    head, tail := b.index.load().split()</span><br><span class="line">    <span class="comment">// 不为空</span></span><br><span class="line">    <span class="keyword">if</span> head &lt; tail &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;head = &quot;</span>, head, <span class="string">&quot;, tail = &quot;</span>, tail, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;attempt to clear non-empty span set&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spanSet.spine第一维索引 = head/512</span></span><br><span class="line">    top := head / spanSetBlockEntries</span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(top) &lt; b.spineLen.Load() &#123;</span><br><span class="line">        <span class="comment">// spine数组第二维，spanSetBlock， =spine[top]</span></span><br><span class="line">        blockp := b.spine.Load().lookup(<span class="type">uintptr</span>(top))</span><br><span class="line">        block := blockp.Load()</span><br><span class="line">        <span class="comment">// 第二维有数据</span></span><br><span class="line">        <span class="keyword">if</span> block != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 没有执行过pop操作</span></span><br><span class="line">            <span class="keyword">if</span> block.popped.Load() == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 不应该为0</span></span><br><span class="line">                throw(<span class="string">&quot;span set block with unpopped elements found in reset&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ==512</span></span><br><span class="line">            <span class="keyword">if</span> block.popped.Load() == spanSetBlockEntries &#123;</span><br><span class="line">                <span class="comment">// 也不应该为512，最后一次pop会将指针置为nil</span></span><br><span class="line">                throw(<span class="string">&quot;fully empty unfreed span set block found in reset&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Clear the pointer to the block.</span></span><br><span class="line">            blockp.StoreNoWB(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// popped置为0，block放回池子里</span></span><br><span class="line">            spanSetBlockPool.free(block)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 置为0</span></span><br><span class="line">    b.index.reset()</span><br><span class="line">    <span class="comment">// 置为0</span></span><br><span class="line">    b.spineLen.Store(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据统计数据调整栈的初始大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcComputeStartingStackSize</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 默认为1</span></span><br><span class="line">    <span class="keyword">if</span> debug.adaptivestackstart == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> scannedStackSize <span class="type">uint64</span></span><br><span class="line">    <span class="keyword">var</span> scannedStacks <span class="type">uint64</span></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        scannedStackSize += p.scannedStackSize</span><br><span class="line">        scannedStacks += p.scannedStacks</span><br><span class="line"></span><br><span class="line">        p.scannedStackSize = <span class="number">0</span></span><br><span class="line">        p.scannedStacks = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为0</span></span><br><span class="line">    <span class="keyword">if</span> scannedStacks == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 设置为2KB</span></span><br><span class="line">        startingStackSize = fixedStack</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平均值=x+928（stackGuard确保不会出发扩容）</span></span><br><span class="line">    avg := scannedStackSize/scannedStacks + stackGuard</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能超过1GB</span></span><br><span class="line">    <span class="keyword">if</span> avg &gt; <span class="type">uint64</span>(maxstacksize) &#123;</span><br><span class="line">        avg = <span class="type">uint64</span>(maxstacksize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能低于2KB</span></span><br><span class="line">    <span class="keyword">if</span> avg &lt; fixedStack &#123;</span><br><span class="line">        avg = fixedStack</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按2的倍数取整</span></span><br><span class="line">    startingStackSize = <span class="type">uint32</span>(round2(<span class="type">int32</span>(avg)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mcache清理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> prepareForSweep() &#123;</span><br><span class="line">    <span class="comment">// sweepgen</span></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// flushGen</span></span><br><span class="line">    flushGen := c.flushGen.Load()</span><br><span class="line">    <span class="comment">// 相等，返回</span></span><br><span class="line">    <span class="keyword">if</span> flushGen == sg &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> flushGen != sg<span class="number">-2</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;bad flushGen&quot;</span>, flushGen, <span class="string">&quot;in prepareForSweep; sweepgen&quot;</span>, sg)</span><br><span class="line">        throw(<span class="string">&quot;bad flushGen&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// alloc列表mspan放到partial或full链表、tiny区域清空</span></span><br><span class="line">    c.releaseAll()</span><br><span class="line">    <span class="comment">// 清空stackcache，如果是_GCoff阶段，将空的mspan释放回mheap</span></span><br><span class="line">    stackcache_clear(c)</span><br><span class="line">    <span class="comment">// sweepgen快照，gcStart前同步</span></span><br><span class="line">    c.flushGen.Store(mheap_.sweepgen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tiny、alloc重置并释放mspan，更新内存统计信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> releaseAll() &#123;</span><br><span class="line">    <span class="comment">// 快照，需要被GC扫描的字节数</span></span><br><span class="line">    scanAlloc := <span class="type">int64</span>(c.scanAlloc)</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    c.scanAlloc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    sg := mheap_.sweepgen</span><br><span class="line">    <span class="comment">// 累计存活字节数</span></span><br><span class="line">    dHeapLive := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 所有mpsan清空</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c.alloc &#123;</span><br><span class="line">        <span class="comment">// mspan</span></span><br><span class="line">        s := c.alloc[i]</span><br><span class="line">        <span class="comment">// 不为空</span></span><br><span class="line">        <span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">            <span class="comment">// 已分配对象数</span></span><br><span class="line">            slotsUsed := <span class="type">int64</span>(s.allocCount) - <span class="type">int64</span>(s.allocCountBeforeCache)</span><br><span class="line">            <span class="comment">// 重置</span></span><br><span class="line">            s.allocCountBeforeCache = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">            <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">            stats := memstats.heapStats.acquire()</span><br><span class="line">            <span class="comment">// 累计到全局计数器</span></span><br><span class="line">            atomic.Xadd64(&amp;stats.smallAllocCount[spanClass(i).sizeclass()], slotsUsed)</span><br><span class="line">            <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">            memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 累计已分配字节数</span></span><br><span class="line">            gcController.totalAlloc.Add(slotsUsed * <span class="type">int64</span>(s.elemsize))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未过期</span></span><br><span class="line">            <span class="keyword">if</span> s.sweepgen != sg+<span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// -=剩余可用字节数</span></span><br><span class="line">                dHeapLive -= <span class="type">int64</span>(s.nelems-s.allocCount) * <span class="type">int64</span>(s.elemsize)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// mspan已过期则清理，未过期则根据是否mspan释放有剩余放到partial或full链表</span></span><br><span class="line">            mheap_.central[i].mcentral.uncacheSpan(s)</span><br><span class="line">            <span class="comment">// 设置为空的mspan</span></span><br><span class="line">            c.alloc[i] = &amp;emptymspan</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tiny区域清理</span></span><br><span class="line">    c.tiny = <span class="number">0</span></span><br><span class="line">    c.tinyoffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 奇数，表示p正在写入stats</span></span><br><span class="line">    <span class="comment">// =stats[gen%3] =&gt; heapStatsDelta</span></span><br><span class="line">    stats := memstats.heapStats.acquire()</span><br><span class="line">    <span class="comment">// 累计到全局tiny计数器</span></span><br><span class="line">    atomic.Xadd64(&amp;stats.tinyAllocCount, <span class="type">int64</span>(c.tinyAllocs))</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    c.tinyAllocs = <span class="number">0</span></span><br><span class="line">    <span class="comment">// statsSeq计数器加1 =&gt; 偶数</span></span><br><span class="line">    memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累计heap存活字节数，如果GC未启动则累计heap扫描字节数，否则重新计算辅助GC的工作量转换参数</span></span><br><span class="line">    gcController.update(dHeapLive, scanAlloc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回收指定字节数量的内存（扫描时是从高地址向低地址进行搜索）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> scavenge(nbytes <span class="type">uintptr</span>, shouldStop <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>, force <span class="type">bool</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">    released := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 回收的内存字节数没有达到指定值</span></span><br><span class="line">    <span class="keyword">for</span> released &lt; nbytes &#123;</span><br><span class="line">        <span class="comment">// 返回可能含有可清理页的chunk的最大索引（扫描时是从高地址向低地址进行搜索）</span></span><br><span class="line">        ci, pageIdx := p.scav.index.find(force)</span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">if</span> ci == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回g0执行</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 在指定chunk内回收一定数量的页</span></span><br><span class="line">            released += p.scavengeOne(ci, pageIdx, nbytes-released)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果scavenger需要停止</span></span><br><span class="line">        <span class="keyword">if</span> shouldStop != <span class="literal">nil</span> &amp;&amp; shouldStop() &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> released</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定chunk内回收一定数量的页</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> scavengeOne(ci chunkIdx, searchIdx <span class="type">uint</span>, max <span class="type">uintptr</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 页数最大值=max/8192</span></span><br><span class="line">    maxPages := max / pageSize</span><br><span class="line">    <span class="comment">// 有溢出</span></span><br><span class="line">    <span class="keyword">if</span> max%pageSize != <span class="number">0</span> &#123;</span><br><span class="line">        maxPages++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页数最小值=physPageSize/8192</span></span><br><span class="line">    minPages := physPageSize / pageSize</span><br><span class="line">    <span class="comment">// 最低1个页</span></span><br><span class="line">    <span class="keyword">if</span> minPages &lt; <span class="number">1</span> &#123;</span><br><span class="line">        minPages = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(p.mheapLock)</span><br><span class="line">    <span class="comment">// x = p.summary[4][ci] =&gt; pallocSum取max部份 (下面条件一般都符合)</span></span><br><span class="line">    <span class="keyword">if</span> p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][ci].max() &gt;= <span class="type">uint</span>(minPages) &#123;</span><br><span class="line">        <span class="comment">// 从pallocData中找到并返回未回收且可用的连续页起始索引以及页数</span></span><br><span class="line">        base, npages := p.chunkOf(ci).findScavengeCandidate(searchIdx, minPages, maxPages)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到n个页</span></span><br><span class="line">        <span class="keyword">if</span> npages != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 起始地址</span></span><br><span class="line">            addr := chunkBase(ci) + <span class="type">uintptr</span>(base)*pageSize</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先标记为分配，防止其他g获得这片区域</span></span><br><span class="line">            <span class="comment">// pallocBits、scavenged更新</span></span><br><span class="line">            p.chunkOf(ci).allocRange(base, npages)</span><br><span class="line">            <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">            p.update(addr, <span class="type">uintptr</span>(npages), <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接下来安全了</span></span><br><span class="line">            unlock(p.mheapLock)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非测试</span></span><br><span class="line">            <span class="keyword">if</span> !p.test &#123;</span><br><span class="line">                <span class="comment">// 将这片内存释放回系统（Ready-&gt;Prepared）</span></span><br><span class="line">                sysUnused(unsafe.Pointer(addr), <span class="type">uintptr</span>(npages)*pageSize)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 统计数据更新</span></span><br><span class="line">                nbytes := <span class="type">int64</span>(npages * pageSize)</span><br><span class="line">                <span class="comment">// 累计到heap内存释放量（释放回OS）</span></span><br><span class="line">                gcController.heapReleased.add(nbytes)</span><br><span class="line">                <span class="comment">// 累计到heap内存可复用量（非free都是减少）</span></span><br><span class="line">                gcController.heapFree.add(-nbytes)</span><br><span class="line"></span><br><span class="line">                stats := memstats.heapStats.acquire()</span><br><span class="line">                atomic.Xaddint64(&amp;stats.committed, -nbytes)</span><br><span class="line">                atomic.Xaddint64(&amp;stats.released, nbytes)</span><br><span class="line">                memstats.heapStats.release()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新加锁</span></span><br><span class="line">            lock(p.mheapLock)</span><br><span class="line">            <span class="comment">// searchAddr更新</span></span><br><span class="line">            <span class="keyword">if</span> b := (offAddr&#123;addr&#125;); b.lessThan(p.searchAddr) &#123;</span><br><span class="line">                p.searchAddr = b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// pallocData.pallocBits更新，指定位置为0</span></span><br><span class="line">            p.chunkOf(ci).free(base, npages)</span><br><span class="line">            <span class="comment">// 统计chunks信息并更新summary</span></span><br><span class="line">            p.update(addr, <span class="type">uintptr</span>(npages), <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// pallocData.scavenged更新，指定位置为1</span></span><br><span class="line">            p.chunkOf(ci).scavenged.setRange(base, npages)</span><br><span class="line">            unlock(p.mheapLock)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放回系统的内存大小</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">uintptr</span>(npages) * pageSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除scavChunkHasFree标志</span></span><br><span class="line">    p.scav.index.setEmpty(ci)</span><br><span class="line">    unlock(p.mheapLock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从pallocData中找到并返回未回收且可用的连续页起始索引以及页数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *pallocData)</span></span> findScavengeCandidate(searchIdx <span class="type">uint</span>, minimum, max <span class="type">uintptr</span>) (<span class="type">uint</span>, <span class="type">uint</span>) &#123;</span><br><span class="line">    <span class="comment">// 非2的倍数 or 为0</span></span><br><span class="line">    <span class="keyword">if</span> minimum&amp;(minimum<span class="number">-1</span>) != <span class="number">0</span> || minimum == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: min = &quot;</span>, minimum, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;min must be a non-zero power of 2&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> minimum &gt; maxPagesPerPhysPage &#123; <span class="comment">// 超过64</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: min = &quot;</span>, minimum, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;min too large&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minimum -&gt; [1,64]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> max == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 最小为minimum</span></span><br><span class="line">        max = minimum</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 按minimum的倍数取整</span></span><br><span class="line">        max = alignUp(max, minimum)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// searchIdx =&gt; [0,511]</span></span><br><span class="line">    <span class="comment">// i =&gt; 64的倍数 =&gt; [0,7]</span></span><br><span class="line">    i := <span class="type">int</span>(searchIdx / <span class="number">64</span>)</span><br><span class="line">    <span class="comment">// 跳过已使用或已回收的页，从高位往低位扫描</span></span><br><span class="line">    <span class="keyword">for</span> ; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 两个64位数按位或，按minimum个位填充1</span></span><br><span class="line">        <span class="comment">// 如fillAligned(0x0100a3, 8) == 0xff00ff =&gt; 每8个位有1的全部填充为1</span></span><br><span class="line">        <span class="comment">// scavenged中1为已回收，pallocBits中1为已使用，所以，x中0表示未回收且可用</span></span><br><span class="line">        x := fillAligned(m.scavenged[i]|m.pallocBits[i], <span class="type">uint</span>(minimum))</span><br><span class="line">        <span class="comment">// 存在未回收且可用的数据</span></span><br><span class="line">        <span class="keyword">if</span> x != ^<span class="type">uint64</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找失败</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到未回收且可用的页</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// double-check ???</span></span><br><span class="line">    x := fillAligned(m.scavenged[i]|m.pallocBits[i], <span class="type">uint</span>(minimum))</span><br><span class="line">    <span class="comment">// x取反算出前导0个数（minimum的倍数）</span></span><br><span class="line">    z1 := <span class="type">uint</span>(sys.LeadingZeros64(^x))</span><br><span class="line">    <span class="comment">// 连续0个数，最后一个0出现的位置</span></span><br><span class="line">    run, end := <span class="type">uint</span>(<span class="number">0</span>), <span class="type">uint</span>(i)*<span class="number">64</span>+(<span class="number">64</span>-z1)</span><br><span class="line">    <span class="comment">// 丢弃高z1位后不为0</span></span><br><span class="line">    <span class="keyword">if</span> x&lt;&lt;z1 != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 低位有为1的数据</span></span><br><span class="line">        <span class="comment">// 丢弃高z1位后前导0的个数</span></span><br><span class="line">        run = <span class="type">uint</span>(sys.LeadingZeros64(x &lt;&lt; z1))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 丢弃高z1位后为0</span></span><br><span class="line">        <span class="comment">// 低位0的个数</span></span><br><span class="line">        run = <span class="number">64</span> - z1</span><br><span class="line">        <span class="comment">// 扩展，继续扫描i之前的位置</span></span><br><span class="line">        <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            x := fillAligned(m.scavenged[j]|m.pallocBits[j], <span class="type">uint</span>(minimum))</span><br><span class="line">            <span class="comment">// 高位0个数</span></span><br><span class="line">            run += <span class="type">uint</span>(sys.LeadingZeros64(x))</span><br><span class="line">            <span class="comment">// 存在已回收或已使用的页</span></span><br><span class="line">            <span class="keyword">if</span> x != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取最小值</span></span><br><span class="line">    size := min(run, <span class="type">uint</span>(max))</span><br><span class="line">    <span class="comment">// 0的起始位置</span></span><br><span class="line">    start := end - size</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保不会破坏huge page的边界，不讨论</span></span><br><span class="line">    <span class="keyword">if</span> physHugePageSize &gt; pageSize &amp;&amp; physHugePageSize &gt; physPageSize &#123;</span><br><span class="line">        pagesPerHugePage := physHugePageSize / pageSize</span><br><span class="line">        hugePageAbove := <span class="type">uint</span>(alignUp(<span class="type">uintptr</span>(start), pagesPerHugePage))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hugePageAbove &lt;= end &#123;</span><br><span class="line">            hugePageBelow := <span class="type">uint</span>(alignDown(<span class="type">uintptr</span>(start), pagesPerHugePage))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> hugePageBelow &gt;= end-run &#123;</span><br><span class="line">                size = size + (start - hugePageBelow)</span><br><span class="line">                start = hugePageBelow</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓冲区-1"><a href="#缓冲区-1" class="headerlink" title="缓冲区"></a>缓冲区</h3><h4 id="任务缓冲区"><a href="#任务缓冲区" class="headerlink" title="任务缓冲区"></a>任务缓冲区</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化wbuf1、wbuf2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> init() &#123;</span><br><span class="line">    <span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line">    w.wbuf1 = getempty()</span><br><span class="line">    <span class="comment">// 尝试从work.full获取一个wbuf</span></span><br><span class="line">    wbuf2 := trygetfull()</span><br><span class="line">    <span class="keyword">if</span> wbuf2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line">        wbuf2 = getempty()</span><br><span class="line">    &#125;</span><br><span class="line">    w.wbuf2 = wbuf2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象放到wbuf-任务缓冲区，已满则从work.empty获取一个wbuf替换用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> put(obj <span class="type">uintptr</span>) &#123;</span><br><span class="line">    flushed := <span class="literal">false</span></span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// workType、mheap加锁</span></span><br><span class="line">    lockWithRankMayAcquire(&amp;work.wbufSpans.lock, lockRankWbufSpans)</span><br><span class="line">    lockWithRankMayAcquire(&amp;mheap_.lock, lockRankMheap)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf1、wbuf2未初始化</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化wbuf1、wbuf2</span></span><br><span class="line">        w.init()</span><br><span class="line">        <span class="comment">// 重新读一遍wbuf1</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line">        <span class="comment">// wbuf1已满</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换wbuf1、wbuf2</span></span><br><span class="line">        w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1</span><br><span class="line">        <span class="comment">// 重新读一遍wbuf1（实际是wbuf2）</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf2也满了</span></span><br><span class="line">        <span class="keyword">if</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line">            <span class="comment">// wbuf2放到work.full</span></span><br><span class="line">            putfull(wbuf)</span><br><span class="line">            <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">            w.flushedWork = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line">            wbuf = getempty()</span><br><span class="line">            <span class="comment">// 优先放到wbuf1</span></span><br><span class="line">            w.wbuf1 = wbuf</span><br><span class="line">            <span class="comment">// 同flushedWork</span></span><br><span class="line">            flushed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到obj数组末尾</span></span><br><span class="line">    wbuf.obj[wbuf.nobj] = obj</span><br><span class="line">    <span class="comment">// 索引往后移</span></span><br><span class="line">    wbuf.nobj++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动更多标记线程</span></span><br><span class="line">    <span class="keyword">if</span> flushed &amp;&amp; gcphase == _GCmark &#123;</span><br><span class="line">        <span class="comment">// 如果需要更多的专用标记线程，随机抢占一个p运行</span></span><br><span class="line">        gcController.enlistWorker()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象放到wbuf-任务缓冲区，未初始化或已满直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> putFast(obj <span class="type">uintptr</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line">    <span class="comment">// wbuf1、wbuf2未初始化 or wbuf1已满</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> || wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到obj数组末尾</span></span><br><span class="line">    wbuf.obj[wbuf.nobj] = obj</span><br><span class="line">    <span class="comment">// 索引往后移</span></span><br><span class="line">    wbuf.nobj++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一批对象放到wbuf-任务缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> putBatch(obj []<span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 空数组</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(obj) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flushed := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// wbuf1</span></span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf1、wbuf2未初始化</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化wbuf1、wbuf2</span></span><br><span class="line">        w.init()</span><br><span class="line">        <span class="comment">// 重新读一遍wbuf1</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个处理</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(obj) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// wbuf1已满</span></span><br><span class="line">        <span class="keyword">for</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line">            <span class="comment">// wbuf放到work.full</span></span><br><span class="line">            putfull(wbuf)</span><br><span class="line">            <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">            w.flushedWork = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// wbuf2替换wbuf1，从work.empty链表获取1个空的wbuf替换wbuf2</span></span><br><span class="line">            w.wbuf1, w.wbuf2 = w.wbuf2, getempty()</span><br><span class="line">            <span class="comment">// 重新读一遍wbuf1（实际是wbuf2）</span></span><br><span class="line">            wbuf = w.wbuf1</span><br><span class="line">            <span class="comment">// 同flushedWork</span></span><br><span class="line">            flushed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制n个obj</span></span><br><span class="line">        n := <span class="built_in">copy</span>(wbuf.obj[wbuf.nobj:], obj)</span><br><span class="line">        <span class="comment">// 索引更新</span></span><br><span class="line">        wbuf.nobj += n</span><br><span class="line">        <span class="comment">// 剩余量</span></span><br><span class="line">        obj = obj[n:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动更多标记线程</span></span><br><span class="line">    <span class="keyword">if</span> flushed &amp;&amp; gcphase == _GCmark &#123;</span><br><span class="line">        <span class="comment">// 如果需要更多的专用标记线程，随机抢占一个p运行</span></span><br><span class="line">        gcController.enlistWorker()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从wbuf获取一个obj</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> tryGet() <span class="type">uintptr</span> &#123;</span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line">    <span class="comment">// wbuf1、wbuf2未初始化</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化wbuf1、wbuf2</span></span><br><span class="line">        w.init()</span><br><span class="line">        <span class="comment">// 重新读一遍wbuf1</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组为空</span></span><br><span class="line">    <span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 交换wbuf1、wbuf2</span></span><br><span class="line">        w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1</span><br><span class="line">        <span class="comment">// 重新读一遍wbuf1（实际是wbuf2）</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 仍然为空</span></span><br><span class="line">        <span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 旧</span></span><br><span class="line">            owbuf := wbuf</span><br><span class="line">            <span class="comment">// 新</span></span><br><span class="line">            <span class="comment">// 尝试从work.full获取一个wbuf</span></span><br><span class="line">            wbuf = trygetfull()</span><br><span class="line">            <span class="comment">// 没有数据，返回</span></span><br><span class="line">            <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// wbuf放到work.empty</span></span><br><span class="line">            putempty(owbuf)</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            w.wbuf1 = wbuf</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引往前移</span></span><br><span class="line">    wbuf.nobj--</span><br><span class="line">    <span class="comment">// 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> wbuf.obj[wbuf.nobj]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从wbuf获取一个obj，未初始化或为空直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> tryGetFast() <span class="type">uintptr</span> &#123;</span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line">    <span class="comment">// wbuf1、wbuf2未初始化 or wbuf1为空</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> || wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引往前移</span></span><br><span class="line">    wbuf.nobj--</span><br><span class="line">    <span class="comment">// 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> wbuf.obj[wbuf.nobj]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wbuf1、wbuf2根据容量选择放入work.empty或work.full队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> dispose() &#123;</span><br><span class="line">    <span class="comment">// wbuf1已初始化</span></span><br><span class="line">    <span class="keyword">if</span> wbuf := w.wbuf1; wbuf != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 为空</span></span><br><span class="line">        <span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// wbuf放到work.empty</span></span><br><span class="line">            putempty(wbuf)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不为空</span></span><br><span class="line">            <span class="comment">// wbuf放到work.full</span></span><br><span class="line">            putfull(wbuf)</span><br><span class="line">            <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">            w.flushedWork = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置为nil</span></span><br><span class="line">        w.wbuf1 = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// wbuf2</span></span><br><span class="line">        wbuf = w.wbuf2</span><br><span class="line">        <span class="comment">// 为空</span></span><br><span class="line">        <span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// wbuf放到work.empty</span></span><br><span class="line">            putempty(wbuf)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不为空</span></span><br><span class="line">            <span class="comment">// wbuf放到work.full</span></span><br><span class="line">            putfull(wbuf)</span><br><span class="line">            <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">            w.flushedWork = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置为nil</span></span><br><span class="line">        w.wbuf2 = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> w.bytesMarked != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 加到work.bytesMarked</span></span><br><span class="line">        atomic.Xadd64(&amp;work.bytesMarked, <span class="type">int64</span>(w.bytesMarked))</span><br><span class="line">        <span class="comment">// 清0</span></span><br><span class="line">        w.bytesMarked = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> w.heapScanWork != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 加到gcController.heapScanWork</span></span><br><span class="line">        gcController.heapScanWork.Add(w.heapScanWork)</span><br><span class="line">        <span class="comment">// 清0</span></span><br><span class="line">        w.heapScanWork = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wbuf2不为空则全部放入work.full，否则将wbuf1的一半放到work.full</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> balance() &#123;</span><br><span class="line">    <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="keyword">if</span> w.wbuf1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf2不为空</span></span><br><span class="line">    <span class="keyword">if</span> wbuf := w.wbuf2; wbuf.nobj != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// wbuf2放到work.full</span></span><br><span class="line">        putfull(wbuf)</span><br><span class="line">        <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">        w.flushedWork = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line">        w.wbuf2 = getempty()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> wbuf := w.wbuf1; wbuf.nobj &gt; <span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">// wbuf1数量&gt;4</span></span><br><span class="line">        <span class="comment">// 从wbuf拿走末尾一半数据创建新的wbuf，剩下的放到work.full</span></span><br><span class="line">        w.wbuf1 = handoff(wbuf)</span><br><span class="line">        <span class="comment">// 表示还有更多灰色对象需要标记</span></span><br><span class="line">        w.flushedWork = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wbuf1为空或对象数量不足4</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记阶段</span></span><br><span class="line">    <span class="keyword">if</span> gcphase == _GCmark &#123;</span><br><span class="line">        <span class="comment">// 如果需要更多的专用标记线程，随机抢占一个p运行</span></span><br><span class="line">        gcController.enlistWorker()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getempty</span><span class="params">()</span></span> *workbuf &#123;</span><br><span class="line">    <span class="keyword">var</span> b *workbuf</span><br><span class="line">    <span class="comment">// work.empty有数据</span></span><br><span class="line">    <span class="keyword">if</span> work.empty != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取work.empty第1个</span></span><br><span class="line">        b = (*workbuf)(work.empty.pop())</span><br><span class="line">        <span class="comment">// 有数据</span></span><br><span class="line">        <span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 确保wbuf为空</span></span><br><span class="line">            b.checkempty()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// workType、mheap加锁</span></span><br><span class="line">    lockWithRankMayAcquire(&amp;work.wbufSpans.lock, lockRankWbufSpans)</span><br><span class="line">    lockWithRankMayAcquire(&amp;mheap_.lock, lockRankMheap)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有从empty拿到数据</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s *mspan</span><br><span class="line"></span><br><span class="line">        <span class="comment">// free链表有数据</span></span><br><span class="line">        <span class="keyword">if</span> work.wbufSpans.free.first != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            lock(&amp;work.wbufSpans.lock)</span><br><span class="line">            <span class="comment">// free链表第一个</span></span><br><span class="line">            s = work.wbufSpans.free.first</span><br><span class="line">            <span class="comment">// double-check</span></span><br><span class="line">            <span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// mspan从free迁移到busy</span></span><br><span class="line">                work.wbufSpans.free.remove(s)</span><br><span class="line">                work.wbufSpans.busy.insert(s)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            unlock(&amp;work.wbufSpans.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有从free链表拿到数据</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">            systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="comment">// 获取mspan、分配n个页面、更新元信息</span></span><br><span class="line">                <span class="comment">// 手动分配4个页，type为spanAllocWorkBuf-3</span></span><br><span class="line">                s = mheap_.allocManual(workbufAlloc/pageSize, spanAllocWorkBuf)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内存不足</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            lock(&amp;work.wbufSpans.lock)</span><br><span class="line">            <span class="comment">// mspan放到busy</span></span><br><span class="line">            work.wbufSpans.busy.insert(s)</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            unlock(&amp;work.wbufSpans.lock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i从0开始，步进为2048，边界为32768</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i+_WorkbufSize &lt;= workbufAlloc; i += _WorkbufSize &#123;</span><br><span class="line">            <span class="comment">// 分配2KB内存创建workbuf</span></span><br><span class="line">            newb := (*workbuf)(unsafe.Pointer(s.base() + i))</span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            newb.nobj = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 校验地址，如果node地址非法，则抛出异常</span></span><br><span class="line">            lfnodeValidate(&amp;newb.node)</span><br><span class="line">            <span class="comment">// 第1个wbuf</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 直接使用</span></span><br><span class="line">                b = newb</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 剩余的wbuf</span></span><br><span class="line">                <span class="comment">// wbuf放到work.empty</span></span><br><span class="line">                putempty(newb)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wbuf放到work.empty</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putempty</span><span class="params">(b *workbuf)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 确保wbuf为空</span></span><br><span class="line">    b.checkempty()</span><br><span class="line">    <span class="comment">// 放到work.empty</span></span><br><span class="line">    work.empty.push(&amp;b.node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wbuf放到work.full</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putfull</span><span class="params">(b *workbuf)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 确保wbuf不为空</span></span><br><span class="line">    b.checknonempty()</span><br><span class="line">    <span class="comment">// 放到work.full</span></span><br><span class="line">    work.full.push(&amp;b.node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从work.full获取一个wbuf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trygetfull</span><span class="params">()</span></span> *workbuf &#123;</span><br><span class="line">    <span class="comment">// 获取work.full第1个</span></span><br><span class="line">    b := (*workbuf)(work.full.pop())</span><br><span class="line">    <span class="comment">// 有数据</span></span><br><span class="line">    <span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 确保wbuf不为空</span></span><br><span class="line">        b.checknonempty()</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从wbuf拿走末尾一半数据创建新的wbuf，剩下的放到work.full</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoff</span><span class="params">(b *workbuf)</span></span> *workbuf &#123;</span><br><span class="line">    <span class="comment">// 从work.empty链表获取1个空的wbuf</span></span><br><span class="line">    b1 := getempty()</span><br><span class="line">    <span class="comment">// 拿走一半</span></span><br><span class="line">    n := b.nobj / <span class="number">2</span></span><br><span class="line">    b.nobj -= n</span><br><span class="line">    b1.nobj = n</span><br><span class="line">    <span class="comment">// 复制数据</span></span><br><span class="line">    memmove(unsafe.Pointer(&amp;b1.obj[<span class="number">0</span>]), unsafe.Pointer(&amp;b.obj[b.nobj]), <span class="type">uintptr</span>(n)*unsafe.Sizeof(b1.obj[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf放到work.full</span></span><br><span class="line">    putfull(b)</span><br><span class="line">    <span class="keyword">return</span> b1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空empty链表，将busy链表数据搬到free链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareFreeWorkbufs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    lock(&amp;work.wbufSpans.lock)</span><br><span class="line">    <span class="comment">// work.full链表不为空</span></span><br><span class="line">    <span class="keyword">if</span> work.full != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;cannot free workbufs when work.full != 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbuf都在empty链表，不关心其mspan归属，直接清空链表，把所有mspan搬到free链表</span></span><br><span class="line">    work.empty = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 合并busy链表的mspan数据到free链表前</span></span><br><span class="line">    work.wbufSpans.free.takeAll(&amp;work.wbufSpans.busy)</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    unlock(&amp;work.wbufSpans.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wbuf的free链表清理64个mspan、mspan内存释放回mheap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freeSomeWbufs</span><span class="params">(preemptible <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 一次性只处理64个mspan，每个mspan耗时~1–2 µs</span></span><br><span class="line">    <span class="keyword">const</span> batchSize = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">    lock(&amp;work.wbufSpans.lock)</span><br><span class="line">    <span class="comment">// 非_GCoff阶段 or free链表为空</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff || work.wbufSpans.free.isEmpty() &#123;</span><br><span class="line">        unlock(&amp;work.wbufSpans.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// g</span></span><br><span class="line">        gp := getg().m.curg</span><br><span class="line">        <span class="comment">// 释放64个mspan，如果遇到抢占则提前退出循环</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; batchSize &amp;&amp; !(preemptible &amp;&amp; gp.preempt); i++ &#123;</span><br><span class="line">            <span class="comment">// free链表第一个</span></span><br><span class="line">            span := work.wbufSpans.free.first</span><br><span class="line">            <span class="comment">// 没数据</span></span><br><span class="line">            <span class="keyword">if</span> span == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移除指定mspan</span></span><br><span class="line">            work.wbufSpans.free.remove(span)</span><br><span class="line">            <span class="comment">// 释放页和mspan，type为spanAllocWorkBuf-3</span></span><br><span class="line">            mheap_.freeManual(span, spanAllocWorkBuf)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// free链表是否还有数据</span></span><br><span class="line">    more := !work.wbufSpans.free.isEmpty()</span><br><span class="line">    unlock(&amp;work.wbufSpans.lock)</span><br><span class="line">    <span class="keyword">return</span> more</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写屏障缓冲区"><a href="#写屏障缓冲区" class="headerlink" title="写屏障缓冲区"></a>写屏障缓冲区</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置wbBuf的next、end指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *wbBuf)</span></span> reset() &#123;</span><br><span class="line">    <span class="comment">// 起始地址</span></span><br><span class="line">    start := <span class="type">uintptr</span>(unsafe.Pointer(&amp;b.buf[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment">// 重置next</span></span><br><span class="line">    b.next = start</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认为false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> testSmallBuf &#123;</span><br><span class="line">        <span class="comment">// = &amp;b.buf[9]</span></span><br><span class="line">        b.end = <span class="type">uintptr</span>(unsafe.Pointer(&amp;b.buf[wbMaxEntriesPerCall+<span class="number">1</span>]))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 边界，指向最后一个元素的末尾</span></span><br><span class="line">        b.end = start + <span class="type">uintptr</span>(<span class="built_in">len</span>(b.buf))*unsafe.Sizeof(b.buf[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有对齐</span></span><br><span class="line">    <span class="keyword">if</span> (b.end-b.next)%unsafe.Sizeof(b.buf[<span class="number">0</span>]) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad write barrier buffer bounds&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写屏障缓冲区可写入位置（容量为1个指针）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *wbBuf)</span></span> get1() *[<span class="number">1</span>]<span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 越界，缓冲区已满</span></span><br><span class="line">    <span class="keyword">if</span> b.next+goarch.PtrSize &gt; b.end &#123;</span><br><span class="line">        <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">        wbBufFlush()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p指向next位置</span></span><br><span class="line">    p := (*[<span class="number">1</span>]<span class="type">uintptr</span>)(unsafe.Pointer(b.next))</span><br><span class="line">    <span class="comment">// 指向下一个可写入位置</span></span><br><span class="line">    b.next += goarch.PtrSize</span><br><span class="line">    <span class="comment">// 返回缓冲区指针</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写屏障缓冲区可写入位置（容量为2个指针）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *wbBuf)</span></span> get2() *[<span class="number">2</span>]<span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// 越界，缓冲区已满</span></span><br><span class="line">    <span class="keyword">if</span> b.next+<span class="number">2</span>*goarch.PtrSize &gt; b.end &#123;</span><br><span class="line">        <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">        wbBufFlush()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p指向next位置</span></span><br><span class="line">    p := (*[<span class="number">2</span>]<span class="type">uintptr</span>)(unsafe.Pointer(b.next))</span><br><span class="line">    <span class="comment">// 指向下一个可写入位置</span></span><br><span class="line">    b.next += <span class="number">2</span> * goarch.PtrSize</span><br><span class="line">    <span class="comment">// 返回缓冲区指针</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wbBufFlush</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 发生panic</span></span><br><span class="line">    <span class="keyword">if</span> getg().m.dying &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// wbBuf的next字段指向buf数组开头</span></span><br><span class="line">        getg().m.p.ptr().wbBuf.discard()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到g0执行</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line">        wbBufFlush1(getg().m.p.ptr())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将符合条件的写屏障wbBuf数据放到wbuf，清空wbBuf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wbBufFlush1</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 起始地址</span></span><br><span class="line">    start := <span class="type">uintptr</span>(unsafe.Pointer(&amp;pp.wbBuf.buf[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment">// 总数量</span></span><br><span class="line">    n := (pp.wbBuf.next - start) / unsafe.Sizeof(pp.wbBuf.buf[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 获取所有指针</span></span><br><span class="line">    ptrs := pp.wbBuf.buf[:n]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为0，防止有新的数据入队</span></span><br><span class="line">    pp.wbBuf.next = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// debug.debug.gccheckmark默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> useCheckmark &#123;</span><br><span class="line">        <span class="comment">// 遍历wbBuf</span></span><br><span class="line">        <span class="keyword">for</span> _, ptr := <span class="keyword">range</span> ptrs &#123;</span><br><span class="line">            <span class="comment">// 根据指针获取对象起始地址、mspan、offset，设置gcmarkBits，放入wbuf队列</span></span><br><span class="line">            shade(ptr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置wbBuf的next、end指针</span></span><br><span class="line">        pp.wbBuf.reset()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcw是wbuf</span></span><br><span class="line">    gcw := &amp;pp.gcw</span><br><span class="line">    pos := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 遍历wbBuf-写屏障缓冲</span></span><br><span class="line">    <span class="keyword">for</span> _, ptr := <span class="keyword">range</span> ptrs &#123;</span><br><span class="line">        <span class="comment">// &lt;4096 =&gt; 比合法指针还要小</span></span><br><span class="line">        <span class="keyword">if</span> ptr &lt; minLegalPointer &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据p查找mspan，找到了返回对象在mspan内的位置和对象起始地址</span></span><br><span class="line">        obj, span, objIndex := findObject(ptr, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 在mspan开头</span></span><br><span class="line">        <span class="keyword">if</span> obj == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// ？？？</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取该对象的bitmap（从gcmarkBits获取，第几个字节、字节内第几位）</span></span><br><span class="line">        mbits := span.markBitsForIndex(objIndex)</span><br><span class="line">        <span class="comment">// 该位是否已经设置为1</span></span><br><span class="line">        <span class="keyword">if</span> mbits.isMarked() &#123;</span><br><span class="line">            <span class="comment">// 已设置，不处理</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该位设置为1（只要用mask跟gcmarkBits按位或）</span></span><br><span class="line">        mbits.setMarked()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据mspan起始地址获取heapArena、页索引、页bitmap位置</span></span><br><span class="line">        arena, pageIdx, pageMask := pageIndexOf(span.base())</span><br><span class="line">        <span class="comment">// 将这个页的bitmap设置为1（粗略，只设置一页，不是所有页，此外，pageMarks在GC启动时清0）</span></span><br><span class="line">        <span class="keyword">if</span> arena.pageMarks[pageIdx]&amp;pageMask == <span class="number">0</span> &#123;</span><br><span class="line">            atomic.Or8(&amp;arena.pageMarks[pageIdx], pageMask)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象不包含指针</span></span><br><span class="line">        <span class="keyword">if</span> span.spanclass.noscan() &#123;</span><br><span class="line">            <span class="comment">// 对象大小累计到bytesMarked-被标记的字节总数</span></span><br><span class="line">            gcw.bytesMarked += <span class="type">uint64</span>(span.elemsize)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放回写屏障缓冲</span></span><br><span class="line">        ptrs[pos] = obj</span><br><span class="line">        <span class="comment">// 索引调整</span></span><br><span class="line">        pos++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一批对象放到wbuf-任务缓冲区</span></span><br><span class="line">    gcw.putBatch(ptrs[:pos])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置wbBuf的next、end指针</span></span><br><span class="line">    pp.wbBuf.reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcControllerState-垃圾回收节奏控制"><a href="#gcControllerState-垃圾回收节奏控制" class="headerlink" title="gcControllerState-垃圾回收节奏控制"></a>gcControllerState-垃圾回收节奏控制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置GC启动阈值、计算目标heap大小和跑道大小，计算辅助GC的工作量转换参数，计算GC触发阈值和目标heap大小，更新sweeper、scavenger的pacing参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcControllerCommit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置GC启动阈值、计算目标heap大小和跑道大小</span></span><br><span class="line">    gcController.commit(isSweepDone())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC运行中</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">        <span class="comment">// 计算辅助GC的工作量转换参数</span></span><br><span class="line">        gcController.revise()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算GC触发阈值和目标heap大小</span></span><br><span class="line">    trigger, heapGoal := gcController.trigger()</span><br><span class="line">    <span class="comment">// 更新sweeper的pacing参数</span></span><br><span class="line">    gcPaceSweeper(trigger)</span><br><span class="line">    <span class="comment">// 更新scavenger的pacing参数</span></span><br><span class="line">    gcPaceScavenger(gcController.memoryLimit.Load(), heapGoal, gcController.lastHeapGoal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新sweeper的pacing参数</span></span><br><span class="line"><span class="comment">// 标记终止阶段调用，或GCPercent/MemoryLimit有变动时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcPaceSweeper</span><span class="params">(trigger <span class="type">uint64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sweeper数量为0</span></span><br><span class="line">    <span class="keyword">if</span> isSweepDone() &#123;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// sweeper数量不为0 =&gt; 还在清扫中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// heap存活字节数</span></span><br><span class="line">        heapLiveBasis := gcController.heapLive.Load()</span><br><span class="line">        <span class="comment">// 距离GC触发的剩余堆大小=触发临界点-heap存活字节数</span></span><br><span class="line">        heapDistance := <span class="type">int64</span>(trigger) - <span class="type">int64</span>(heapLiveBasis)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加边距，防止有页未被清理</span></span><br><span class="line">        heapDistance -= <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">        <span class="comment">// 最低为8192</span></span><br><span class="line">        <span class="keyword">if</span> heapDistance &lt; _PageSize &#123;</span><br><span class="line">            heapDistance = _PageSize</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已完成清扫的页数量</span></span><br><span class="line">        pagesSwept := mheap_.pagesSwept.Load()</span><br><span class="line">        <span class="comment">// heap内存页使用量（mSpanInUse）</span></span><br><span class="line">        pagesInUse := mheap_.pagesInUse.Load()</span><br><span class="line">        <span class="comment">// 剩余待清扫页数量</span></span><br><span class="line">        sweepDistancePages := <span class="type">int64</span>(pagesInUse) - <span class="type">int64</span>(pagesSwept)</span><br><span class="line">        <span class="keyword">if</span> sweepDistancePages &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不能为负数，重置为0</span></span><br><span class="line">            mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 还没清扫完</span></span><br><span class="line">            <span class="comment">// 每分配1字节需要清扫的页数=剩余待清扫页数量/距离GC触发的剩余堆大小</span></span><br><span class="line">            mheap_.sweepPagesPerByte = <span class="type">float64</span>(sweepDistancePages) / <span class="type">float64</span>(heapDistance)</span><br><span class="line">            <span class="comment">// 纪录heapLive快照</span></span><br><span class="line">            mheap_.sweepHeapLiveBasis = heapLiveBasis</span><br><span class="line">            <span class="comment">// 纪录pagesSwept快照-已完成清扫的页数量</span></span><br><span class="line">            mheap_.pagesSweptBasis.Store(pagesSwept)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新scavenger的pacing参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcPaceScavenger</span><span class="params">(memoryLimit <span class="type">int64</span>, heapGoal, lastHeapGoal <span class="type">uint64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">    assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memoryLimit*0.95</span></span><br><span class="line">    memoryLimitGoal := <span class="type">uint64</span>(<span class="type">float64</span>(memoryLimit) * (<span class="number">1</span> - reduceExtraPercent/<span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已映射且可用的内存量（总内存）</span></span><br><span class="line">    mappedReady := gcController.mappedReady.Load()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总内存没有超过限制</span></span><br><span class="line">    <span class="keyword">if</span> mappedReady &lt;= memoryLimitGoal &#123;</span><br><span class="line">        <span class="comment">// 设置为最大值=2^64-1</span></span><br><span class="line">        scavenge.memoryLimitGoal.Store(^<span class="type">uint64</span>(<span class="number">0</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 总内存超过限制</span></span><br><span class="line">        <span class="comment">// 设置为当前值</span></span><br><span class="line">        scavenge.memoryLimitGoal.Store(memoryLimitGoal)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次GC还没完成，没有足够的信息，停止清理</span></span><br><span class="line">    <span class="keyword">if</span> lastHeapGoal == <span class="number">0</span> &#123;</span><br><span class="line">        scavenge.gcPercentGoal.Store(^<span class="type">uint64</span>(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算scavenging goal</span></span><br><span class="line">    goalRatio := <span class="type">float64</span>(heapGoal) / <span class="type">float64</span>(lastHeapGoal)</span><br><span class="line">    gcPercentGoal := <span class="type">uint64</span>(<span class="type">float64</span>(memstats.lastHeapInUse) * goalRatio)</span><br><span class="line">    <span class="comment">// += gcPercentGoal/10 =&gt; 这里的retainExtraPercent作用是为了得到更好的被除数</span></span><br><span class="line">    gcPercentGoal += gcPercentGoal / (<span class="number">1.0</span> / (retainExtraPercent / <span class="number">100.0</span>))</span><br><span class="line">    <span class="comment">// 按物理页的大小对齐</span></span><br><span class="line">    gcPercentGoal = (gcPercentGoal + <span class="type">uint64</span>(physPageSize) - <span class="number">1</span>) &amp;^ (<span class="type">uint64</span>(physPageSize) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =heapInUse+heapFree（gcController）</span></span><br><span class="line">    heapRetainedNow := heapRetained()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果小于等于goal or 差值在一个物理页内</span></span><br><span class="line">    <span class="keyword">if</span> heapRetainedNow &lt;= gcPercentGoal || heapRetainedNow-gcPercentGoal &lt; <span class="type">uint64</span>(physPageSize) &#123;</span><br><span class="line">        <span class="comment">// 停止清理</span></span><br><span class="line">        scavenge.gcPercentGoal.Store(^<span class="type">uint64</span>(<span class="number">0</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        scavenge.gcPercentGoal.Store(gcPercentGoal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> init(gcPercent <span class="type">int32</span>, memoryLimit <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// heap最小为4MB</span></span><br><span class="line">    c.heapMinimum = defaultHeapMinimum</span><br><span class="line">    <span class="comment">// ^uint64(0) =&gt; 64位全为1</span></span><br><span class="line">    c.triggered = ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 设置gcPercent并返回旧值（gcPercent从GOGC环境变量获取，默认为100）</span></span><br><span class="line">    c.setGCPercent(gcPercent)</span><br><span class="line">    <span class="comment">// 设置memoryLimit（memoryLimit从GOMEMLIMIT环境变量获取，默认2^64-1）</span></span><br><span class="line">    c.setMemoryLimit(memoryLimit)</span><br><span class="line">    <span class="comment">// 设置GC启动阈值、计算目标heap大小和跑道大小</span></span><br><span class="line">    c.commit(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置gcPercent并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> setGCPercent(in <span class="type">int32</span>) <span class="type">int32</span> &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> !c.test &#123;</span><br><span class="line">        assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前值</span></span><br><span class="line">    out := c.gcPercent.Load()</span><br><span class="line">    <span class="comment">// 最小为-1</span></span><br><span class="line">    <span class="keyword">if</span> in &lt; <span class="number">0</span> &#123;</span><br><span class="line">        in = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =4MB*GCPercent/100 =&gt; GCPercent默认100</span></span><br><span class="line">    c.heapMinimum = defaultHeapMinimum * <span class="type">uint64</span>(in) / <span class="number">100</span></span><br><span class="line">    <span class="comment">// 纪录GCPercent</span></span><br><span class="line">    c.gcPercent.Store(in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置GC启动阈值、计算目标heap大小和跑道大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> commit(isSweepDone <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 测试，忽略</span></span><br><span class="line">    <span class="keyword">if</span> !c.test &#123;</span><br><span class="line">        <span class="comment">// 空函数（staticlockranking默认为false）</span></span><br><span class="line">        assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isSweepDone &#123;</span><br><span class="line">        <span class="comment">// sweeper数量为0 =&gt; 清扫阶段已结束，可以随时启动GC</span></span><br><span class="line">        <span class="comment">// =0</span></span><br><span class="line">        c.sweepDistMinTrigger.Store(<span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// sweeper数量不为0 =&gt; 还在清扫，设置一个阈值，避免GC过早启动</span></span><br><span class="line">        <span class="comment">// =heapLive+1MB</span></span><br><span class="line">        c.sweepDistMinTrigger.Store(c.heapLive.Load() + sweepMinHeapDistance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算目标heap大小，可以粗略地认为是2倍heap大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始值设为64位数最大值</span></span><br><span class="line">    gcPercentHeapGoal := ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// gcPercent默认为100</span></span><br><span class="line">    <span class="keyword">if</span> gcPercent := c.gcPercent.Load(); gcPercent &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//目标heap大小 =上一次GC后heap存活字节数 + (上一次GC后stack扫描字节数+全部模块的bss+data段大小)*100/100</span></span><br><span class="line">        gcPercentHeapGoal = c.heapMarked + (c.heapMarked+c.lastStackScan.Load()+c.globalsScan.Load())*<span class="type">uint64</span>(gcPercent)/<span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低为4MB</span></span><br><span class="line">    <span class="keyword">if</span> gcPercentHeapGoal &lt; c.heapMinimum &#123;</span><br><span class="line">        gcPercentHeapGoal = c.heapMinimum</span><br><span class="line">    &#125;</span><br><span class="line">    c.gcPercentHeapGoal.Store(gcPercentHeapGoal)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算runway大小，默认情况下为根对象大小的3倍</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =consMark*(1-0.25)/0.25*(heap扫描字节数+stack扫描字节数+全部模块的bss+data段大小)</span></span><br><span class="line">    c.runway.Store(<span class="type">uint64</span>((c.consMark * (<span class="number">1</span> - gcGoalUtilization) / (gcGoalUtilization)) * <span class="type">float64</span>(c.lastHeapScan+c.lastStackScan.Load()+c.globalsScan.Load())))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算GC触发阈值和目标heap大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> trigger() (<span class="type">uint64</span>, <span class="type">uint64</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）、最小目标heap大小</span></span><br><span class="line">    <span class="comment">// goal介于上一次GC后heap存活字节数和2*上一次GC后heap存活字节数</span></span><br><span class="line">    <span class="comment">// minTrigger为0或heap存活字节数+1MB</span></span><br><span class="line">    goal, minTrigger := c.heapGoalInternal()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一次GC后heap存活字节数 &gt;= 目标heap大小</span></span><br><span class="line">    <span class="keyword">if</span> c.heapMarked &gt;= goal &#123;</span><br><span class="line">        <span class="comment">// goal不应该小于heapMarked</span></span><br><span class="line">        <span class="keyword">return</span> goal, goal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c.heapMarked &lt; goal</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =max(最小目标heap大小,上一次GC后heap存活字节数)</span></span><br><span class="line">    <span class="keyword">if</span> minTrigger &lt; c.heapMarked &#123;</span><br><span class="line">        minTrigger = c.heapMarked</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低为70%触发</span></span><br><span class="line">    <span class="comment">// =(目标heap大小-上一次GC后heap存活字节数)/64*45 + 上一次GC后heap存活字节数</span></span><br><span class="line">    triggerLowerBound := ((goal-c.heapMarked)/triggerRatioDen)*minTriggerRatioNum + c.heapMarked</span><br><span class="line">    <span class="keyword">if</span> minTrigger &lt; triggerLowerBound &#123;</span><br><span class="line">        minTrigger = triggerLowerBound</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最高为95%触发</span></span><br><span class="line">    <span class="comment">// =(目标heap大小-上一次GC后heap存活字节数)/64*61 + 上一次GC后heap存活字节数</span></span><br><span class="line">    maxTrigger := ((goal-c.heapMarked)/triggerRatioDen)*maxTriggerRatioNum + c.heapMarked</span><br><span class="line">    <span class="comment">// 目标heap大小&gt;4MB and 目标heap大小-4MB&gt;maxTrigger</span></span><br><span class="line">    <span class="keyword">if</span> goal &gt; defaultHeapMinimum &amp;&amp; goal-defaultHeapMinimum &gt; maxTrigger &#123;</span><br><span class="line">        <span class="comment">// =目标heap大小-4MB</span></span><br><span class="line">        maxTrigger = goal - defaultHeapMinimum</span><br><span class="line">    &#125;</span><br><span class="line">    maxTrigger = max(maxTrigger, minTrigger)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发阈值</span></span><br><span class="line">    <span class="keyword">var</span> trigger <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 飞机起飞前需要滑行的距离，默认情况下为根对象大小的3倍</span></span><br><span class="line">    runway := c.runway.Load()</span><br><span class="line">    <span class="keyword">if</span> runway &gt; goal &#123;</span><br><span class="line">        <span class="comment">// 容错空间比目标heap大</span></span><br><span class="line">        <span class="comment">// 取最小目标heap大小</span></span><br><span class="line">        trigger = minTrigger</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 容错空间比目标heap小</span></span><br><span class="line">        <span class="comment">// 取剩余量</span></span><br><span class="line">        trigger = goal - runway</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最小为minTrigger</span></span><br><span class="line">    trigger = max(trigger, minTrigger)</span><br><span class="line">    <span class="comment">// 最大为maxTrigger</span></span><br><span class="line">    trigger = min(trigger, maxTrigger)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可能</span></span><br><span class="line">    <span class="keyword">if</span> trigger &gt; goal &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;trigger=&quot;</span>, trigger, <span class="string">&quot; heapGoal=&quot;</span>, goal, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;minTrigger=&quot;</span>, minTrigger, <span class="string">&quot; maxTrigger=&quot;</span>, maxTrigger, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;produced a trigger greater than the heap goal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trigger, goal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置相关字段，计算不同模式的标记工作线程目标，设置最大标记工作线程数，计算辅助GC的工作量转换参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> startCycle(markStartTime <span class="type">int64</span>, procs <span class="type">int</span>, trigger gcTrigger) &#123;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    c.heapScanWork.Store(<span class="number">0</span>)</span><br><span class="line">    c.stackScanWork.Store(<span class="number">0</span>)</span><br><span class="line">    c.globalsScanWork.Store(<span class="number">0</span>)</span><br><span class="line">    c.bgScanCredit.Store(<span class="number">0</span>)</span><br><span class="line">    c.assistTime.Store(<span class="number">0</span>)</span><br><span class="line">    c.dedicatedMarkTime.Store(<span class="number">0</span>)</span><br><span class="line">    c.fractionalMarkTime.Store(<span class="number">0</span>)</span><br><span class="line">    c.idleMarkTime.Store(<span class="number">0</span>)</span><br><span class="line">    c.markStartTime = markStartTime <span class="comment">// 开始时间</span></span><br><span class="line">    c.triggered = c.heapLive.Load() <span class="comment">// heap存活字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC设置25%的CPU使用率（GOGC=100时）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用率目标 =procs*0.25（假设为6核处理器，则结果为1.5）</span></span><br><span class="line">    totalUtilizationGoal := <span class="type">float64</span>(procs) * gcBackgroundUtilization</span><br><span class="line">    <span class="comment">// 四舍五入（假设为6核处理器，则结果为2）</span></span><br><span class="line">    dedicatedMarkWorkersNeeded := <span class="type">int64</span>(totalUtilizationGoal + <span class="number">0.5</span>)</span><br><span class="line">    <span class="comment">// （假设为6核处理器，则结果为0.333）</span></span><br><span class="line">    utilError := <span class="type">float64</span>(dedicatedMarkWorkersNeeded)/totalUtilizationGoal - <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> maxUtilError = <span class="number">0.3</span></span><br><span class="line">    <span class="comment">// 分数的绝对值超过0.3</span></span><br><span class="line">    <span class="keyword">if</span> utilError &lt; -maxUtilError || utilError &gt; maxUtilError &#123;</span><br><span class="line">        <span class="comment">// 目标值25%，实际超过30%，启动比例标记线程（GOMAXPROCS&lt;=3 or GOMAXPROCS=6时）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">float64</span>(dedicatedMarkWorkersNeeded) &gt; totalUtilizationGoal &#123;</span><br><span class="line">            <span class="comment">// 减少专用标记线程（假设为6核处理器，则结果为1）</span></span><br><span class="line">            dedicatedMarkWorkersNeeded--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// （假设为6核处理器，则结果为=(1.5-1)/6=0.083）</span></span><br><span class="line">        c.fractionalUtilizationGoal = (totalUtilizationGoal - <span class="type">float64</span>(dedicatedMarkWorkersNeeded)) / <span class="type">float64</span>(procs)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分数的绝对值小于等于0.3</span></span><br><span class="line">        <span class="comment">// 设为0</span></span><br><span class="line">        c.fractionalUtilizationGoal = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcstoptheworld默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debug.gcstoptheworld &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// STW时，只需要专用标记线程</span></span><br><span class="line">        dedicatedMarkWorkersNeeded = <span class="type">int64</span>(procs)</span><br><span class="line">        c.fractionalUtilizationGoal = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有p</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="comment">// 重置时间</span></span><br><span class="line">        p.gcAssistTime = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 比例标记任务耗时</span></span><br><span class="line">        p.gcFractionalMarkTime = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时触发</span></span><br><span class="line">    <span class="keyword">if</span> trigger.kind == gcTriggerTime &#123;</span><br><span class="line">        <span class="comment">// 减少空闲标记线程数量，某些场景下至少有一个专用标记线程</span></span><br><span class="line">        <span class="keyword">if</span> dedicatedMarkWorkersNeeded &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 大于0</span></span><br><span class="line">            <span class="comment">// 设置最大空闲标记线程数，不超过2^31</span></span><br><span class="line">            <span class="comment">// 如果此时idleMarkWorkers=3，那么这个值就是最大值</span></span><br><span class="line">            c.setMaxIdleMarkWorkers(<span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为0</span></span><br><span class="line">            <span class="comment">// 设置最大空闲标记线程数，不超过2^32</span></span><br><span class="line">            c.setMaxIdleMarkWorkers(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// heap触发或手动/强制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置最大空闲标记线程数（假设为6核处理器，则结果为5）</span></span><br><span class="line">        c.setMaxIdleMarkWorkers(<span class="type">int32</span>(procs) - <span class="type">int32</span>(dedicatedMarkWorkersNeeded))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纪录专用标记线程数量</span></span><br><span class="line">    c.dedicatedMarkWorkersNeeded.Store(dedicatedMarkWorkersNeeded)</span><br><span class="line">    <span class="comment">// 计算辅助GC的工作量转换参数</span></span><br><span class="line">    c.revise()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大空闲标记线程数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> setMaxIdleMarkWorkers(max <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := c.idleMarkWorkers.Load()</span><br><span class="line">        n := <span class="type">int32</span>(old &amp; <span class="type">uint64</span>(^<span class="type">uint32</span>(<span class="number">0</span>)))</span><br><span class="line">        <span class="comment">// 溢出（超过2^31)</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n, <span class="string">&quot; max=&quot;</span>, max, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;negative idle mark workers&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不超过2^31</span></span><br><span class="line">        <span class="built_in">new</span> := <span class="type">uint64</span>(<span class="type">uint32</span>(n)) | (<span class="type">uint64</span>(max) &lt;&lt; <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">if</span> c.idleMarkWorkers.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算辅助GC的工作量转换参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> revise() &#123;</span><br><span class="line">    <span class="comment">// GC参数</span></span><br><span class="line">    gcPercent := c.gcPercent.Load()</span><br><span class="line">    <span class="comment">// GOGC为负数，被禁用，但是用户强制执行GC</span></span><br><span class="line">    <span class="keyword">if</span> gcPercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">        gcPercent = <span class="number">100000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap相关参数</span></span><br><span class="line">    live := c.heapLive.Load() <span class="comment">// heap存活字节数</span></span><br><span class="line">    scan := c.heapScan.Load() <span class="comment">// heap扫描字节数 - 待扫描</span></span><br><span class="line">    <span class="comment">// 已扫描字节数 =heap扫描字节数+栈扫描字节数+bss/data段扫描字节数</span></span><br><span class="line">    work := c.heapScanWork.Load() + c.stackScanWork.Load() + c.globalsScanWork.Load()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）</span></span><br><span class="line">    heapGoal := <span class="type">int64</span>(c.heapGoal())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预期的扫描工作量 =heap扫描字节数+栈扫描字节数+全部模块的bss+data段大小</span></span><br><span class="line">    scanWorkExpected := <span class="type">int64</span>(c.lastHeapScan + c.lastStackScan.Load() + c.globalsScan.Load())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =累计所有的栈字节数</span></span><br><span class="line">    maxStackScan := c.maxStackScan.Load()</span><br><span class="line">    <span class="comment">// 最坏情况下的扫描量 =heap扫描字节数+累计所有的栈字节数+全部模块的bss+data段大小</span></span><br><span class="line">    maxScanWork := <span class="type">int64</span>(scan + maxStackScan + c.globalsScan.Load())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整目标heap大小</span></span><br><span class="line">    <span class="keyword">if</span> work &gt; scanWorkExpected &#123;</span><br><span class="line">        <span class="comment">// 软限制</span></span><br><span class="line">        <span class="comment">// =(heapGoal-triggered)/scanWorkExpected*maxScanWork+triggered</span></span><br><span class="line">        extHeapGoal := <span class="type">int64</span>(<span class="type">float64</span>(heapGoal-<span class="type">int64</span>(c.triggered))/<span class="type">float64</span>(scanWorkExpected)*<span class="type">float64</span>(maxScanWork)) + <span class="type">int64</span>(c.triggered)</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        scanWorkExpected = maxScanWork</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 硬限制</span></span><br><span class="line">        <span class="comment">// 2倍的heapGoal（GOGC=100时）</span></span><br><span class="line">        hardGoal := <span class="type">int64</span>((<span class="number">1.0</span> + <span class="type">float64</span>(gcPercent)/<span class="number">100.0</span>) * <span class="type">float64</span>(heapGoal))</span><br><span class="line">        <span class="comment">// 以硬限制为准</span></span><br><span class="line">        <span class="keyword">if</span> extHeapGoal &gt; hardGoal &#123;</span><br><span class="line">            extHeapGoal = hardGoal</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        heapGoal = extHeapGoal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存活对象已经超过目标heap大小</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">int64</span>(live) &gt; heapGoal &#123;</span><br><span class="line">        <span class="comment">// 放宽，允许超出10%</span></span><br><span class="line">        <span class="keyword">const</span> maxOvershoot = <span class="number">1.1</span></span><br><span class="line">        heapGoal = <span class="type">int64</span>(<span class="type">float64</span>(heapGoal) * maxOvershoot)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        scanWorkExpected = maxScanWork</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余扫描工作量=预计的总扫描工作量-已完成的扫描工作 =&gt; bss+data 或 bss+data+stack</span></span><br><span class="line">    scanWorkRemaining := scanWorkExpected - work</span><br><span class="line">    <span class="comment">// 最低为1000</span></span><br><span class="line">    <span class="keyword">if</span> scanWorkRemaining &lt; <span class="number">1000</span> &#123;</span><br><span class="line">        scanWorkRemaining = <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余heap空间 =&gt; heapGoal-heap存活字节数</span></span><br><span class="line">    heapRemaining := heapGoal - <span class="type">int64</span>(live)</span><br><span class="line">    <span class="keyword">if</span> heapRemaining &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 不应该发生，为防止除以0，设置为1</span></span><br><span class="line">        heapRemaining = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每分配1字节需要辅助完成多少GC工作量</span></span><br><span class="line">    assistWorkPerByte := <span class="type">float64</span>(scanWorkRemaining) / <span class="type">float64</span>(heapRemaining)</span><br><span class="line">    <span class="comment">// 每完成1单位GC工作量可以分配多少字节</span></span><br><span class="line">    assistBytesPerWork := <span class="type">float64</span>(heapRemaining) / <span class="type">float64</span>(scanWorkRemaining)</span><br><span class="line">    c.assistWorkPerByte.Store(assistWorkPerByte)</span><br><span class="line">    c.assistBytesPerWork.Store(assistBytesPerWork)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算目标heap大小和并发标记进度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> endCycle(now <span class="type">int64</span>, procs <span class="type">int</span>, userForced <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）</span></span><br><span class="line">    gcController.lastHeapGoal = c.heapGoal()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记阶段耗时</span></span><br><span class="line">    assistDuration := now - c.markStartTime</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC利用率 =0.25</span></span><br><span class="line">    utilization := gcBackgroundUtilization</span><br><span class="line">    <span class="comment">// 防止除以0</span></span><br><span class="line">    <span class="keyword">if</span> assistDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// += 助攻积分/总耗时</span></span><br><span class="line">        utilization += <span class="type">float64</span>(c.assistTime.Load()) / <span class="type">float64</span>(assistDuration*<span class="type">int64</span>(procs))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap存活字节数 &lt;= GC启动前heap存活字节数</span></span><br><span class="line">    <span class="keyword">if</span> c.heapLive.Load() &lt;= c.triggered &#123;</span><br><span class="line">        <span class="comment">// 不应该发生</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲GC利用率</span></span><br><span class="line">    idleUtilization := <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">if</span> assistDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// =闲标记耗时/总耗时</span></span><br><span class="line">        idleUtilization = <span class="type">float64</span>(c.idleMarkTime.Load()) / <span class="type">float64</span>(assistDuration*<span class="type">int64</span>(procs))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总扫描字节数 =heap扫描字节数+stack扫描字节数+bss/data扫描字节数</span></span><br><span class="line">    scanWork := c.heapScanWork.Load() + c.stackScanWork.Load() + c.globalsScanWork.Load()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前并发标记进度 =(heap存活字节数-GC启动前heap存活字节数)*(GC利用率+空闲GC利用率)/(总扫描字节数*(1-GC利用率))</span></span><br><span class="line">    currentConsMark := (<span class="type">float64</span>(c.heapLive.Load()-c.triggered) * (utilization + idleUtilization)) /</span><br><span class="line">        (<span class="type">float64</span>(scanWork) * (<span class="number">1</span> - utilization))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// currentConsMark &gt; 1.0 =&gt; GC当前落后于内存分配速度，会启用更激进的GC策略</span></span><br><span class="line">    <span class="comment">// currentConsMark &lt; 1.0 =&gt; GC当前标记进度是健康的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一次并发标记进度</span></span><br><span class="line">    oldConsMark := c.consMark</span><br><span class="line">    c.consMark = currentConsMark</span><br><span class="line">    <span class="comment">// 遍历历史4个consMark，已最大的为准</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c.lastConsMark &#123;</span><br><span class="line">        <span class="keyword">if</span> c.lastConsMark[i] &gt; c.consMark &#123;</span><br><span class="line">            c.consMark = c.lastConsMark[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 丢弃最旧的一个</span></span><br><span class="line">    <span class="built_in">copy</span>(c.lastConsMark[:], c.lastConsMark[<span class="number">1</span>:])</span><br><span class="line">    <span class="comment">// 放到第一个位置</span></span><br><span class="line">    c.lastConsMark[<span class="built_in">len</span>(c.lastConsMark)<span class="number">-1</span>] = currentConsMark</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记终止时，纪录快照，重置heapLive、heapMarked等字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> resetLive(bytesMarked <span class="type">uint64</span>) &#123;</span><br><span class="line">    c.heapMarked = bytesMarked</span><br><span class="line">    c.heapLive.Store(bytesMarked)</span><br><span class="line">    c.heapScan.Store(<span class="type">uint64</span>(c.heapScanWork.Load()))</span><br><span class="line">    c.lastHeapScan = <span class="type">uint64</span>(c.heapScanWork.Load())</span><br><span class="line">    c.lastStackScan.Store(<span class="type">uint64</span>(c.stackScanWork.Load()))</span><br><span class="line">    c.triggered = ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> heapGoal() <span class="type">uint64</span> &#123;</span><br><span class="line">    <span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）、最小目标heap大小</span></span><br><span class="line">    goal, _ := c.heapGoalInternal()</span><br><span class="line">    <span class="keyword">return</span> goal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算目标heap大小（一般情况下是上一次GC后heap存活字节数的两倍）、最小目标heap大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> heapGoalInternal() (goal, minTrigger <span class="type">uint64</span>) &#123;</span><br><span class="line">    <span class="comment">// 目标heap大小，可以粗略的认为是2*上一次GC后heap存活字节数</span></span><br><span class="line">    goal = c.gcPercentHeapGoal.Load()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据总内存限制计算目标heap大小，最小为上一次GC后heap存活字节数</span></span><br><span class="line">    <span class="keyword">if</span> newGoal := c.memoryLimitHeapGoal(); newGoal &lt; goal &#123;</span><br><span class="line">        goal = newGoal</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// newGoal &gt;= 目标heap大小</span></span><br><span class="line">        <span class="comment">// 一般情况下，memoryLimit不设置，所以都会走到这里</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清扫阶段已结束为0，否则为heap存活字节数+1MB</span></span><br><span class="line">        sweepDistTrigger := c.sweepDistMinTrigger.Load()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标heap大小 =max(goal,sweepDistTrigger)</span></span><br><span class="line">        <span class="keyword">if</span> sweepDistTrigger &gt; goal &#123;</span><br><span class="line">            goal = sweepDistTrigger</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最小目标heap大小</span></span><br><span class="line">        minTrigger = sweepDistTrigger</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> minRunway = <span class="number">64</span> &lt;&lt; <span class="number">10</span> <span class="comment">// 容错量=64KB</span></span><br><span class="line">        <span class="comment">// GC已启动 and 目标heap大小 &lt; 上一次GC后heap存活字节数+64KB</span></span><br><span class="line">        <span class="keyword">if</span> c.triggered != ^<span class="type">uint64</span>(<span class="number">0</span>) &amp;&amp; goal &lt; c.triggered+minRunway &#123;</span><br><span class="line">            goal = c.triggered + minRunway</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// goal介于上一次GC后heap存活字节数和2*上一次GC后heap存活字节数</span></span><br><span class="line">    <span class="comment">// minTrigger为0或heap存活字节数+1MB</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据总内存限制计算目标heap大小，最小为上一次GC后heap存活字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> memoryLimitHeapGoal() <span class="type">uint64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> heapFree, heapAlloc, mappedReady <span class="type">uint64</span></span><br><span class="line">    <span class="comment">// 确认当前内存状态一致、合法</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        heapFree = c.heapFree.load()                         <span class="comment">// heap内存可复用量</span></span><br><span class="line">        heapAlloc = c.totalAlloc.Load() - c.totalFree.Load() <span class="comment">// 累计已分配字节数-累计回收量</span></span><br><span class="line">        mappedReady = c.mappedReady.Load()                   <span class="comment">// 已映射且可用的内存量（总内存）</span></span><br><span class="line">        <span class="keyword">if</span> heapFree+heapAlloc &lt;= mappedReady &#123;</span><br><span class="line">            <span class="comment">// 一切正常</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不可能发生，因为部份更新的缘故，需要重试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总内存限制 = heap+nonHeap</span></span><br><span class="line">    memoryLimit := <span class="type">uint64</span>(c.memoryLimit.Load())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非heap内存 =总内存-heap内存可复用量-累计已分配字节数</span></span><br><span class="line">    nonHeapMemory := mappedReady - heapFree - heapAlloc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> overage <span class="type">uint64</span></span><br><span class="line">    <span class="comment">// 总内存超过限制</span></span><br><span class="line">    <span class="keyword">if</span> mappedReady &gt; memoryLimit &#123;</span><br><span class="line">        <span class="comment">// 超出部份</span></span><br><span class="line">        overage = mappedReady - memoryLimit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非heap内存+内存超出部份 &gt;= memoryLimit</span></span><br><span class="line">    <span class="keyword">if</span> nonHeapMemory+overage &gt;= memoryLimit &#123;</span><br><span class="line">        <span class="comment">// 上一次GC后heap存活字节数 =&gt; 立即回收</span></span><br><span class="line">        <span class="keyword">return</span> c.heapMarked</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 距离内存限制剩余量</span></span><br><span class="line">    goal := memoryLimit - (nonHeapMemory + overage)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容错空间 =3%的goal，最低为1MB</span></span><br><span class="line">    headroom := goal / <span class="number">100</span> * memoryLimitHeapGoalHeadroomPercent</span><br><span class="line">    <span class="keyword">if</span> headroom &lt; memoryLimitMinHeapGoalHeadroom &#123;</span><br><span class="line">        headroom = memoryLimitMinHeapGoalHeadroom</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;容错空间 or &lt;2倍的容错空间</span></span><br><span class="line">    <span class="keyword">if</span> goal &lt; headroom || goal-headroom &lt; headroom &#123;</span><br><span class="line">        goal = headroom</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        goal = goal - headroom</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// goal &gt;= headroom</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低为上一次GC后heap存活字节数</span></span><br><span class="line">    <span class="keyword">if</span> goal &lt; c.heapMarked &#123;</span><br><span class="line">        goal = c.heapMarked</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> goal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累计标记耗时、复原计数器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> markWorkerStop(mode gcMarkWorkerMode, duration <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> mode &#123;</span><br><span class="line">    <span class="keyword">case</span> gcMarkWorkerDedicatedMode:  <span class="comment">// 专用标记任务</span></span><br><span class="line">        <span class="comment">// 累计标记耗时</span></span><br><span class="line">        c.dedicatedMarkTime.Add(duration)</span><br><span class="line">        <span class="comment">// 重置，启动worker时-1，复原时+1</span></span><br><span class="line">        c.dedicatedMarkWorkersNeeded.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">case</span> gcMarkWorkerFractionalMode: <span class="comment">// 比例标记任务</span></span><br><span class="line">        <span class="comment">// 累计标记耗时</span></span><br><span class="line">        c.fractionalMarkTime.Add(duration)</span><br><span class="line">    <span class="keyword">case</span> gcMarkWorkerIdleMode:       <span class="comment">// 空闲标记任务</span></span><br><span class="line">        <span class="comment">// 累计标记耗时</span></span><br><span class="line">        c.idleMarkTime.Add(duration)</span><br><span class="line">        <span class="comment">// idleMarkWorkers计数器减1</span></span><br><span class="line">        c.removeIdleMarkWorker()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        throw(<span class="string">&quot;markWorkerStop: unknown mark worker mode&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累计heap存活字节数，如果GC未启动则累计heap扫描字节数，否则重新计算辅助GC的工作量转换参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> update(dHeapLive, dHeapScan <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> dHeapLive != <span class="number">0</span> &#123;</span><br><span class="line">        live := gcController.heapLive.Add(dHeapLive)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC未启动/停止</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 需要被GC扫描的字节数不为0 =&gt; scan类型</span></span><br><span class="line">        <span class="keyword">if</span> dHeapScan != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 累计到heapScan</span></span><br><span class="line">            gcController.heapScan.Add(dHeapScan)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算辅助GC的工作量转换参数</span></span><br><span class="line">        c.revise()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲标记线程数量是否超过最大限制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> needIdleMarkWorker() <span class="type">bool</span> &#123;</span><br><span class="line">    p := c.idleMarkWorkers.Load()</span><br><span class="line">    <span class="comment">// 低32位，高32位</span></span><br><span class="line">    n, max := <span class="type">int32</span>(p&amp;<span class="type">uint64</span>(^<span class="type">uint32</span>(<span class="number">0</span>))), <span class="type">int32</span>(p&gt;&gt;<span class="number">32</span>)</span><br><span class="line">    <span class="comment">// 空闲标记线程数量是否超过最大限制</span></span><br><span class="line">    <span class="keyword">return</span> n &lt; max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲标记线程数量加1，超过最大限制时失败</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> addIdleMarkWorker() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := c.idleMarkWorkers.Load()</span><br><span class="line">        <span class="comment">// 低32位，高32位</span></span><br><span class="line">        n, max := <span class="type">int32</span>(old&amp;<span class="type">uint64</span>(^<span class="type">uint32</span>(<span class="number">0</span>))), <span class="type">int32</span>(old&gt;&gt;<span class="number">32</span>)</span><br><span class="line">        <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">if</span> n &gt;= max &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n, <span class="string">&quot; max=&quot;</span>, max, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;negative idle mark workers&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器加1</span></span><br><span class="line">        <span class="built_in">new</span> := <span class="type">uint64</span>(<span class="type">uint32</span>(n+<span class="number">1</span>)) | (<span class="type">uint64</span>(max) &lt;&lt; <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">if</span> c.idleMarkWorkers.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 失败，重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idleMarkWorkers计数器减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> removeIdleMarkWorker() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := c.idleMarkWorkers.Load()</span><br><span class="line">        <span class="comment">// 低32位，高32位</span></span><br><span class="line">        n, max := <span class="type">int32</span>(old&amp;<span class="type">uint64</span>(^<span class="type">uint32</span>(<span class="number">0</span>))), <span class="type">int32</span>(old&gt;&gt;<span class="number">32</span>)</span><br><span class="line">        <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">if</span> n<span class="number">-1</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n, <span class="string">&quot; max=&quot;</span>, max, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            throw(<span class="string">&quot;negative idle mark workers&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器减1</span></span><br><span class="line">        <span class="built_in">new</span> := <span class="type">uint64</span>(<span class="type">uint32</span>(n<span class="number">-1</span>)) | (<span class="type">uint64</span>(max) &lt;&lt; <span class="number">32</span>)</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">if</span> c.idleMarkWorkers.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 失败，重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要更多的专用标记线程，随机抢占一个p运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> enlistWorker() &#123;</span><br><span class="line">    <span class="comment">// 已经不需要新的空闲标记线程了</span></span><br><span class="line">    <span class="keyword">if</span> c.dedicatedMarkWorkersNeeded.Load() &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要更多的专用标记线程，抢占一个p运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有1个CPU</span></span><br><span class="line">    <span class="keyword">if</span> gomaxprocs &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> || gp.m == <span class="literal">nil</span> || gp.m.p == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p的索引</span></span><br><span class="line">    myID := gp.m.p.ptr().id</span><br><span class="line">    <span class="comment">// 随机挑选一个p抢占</span></span><br><span class="line">    <span class="keyword">for</span> tries := <span class="number">0</span>; tries &lt; <span class="number">5</span>; tries++ &#123;</span><br><span class="line">        id := <span class="type">int32</span>(cheaprandn(<span class="type">uint32</span>(gomaxprocs - <span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">if</span> id &gt;= myID &#123;</span><br><span class="line">            id++</span><br><span class="line">        &#125;</span><br><span class="line">        p := allp[id]</span><br><span class="line">        <span class="comment">// 运行中，重试</span></span><br><span class="line">        <span class="keyword">if</span> p.status != _Prunning &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置g、p抢占标志、发送抢占信号给m</span></span><br><span class="line">        <span class="keyword">if</span> preemptone(p) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从gcBgMarkWorkerPool获取一个g，符合条件则返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> findRunnableGCWorker(pp *p, now <span class="type">int64</span>) (*g, <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// GC未启动/停止</span></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcControllerState.findRunnable: blackening not enabled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 耗时超过10ms则需要更新</span></span><br><span class="line">    <span class="keyword">if</span> gcCPULimiter.needUpdate(now) &#123;</span><br><span class="line">        <span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line">        gcCPULimiter.update(now)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否还有标记任务（根对象是否扫描完，任务缓冲区是否为空）</span></span><br><span class="line">    <span class="keyword">if</span> !gcMarkWorkAvailable(pp) &#123;</span><br><span class="line">        <span class="comment">// 没有任务可执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要新的专用标记线程以及比例标记线程</span></span><br><span class="line">    <span class="keyword">if</span> c.dedicatedMarkWorkersNeeded.Load() &lt;= <span class="number">0</span> &amp;&amp; c.fractionalUtilizationGoal == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 返回nil</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从gcBgMarkWorkerPool拿一个g</span></span><br><span class="line">    node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">    <span class="comment">// 没有数据</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v&gt;0时，减1</span></span><br><span class="line">    decIfPositive := <span class="function"><span class="keyword">func</span><span class="params">(val *atomic.Int64)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            v := val.Load()</span><br><span class="line">            <span class="keyword">if</span> v &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> val.CompareAndSwap(v, v<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动标记线程，dedicatedMarkWorkersNeeded-=1，线程退出时会加回来</span></span><br><span class="line">    <span class="keyword">if</span> decIfPositive(&amp;c.dedicatedMarkWorkersNeeded) &#123;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 专用标记任务</span></span><br><span class="line">        pp.gcMarkWorkerMode = gcMarkWorkerDedicatedMode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.fractionalUtilizationGoal == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 比例标记任务利用率目标为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放回池子</span></span><br><span class="line">        gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 比例标记任务利用率目标不为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记阶段耗时</span></span><br><span class="line">        delta := now - c.markStartTime</span><br><span class="line">        <span class="comment">// 比例标记任务下的标记耗时/总耗时 &gt; 比例标记任务利用率目标</span></span><br><span class="line">        <span class="keyword">if</span> delta &gt; <span class="number">0</span> &amp;&amp; <span class="type">float64</span>(pp.gcFractionalMarkTime)/<span class="type">float64</span>(delta) &gt; c.fractionalUtilizationGoal &#123;</span><br><span class="line">            <span class="comment">// 超过比例标记任务利用率目标</span></span><br><span class="line">            <span class="comment">// g放回池子</span></span><br><span class="line">            gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, now</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有超过比例标记任务利用率目标</span></span><br><span class="line">        <span class="comment">// 启动一个比例标记线程</span></span><br><span class="line">        pp.gcMarkWorkerMode = gcMarkWorkerFractionalMode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g</span></span><br><span class="line">    gp := node.gp.ptr()</span><br><span class="line">    <span class="comment">// 从_Gwaiting状态改为_Grunnable</span></span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gp, now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcCPULimiterState-CPU限制器"><a href="#gcCPULimiterState-CPU限制器" class="headerlink" title="gcCPULimiterState-CPU限制器"></a>gcCPULimiterState-CPU限制器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enabled为true =&gt; 限制GC运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> limiting() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> l.enabled.Load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时超过10ms则需要更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> needUpdate(now <span class="type">int64</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// now-lastUpdate &gt; 10e6 </span></span><br><span class="line">    <span class="keyword">return</span> now-l.lastUpdate.Load() &gt; gcCPULimiterUpdatePeriod</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步gcEnabled、标记当前处于过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> startGCTransition(enableGC <span class="type">bool</span>, now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 原子更新lock，0-&gt;1</span></span><br><span class="line">    <span class="keyword">if</span> !l.tryLock() &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        throw(<span class="string">&quot;failed to acquire lock to start a GC transition&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跟传入的参数一样，状态没有发生变更</span></span><br><span class="line">    <span class="keyword">if</span> l.gcEnabled == enableGC &#123;</span><br><span class="line">        throw(<span class="string">&quot;transitioning GC to the same state as before?&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行</span></span><br><span class="line">    l.updateLocked(now)</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    l.gcEnabled = enableGC</span><br><span class="line">    <span class="comment">// 标记当前处于过渡状态</span></span><br><span class="line">    l.transitioning = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除过渡状态，计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> finishGCTransition(now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 状态不对，处于非过渡状态</span></span><br><span class="line">    <span class="keyword">if</span> !l.transitioning &#123;</span><br><span class="line">        throw(<span class="string">&quot;finishGCTransition called without starting one?&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 纪录耗时</span></span><br><span class="line">    <span class="keyword">if</span> lastUpdate := l.lastUpdate.Load(); now &gt;= lastUpdate &#123;</span><br><span class="line">        <span class="comment">// 根据mutator耗时跟gc耗时判断是否需要限制GC运行</span></span><br><span class="line">        l.accumulate(<span class="number">0</span>, (now-lastUpdate)*<span class="type">int64</span>(l.nprocs))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步now</span></span><br><span class="line">    l.lastUpdate.Store(now)</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    l.transitioning = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    l.unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行（加锁）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> update(now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 原子更新lock，0-&gt;1</span></span><br><span class="line">    <span class="keyword">if</span> !l.tryLock() &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常，处于过渡状态中，已经在调整了</span></span><br><span class="line">    <span class="keyword">if</span> l.transitioning &#123;</span><br><span class="line">        throw(<span class="string">&quot;update during transition&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行</span></span><br><span class="line">    l.updateLocked(now)</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    l.unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算mutator耗时跟gc耗时，判断是否需要限制GC运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> updateLocked(now <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 上一次update时的now参数</span></span><br><span class="line">    lastUpdate := l.lastUpdate.Load()</span><br><span class="line">    <span class="comment">// 过期不处理</span></span><br><span class="line">    <span class="keyword">if</span> now &lt; lastUpdate &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU总耗时</span></span><br><span class="line">    windowTotalTime := (now - lastUpdate) * <span class="type">int64</span>(l.nprocs)</span><br><span class="line">    <span class="comment">// 纪录now</span></span><br><span class="line">    l.lastUpdate.Store(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将助攻积分清0</span></span><br><span class="line">    assistTime := l.assistTimePool.Load()</span><br><span class="line">    <span class="keyword">if</span> assistTime != <span class="number">0</span> &#123;</span><br><span class="line">        l.assistTimePool.Add(-assistTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将p的空闲辅助标记耗时清0</span></span><br><span class="line">    idleTime := l.idleTimePool.Load()</span><br><span class="line">    <span class="keyword">if</span> idleTime != <span class="number">0</span> &#123;</span><br><span class="line">        l.idleTimePool.Add(-idleTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非测试</span></span><br><span class="line">    <span class="keyword">if</span> !l.test &#123;</span><br><span class="line">        <span class="comment">// 禁止抢占</span></span><br><span class="line">        mp := acquirem()</span><br><span class="line">        <span class="comment">// 遍历所有p</span></span><br><span class="line">        <span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            typ, duration := pp.limiterEvent.consume(now)</span><br><span class="line">            <span class="keyword">switch</span> typ &#123;</span><br><span class="line">            <span class="keyword">case</span> limiterEventIdleMarkWork:   <span class="comment">// 空闲辅助标记</span></span><br><span class="line">                <span class="keyword">fallthrough</span></span><br><span class="line">            <span class="keyword">case</span> limiterEventIdle:           <span class="comment">// 空闲</span></span><br><span class="line">                idleTime += duration</span><br><span class="line">                sched.idleTime.Add(duration)</span><br><span class="line">            <span class="keyword">case</span> limiterEventMarkAssist:     <span class="comment">// 辅助标记</span></span><br><span class="line">                <span class="keyword">fallthrough</span></span><br><span class="line">            <span class="keyword">case</span> limiterEventScavengeAssist: <span class="comment">// 辅助回收</span></span><br><span class="line">                assistTime += duration</span><br><span class="line">            <span class="keyword">case</span> limiterEventNone:           <span class="comment">// 无</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                throw(<span class="string">&quot;invalid limiter event type found&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        releasem(mp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 助攻积分 =&gt; 花费在GC上的时间</span></span><br><span class="line">    windowGCTime := assistTime</span><br><span class="line">    <span class="comment">// 还在标记阶段</span></span><br><span class="line">    <span class="keyword">if</span> l.gcEnabled &#123;</span><br><span class="line">        <span class="comment">// =助攻积分+25%的总耗时</span></span><br><span class="line">        windowGCTime += <span class="type">int64</span>(<span class="type">float64</span>(windowTotalTime) * gcBackgroundUtilization)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 总耗时-=p空闲辅助标记耗时</span></span><br><span class="line">    windowTotalTime -= idleTime</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据mutator耗时跟gc耗时判断是否需要限制GC运行</span></span><br><span class="line">    <span class="comment">// 总耗时-助攻积分（耗时） =&gt; 剩下的就是非GC耗时，助攻积分（GC耗时）</span></span><br><span class="line">    l.accumulate(windowTotalTime-windowGCTime, windowGCTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据mutator耗时跟gc耗时判断是否需要限制GC运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gcCPULimiterState)</span></span> accumulate(mutatorTime, gcTime <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 整个逻辑有点像TCP的慢启动、拥塞避免</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统发放的额度，范围：[0,fill]</span></span><br><span class="line">    headroom := l.bucket.capacity - l.bucket.fill</span><br><span class="line">    <span class="comment">// fill==capacity =&gt; 额度为0</span></span><br><span class="line">    enabled := headroom == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欠债=gc耗时-mutator耗时</span></span><br><span class="line">    change := gcTime - mutatorTime</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gc耗时超过mutator耗时 and 额度不足</span></span><br><span class="line">    <span class="keyword">if</span> change &gt; <span class="number">0</span> &amp;&amp; headroom &lt;= <span class="type">uint64</span>(change) &#123;</span><br><span class="line">        <span class="comment">// 超额累计到overflow</span></span><br><span class="line">        l.overflow += <span class="type">uint64</span>(change) - headroom</span><br><span class="line">        <span class="comment">// 水桶满了</span></span><br><span class="line">        l.bucket.fill = l.bucket.capacity</span><br><span class="line">        <span class="comment">// 以前没限速过</span></span><br><span class="line">        <span class="keyword">if</span> !enabled &#123;</span><br><span class="line">            <span class="comment">// 开启限速 </span></span><br><span class="line">            l.enabled.Store(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// 记录限速开始的GC轮次</span></span><br><span class="line">            l.lastEnabledCycle.Store(memstats.numgc + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gc耗时小于或等于mutator耗时（回收额度） or 额度足够</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止fill小于0</span></span><br><span class="line">    <span class="keyword">if</span> change &lt; <span class="number">0</span> &amp;&amp; l.bucket.fill &lt;= <span class="type">uint64</span>(-change) &#123;</span><br><span class="line">        <span class="comment">// 直接清0</span></span><br><span class="line">        l.bucket.fill = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 继续释放额度</span></span><br><span class="line">        l.bucket.fill -= <span class="type">uint64</span>(-change)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前是限速状态</span></span><br><span class="line">    <span class="keyword">if</span> change != <span class="number">0</span> &amp;&amp; enabled &#123;</span><br><span class="line">        <span class="comment">// 取消限速</span></span><br><span class="line">        l.enabled.Store(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GMP调度相关"><a href="#GMP调度相关" class="headerlink" title="GMP调度相关"></a>GMP调度相关</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起GC时，已经有其他G运行（同一个周期），挂起等待（_GCmarktermination时唤醒）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcWaitOnMark</span><span class="params">(n <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock(&amp;work.sweepWaiters.lock)</span><br><span class="line">        <span class="comment">// 正在执行的周期</span></span><br><span class="line">        nMarks := work.cycles.Load()</span><br><span class="line">        <span class="comment">// GC还没发起</span></span><br><span class="line">        <span class="keyword">if</span> gcphase != _GCmark &#123;</span><br><span class="line">            <span class="comment">// 预判下一个周期</span></span><br><span class="line">            nMarks++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否是同一个周期</span></span><br><span class="line">        <span class="keyword">if</span> nMarks &gt; n &#123;</span><br><span class="line">            <span class="comment">// 可以继续执行</span></span><br><span class="line">            unlock(&amp;work.sweepWaiters.lock)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个周期</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把g放到链表</span></span><br><span class="line">        work.sweepWaiters.list.push(getg())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前g让出CPU，g0执行调度运行其他g</span></span><br><span class="line">        <span class="comment">// 在内部g、m解除绑定后会解锁sweepWaiters.lock</span></span><br><span class="line">        goparkunlock(&amp;work.sweepWaiters.lock, waitReasonWaitForGCCycle, traceBlockUntilGCEnds, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步标记，如果允许user类型g运行则把阻塞的g全部放回全局队列并尝试获取p绑定m唤醒运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedEnableUser</span><span class="params">(enable <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 已经设置了</span></span><br><span class="line">    <span class="keyword">if</span> sched.disable.user == !enable &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    sched.disable.user = !enable</span><br><span class="line">    <span class="comment">// 如果是允许user类型g运行</span></span><br><span class="line">    <span class="keyword">if</span> enable &#123;</span><br><span class="line">        <span class="comment">// g数量</span></span><br><span class="line">        n := sched.disable.n</span><br><span class="line">        sched.disable.n = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 把一批g放到全局队列</span></span><br><span class="line">        globrunqputbatch(&amp;sched.disable.runnable, n)</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="comment">// 如果g数量不为0 and 空闲p数量也不为0</span></span><br><span class="line">        <span class="keyword">for</span> ; n != <span class="number">0</span> &amp;&amp; sched.npidle.Load() != <span class="number">0</span>; n-- &#123;</span><br><span class="line">             <span class="comment">// 从midle空闲链表中拿一个m绑定p并唤醒（可能拿不到p）</span></span><br><span class="line">            startm(<span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新p、调度器状态，把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcstopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态不一致</span></span><br><span class="line">    <span class="keyword">if</span> !sched.gcwaiting.Load() &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcstopm: not waiting for gc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m自旋中</span></span><br><span class="line">    <span class="keyword">if</span> gp.m.spinning &#123;</span><br><span class="line">        <span class="comment">// 重置spinning</span></span><br><span class="line">        gp.m.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 复原，nmspinning-=1</span></span><br><span class="line">        <span class="keyword">if</span> sched.nmspinning.Add(<span class="number">-1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 小于0，异常</span></span><br><span class="line">            throw(<span class="string">&quot;gcstopm: negative nmspinning&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消p与m的绑定</span></span><br><span class="line">    pp := releasep()</span><br><span class="line">    <span class="comment">// 调度器加锁</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// p的状态设置为_Pgcstop</span></span><br><span class="line">    pp.status = _Pgcstop</span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    pp.gcStopTime = nanotime()</span><br><span class="line">    <span class="comment">// 计数器stopwait-=1</span></span><br><span class="line">    sched.stopwait--</span><br><span class="line">    <span class="comment">// 所有的p都放到空闲队列了</span></span><br><span class="line">    <span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒GC相关的m（m放在stopnote.key）</span></span><br><span class="line">        notewakeup(&amp;sched.stopnote)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="comment">// 把m放到midle空闲链表并挂起休眠，被唤醒后绑定一个p返回</span></span><br><span class="line">    stopm()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列为空时执行netpoll轮询，检查有g返回true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pollWork</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 全局队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    p := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// 本地队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> !runqempty(p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// netpoll已初始化 and 挂起的g数量不为0 and 当前没有进行轮询</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; netpollAnyWaiters() &amp;&amp; sched.lastpoll.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 平台相关</span></span><br><span class="line">        <span class="comment">// 执行epollWait检查，0-没有数据立即返回</span></span><br><span class="line">        <span class="keyword">if</span> list, delta := netpoll(<span class="number">0</span>); !list.empty() &#123;</span><br><span class="line">            <span class="comment">// 修改g状态放进本地/全局队列，并尝试唤醒m处理</span></span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            <span class="comment">// 计数器+=delta =&gt; netpollWaiters+=delta</span></span><br><span class="line">            netpollAdjustWaiters(delta)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断标记工作线程是否需要自我抢占，超过目标值返回true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pollFractionalWorkerExit</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 当前时刻</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="comment">// 当前周期GC耗时</span></span><br><span class="line">    delta := now - gcController.markStartTime</span><br><span class="line">    <span class="comment">// 防御性编程</span></span><br><span class="line">    <span class="keyword">if</span> delta &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p</span></span><br><span class="line">    p := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// 比例标记线程会多次启动、暂停，gcFractionalMarkTime是历史累计，gcMarkWorkerStartTime是当前运行耗时，相当于最后一次纪录</span></span><br><span class="line">    <span class="comment">// 当前周期内的总耗时=比例标记任务下的耗时+当前比例标记线程的耗时</span></span><br><span class="line">    selfTime := p.gcFractionalMarkTime + (now - p.gcMarkWorkerStartTime)</span><br><span class="line">    <span class="comment">// 当前周期内的总耗时/当前周期GC耗时 &gt; 1.2*比例标记任务利用率目标 =&gt; 比例标记任务的CPU使用率是否超过目标值的1.2倍</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(selfTime)/<span class="type">float64</span>(delta) &gt; <span class="number">1.2</span>*gcController.fractionalUtilizationGoal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据额度唤醒一批g，额度有剩余就累计到全局额度bgScanCredit（与gcParkAssist成对使用）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcFlushBgCredit</span><span class="params">(scanWork <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// assist队列为空</span></span><br><span class="line">    <span class="keyword">if</span> work.assistQueue.q.empty() &#123;</span><br><span class="line">        <span class="comment">// 额度累计到全局bgScanCredit</span></span><br><span class="line">        gcController.bgScanCredit.Add(scanWork)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换参数</span></span><br><span class="line">    assistBytesPerWork := gcController.assistBytesPerWork.Load()</span><br><span class="line">    <span class="comment">// 额度转换为字节数</span></span><br><span class="line">    scanBytes := <span class="type">int64</span>(<span class="type">float64</span>(scanWork) * assistBytesPerWork)</span><br><span class="line"></span><br><span class="line">    lock(&amp;work.assistQueue.lock)</span><br><span class="line">    <span class="comment">// assist队列不为空 and 额度大于0</span></span><br><span class="line">    <span class="keyword">for</span> !work.assistQueue.q.empty() &amp;&amp; scanBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 拿走队列第一个g</span></span><br><span class="line">        gp := work.assistQueue.q.pop()</span><br><span class="line">        <span class="comment">// &gt;=0 =&gt; 额度为正，不欠债</span></span><br><span class="line">        <span class="keyword">if</span> scanBytes+gp.gcAssistBytes &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// g的欠债，字节数</span></span><br><span class="line">            scanBytes += gp.gcAssistBytes</span><br><span class="line">            <span class="comment">// 重置，不欠债</span></span><br><span class="line">            gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 将g放到p.runq队列，从空闲队列拿一个p和一个m绑定并唤醒（可能拿不到p）</span></span><br><span class="line">            <span class="comment">// 放到队列尾部，降低优先级。这个g是gcParkAssist导致挂起的</span></span><br><span class="line">            ready(gp, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 额度还有数据，继续找下一个g</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// &lt;0，g还是欠债状态</span></span><br><span class="line">            <span class="comment">// 更新g的额度</span></span><br><span class="line">            gp.gcAssistBytes += scanBytes</span><br><span class="line">            <span class="comment">// 额度用完了</span></span><br><span class="line">            scanBytes = <span class="number">0</span></span><br><span class="line">            <span class="comment">// g放回队列，继续挂起等待</span></span><br><span class="line">            work.assistQueue.q.pushBack(gp)</span><br><span class="line">            <span class="comment">// 额度用完了，剩下的g也不用处理了，退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要么队列为空 or 要么额度不足</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 额度还有，那就是队列为空</span></span><br><span class="line">    <span class="keyword">if</span> scanBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 转换参数</span></span><br><span class="line">        assistWorkPerByte := gcController.assistWorkPerByte.Load()</span><br><span class="line">        <span class="comment">// 字节转换成额度</span></span><br><span class="line">        scanWork = <span class="type">int64</span>(<span class="type">float64</span>(scanBytes) * assistWorkPerByte)</span><br><span class="line">        <span class="comment">// 剩余的额度累计到全局bgScanCredit</span></span><br><span class="line">        gcController.bgScanCredit.Add(scanWork)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;work.assistQueue.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈相关"><a href="#栈相关" class="headerlink" title="栈相关"></a>栈相关</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackfree</span><span class="params">(stk stack)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// stk.lo</span></span><br><span class="line">    v := unsafe.Pointer(stk.lo)</span><br><span class="line">    <span class="comment">// 栈空间大小</span></span><br><span class="line">    n := stk.hi - stk.lo</span><br><span class="line">    <span class="comment">// 非2的倍数</span></span><br><span class="line">    <span class="keyword">if</span> n&amp;(n<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;stack not a power of 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> stk.lo+n &lt; stk.hi &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad stack size&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;stackfree&quot;</span>, v, n)</span><br><span class="line">        memclrNoHeapPointers(v, n) <span class="comment">// for testing, clobber stack data</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug.efence默认为0、stackFromSystem默认为0，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debug.efence != <span class="number">0</span> || stackFromSystem != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> debug.efence != <span class="number">0</span> || stackFaultOnFree != <span class="number">0</span> &#123;</span><br><span class="line">            sysFault(v, n)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sysFree(v, n, &amp;memstats.stacks_sys)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n &lt; 2KB*2^4 and n &lt; 32KB（一样的条件）</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; fixedStack&lt;&lt;_NumStackOrders &amp;&amp; n &lt; _StackCacheSize &#123;</span><br><span class="line">        <span class="comment">// order索引，linux下有4个层级</span></span><br><span class="line">        order := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">        n2 := n</span><br><span class="line">        <span class="comment">// &gt;2KB</span></span><br><span class="line">        <span class="keyword">for</span> n2 &gt; fixedStack &#123;</span><br><span class="line">            order++</span><br><span class="line">            n2 &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// stk.lo</span></span><br><span class="line">        x := gclinkptr(v)</span><br><span class="line">        <span class="comment">// stackNoCache默认为0 or 没有p or 禁止抢占</span></span><br><span class="line">        <span class="keyword">if</span> stackNoCache != <span class="number">0</span> || gp.m.p == <span class="number">0</span> || gp.m.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            lock(&amp;stackpool[order].item.mu)</span><br><span class="line">            <span class="comment">// 纪录mspan到stackpool、栈放回mspan.manualFreeList，符合条件则将mspan释放回系统</span></span><br><span class="line">            stackpoolfree(x, order)</span><br><span class="line">            unlock(&amp;stackpool[order].item.mu)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有p and 可抢占</span></span><br><span class="line">            c := gp.m.p.ptr().mcache</span><br><span class="line">            <span class="comment">// &gt;= 32KB</span></span><br><span class="line">            <span class="keyword">if</span> c.stackcache[order].size &gt;= _StackCacheSize &#123;</span><br><span class="line">                <span class="comment">// 将一半的数据使用stackpoolfree释放</span></span><br><span class="line">                stackcacherelease(c, order)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 放回stackcache</span></span><br><span class="line">            x.ptr().next = c.stackcache[order].list</span><br><span class="line">            c.stackcache[order].list = x</span><br><span class="line">            c.stackcache[order].size += n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// n &gt;= 32KB</span></span><br><span class="line">        <span class="comment">// 根据地址找到heapArena再找到mspan</span></span><br><span class="line">        s := spanOfUnchecked(<span class="type">uintptr</span>(v))</span><br><span class="line">        <span class="comment">// 非手动管理，异常</span></span><br><span class="line">        <span class="keyword">if</span> s.state.get() != mSpanManual &#123;</span><br><span class="line">            <span class="built_in">println</span>(hex(s.base()), v)</span><br><span class="line">            throw(<span class="string">&quot;bad span state&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> gcphase == _GCoff &#123;</span><br><span class="line">            <span class="comment">// 清理阶段</span></span><br><span class="line">            <span class="comment">// 释放栈</span></span><br><span class="line">            osStackFree(s)</span><br><span class="line">            mheap_.freeManual(s, spanAllocStack)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// GC运行中</span></span><br><span class="line">            <span class="comment">// mspan可能被重用，状态修改可能跟GC冲突，直接放到stackLarge即可</span></span><br><span class="line">            log2npage := stacklog2(s.npages)</span><br><span class="line">            lock(&amp;stackLarge.lock)</span><br><span class="line">            stackLarge.free[log2npage].insert(s)</span><br><span class="line">            unlock(&amp;stackLarge.lock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描栈帧内指针、defer链、panic、state.buf队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanstack</span><span class="params">(gp *g, gcw *gcWork)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 判断g的状态是不是_Gscanrunnable、_Gscansyscall、_Gscanwaiting</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有_Gscan标志，异常</span></span><br><span class="line">    <span class="keyword">if</span> readgstatus(gp)&amp;_Gscan == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime:scanstack: gp=&quot;</span>, gp, <span class="string">&quot;, goid=&quot;</span>, gp.goid, <span class="string">&quot;, gp-&gt;atomicstatus=&quot;</span>, hex(readgstatus(gp)), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;scanstack - bad status&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消_Gscan标志后检查</span></span><br><span class="line">    <span class="keyword">switch</span> readgstatus(gp) &amp;^ _Gscan &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: gp=&quot;</span>, gp, <span class="string">&quot;, goid=&quot;</span>, gp.goid, <span class="string">&quot;, gp-&gt;atomicstatus=&quot;</span>, readgstatus(gp), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;mark - bad status&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _Gdead:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> _Grunning:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;runtime: gp=&quot;</span>, gp, <span class="string">&quot;, goid=&quot;</span>, gp.goid, <span class="string">&quot;, gp-&gt;atomicstatus=&quot;</span>, readgstatus(gp), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;scanstack: goroutine not stopped&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _Grunnable, _Gsyscall, _Gwaiting:</span><br><span class="line">        <span class="comment">// 目标状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g0执行</span></span><br><span class="line">    <span class="keyword">if</span> gp == getg() &#123;</span><br><span class="line">        throw(<span class="string">&quot;can&#x27;t scan our own stack&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈指针</span></span><br><span class="line">    <span class="keyword">var</span> sp <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallsp != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 处于系统调用</span></span><br><span class="line">        sp = gp.syscallsp</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一般情况下</span></span><br><span class="line">        sp = gp.sched.sp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已使用栈大小</span></span><br><span class="line">    scannedSize := gp.stack.hi - sp</span><br><span class="line"></span><br><span class="line">    p := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// 累计扫描栈大小</span></span><br><span class="line">    p.scannedStackSize += <span class="type">uint64</span>(scannedSize)</span><br><span class="line">    <span class="comment">// 累计扫描栈数量</span></span><br><span class="line">    p.scannedStacks++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否允许栈缩小</span></span><br><span class="line">    <span class="keyword">if</span> isShrinkStackSafe(gp) &#123;</span><br><span class="line">        <span class="comment">// 缩小栈（暂不深入研究）</span></span><br><span class="line">        shrinkstack(gp)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不允许缩小：g处于系统调用、异步安全点、挂起在channel、tracing开启并在等待用于GC</span></span><br><span class="line">        <span class="comment">// 在下一个同步安全点缩小</span></span><br><span class="line">        gp.preemptShrink = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> state stackScanState</span><br><span class="line">    state.stack = gp.stack</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stackTraceDebug默认false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> stackTraceDebug &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;stack trace goroutine&quot;</span>, gp.goid)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debugScanConservative默认false，忽略</span></span><br><span class="line">    <span class="keyword">if</span> debugScanConservative &amp;&amp; gp.asyncSafePoint &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;scanning async preempted goroutine &quot;</span>, gp.goid, <span class="string">&quot; stack [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;,&quot;</span>, hex(gp.stack.hi), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描并保存ctxt寄存器</span></span><br><span class="line">    <span class="keyword">if</span> gp.sched.ctxt != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">        scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;gp.sched.ctxt)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描栈</span></span><br><span class="line">    <span class="keyword">var</span> u unwinder</span><br><span class="line">    <span class="keyword">for</span> u.init(gp, <span class="number">0</span>); u.valid(); u.next() &#123;</span><br><span class="line">        <span class="comment">// （暂不深入研究）</span></span><br><span class="line">        scanframeworker(&amp;u.frame, &amp;state, gcw)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是defer跟panic扫描</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// defer链</span></span><br><span class="line">    <span class="keyword">for</span> d := gp._defer; d != <span class="literal">nil</span>; d = d.link &#123;</span><br><span class="line">        <span class="comment">// 扫描函数值</span></span><br><span class="line">        <span class="keyword">if</span> d.fn != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 放在栈上的闭包函数</span></span><br><span class="line">            <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;d.fn)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可能指向一个heap上分配的defer</span></span><br><span class="line">        <span class="keyword">if</span> d.link != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;d.link)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规方法无法访问的defer</span></span><br><span class="line">        <span class="keyword">if</span> d.heap &#123;</span><br><span class="line">            <span class="comment">// 扫描一片内存，如果是指针则设置对象在mspan的gcmarkBits、pageMarks，累计bytesMarked，最后放入任务缓冲区</span></span><br><span class="line">            scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;d)), goarch.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic</span></span><br><span class="line">    <span class="keyword">if</span> gp._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// panic只会在栈上分配</span></span><br><span class="line">        <span class="comment">// 指针放到state.buf队列</span></span><br><span class="line">        state.putPtr(<span class="type">uintptr</span>(unsafe.Pointer(gp._panic)), <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并扫描所有可达的栈对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造BST树</span></span><br><span class="line">    state.buildIndex()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 返回cbuf数组最后一个元素</span></span><br><span class="line">        p, conservative := state.getPtr()</span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据指针找到对象</span></span><br><span class="line">        obj := state.findObject(p)</span><br><span class="line">        <span class="keyword">if</span> obj == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        r := obj.r</span><br><span class="line">        <span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 已扫描</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// obj.r = nil =&gt; 防止重复扫描</span></span><br><span class="line">        obj.setRecord(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// stackTraceDebug默认false，忽略</span></span><br><span class="line">        <span class="keyword">if</span> stackTraceDebug &#123;</span><br><span class="line">            printlock()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;  live stkobj at&quot;</span>, hex(state.stack.lo+<span class="type">uintptr</span>(obj.off)), <span class="string">&quot;of size&quot;</span>, obj.size)</span><br><span class="line">            <span class="keyword">if</span> conservative &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot; (conservative)&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">println</span>()</span><br><span class="line">            printunlock()</span><br><span class="line">        &#125;</span><br><span class="line">        ptrBytes, gcData := r.gcdata()</span><br><span class="line">        b := state.stack.lo + <span class="type">uintptr</span>(obj.off)</span><br><span class="line">        <span class="keyword">if</span> conservative &#123;</span><br><span class="line">            scanConservative(b, ptrBytes, gcData, gcw, &amp;state)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            scanblock(b, ptrBytes, gcData, gcw, &amp;state)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放对象缓冲区（上一个循环中，指针缓冲区已释放）</span></span><br><span class="line">    <span class="keyword">for</span> state.head != <span class="literal">nil</span> &#123;</span><br><span class="line">        x := state.head</span><br><span class="line">        state.head = x.next</span><br><span class="line">        <span class="comment">// stackTraceDebug默认false，忽略</span></span><br><span class="line">        <span class="keyword">if</span> stackTraceDebug &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; x.nobj; i++ &#123;</span><br><span class="line">                obj := &amp;x.obj[i]</span><br><span class="line">                <span class="keyword">if</span> obj.r == <span class="literal">nil</span> &#123; <span class="comment">// reachable</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;  dead stkobj at&quot;</span>, hex(gp.stack.lo+<span class="type">uintptr</span>(obj.off)), <span class="string">&quot;of size&quot;</span>, obj.r.size)</span><br><span class="line">                <span class="comment">// Note: not necessarily really dead - only reachable-from-ptr dead.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x.nobj = <span class="number">0</span></span><br><span class="line">        <span class="comment">// wbuf放到work.empty</span></span><br><span class="line">        putempty((*workbuf)(unsafe.Pointer(x)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有残留</span></span><br><span class="line">    <span class="keyword">if</span> state.buf != <span class="literal">nil</span> || state.cbuf != <span class="literal">nil</span> || state.freeBuf != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;remaining pointer buffers&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(scannedSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bitmap操作相关"><a href="#bitmap操作相关" class="headerlink" title="bitmap操作相关"></a>bitmap操作相关</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从gcBitsArenas分配足以容纳nelems个位的内存（64的倍数向上取整）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMarkBits</span><span class="params">(nelems <span class="type">uintptr</span>)</span></span> *gcBits &#123;</span><br><span class="line">    <span class="comment">// 计算需要多少个块</span></span><br><span class="line">    blocksNeeded := (nelems + <span class="number">63</span>) / <span class="number">64</span></span><br><span class="line">    <span class="comment">// 每个块8个字节（64位）</span></span><br><span class="line">    bytesNeeded := blocksNeeded * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前arena</span></span><br><span class="line">    head := (*gcBitsArena)(atomic.Loadp(unsafe.Pointer(&amp;gcBitsArenas.next)))</span><br><span class="line">    <span class="comment">// 尝试从head分配bytesNeeded个字节</span></span><br><span class="line">    <span class="keyword">if</span> p := head.tryAlloc(bytesNeeded); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 分配成功</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配失败，head要么为nil，要么空间不足，新建一个新的arena</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock(&amp;gcBitsArenas.lock)</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="keyword">if</span> p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 分配成功</span></span><br><span class="line">        unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定空间不足</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从gcBitsArenas申请一个arena，没有则向系统申请64KB大小内存用作新的arena（期间会解锁）</span></span><br><span class="line">    fresh := newArenaMayUnlock()</span><br><span class="line">    <span class="comment">// double-check</span></span><br><span class="line">    <span class="keyword">if</span> p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 把新的arena放到free链表</span></span><br><span class="line">        fresh.next = gcBitsArenas.free</span><br><span class="line">        gcBitsArenas.free = fresh</span><br><span class="line">        unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从新的arena分配</span></span><br><span class="line">    p := fresh.tryAlloc(bytesNeeded)</span><br><span class="line">    <span class="comment">// 分配失败</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;markBits overflow&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新的arena放到next链表</span></span><br><span class="line">    fresh.next = gcBitsArenas.next</span><br><span class="line">    <span class="comment">// gcBitsArenas.next = fresh</span></span><br><span class="line">    atomic.StorepNoWB(unsafe.Pointer(&amp;gcBitsArenas.next), unsafe.Pointer(fresh))</span><br><span class="line"></span><br><span class="line">    unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从gcBitsArenas申请一个arena，没有则向系统申请64KB大小内存用作新的arena</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newArenaMayUnlock</span><span class="params">()</span></span> *gcBitsArena &#123;</span><br><span class="line">    <span class="keyword">var</span> result *gcBitsArena</span><br><span class="line">    <span class="comment">// free链表没有足够空间</span></span><br><span class="line">    <span class="keyword">if</span> gcBitsArenas.free == <span class="literal">nil</span> &#123;</span><br><span class="line">        unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">        <span class="comment">// 向系统申请64KB大小内存（Reserved），最低64MB，创建arenaHint、heapArena</span></span><br><span class="line">        result = (*gcBitsArena)(sysAlloc(gcBitsChunkBytes, &amp;memstats.gcMiscSys))</span><br><span class="line">        <span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">if</span> result == <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtime: cannot allocate memory&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        lock(&amp;gcBitsArenas.lock)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// free链表还有足够空间</span></span><br><span class="line">        <span class="comment">// 拿走free链表第一个节点</span></span><br><span class="line">        result = gcBitsArenas.free</span><br><span class="line">        gcBitsArenas.free = gcBitsArenas.free.next</span><br><span class="line">        <span class="comment">// 清0</span></span><br><span class="line">        memclrNoHeapPointers(unsafe.Pointer(result), gcBitsChunkBytes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置next指针</span></span><br><span class="line">    result.next = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 偏移量设置8字节对齐</span></span><br><span class="line">    <span class="keyword">if</span> unsafe.Offsetof(gcBitsArena&#123;&#125;.bits)&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">        result.free = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.free = <span class="number">8</span> - (<span class="type">uintptr</span>(unsafe.Pointer(&amp;result.bits[<span class="number">0</span>])) &amp; <span class="number">7</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://betterprogramming.pub/memory-optimization-and-garbage-collector-management-in-go-71da4612a960">Memory Optimization and Garbage Collector Management in Go</a><br><a target="_blank" rel="noopener" href="https://tip.golang.org/doc/gc-guide">A Guide to the Go Garbage Collector</a><br><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976">Go: How Does the Garbage Collector Mark the Memory?</a><br><a target="_blank" rel="noopener" href="https://itnext.io/go-does-not-need-a-java-style-gc-ac99b8d26c60">Go Does Not Need a Java Style GC</a><br><a target="_blank" rel="noopener" href="https://xargin.com/impl-of-go-gc/">Go 语言的 GC 实现分析</a><br><a target="_blank" rel="noopener" href="https://community.apinto.com/d/34057-golang-gc">一文弄懂 Golang GC、三色标记、混合写屏障机制</a><br><a target="_blank" rel="noopener" href="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/">Golang垃圾回收(GC)介绍</a><br><a target="_blank" rel="noopener" href="https://groups.google.com/g/golang-dev/c/oUFIOm7IMxo">How does go GC identify GC roots</a><br><a target="_blank" rel="noopener" href="https://www.quora.com/What-is-a-garbage-collection-GC-root">What is a garbage collection (GC) root?</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eDd212DhjIRGpytBkgfzAg">关于Golang GC的一些误解–真的比Java算法更领先吗？</a><br><a target="_blank" rel="noopener" href="https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%86%99%E5%B1%8F%E9%9A%9C/2020/07/24/gc5.html">golang 垃圾回收（五）混合写屏障</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/golang-series-memory-allocation/" rel="prev" title="golang系列之-内存分配">
                  <i class="fa fa-angle-left"></i> golang系列之-内存分配
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">y2k38</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">170k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:16</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Y2k38/y2k38.github.io","repo_id":"R_kgDOMZGvZA","category":"Announcements","category_id":"DIC_kwDOMZGvZM4CirXX","mapping":"pathname","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"preferred_color_scheme","lang":"zh-CN","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
